<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/4/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">756</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">670</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/04/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-joeschmo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/04/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-joeschmo/" class="post-title-link" itemprop="url">2025 春夏季开源操作系统训练营阶段总结-joeschmo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-04 20:48:14" itemprop="dateCreated datePublished" datetime="2025-06-04T20:48:14+00:00">2025-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage 1"></a>Stage 1</h2><p>这个阶段主要是学习Rust语法，因为之前有报名过训练营，所以做起来比较顺手，把基础语法又复习了一遍。</p>
<h2 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage 2"></a>Stage 2</h2><p>这个阶段主要是阅读实验指导书和源码。实验指导书非常重要，如果没有看明白的话对做实验有很大影响，所以要细心耐心看。时间有限的话，看精简版指导书即可。<br>完成实验部分需要重点理解几个点：</p>
<ol>
<li>任务切换机制，保存切换前后程序上下文</li>
<li>地址空间，多级页表机制</li>
<li>文件系统，操作与管理</li>
</ol>
<h2 id="Stage-3"><a href="#Stage-3" class="headerlink" title="Stage 3"></a>Stage 3</h2><p>这个阶段主要是看视频和PPT，并通过做6个实验来熟悉ArceOS的设计思想。相对于上一个阶段的实验会简单一些。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前有报名过两次训练营，但都没有坚持下来。对于如何平衡学习、工作和自我提升之间的平衡，是一个我现在以及将来都需要仔细思考的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/03/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-vipectuSSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/03/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-vipectuSSS/" class="post-title-link" itemprop="url">2025春夏开源操作系统训练营三阶段总结报告--vipectuSSS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-03 14:06:08" itemprop="dateCreated datePublished" datetime="2025-06-03T14:06:08+00:00">2025-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>这样的总结应该从何开始？我是从<a href="https://www.bilibili.com/" target="_blank" rel="noopener">Bilibili</a>刷视频偶然了解到与训练营相关的信息的。使用Rust语言编写操作系统的实践，我太喜欢这个方向了。因为我正学过一点Rust，也经学校老师的推荐看过CSAPP并完成了大多数的实验。其中我最喜欢的便是<code>shlab</code>和<code>attacklab</code>────写一个shell！实在是有趣不过，如果再写一个操作系统呢？好吧，我应该没有与之匹配的实力，不过开源操作系统训练营就这样给了我一个类似的机会。报名人数破千！全程免费！还有什么好说的呢，杀😡。</p>
<h1 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage 1"></a>Stage 1</h1><p>110道Rustling编程题，并没有耗费我太多功夫，更多的是重新熟悉一下语法。我觉得，学习Rust不仅是学会如何使用一门编程语言，更是了解更多的编程范式。例如<code>trait</code>背后的组合大于继承；函数式编程对现代编程语言深刻的影响：默认不可变、闭包、HOFs、链式操作等；所有权与生命周期机制，这种RAII思想是C++首创的（但是opt-out）。Rust编译器就是你最好的老师，更别说还有满地走的各式AI（<del><em>本总结经AI辅助完成</em></del>），2025年的今天，学习Rust不应该再是一件难事🥳。</p>
<h1 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage 2"></a>Stage 2</h1><p>到了OS设计实现，主要是完成5道rCore操作系统大实验编程题。我是提前进入该阶段，所以全程并没有看过相关学习视频，而是跟随<a href="https://learningos.cn/rCore-Tutorial-Guide-2025S/" target="_blank" rel="noopener">rCore-Tutorial-Guide</a>文档完成的🤓。</p>
<p>这阶段最耗时的是lab2───地址空间和lab5───并发，这两个不管哪个太痛苦了😭。lab2是因为分页机制本身就相对复杂，层层抽象，读内核新增的代码就花了我很久时间（光论这一点文件系统其实不遑多让，不过到这里我的读代码能力已经得到显著锻炼了，所以带给我的痛苦远不及地址空间🥱）。而lab5，单纯是我因为技术路线的左右互博而无限拖缓了进度，我一直在对死锁检测资源的获取上究竟是现场构建还是跟随进程保存之间反复横跳。倒不如说，是因为我在实现这两个的时候遭遇多方掣肘，导致我不停怀疑我自己，不停的重构。使用Rust编程不就是戴着脚镣在跳舞吗？我现在水平还不够，只能写出不够优美的实现，但是我不会放弃的😡。</p>
<h1 id="Stage-3"><a href="#Stage-3" class="headerlink" title="Stage 3"></a>Stage 3</h1><p>组件化操作系统，这大概是最各显神通的阶段了。我对这阶段的印象其实是一点草台味🤯，遇到各方面奇怪的问题，测试脚本死活不通过，各种不同的资料，到底要实现在哪里，我要怎么修改一个crate依赖的代码？我是个不撞南墙不愿意问别人的人，所以我全部都闭门造车自己解决了所有问题（真的吗？至少测例说我通过了）。但实际上，在讨论群里大家都很乐意回答别人的提问，每个人都有自己的“奇技淫巧”，应该让大家全都热烈讨论遇到的问题，才能让训练营变得更好😈。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>写到这里我已经有点精疲力竭。我在参与前三个阶段的过程中收获颇多，不只是对整个组件化操作系统的认识。还有各种在学习过程中对工具的使用，<code>helix</code>、<code>Zellij</code>，这些工具，我很早就下载了，只是因为它是Rust重写的老工具。现在呢？我需要<code>helix</code>丰富的快捷键，我需要<code>Zellij</code>的分屏。我开始熟悉，正是我开始迈出一步，参加了这次，<a href="https://opencamp.cn/os2edu/camp/2025spring" target="_blank" rel="noopener">2025 春夏季开源操作系统训练营</a>。</p>
<p>完成了三阶段的任务，我也疲惫了，进入了一种拖延的状态。五月二十二号，新建文件夹，想要完成这篇总结报告。一直到今天，我终于又想重新出发了。希望到了第四阶段，我可以找到新的方向。</p>
<p>编程的乐趣：⭐️⭐️⭐️⭐️<br>挑战的难度：⭐️⭐️⭐️<br>开源训练营：⭐️⭐️⭐️⭐️⭐️</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/30/wwj%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/30/wwj%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">wwj三阶段学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-30 10:26:23" itemprop="dateCreated datePublished" datetime="2025-05-30T10:26:23+00:00">2025-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RUST学习总结"><a href="#RUST学习总结" class="headerlink" title="RUST学习总结"></a>RUST学习总结</h1><h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ul>
<li>函数名和变量名使用<a href="https://course.rs/practice/naming.html" target="_blank" rel="noopener">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; {}</code></li>
<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>
<li>每个函数参数都需要标注类型</li>
</ul>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>基础类型：不会转移所有权，属于复制变量的值</p>
<p>复合类型：会转移所有权，相当于重新绑定变量</p>
<p> （深拷贝：<code>复合类型变量名.clone()</code>，不转移所有权）</p>
<p><strong>引用</strong></p>
<ul>
<li>以<code>&amp;</code>表示引用，以<code>*</code>表示解引用</li>
<li>可变引用首先要求变量可变，引用时也要写成<code>&amp;mut 变量名</code>，否则是可变变量的不可变引用</li>
<li>一个变量的可变引用同时只能存在一个，可变与不可变引用不可同时存在</li>
<li>“同时”指引用的作用域，为引用”从创建开始，一直持续到它最后一次使用的地方“</li>
</ul>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>切片：对<code>string</code>类型中某一部分的引用，即<code>&amp;变量名[开始……终止]</code>，切片类型为<code>&amp;str</code></p>
<p><code>string</code>与<code>&amp;str</code>的转化：</p>
<p> <code>&amp;str</code>化成<code>string</code>: <code>String::from(&quot;字符串字面量&quot;)</code>/<code>&quot;字符串字面量&quot;.to_string()</code></p>
<p> <code>string</code>化成<code>&amp;str</code>: 取切片</p>
<p><strong>操作字符串</strong>（针对于<code>string</code>）</p>
<ul>
<li>追加：<code>push(字符)/push_str(字符串字面量（不能是string类型）)</code> 改变原有的字符串（不返回新值，必须<code>mut</code>可变）</li>
<li>插入：<code>insert()/insert_str()</code> 需要传入两个参数，第一个是插入位置索引，第二个是插入内容 改变原有字符串</li>
<li>替换：<code>replace(被替换的字符串，新的字符串)</code> 返回新的字符串（需要新变量接收）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let string_replace &#x3D; String::from(&quot;I like rust. Learning rust is my favorite!&quot;);</span><br><span class="line">let new_string_replace &#x3D; string_replace.replace(&quot;rust&quot;, &quot;RUST&quot;);</span><br></pre></td></tr></table></figure>

<p> <code>replacen(被替换的字符串，新的字符串，替换的个数)</code> 返回新的字符串</p>
<p> <code>replace_range(要替换的范围，新的字符串)</code> 改变原有的字符串</p>
<ul>
<li><p>删除：<code>pop()</code> 删除并返回最后一个字符 改变原有的字符串</p>
<p><code>remove(字符起始索引)</code> 删除并返回指定位置的字符 改变原有的字符串</p>
<p><code>truncate(字符起始索引)</code> 删除指定位置至结尾的所有字符 改变原有字符串</p>
<p><code>clear()</code> 清空字符串</p>
</li>
<li><p>连接：<code>+/+=</code> 相当于调用函数<code>add(self, s:&amp;str……)</code> 第一个参数是<code>string</code>,其所有权会被转移，后面的参数需要<code>&amp;str</code>类型 <code>&#39;+&#39;返回新的字符串</code></p>
<p> <code>format!(&quot;{}&quot;, s)</code> 用法与<code>println!</code>类似， 返回新的字符串</p>
</li>
</ul>
<p><strong>注：</strong>此处所有涉及索引的方法（包括切片），都是以字节为单位处理数据；对于<code>UTF-8</code>类型字符非常容易出错</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、&#x2F;&#x2F; 定义字段</span><br><span class="line">struct 结构体名称 &#123;</span><br><span class="line">    字段名称1： 类型 &#x2F;&#x2F;结构体字段</span><br><span class="line">&#125;</span><br><span class="line">gree</span><br><span class="line">2、&#x2F;&#x2F; 初始化：每个字段都要初始化，但顺序不一定一样</span><br><span class="line">let 变量名 &#x3D;  结构体名称 &#123;</span><br><span class="line">    字段名称1： 值 </span><br><span class="line">&#125;</span><br><span class="line">let 变量名 &#x3D;  结构体名称 &#123;</span><br><span class="line">    字段名称1： 值 </span><br><span class="line">    ..另一个同类型变量2名的名称	&#x2F;&#x2F;	剩余自动从另一变量中获取（该语句必须位于尾部）</span><br><span class="line">    				&#x2F;&#x2F;	同时变量2部分字段会发生所有权转移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、&#x2F;&#x2F; 访问字段</span><br><span class="line">变量名.字段名	</span><br><span class="line"></span><br><span class="line">4、&#x2F;&#x2F; 元组结构体、单元结构体</span><br><span class="line">let a : (i32, f64, u8) &#x3D; (500, 6.4, 1); &#x2F;&#x2F; (i32, f64, u8)是元组</span><br><span class="line">struct Color(i32, i32, i32); &#x2F;&#x2F; 元组结构体，适用于结构体有名称，字段没有的情况</span><br><span class="line">struct AlwaysEqual; &#x2F;&#x2F; 单元结构体，没有属性与字段</span><br><span class="line"></span><br><span class="line">5、 &#x2F;&#x2F; 结构体数据所有权：字段值最好不要基于引用，否则需要加上生命周期</span><br><span class="line"></span><br><span class="line">6、 &#x2F;&#x2F; 正常情况无法&#123;&#125;打印，需要在开头加上#[derive(Debug)]，使用&#123;:?&#125;或&#123;:#?&#125;来打印</span><br></pre></td></tr></table></figure>



<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 枚举变体携带数据</span><br><span class="line">enum PokerCard &#123;</span><br><span class="line">    Clubs(u8),</span><br><span class="line">    Spades(u8),</span><br><span class="line">    Diamonds(char),</span><br><span class="line">    Hearts(char),</span><br><span class="line">&#125; &#x2F;&#x2F; 任何类型的数据都可以放入枚举成员中，包括另一个枚举或者结构体</span><br><span class="line">let c1 &#x3D; PokerCard::Spades(5);</span><br></pre></td></tr></table></figure>



<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>分为静态的<code>array</code>和动态数组<code>vector</code>，先看<code>array</code></p>
<p><code>array</code>可以正常使用下标访问，可以使用<code>{:?}</code>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1, 2, 3, 4, 5]; &#x2F;&#x2F; 定义</span><br><span class="line">let a: [i32; 5] &#x3D; [1, 2, 3, 4, 5]; &#x2F;&#x2F; 需要声明类型时</span><br><span class="line">let a &#x3D; [3; 5]; &#x2F;&#x2F; 某个值重复出现</span><br><span class="line">let arrays: [[u8; 3]; 4]  &#x3D; [one, two, blank1, blank2]; &#x2F;&#x2F; 二维数组</span><br><span class="line"></span><br><span class="line">let slice: &amp;[i32] &#x3D; &amp;a[1..3]; &#x2F;&#x2F; 数组切片</span><br></pre></td></tr></table></figure>



<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>if:</strong> <code>if</code>语句块是表达式，可以有返回值</p>
<p><strong>for</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for 元素 in 集合&#x2F;0..集合.len() &#123; &#x2F;&#x2F; 注意，此处集合需要使用引用，否则所有权会被转移（如需更改加上mut）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 想要获取元素的索引</span><br><span class="line">let a &#x3D; [4, 3, 2, 1];</span><br><span class="line">for (i, v) in a.iter().enumerate() &#123;</span><br><span class="line">    println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;, i + 1, v); &#x2F;&#x2F; .iter()方法把 &#96;a&#96; 数组变成一个迭代器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只在意循环次数</span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>continue</code>与<code>break</code>依然存在</p>
<p><strong>while</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while 条件 &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>loop</strong></p>
<p>无条件循环，必须搭配<code>break</code></p>
<p>（<code>break</code>类似于<code>return</code>，可以单独使用也可以带回来一个返回值；</p>
<p> loop同样是表达式，可以返回一个值）</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><h4 id="match和if-let"><a href="#match和if-let" class="headerlink" title="match和if let"></a>match和if let</h4><p><strong>match:</strong> 非常类似于<code>switch</code>(但匹配后只会执行当前分支，而不会往下”贯穿“)</p>
<p><code>match</code>同样是表达式，可以有返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">match target &#123;</span><br><span class="line">    模式1 &#x3D;&gt; 表达式1, &#x2F;&#x2F; &#x3D;&gt;代替了:</span><br><span class="line">    模式2 | 模式3 &#x3D;&gt; &#123;	&#x2F;&#x2F; X|Y</span><br><span class="line">        语句1;</span><br><span class="line">        语句2;</span><br><span class="line">        表达式2 &#x2F;&#x2F; 注意，语句同样可以返回()</span><br><span class="line">    &#125;,</span><br><span class="line">    _ &#x3D;&gt; 表达式3 &#x2F;&#x2F; _代替了default，必须穷尽所有情况否则会报错</span><br><span class="line">    &#x2F;&#x2F;或者 任意无关变量名 &#x3D;&gt; 表达式3  &#x2F;&#x2F; 此时就可以对该变量操作，不操作记得使用_开头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式绑定（从匹配到的分支中取出绑定的值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState), &#x2F;&#x2F; 25美分硬币</span><br><span class="line">&#125;</span><br><span class="line">match coin &#123;</span><br><span class="line">        Coin::Penny &#x3D;&gt; 1,</span><br><span class="line">        Coin::Nickel &#x3D;&gt; 5,</span><br><span class="line">        Coin::Dime &#x3D;&gt; 10,</span><br><span class="line">        Coin::Quarter(state) &#x3D;&gt; &#123;</span><br><span class="line">            println!(&quot;State quarter from &#123;:?&#125;!&quot;, state); &#x2F;&#x2F; 可以取出绑定的具体state值</span><br><span class="line">            25</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>if let:</strong> 适用于只需要判断一个模式是否匹配的情况,比<code>if</code>更适用于匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let some_value &#x3D; Some(5);</span><br><span class="line">if let Some(v) &#x3D; some_value &#123;</span><br><span class="line">    println!(&quot;Value is: &#123;&#125;&quot;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>while let:</strong> while和let的总和，即如果满足条件就可循环，同样可以从模式匹配中拆出值</p>
<p><strong>注：</strong>match/if let/while let都会转移被匹配值的借用值的所有权，需要使用<code>ref</code>抵消（<code>ref</code>只在左侧生效）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let Some(ref x) &#x3D; value</span><br><span class="line">match opt &#123;</span><br><span class="line">    Some(ref s) &#x3D;&gt; println!(&quot;Got a reference to string: &#123;&#125;&quot;, s),</span><br></pre></td></tr></table></figure>



<h4 id="Option-lt-T-gt"><a href="#Option-lt-T-gt" class="headerlink" title="Option&lt;T&gt;"></a><code>Option&lt;T&gt;</code></h4><p>表示一个值是否存在的<strong>枚举</strong>(<code>Some&lt;T&gt;</code>与<code>T</code>不是同一类型)</p>
<p>对于<code>Some</code>和<code>None</code>可以不加<code>Option::</code>前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),  &#x2F;&#x2F; 表示有值</span><br><span class="line">    None,     &#x2F;&#x2F; 表示无值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储</span><br><span class="line">let x: Option&lt;i32&gt; &#x3D; Some(42);  &#x2F;&#x2F; Some(42) 代表 x 里面存了 42</span><br><span class="line">let y: Option&lt;i32&gt; &#x3D; None;      &#x2F;&#x2F; None 代表没有值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解构</span><br><span class="line">match x &#123;</span><br><span class="line">    Some(v) &#x3D;&gt; println!(&quot;Value is: &#123;&#125;&quot;, v),  &#x2F;&#x2F; 取出 v</span><br><span class="line">    None &#x3D;&gt; println!(&quot;No value&quot;),</span><br><span class="line">&#125;</span><br><span class="line">if let Some(v) &#x3D; x &#123;</span><br><span class="line">    println!(&quot;Value is: &#123;&#125;&quot;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>impl</code>中存储方法与<code>struct</code>中声明字段分开，同时一个结构体可以有多个<code>impl</code>块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; &amp;self代替了self:&amp;Self</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li><p><code>self</code> 表示 <code>Rectangle</code> 的所有权转移到该方法中，这种形式用的较少</p>
<p><code>&amp;self</code> 表示该方法对 <code>Rectangle</code> 的不可变借用</p>
<p><code>&amp;mut self</code> 表示可变借用</p>
</li>
<li><p>允许方法名和字段名相同</p>
</li>
<li><p>在调用方法时只有<code>.</code>没有<code>-&gt;</code></p>
</li>
<li><p>枚举同样可以定义方法</p>
</li>
</ul>
<p><strong>关联函数</strong></p>
<p>定义在结构体<code>impl</code>且没有<code>self</code>的函数</p>
<p>不能使用<code>变量.函数()</code>的方法调用，只能使用<code>结构体名称::函数名(参数)</code>来调用</p>
<p>比如<code>String::from()</code></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>为了抽象不同的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn 函数名&lt;T&gt;(变量名: T) -&gt; T &#123; &#x2F;&#x2F; 函数泛型</span><br><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125; &#x2F;&#x2F; 结构体泛型，多个类型也可以声明如struct Point&lt;T,U&gt;</span><br><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125; &#x2F;&#x2F; 枚举泛型，可以根据返回值的类型判断是否成功</span><br><span class="line">struct Point&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; </span><br><span class="line">    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: self.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 结构体泛型，impl处需要另外声明，impl中的方法可以拥有自己的泛型</span><br><span class="line">  &#x2F;&#x2F;对于结构体泛型，还可以为特定的泛型单独声明方法</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用<code>T</code>前需要先声明<code>&lt;T&gt;</code>，<code>T</code>的名字可以随便取</li>
<li>有时在调用泛型函数时需使用<code>函数名::&lt;具体类型&gt;()</code>来显式指定<code>T</code>的类型</li>
</ul>
<p><strong>const泛型</strong></p>
<p>允许常量值成为泛型变量，语法为<code>const N: usize</code>，表示const泛型N，它的值基于<code>usize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Buffer&lt;T, const N: usize&gt; &#123;</span><br><span class="line">    data: [T; N], &#x2F;&#x2F; N 作为数组大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const fn:</code> 在函数声明前加上<code>const</code>关键字</p>
<p><strong>注：</strong><code>const</code>泛型与<code>const fn</code>都需要在编译时确定，<code>const fn</code>就可以用于给<code>const</code>泛型赋值</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>定义了一组可以被共享的行为，只要实现了特征，你就能使用这组行为（类似于接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String; &#x2F;&#x2F; 只是一个抽象接口，而不具体实现</span><br><span class="line">&#125; &#x2F;&#x2F; 定义特征</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为每个需要的类单独实现特征</span><br><span class="line">impl Summary for Post &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;, self.title, self.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Summary for Weibo &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;, self.username, self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>孤儿规则：如果你想要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> <strong>或者</strong> <code>T</code> 至少有一个是在当前作用域中定义的（另一个可以在其他库中引入）</li>
<li>默认实现：可以在特征中定义具有默认实现的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法（默认实现允许调用特征中其他方法，哪怕这个方法没有默认实现）</li>
</ul>
<h4 id="特征约束"><a href="#特征约束" class="headerlink" title="特征约束"></a><strong>特征约束</strong></h4><p>特征作为函数参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify(item: &amp;impl Summary) &#123; &#x2F;&#x2F; 实现了Summary特征 的 item 参数</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 对于结构体方法</span><br><span class="line">impl&lt;T: Display&gt; ToString for T &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形如 <code>T: Summary</code> 被称为特征约束</p>
<p>多重约束:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 要求同时实现了两个特征的参数</span><br><span class="line">pub fn notify(item: &amp;(impl Summary + Display)) &#123;&#125;</span><br><span class="line">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>where</code>约束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 &#123;&#125;</span><br><span class="line">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32</span><br><span class="line">    where T: Display + Clone,</span><br><span class="line">          U: Clone + Debug</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>函数返回值：</p>
<p>通过 <code>impl Trait</code> 来说明一个函数返回了一个类型，该类型实现了某个特征</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn returns_summarizable() -&gt; impl Summary &#123; &#x2F;&#x2F; 返回一个实现了Summary特征的类型</span><br></pre></td></tr></table></figure>



<h4 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h4><table>
<thead>
<tr>
<th>特征约束</th>
<th>特征对象</th>
</tr>
</thead>
<tbody><tr>
<td><code>impl Trait</code></td>
<td><code>dyn Trait</code></td>
</tr>
<tr>
<td>接收所有实现了<code>Trait</code>的类型</td>
<td>接收所有实现了<code>Trait</code>的类型</td>
</tr>
<tr>
<td>认为是不一样的类型，不能一起存储</td>
<td>认为是相同的类型，可以一起存储</td>
</tr>
<tr>
<td>静态分发，编译时确定</td>
<td>动态分发，运行时确定</td>
</tr>
</tbody></table>
<p>允许你使用 不同类型 但 实现了相同特征 的对象，使它们可以在 同一个变量、参数或返回值 中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 语法</span><br><span class="line">&amp;dyn 特征名 &#x2F;&#x2F; 必须要使用指针，否则无法确定大小</span><br><span class="line">Box&lt;dyn 特征名&gt; &#x2F;&#x2F; 智能指针</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态数组</span><br><span class="line">Vec&lt;Box&lt;dyn 特征名&gt;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><h4 id="动态数组Vector"><a href="#动态数组Vector" class="headerlink" title="动态数组Vector"></a>动态数组<code>Vector</code></h4><p>使用<code>Vec&lt;T&gt;</code>表示，只能存储相同类型的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建数组</span><br><span class="line">let v: Vec&lt;i32&gt; &#x3D; Vec::new();</span><br><span class="line">let mut v &#x3D; Vec::new(); &#x2F;&#x2F; 在添加元素后会自动推导</span><br><span class="line">let mut v: Vec&lt;i32&gt; &#x3D; Vec::with_capacity(5); &#x2F;&#x2F; 预先分配空间</span><br><span class="line"></span><br><span class="line">let v &#x3D; vec![1, 2, 3]; &#x2F;&#x2F; 宏vec!可以给予初始值</span><br><span class="line">let v &#x3D; vec![0; 3];   &#x2F;&#x2F; 默认值为 0，初始长度为 3</span><br><span class="line">let v_from &#x3D; Vec::from([0, 0, 0]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新（需要为mut）</span><br><span class="line">v.push(n); &#x2F;&#x2F; 可变引用，不能与其他引用同时存在</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问元素</span><br><span class="line">v[下标] &#x2F;&#x2F;		越界不会检查</span><br><span class="line">v.get(下标) &#x2F;&#x2F; 返回Option&lt;T&gt;,需要match来解构出值		确保不会越界</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for i in &amp;(mut) v &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 常见方法</span><br><span class="line">v.is_empty()</span><br><span class="line">v.insert(pos, val) &#x2F;&#x2F; 在指定索引pos处插入数值val</span><br><span class="line">v.remove(pos) &#x2F;&#x2F; 删除在pos处的数并返回该数</span><br><span class="line">v.pop() &#x2F;&#x2F; 删除尾部的数并返回(返回的是Option&lt;T&gt;的枚举值)</span><br><span class="line">v.clear()</span><br><span class="line">v.append(&amp;mut v1) &#x2F;&#x2F; v1所有数据全部转入v，v1被清空</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排序</span><br><span class="line">sort&#x2F;sort_unstable() &#x2F;&#x2F; 默认按照升序类型，且要元素可比较</span><br><span class="line">sort_by&#x2F;sort_unstable_by(闭包实现) &#x2F;&#x2F; 可以自定义比较规则来实现多种类型的比较</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>可以通过使用枚举类型和特征对象来实现不同类型元素的存储</p>
<h4 id="KV存储HashMap"><a href="#KV存储HashMap" class="headerlink" title="KV存储HashMap"></a><code>KV</code>存储<code>HashMap</code></h4><p>需要使用<code>use std::collections::HashMap;</code>来引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建与插入</span><br><span class="line">let mut my_gems &#x3D; HashMap::new();</span><br><span class="line">my_gems.insert(&quot;红宝石&quot;, 1);</span><br><span class="line"></span><br><span class="line">HashMap::with_capacity(capacity)</span><br><span class="line"></span><br><span class="line">let teams_list &#x3D; vec![</span><br><span class="line">        (&quot;中国队&quot;.to_string(), 100),</span><br><span class="line">        (&quot;美国队&quot;.to_string(), 10),</span><br><span class="line">        (&quot;日本队&quot;.to_string(), 50),</span><br><span class="line">    ];</span><br><span class="line">let teams_map: HashMap&lt;_,_&gt; &#x3D; teams_list.into_iter().collect(); &#x2F;&#x2F; 从动态数组转化为hashmap</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在表中查询元素</span><br><span class="line">let score: Option&lt;&amp;value类型&gt; &#x3D; 表名.get(key的引用); &#x2F;&#x2F; 注意返回的是Option&lt;T&gt;类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for (key, value) in &amp;表名 &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新表中的值</span><br><span class="line">let old &#x3D; scores.insert(&quot;Blue&quot;, 20); &#x2F;&#x2F; 会直接覆盖旧值，返回Some(旧值)&#x2F;None</span><br><span class="line">let v &#x3D; scores.entry(&quot;Yellow&quot;).or_insert(5); &#x2F;&#x2F; 查询Yellow对应的值，若不存在则插入新值；返回存储值的可变引用</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<p><code>HashMap</code> 的所有权规则与其它 Rust 类型没有区别：</p>
<ul>
<li>若类型实现 <code>Copy</code> 特征，该类型会被复制进 <code>HashMap</code>，因此无所谓所有权</li>
<li>若没实现 <code>Copy</code> 特征，所有权将被转移给 <code>HashMap</code> 中（使用引用要确保其生命周期足够长）</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>变量的生命周期声明方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#39;a i32     &#x2F;&#x2F; 具有显式生命周期的引用</span><br><span class="line">&amp;&#39;a mut i32 &#x2F;&#x2F; 具有显式生命周期的可变引用</span><br></pre></td></tr></table></figure>

<h4 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h4><p>需要标注生命周期的情况如下：</p>
<ul>
<li>首先返回值必须是引用类型，可能会出现悬垂引用错误</li>
<li>存在多个参数时，如果编译器无法确定返回值需要跟随哪个参数的生命周期（哪怕这两个参数的生命周期是一样的），那么不标注就会报错</li>
<li>标注之后，编译时就会检查返回值使用会不会超出某个参数，如果发现超出就会报错（标注生命周期实际上<strong>不会更改任何返回值或者变量的真实生命周期</strong>，只是告诉编译器当返回值的生命周期不与较短的参数生命周期一致时，不予通过）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用&#39;a显式表示生命周期，此处的&#39;a表示两个参数中较短的生命周期，需要提前标注</span><br><span class="line">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特殊情况：返回值永远只和一个参数有关&#x2F;返回值与参数无关</span><br><span class="line">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;str) -&gt; &amp;&#39;a str &#123; &#x2F;&#x2F; 只与一个有关就只标注一个</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line">fn longest(_x: &amp;str, _y: &amp;str) -&gt; String &#123; &#x2F;&#x2F; 与新建变量有关尽量不返回引用</span><br><span class="line">    String::from(&quot;really long string&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h4><p>如果结构体的字段值类型为引用型，也需要标注生命周期<code>&#39;a</code>（<code>a</code>可以任意替换）</p>
<p>作用是避免编译器报错、同时(提醒编译器)在编译时就检查其是否不超过原变量的生命周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    part: &amp;&#39;a str,</span><br><span class="line">&#125; &#x2F;&#x2F; 只要在结构体每一个引用标注上生命周期即可，此处也需要提前声明&lt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期声明消除"><a href="#生命周期声明消除" class="headerlink" title="生命周期声明消除"></a>生命周期声明消除</h4><p>为何在只有一个参数时可以不标注生命周期？</p>
<p>存在以下三个步骤可以省略生命周期声明（函数中参数的生命周期是输入生命周期，返回值为输出）：</p>
<ol>
<li><p>每一个引用参数都会获得独自的生命周期（所以不声明则多个参数有各自的生命周期声明）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32) &#x2F;&#x2F; 所以不显式标出不知道跟随a还是b</span><br></pre></td></tr></table></figure>
</li>
<li><p>若只有一个输入生命周期（函数参数中只有一个引用类型），那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32 &#x2F;&#x2F; 所以单个参数可以省略</span><br></pre></td></tr></table></figure>
</li>
<li><p>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</p>
</li>
</ol>
<h4 id="方法中的生命周期"><a href="#方法中的生命周期" class="headerlink" title="方法中的生命周期"></a>方法中的生命周期</h4><ul>
<li>类似于泛型结构体</li>
<li>方法签名中一般不需要标注，因为有<code>&amp;self</code>参数（根据以上第三条规则）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    part: &amp;&#39;a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    fn level(&amp;self) -&gt; i32 &#123;</span><br><span class="line">        3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h4><p>拥有<code>&#39;static</code>生命周期声明的引用生命周期是整个程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s: &amp;&#39;static str &#x3D; &quot;我没啥优点，就是活得久，嘿嘿&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是一种元数据，用于修改编译器的行为、提供额外信息或影响代码生成方式</p>
<p>使用<code>#[]</code>语法</p>
<h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><p><strong><code>#[derive()]</code></strong> 自动派生特征</p>
<p>用于让编译器自动为结构体或枚举实现特定的 <strong>trait</strong>（特征），如 <code>Debug</code>、<code>Clone</code> 等</p>
<p>注意只针对结构体与枚举，同时在实现某特征时（比如<code>Copy</code>）结构体中不能够有<code>String</code>这种无法自动实现<code>Copy</code>的字段</p>
<p><strong><code>#[cfg(...)]</code></strong> 条件编译</p>
<p>用于根据特定 条件选择性地编译代码，例如目标平台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(target_os &#x3D; &quot;linux&quot;)]</span><br><span class="line">fn platform_specific() &#123;</span><br><span class="line">    println!(&quot;Running on Linux!&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 只在linux上面编译</span><br><span class="line"></span><br><span class="line">#[cfg(feature &#x3D; &quot;logging&quot;)]</span><br><span class="line">fn log_message() &#123;</span><br><span class="line">    println!(&quot;Logging is enabled&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 启用了feature特征才能编译（feature特征是cargo.toml中定义的）</span><br></pre></td></tr></table></figure>

<p><strong><code>#[test]</code></strong> Rust 测试函数</p>
<p>用于标记测试函数，让 <code>cargo test</code> 自动运行它</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="panic"><a href="#panic" class="headerlink" title="panic"></a><code>panic</code></h4><ul>
<li>标识不可恢复错误</li>
<li>有被动与主动触发两种情况</li>
</ul>
<p>主动触发：使用<code>panic!</code>宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    panic!(&quot;crash and burn&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序</span><br></pre></td></tr></table></figure>

<h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a><code>Result</code></h4><p>标识可恢复的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回了该枚举类型之后就可以使用<code>match</code>来匹配解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let f &#x3D; match f &#123;</span><br><span class="line">       Ok(file) &#x3D;&gt; file,</span><br><span class="line">       Err(error) &#x3D;&gt; match error.kind() &#123;</span><br><span class="line">           ErrorKind::NotFound &#x3D;&gt; match File::create(&quot;hello.txt&quot;) &#123;</span><br><span class="line">               Ok(fc) &#x3D;&gt; fc,</span><br><span class="line">               Err(e) &#x3D;&gt; panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, e),</span><br><span class="line">           &#125;,</span><br><span class="line">           other_error &#x3D;&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, other_error),</span><br><span class="line">       &#125;,</span><br><span class="line">   &#125;; &#x2F;&#x2F; 一个打开文件的返回处理</span><br></pre></td></tr></table></figure>

<p>如果不需要处理错误情况（即要么<code>Ok()</code>要么<code>panic()</code>，就使用<code>unwrap()</code>/<code>expect</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;).unwrap();</span><br><span class="line">&#x2F;&#x2F; 要么返回正确值要么直接panic</span><br><span class="line"></span><br><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);</span><br><span class="line">&#x2F;&#x2F; 与unwrap()一样，只不过会报出里面的信息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 改变错误类型：假设有f1(T)返回值T1类型，f2(F)返回值F2类型</span><br><span class="line">let n: u8 &#x3D; &quot;1&quot;.parse().map(f1).map_err(f2) &#x2F;&#x2F;原本返回T&#x2F;F,现在返回T1&#x2F;F1</span><br></pre></td></tr></table></figure>

<p><strong>传播错误</strong></p>
<p>如果需要上级来处理这个函数中出现的错误呢？</p>
<p>返回<code>Result&lt;, &gt;</code>类型</p>
<ul>
<li>使用<code>match</code>匹配，用分支来操作/返回</li>
<li>使用宏<code>?</code></li>
</ul>
<p><code>?</code>功能类似于match</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; match写法</span><br><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;);</span><br><span class="line">let mut f &#x3D; match f &#123;</span><br><span class="line">    Ok(file) &#x3D;&gt; file,</span><br><span class="line">    Err(e) &#x3D;&gt; return Err(e),</span><br><span class="line">&#125;;</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">match f.read_to_string(&amp;mut s) &#123;</span><br><span class="line">    Ok(_) &#x3D;&gt; Ok(s),</span><br><span class="line">    Err(e) &#x3D;&gt; Err(e),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ？写法：Err则该函数返回，Ok则语句返回正确值</span><br><span class="line">let mut f &#x3D; File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">f.read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br><span class="line">&#x2F;&#x2F; ？同时可以进行类型提升，把所有的错误类型都提升为std::error::Error</span><br><span class="line">&#x2F;&#x2F; 此时就是返回Result&lt;Ok值, Box&lt;dyn std::error::Error&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ？可以链式调用</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li><code>?</code>操作符一定需要一个变量来承接正确的值</li>
<li>函数一定要是<code>Result&lt;, &gt;</code>返回值</li>
</ul>
<h4 id="Option与Result的转换"><a href="#Option与Result的转换" class="headerlink" title="Option与Result的转换"></a><code>Option</code>与<code>Result</code>的转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Option&#96;转&#96;Result&#96;: 使用&#96;.ok_or()&#96;或&#96;.ok_or_else()</span><br><span class="line">&#x2F;&#x2F; Option&lt;T&gt;	Result&lt;T, E&gt;</span><br><span class="line">let res1: Result&lt;T, E&gt; &#x3D; Option类型值.ok_or(E类型值);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Result&#96;转&#96;Option&#96;: 丢弃错误使用&#96;ok()&#96;，丢弃成功值使用&#96;.err()</span><br><span class="line">&#x2F;&#x2F; Option&lt;T&gt;	Result&lt;T, E&gt;</span><br><span class="line">let opt1: Option&lt;T&gt; &#x3D; Result类型值.ok();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Option&lt;E&gt;	Result&lt;T, E&gt;</span><br><span class="line">let opt1: Option&lt;E&gt; &#x3D; Result类型值.err(); &#x2F;&#x2F; 如果Result类型值是ok()则丢弃</span><br></pre></td></tr></table></figure>

<h3 id="包与模块"><a href="#包与模块" class="headerlink" title="包与模块"></a>包与模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my_project&#x2F;</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src&#x2F;</span><br><span class="line">    ├── lib.rs         # library crate (名为 my_project)</span><br><span class="line">    ├── main.rs        # binary crate (名为 my_project)</span><br><span class="line">    └── bin&#x2F;</span><br><span class="line">        ├── tool1.rs   # binary crate (名为 tool1)</span><br><span class="line">        └── tool2.rs   # binary crate (名为 tool2)</span><br><span class="line">├── tests			   # 集成测试文件</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches			   # 基准性能测试文件</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples		   # 项目示例</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package&#96; &#x3D;&gt; &#96;Crate&#96; &#x3D;&gt; &#96;mod</span><br></pre></td></tr></table></figure>

<h4 id="Package-包"><a href="#Package-包" class="headerlink" title="Package(包)"></a><strong><code>Package(包)</code></strong></h4><p>一个<code>Package</code>就是一个项目，包含一个或多个<code>Crate</code>（最多一个）</p>
<p>每个 Package 必须包含一个 <code>Cargo.toml</code> 文件来描述包的元信息和依赖</p>
<h4 id="Crate-单元-箱"><a href="#Crate-单元-箱" class="headerlink" title="Crate(单元/箱)"></a><strong><code>Crate(单元/箱)</code></strong></h4><ul>
<li><code>crate</code> 是一个 Rust 项目或库的最小单元，即需要一起编译不可继续拆分</li>
<li>分为<code>lib</code>单元（入口文件一般为<code>src/lib.rs</code>；编译为库文件<code>.rlib</code>；不可单独执行，可以为其他项目提供依赖）和二进制单元（入口文件一般为<code>src/main.rs</code>或者在 <code>src/bin/</code> 目录下；编译为可执行文件）</li>
<li>一个<code>Package</code>最多可以包含一个库单元和多个二进制单元，也可以只包含一个库单元/一个或几个二进制单元</li>
<li>对于二进制单元，<code>src/main.rs</code>是默认的crate，其他的crate都在<code>src/bin/</code>（或其他）目录下，且文件可以单独编译（一个文件就是一个<code>crate</code>）</li>
</ul>
<p>考虑划分多个 crate 当：</p>
<ol>
<li>部分代码需要作为独立库被其他项目使用</li>
<li>项目包含多个独立可执行工具</li>
<li>某些功能需要单独编译和测试</li>
<li>需要减少编译时间（修改一个 crate 不会导致其他 crate 重新编译）</li>
</ol>
<h4 id="Mod-模块"><a href="#Mod-模块" class="headerlink" title="Mod(模块)"></a><strong><code>Mod(模块)</code></strong></h4><p>使用模块只是为了更好地组织代码，同时控制它们的可见性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义语法</span><br><span class="line">mod A &#123;</span><br><span class="line">	mod B &#123;fn B1()&#123;&#125;&#125; &#x2F;&#x2F;可以嵌套</span><br><span class="line">	mod C &#123;fn C1()&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路径引用</span><br><span class="line">fn D() &#123;</span><br><span class="line">    &#x2F;&#x2F; 绝对路径</span><br><span class="line">    crate::A::B::B1(); </span><br><span class="line">    &#x2F;&#x2F;相对路径：只能以super&#x2F;self&#x2F;模块名或Crate开头</span><br><span class="line">    A::B::B1(); &#x2F;&#x2F; 在同一个Crate根部的相对路径可以直接这么写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可见性设置</span><br><span class="line">pub mod hosting &#123; &#x2F;&#x2F; 模块写pub仅代表其可被访问，而其中的函数等还是对外界不可见</span><br><span class="line">    pub fn add_to_waitlist() &#123;&#125; &#x2F;&#x2F; 函数也需以pub开头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个<code>Crate</code>是一棵模块树，而<code>src/main.rs</code>及<code>src/lib.rs</code>就是该树的根</li>
<li>模块A包含模块B，则A是B的父模块，B是A的子模块</li>
<li>模块中可以定义各种<code>Rust</code>类型，如函数、结构体、枚举、特征等</li>
<li>在同一个<code>Crate</code>根下的模块，相互引用的相对路径可以直接以对方模块名称开头；在同一父模块下的两个子模块，若在同文件中实现则也可以以对方模块名称开头，否则需要通过<code>super::</code>来使用父模块中转</li>
<li>将结构体设置为 <code>pub</code>，但它的所有字段依然是私有的；将枚举设置为 <code>pub</code>，它的所有字段也将对外可见</li>
<li>可以把模块实现放入对应等级的<code>*.rs</code>文件中，<code>*</code>要等同于模块名（文件中便不必再写），模块的定义/声明还是在父文件/模块中</li>
</ul>
<h4 id="use"><a href="#use" class="headerlink" title="use"></a><code>use</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本引用方式：绝对或相对路径</span><br><span class="line">use crate::front_of_house::hosting; &#x2F;&#x2F; 引入模块</span><br><span class="line">use front_of_house::hosting::add_to_waitlist; &#x2F;&#x2F; 引入函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; as别名</span><br><span class="line">use std::fmt::Result;</span><br><span class="line">use std::io::Result as IoResult;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引入再导出</span><br><span class="line">pub use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简化引入</span><br><span class="line">use std::collections::&#123;HashMap,BTreeMap,HashSet&#125;;</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line">use std::io;</span><br><span class="line">use std::io::Write;</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br><span class="line"></span><br><span class="line">use std::collections::*; &#x2F;&#x2F; 引入模块下所有项</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>如果引入的函数存在同名的情况时，需使用<code>模块名::函数名</code>的方式或者<code>as</code>别名的方式来区分</li>
</ul>
<p><strong>限制可见性</strong></p>
<ul>
<li><code>pub</code> 意味着可见性无任何限制</li>
<li><code>pub(crate)</code> 表示在当前包可见</li>
<li><code>pub(self)</code> 在当前模块可见</li>
<li><code>pub(super)</code> 在父模块可见</li>
<li><code>pub(in &lt;path&gt;)</code> 表示在某个路径代表的模块中可见，其中 <code>path</code> 必须是父模块或者祖先模块</li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>简单来说，迭代器/高阶函数是“流水线模板”，提供规范流程（比如<code>map\filter</code>等等）；闭包是“可替换的工具”，即灵活调整传入的参数；而这两者都需要满足“不可变性”的安全要求</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是一种匿名函数，它<strong>可以赋值给变量也可以作为参数传递给其它函数</strong>，不同于函数的是，它<strong>允许捕获调用者作用域中的值</strong></p>
<p>闭包语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义闭包</span><br><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句1;</span><br><span class="line">    语句2;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125; </span><br><span class="line">|param1| 返回表达式 &#x2F;&#x2F; 只需要有一个表达式时</span><br><span class="line">|| &#123;&#125; &#x2F;&#x2F; 如果不需要参数时</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结构体中的闭包</span><br><span class="line">struct Cacher&lt;T&gt;</span><br><span class="line">where T: Fn(u32) -&gt; u32,</span><br><span class="line">&#123;</span><br><span class="line">    query: T,</span><br><span class="line">&#125;  &#x2F;&#x2F; 等价于struct Cacher&lt;T: Fn(u32) -&gt; u32&gt;，query字段同样也可以使用一个符合的函数作为值</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>闭包函数中是否标注类型皆可（如果未使用过则需要标注），同样可以以此省略返回值</li>
<li>闭包函数中的类型不可以是泛型，所以每次使用参数要求同类型</li>
</ul>
<p><strong>三种<code>Fn</code>特征</strong></p>
<p><code>FnOnce</code>: 强制需要闭包所捕获变量的所有权</p>
<p><code>FnMut</code>: 用于闭包函数内需要改变被捕获变量的值的情况，需要闭包和捕获变量都有<code>mut</code>声明</p>
<p><code>Fn</code>: 以不可变借用的方式捕获环境中的值(与<code>FnMut</code>不兼容，即不可改变捕获函数的值)</p>
<p><strong>注：</strong></p>
<ul>
<li><p>在<code>FnOnce</code>作为传入闭包的特征约束时，传入闭包和其捕获函数的所有权都会在第一次调用时被消耗；特殊情况：同时要求<code>FnOnce</code>与<code>Copy</code>（闭包会实现Copy，而其捕获的变量也会尽量实现Copy）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x &#x3D; vec![1, 2, 3];</span><br><span class="line">    fn_once(|z|&#123;z &#x3D;&#x3D; x.len()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fn_once&lt;F&gt;(func: F)</span><br><span class="line">where</span><br><span class="line">    F: FnOnce(usize) -&gt; bool,</span><br><span class="line">&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(3)); &#x2F;&#x2F; 捕获的Vec的所有权，闭包与变量一起消耗</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(4));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fn_once&lt;F&gt;(func: F)</span><br><span class="line">where</span><br><span class="line">    F: FnOnce(usize) -&gt; bool + Copy,&#x2F;&#x2F; 改动在这里</span><br><span class="line">&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(3)); &#x2F;&#x2F; 闭包实现Copy，不消耗；尽可能捕获可Copy的值如x.len()，没有则会在编译报错</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由上所知，闭包的捕获行为会根据上下文约束来调整</p>
</li>
<li><p>闭包自动实现<code>Copy</code>特征的规则是，只要闭包捕获的类型都实现了<code>Copy</code>特征的话，这个闭包就会默认实现<code>Copy</code>特征</p>
</li>
<li><p><code>FnOnce</code>会消耗闭包的所有权；但无论按值还是按引用传递，<code>Fn</code>/<code>FnMut</code>通常都不会消耗闭包的所有权。即在传入一个有<code>Fn(Mut)</code>特征约束的函数之后，一个闭包函数的变量还可以继续使用</p>
</li>
<li><p>所有的闭包都自动实现了 <code>FnOnce</code> 特征，因此任何一个闭包都至少可以被调用一次；没有移出所捕获变量的所有权的闭包自动实现了 <code>FnMut</code> 特征；不需要对捕获变量进行改变的闭包自动实现了 <code>Fn</code> 特征</p>
</li>
</ul>
<p><strong><code>move</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let update_string &#x3D;  move || println!(&quot;&#123;&#125;&quot;,s); &#x2F;&#x2F; move强制闭包获取变量所有权</span><br></pre></td></tr></table></figure>

<p>闭包作为函数返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fn factory() -&gt; Fn(i32) -&gt; i32 &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    |x| x + num</span><br><span class="line">&#125; &#x2F;&#x2F; 报错，特征不是类型，需要其他辅助声明</span><br><span class="line"></span><br><span class="line">fn factory(x:i32) -&gt; impl Fn(i32) -&gt; i32 &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    if x &gt; 1&#123;</span><br><span class="line">        move |x| x + num</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        move |x| x - num</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 报错，返回的内容要求是同一类型，此处虽然满足同一特征，但属于不同类型</span><br><span class="line"></span><br><span class="line">fn factory(x:i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    if x &gt; 1&#123;</span><br><span class="line">        Box::new(move |x| x + num)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Box::new(move |x| x - num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 正确，使用智能指针将其视为同一类型</span><br></pre></td></tr></table></figure>

<h4 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器<code>Iterator</code></h4><p>迭代器允许我们迭代一个连续的集合，例如数组、动态数组 <code>Vec</code>、<code>HashMap</code> 等，在此过程中，只需关心集合中的元素如何处理，而无需关心如何开始、如何结束、按照什么样的索引去访问</p>
<p>1、<code>.next</code>是迭代器中取下一个值的方式,返回<code>Option&lt;T&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</span><br><span class="line">    &#x2F;&#x2F; 省略其余有默认实现的方法</span><br><span class="line">&#125; &#x2F;&#x2F; 迭代器实现的特征Interator</span><br></pre></td></tr></table></figure>

<p>2、将数组转化为迭代器的三种方式(<code>Vec</code>动态数组实现的<code>IntoIterator</code>中的函数)：</p>
<ul>
<li><code>into_iter</code> 会夺走所有权</li>
<li><code>iter</code> 是借用</li>
<li><code>iter_mut</code> 是可变借用（<code>next</code>方法返回的<code>&amp;mut</code>）</li>
</ul>
<p>3、迭代器的消费者与适配器（都是迭代器特征中的方法）</p>
<ul>
<li><p>消费者：消费掉迭代器，返回一个值</p>
<p> 会拿走迭代器的所有权，即调用它之后迭代器无法再使用</p>
</li>
<li><p>适配器：返回一个新的迭代器，是链式调用的基础</p>
<p> 因此在链式调用末尾需要一个消费者来收尾用以返回一个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例1</span><br><span class="line">let v1: Vec&lt;i32&gt; &#x3D; vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">let v2: Vec&lt;_&gt; &#x3D; v1.iter().map(|x| x + 1).collect();</span><br><span class="line">&#x2F;&#x2F; collect():消费掉迭代器，把值收集成特定类型（需要显式注明）</span><br><span class="line">&#x2F;&#x2F; .map():对迭代器的每一个值操作，换为另一个新值</span><br><span class="line"></span><br><span class="line">assert_eq!(v2, vec![2, 3, 4]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例2</span><br><span class="line">let names &#x3D; [&quot;sunface&quot;, &quot;sunfei&quot;];</span><br><span class="line">let ages &#x3D; [18, 18];</span><br><span class="line">let folks: HashMap&lt;_, _&gt; &#x3D; names.into_iter().zip(ages.into_iter()).collect();</span><br><span class="line">&#x2F;&#x2F; .zip():将两个迭代器压缩在一起，形成Iterator&lt;Item&#x3D;(ValueFromA, ValueFromB)&gt; 这样的新的迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例3：闭包用作适配器参数</span><br><span class="line">fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.into_iter().filter(|s| s.size &#x3D;&#x3D; shoe_size).collect()</span><br><span class="line">&#125; &#x2F;&#x2F; filter():对迭代器每个值进行过滤，若满足则保留</span><br><span class="line">&#x2F;&#x2F; 此处闭包同样可以捕捉环境变量</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="深入类型"><a href="#深入类型" class="headerlink" title="深入类型"></a>深入类型</h3><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>as转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 3.1 as i8;</span><br><span class="line">let b &#x3D; 100_i8 as i32;</span><br><span class="line">let c &#x3D; &#39;a&#39; as u8; &#x2F;&#x2F; 将字符&#39;a&#39;转换为整数，97</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>转换不具有传递性：就算 <code>e as U1 as U2</code> 是合法的，也不能说明 <code>e as U2</code> 是合法的（<code>e</code> 不能直接转换成 <code>U2</code>）</p>
<p><strong><code>TryInto</code>转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: u8 &#x3D; 10;</span><br><span class="line">let b: u16 &#x3D; 1500;</span><br><span class="line">let b_: u8 &#x3D; b.try_into().unwrap(); &#x2F;&#x2F;尝试进行一次转换，并返回一个 Result</span><br></pre></td></tr></table></figure>

<p>注：<code>try_into</code> 转换会捕获大类型向小类型转换时导致的溢出错误</p>
<p><strong><code>From</code>和<code>Into</code>特征</strong></p>
<ul>
<li><strong><code>From&lt;T&gt;</code></strong>：定义如何从类型 <code>T</code> 转换到当前类型。</li>
<li><strong><code>Into&lt;T&gt;</code></strong>：自动为实现了 <code>From</code> 的类型生成反向转换。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">impl From&lt;i32&gt; for MyType &#123;</span><br><span class="line">    fn from(value: i32) -&gt; Self &#123;</span><br><span class="line">        MyType(value)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a &#x3D; MyType::from(42);  &#x2F;&#x2F; 显式调用</span><br><span class="line">let b: MyType &#x3D; 42.into(); &#x2F;&#x2F; 自动推导（需类型注解）</span><br></pre></td></tr></table></figure>

<h4 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a><code>newtype</code></h4><p>使用<a href="https://course.rs/basic/compound-type/struct.html#元组结构体tuple-struct" target="_blank" rel="noopener">元组结构体</a>的方式将已有的类型包裹起来：<code>struct Meters(u32);</code>，那么此处 <code>Meters</code> 就是一个 <code>newtype</code></p>
<ul>
<li>自定义类型可以让我们给出更有意义和可读性的类型名，例如与其使用 <code>u32</code> 作为距离的单位类型，我们可以使用 <code>Meters</code>，它的可读性要好得多</li>
<li>对于某些场景，只有 <code>newtype</code> 可以很好地解决</li>
<li>隐藏内部类型的细节</li>
</ul>
<p><strong>为外部类型实现外部特征</strong></p>
<p>孤儿规则：要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 必须至少有一个在当前的作用范围内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例：想为Vec实现Display特征，但这两个都在标准库中</span><br><span class="line">use std::fmt;</span><br><span class="line">struct Wrapper(Vec&lt;String&gt;);</span><br><span class="line">impl fmt::Display for Wrapper &#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f, &quot;[&#123;&#125;]&quot;, self.0.join(&quot;, &quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注：包裹一样类型的newtype是不同的类型,newtype与其内部包裹的类型同理</span><br></pre></td></tr></table></figure>



<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Meters &#x3D; u32</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>类型别名仅仅为了更好的可读性，与原类型没有任何区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 应用：减少代码模板的使用</span><br><span class="line">let f: Box&lt;dyn Fn() + Send + &#39;static&gt; &#x3D; Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line"></span><br><span class="line">type Thunk &#x3D; Box&lt;dyn Fn() + Send + &#39;static&gt;;</span><br><span class="line">let f: Thunk &#x3D; Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;常用于简化Result&lt;T, E&gt; 枚举中</span><br><span class="line">type Result&lt;T&gt; &#x3D; std::result::Result&lt;T, std::io::Error&gt;; &#x2F;&#x2F; 此处为std::io库中Error类型的简化</span><br></pre></td></tr></table></figure>



<h4 id="不定长类型DST"><a href="#不定长类型DST" class="headerlink" title="不定长类型DST"></a>不定长类型DST</h4><p>定长类型：基础类型、集合 <code>Vec</code>、<code>String</code> 和 <code>HashMap</code> 等(其在栈上拥有固定大小的指针)</p>
<p>不定长类型：<code>str</code>、特征对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn foobar_1(thing: &amp;dyn MyThing) &#123;&#125;     &#x2F;&#x2F; OK</span><br><span class="line">fn foobar_2(thing: Box&lt;dyn MyThing&gt;) &#123;&#125; &#x2F;&#x2F; OK</span><br><span class="line">fn foobar_3(thing: MyThing) &#123;&#125;          &#x2F;&#x2F; ERROR!</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>只能间接使用DST，通过引用或<code>Box</code>来使用</p>
<p><strong><code>Sized</code>特征</strong></p>
<p>怎么保证泛型参数是固定大小的类型？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T(: Sized)&gt;(t: T) &#123; &#x2F;&#x2F; 自动补全了Sized特征</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举与整数"><a href="#枚举与整数" class="headerlink" title="枚举与整数"></a>枚举与整数</h4><p>枚举到整数很容易，但反过来需要借助三方库来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">enum MyEnum &#123;</span><br><span class="line">    A &#x3D; 1,</span><br><span class="line">    B,</span><br><span class="line">    C,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将枚举转换成整数，顺利通过</span><br><span class="line">    let x &#x3D; MyEnum::C as i32;</span><br><span class="line">    &#x2F;&#x2F; 将整数转换为枚举，失败</span><br><span class="line">    match x &#123;</span><br><span class="line">        MyEnum::A &#x3D;&gt; &#123;&#125;</span><br><span class="line">        MyEnum::B &#x3D;&gt; &#123;&#125;</span><br><span class="line">        MyEnum::C &#x3D;&gt; &#123;&#125;</span><br><span class="line">        _ &#x3D;&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用num-traits&#x2F;num-derive库</span><br><span class="line">use num_derive::FromPrimitive;</span><br><span class="line">use num_traits::FromPrimitive;</span><br><span class="line"></span><br><span class="line">match FromPrimitive::from_i32(x) &#123;</span><br><span class="line">    Some(MyEnum::A) &#x3D;&gt; println!(&quot;Got A&quot;),</span><br><span class="line">    Some(MyEnum::B) &#x3D;&gt; println!(&quot;Got B&quot;),</span><br><span class="line">    Some(MyEnum::C) &#x3D;&gt; println!(&quot;Got C&quot;),</span><br><span class="line">    None            &#x3D;&gt; println!(&quot;Couldn&#39;t convert &#123;&#125;&quot;, x),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>引用（<code>&amp;T</code>/<code>&amp;mut T</code>）</strong></th>
<th><strong>智能指针（如 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所有权关系</strong></td>
<td>无所有权，仅是借用</td>
<td>通常拥有数据的所有权</td>
</tr>
<tr>
<td><strong>可变性控制</strong></td>
<td>分为共享引用（<code>&amp;T</code>）和可变引用（<code>&amp;mut T</code>）</td>
<td>通过内部可变性（如 <code>RefCell&lt;T&gt;</code>）或类型设计实现</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>必须显式或隐式标注生命周期</td>
<td>通常管理数据的整个生命周期（如 <code>Box</code> 负责释放）</td>
</tr>
<tr>
<td><strong>动态行为</strong></td>
<td>仅提供访问，无额外逻辑</td>
<td>可附加逻辑（如引用计数、自动释放、线程安全）</td>
</tr>
<tr>
<td><strong>常见类型</strong></td>
<td><code>&amp;T</code>, <code>&amp;mut T</code></td>
<td><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code></td>
</tr>
</tbody></table>
<p>智能指针与普通自定义结构体区别：实现了<code>Deref</code>和<code>Drop</code>特征</p>
<p>智能指针用于一些较引用更复杂的场景</p>
<h4 id="Box-lt-T-gt-堆对象分配"><a href="#Box-lt-T-gt-堆对象分配" class="headerlink" title="Box&lt;T&gt;堆对象分配"></a><code>Box&lt;T&gt;</code>堆对象分配</h4><p><code>Box</code> 简单的封装，用于将值存储在堆上</p>
<p>使用场景：</p>
<ul>
<li>特意的将数据分配在堆上</li>
<li>数据较大时，又不想在转移所有权时进行数据拷贝</li>
<li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时</li>
<li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将数据存储在堆上</span><br><span class="line">let a &#x3D; 3; &#x2F;&#x2F; a在栈上</span><br><span class="line">let a &#x3D; Box::new(3); &#x2F;&#x2F; 在堆上</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 避免栈上数据拷贝</span><br><span class="line">let arr &#x3D; [0;1000];</span><br><span class="line">let arr1 &#x3D; arr; &#x2F;&#x2F; 此时两份数据，是深拷贝</span><br><span class="line"></span><br><span class="line">let arr &#x3D; Box::new([0;1000]);</span><br><span class="line">let arr1 &#x3D; arr; &#x2F;&#x2F; 所有权顺利转移给 arr1，arr 不再拥有所有权</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提供固定大小</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, List), &#x2F;&#x2F; 递归类型：无法确定大小，因为DST报错</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, Box&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特征对象</span><br><span class="line">&#x2F;&#x2F; 想实现不同类型组成的数组只有两个办法：枚举和特征对象</span><br><span class="line">&#x2F;&#x2F; 特征对象其实就是把DST类型的特征转为固定大小</span><br></pre></td></tr></table></figure>

<p><strong>另：</strong><code>Box::leak</code>可以真正将一个运行期的值转化为<code>&#39;static</code>，如果只标注<code>&#39;static</code>可能无法成功</p>
<h4 id="Deref解引用"><a href="#Deref解引用" class="headerlink" title="Deref解引用"></a><code>Deref</code>解引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deref&#96; 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 &#96;*T</span><br></pre></td></tr></table></figure>

<p><strong><code>\*</code>:</strong> 对常规引用使用<code>*</code>操作符，即可以通过解引用的方式获取到内存地址对应的数据值</p>
<p><strong>智能指针解引用：</strong> 在使用给定的智能指针时，直接使用<code>*</code>解引用即可</p>
<p>在智能指针解引用时，实际上调用了<code>*(y.deref())</code>方法：<code>y.deref()</code>先返回了值的常规引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果要实现自己的智能指针同样要实现Deref特征</span><br><span class="line">use std::ops::Deref;</span><br><span class="line">impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;</span><br><span class="line">    type Target &#x3D; T;</span><br><span class="line">    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;</span><br><span class="line">        &amp;self.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 实现该特征后才能使用*解引用</span><br></pre></td></tr></table></figure>

<p><strong>函数/方法中的隐式<code>Deref</code>转换</strong></p>
<p>函数和方法的传参中有<code>Deref</code>的隐式转换。</p>
<p>若一个类型实现了 <code>Deref</code> 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 <code>Deref</code> 转换(<code>Deref</code>支持连续的隐式转换)</p>
<p><strong>总结</strong></p>
<ul>
<li>一个类型为 <code>T</code> 的对象 <code>foo</code>，如果 <code>T: Deref&lt;Target=U&gt;</code>，那么，相关 <code>foo</code> 的引用 <code>&amp;foo</code> 在应用的时候会自动转换为 <code>&amp;U</code></li>
<li>在解引用时自动把智能指针和 <code>&amp;&amp;&amp;&amp;v</code> 做引用归一化操作，转换成 <code>&amp;v</code> 形式，最终再对 <code>&amp;v</code> 进行解引用（即将智能指针脱壳为内部的引用类型即<code>&amp;v</code>， 把多级引用归一为一级<code>&amp;v</code>）</li>
</ul>
<h4 id="Drop释放资源"><a href="#Drop释放资源" class="headerlink" title="Drop释放资源"></a><code>Drop</code>释放资源</h4><p>指定在一个变量超出作用域时，执行一段特定的代码，最终编译器将帮你自动插入这段收尾代码（无需在每一个使用该变量的地方，都写一段代码来进行收尾工作和资源释放）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Drop for Foo &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123; &#x2F;&#x2F; 传入的是可变借用</span><br><span class="line">        println!(&quot;Dropping Foo!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Drop 的顺序</strong></p>
<ul>
<li>变量级别，按照逆序的方式（<code>_x</code> 在 <code>_foo</code> 之前创建，因此 <code>_x</code> 在 <code>_foo</code> 之后被 <code>drop</code>）</li>
<li>结构体内部，按照顺序的方式</li>
</ul>
<p><strong>注：</strong></p>
<ul>
<li>Rust 自动为几乎所有类型都实现了 <code>Drop</code> 特征（除了栈上的简单类型）</li>
<li>不允许显式地调用析构函数<code>变量名.drop()</code>，但可以调用函数<code>drop(变量名)</code>（<code>drop()</code>函数会拿走目标值的所有权）</li>
<li><code>Copy</code>和<code>Drop</code>互斥，不会在一种类型上面出现（为了防止重复释放内存）</li>
</ul>
<h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a><code>Rc</code></h4><p>通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者</p>
<p>实现机制就是 <code>Rc</code> 和 <code>Arc</code>，前者适用于单线程，后者适用于多线程</p>
<p><strong><code>Rc&lt;T&gt;</code></strong></p>
<p>引用计数：通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放</p>
<p>当我们希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用 <code>Rc</code> 成为数据值的所有者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; Rc::new(String::from(&quot;hello, world&quot;)); &#x2F;&#x2F; 创建时引用计数+1，此时Rc::strong_count(&amp;a) 返回的值是 1</span><br><span class="line">let b &#x3D; Rc::clone(&amp;a); &#x2F;&#x2F; clone 仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据；同样可以使用a.clone()</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>这几个智能指针都是相同的所以<code>Rc::strong_count(&amp;a/b/c)</code>皆可</li>
<li>当其中一个变量离开作用域被销毁后，计数<code>-1</code>，但只有当计数为0时，这个指针和指向的底层数据才会销毁</li>
<li><code>Rc&lt;T&gt;</code>指向的是底层数据的不可变应用(相当于有多个不可变引用)</li>
<li>实现了<code>Deref</code>特征，可以直接使用里面的数值</li>
</ul>
<p><strong><code>Arc</code></strong></p>
<ul>
<li>原子化的 <code>Rc&lt;T&gt;</code> 智能指针,保证我们的数据能够安全的在线程间共享</li>
<li>与<code>Rc</code>的API完全相同</li>
<li><code>Arc</code> 和 <code>Rc</code> 并没有定义在同一个模块，前者通过 <code>use std::sync::Arc</code> 来引入，后者通过 <code>use std::rc::Rc</code></li>
</ul>
<h4 id="Cell和RefCell"><a href="#Cell和RefCell" class="headerlink" title="Cell和RefCell"></a><code>Cell</code>和<code>RefCell</code></h4><p>解决问题（相较于引用）：</p>
<ul>
<li>可以通过不可变引用来修改数据</li>
<li>绕过编译期借用检查</li>
<li>实现了部分可变性（比如标定结构体某个字段为内部可变）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><code>Cell&lt;T&gt;</code></th>
<th><code>RefCell&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td>获取不可变访问</td>
<td><code>get()</code> → <code>T</code>（复制）</td>
<td><code>borrow()</code> → <code>Ref&lt;T&gt;</code></td>
</tr>
<tr>
<td>获取可变访问</td>
<td><code>set(new_value)</code></td>
<td><code>borrow_mut()</code> → <code>RefMut&lt;T&gt;</code></td>
</tr>
<tr>
<td>运行时检查</td>
<td>无</td>
<td>有（可能 panic）</td>
</tr>
<tr>
<td>适用类型</td>
<td><code>T: Copy</code>（如 <code>i32</code>）</td>
<td>任意 <code>T</code>（如 <code>String</code>）</td>
</tr>
</tbody></table>
<p><strong><code>Cell</code></strong></p>
<p><code>Cell</code> 和 <code>RefCell</code> 在功能上没有区别，区别在于 <code>Cell&lt;T&gt;</code> 适用于 <code>T</code> 实现 <code>Copy</code> 的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let c &#x3D; Cell::new(42);</span><br><span class="line">let val &#x3D; c.get(); &#x2F;&#x2F; 复制值（42）</span><br><span class="line">c.set(100); &#x2F;&#x2F; 替换新值，仍然拥有所有权不会报错</span><br><span class="line"></span><br><span class="line">let c &#x3D; Cell::new(String::from(&quot;asdf&quot;)); &#x2F;&#x2F; 这样会报错</span><br></pre></td></tr></table></figure>

<p><strong><code>RefCell</code></strong></p>
<ul>
<li>允许通过不可变引用 (<code>&amp;T</code>) 修改内部数据（内部可变性）。</li>
<li>在运行时（而非编译期）检查借用规则，违反规则时触发 <code>panic</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; RefCell::new(String::from(&quot;hello, world&quot;)); &#x2F;&#x2F; s为RefCell&lt;T&gt;类型</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>borrow()</code></td>
<td>获取不可变引用 (<code>Ref&lt;T&gt;</code>)，增加不可变借用计数。若已有可变借用，则 <code>panic</code>。</td>
</tr>
<tr>
<td><code>borrow_mut()</code></td>
<td>获取可变引用 (<code>RefMut&lt;T&gt;</code>)，标记独占借用。若已有任何借用，则 <code>panic</code>。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Logger &#123;</span><br><span class="line">    logs: RefCell&lt;Vec&lt;String&gt;&gt;, &#x2F;&#x2F; 内部可变</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Logger &#123;</span><br><span class="line">    fn log(&amp;self, message: &amp;str) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过不可变的 &amp;self 修改 logs！</span><br><span class="line">        self.logs.borrow_mut().push(message.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong><code>RefCell</code> 的核心机制是，将一个本应可变的数据（如 <code>String</code>）包裹在“壳子”（<code>RefCell</code>）里，然后通过这个壳子的不可变引用（<code>&amp;RefCell&lt;T&gt;</code>），在运行时安全地修改内部数据</p>
<h4 id="循环引用与自引用"><a href="#循环引用与自引用" class="headerlink" title="循环引用与自引用"></a>循环引用与自引用</h4><p>面临问题：当使用<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>时，可以a指向b，b再指向a，出现循环引用，最后<code>Rc</code>计数无法归0</p>
<p><strong><code>Weak</code></strong></p>
<p>仅保存一份指向数据的弱引用，不保证引用关系依然存在，无法阻止所引用的内存值被释放</p>
<table>
<thead>
<tr>
<th><code>Weak</code></th>
<th><code>Rc</code></th>
</tr>
</thead>
<tbody><tr>
<td>不计数</td>
<td>引用计数</td>
</tr>
<tr>
<td>不拥有所有权</td>
<td>拥有值的所有权</td>
</tr>
<tr>
<td>不阻止值被释放(drop)</td>
<td>所有权计数归零，才能 drop</td>
</tr>
<tr>
<td>引用的值存在返回 <code>Some</code>，不存在返回 <code>None</code></td>
<td>引用的值必定存在</td>
</tr>
<tr>
<td>通过 <code>upgrade</code> 取到 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，然后再取值</td>
<td>通过 <code>Deref</code> 自动解引用，取值无需任何操作</td>
</tr>
</tbody></table>
<p><code>Weak</code> 通过 <code>use std::rc::Weak</code> 来引入，它具有以下特点:</p>
<ul>
<li>可访问，但没有所有权，不增加引用计数，因此不会影响被引用值的释放回收</li>
<li>可由 <code>Rc&lt;T&gt;</code> 调用 <code>Rc::downgrade</code> 方法转换成 <code>Weak&lt;T&gt;</code></li>
<li><code>Weak&lt;T&gt;</code> 可使用 <code>upgrade</code> 方法转换成 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，如果资源已经被释放，则 <code>Option</code> 的值是 <code>None</code></li>
<li>常用于解决循环引用的问题</li>
</ul>
<h3 id="多线程并发编程"><a href="#多线程并发编程" class="headerlink" title="多线程并发编程"></a>多线程并发编程</h3><p>并发：同时存在多个动作</p>
<p>并行：可以同时执行多个动作</p>
<p>关系：并发程序可以由人编写，但只有有多个CPU内核时才可以并行执行；</p>
<p> 并行一定并发，但只有多核时并发才能够并行</p>
<h4 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h4><p><strong>风险</strong></p>
<p>由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：</p>
<ul>
<li>竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源</li>
<li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li>
<li>一些因为多线程导致的很隐晦的 BUG，难以复现和解决</li>
</ul>
<p><strong>创建线程：</strong><code>thread::spawn</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let handle &#x3D; </span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        for i in 1..10 &#123;</span><br><span class="line">            println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(1)); &#x2F;&#x2F; thread::sleep 会让当前线程休眠指定的时间，随后其它线程会被调度运行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); &#x2F;&#x2F; 线程内部的代码使用闭包来执行</span><br><span class="line">    </span><br><span class="line">    handle.join().unwrap(); &#x2F;&#x2F; 让当前线程阻塞，直到它等待的子线程的结束</span><br><span class="line">    </span><br><span class="line">    for i in 1..5 &#123;</span><br><span class="line">        println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; main 线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>线程的启动结束时间点都是不固定的</li>
<li>由上一条，为了保证子线程中的变量一直有效，在子线程的闭包中捕获了环境变量时，需要使用<code>move</code>来转移所有权</li>
<li>主线程（<code>main</code>）退出时，会强制终止所有子线程（无论它们是否在运行）；父线程（非主线程）退出时，不会影响它创建的子线程</li>
<li><code>thread::spawn</code> 的返回值是<strong><code>std::thread::JoinHandle</code></strong>类型，表示对线程的控制权，允许主线程通过 <code>join()</code> 等待子线程结束，同样可以使用数组收集</li>
</ul>
<p><strong>多线程的性能</strong></p>
<p>当任务是 CPU 密集型时，就算线程数超过了 CPU 核心数，也并不能帮你获得更好的性能</p>
<p>当你的任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量（典型就是网络 IO 操作）</p>
<p><strong>线程屏障<code>Barrier</code></strong></p>
<p>让多个线程都执行到某个点后，才继续一起往后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Barrier&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let barrier &#x3D; Arc::new(Barrier::new(3));</span><br><span class="line">    let mut handles &#x3D; vec![];</span><br><span class="line"></span><br><span class="line">    for i in 0..3 &#123;</span><br><span class="line">        let barrier &#x3D; barrier.clone();</span><br><span class="line">        handles.push(thread::spawn(move || &#123;</span><br><span class="line">            println!(&quot;线程 &#123;&#125;: 阶段1&quot;, i);</span><br><span class="line">            barrier.wait(); &#x2F;&#x2F; 等待所有线程完成阶段1</span><br><span class="line">            println!(&quot;线程 &#123;&#125;: 阶段2&quot;, i);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>需要<code>Arc</code>智能指针，作用是允许多个线程同时拥有同一数据（跨线程<code>Rc</code>）</li>
<li><code>Barrier::new(n)</code>中的<code>n</code>值一定要与实际调用<code>wait()</code>的线程数相等</li>
</ul>
<p><strong>多线程局部变量</strong></p>
<p>标准库<code>thread_local</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义</span><br><span class="line">thread_local! &#123;</span><br><span class="line">    static MY_TLS: 类型 &#x3D; 初始化值; &#x2F;&#x2F; 必须使用static声明为全局变量，一般使用RefCell&#x2F;Cell&#x2F;Mutex包裹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 语法：变量名.with(|绑定名| &#123; 操作 &#125;); 闭包传入参数即为局部变量</span><br><span class="line">thread::spawn(|| &#123;</span><br><span class="line">    &#x2F;&#x2F; 每个线程独立操作 COUNTER</span><br><span class="line">    COUNTER.with(|c| &#123;</span><br><span class="line">          *c.borrow_mut() +&#x3D; 1;</span><br><span class="line">          println!(&quot;Thread &#123;:?&#125;: &#123;&#125;&quot;, thread::current().id(), c.borrow());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>如果想使用多个局部变量的闭包函数，使用嵌套</p>
<p> 同样还有使用<code>use thread_local::ThreadLocal;</code>引用的三方库，这个库不仅仅使用了值的拷贝，而且还能自动把多个拷贝汇总到一个迭代器中，最后进行求和</p>
<p>条件控制线程的挂起和执行：<code>let pair = Arc::new((Mutex::new(false), Condvar::new()));</code></p>
<p>只会调用一次的函数：<code>static INIT: Once =Once::new();</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT.call_once(|| &#123;unsafe &#123;VAL &#x3D; 2;&#125;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a><strong>消息传递</strong></h5><p>线程通过发送和接收消息来通信，而非直接共享内存</p>
<p><strong>标准库工具<code>mpsc</code></strong>，允许多发送者，单接收者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个消息通道, 返回一个元组：(发送者，接收者)</span><br><span class="line">let (tx, rx) &#x3D; mpsc::channel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建线程，并发送消息</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    tx.send(1).unwrap(); &#x2F;&#x2F; 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span><br><span class="line">    &#x2F;&#x2F; tx.send(Some(1)).unwrap()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在主线程中接收子线程发送的消息并输出</span><br><span class="line">println!(&quot;receive &#123;&#125;&quot;, rx.recv().unwrap());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试接收一次消息，不会阻塞线程，当通道中没有消息时，它会立刻返回一个错误</span><br><span class="line">println!(&quot;receive &#123;:?&#125;&quot;, rx.try_recv());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 连续接收消息</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    let vals &#x3D; vec![</span><br><span class="line">        String::from(&quot;hi&quot;),</span><br><span class="line">        String::from(&quot;from&quot;),</span><br><span class="line">        String::from(&quot;the&quot;),</span><br><span class="line">        String::from(&quot;thread&quot;),</span><br><span class="line">    ];</span><br><span class="line">    for val in vals &#123;</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        thread::sleep(Duration::from_secs(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for received in rx &#123;</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用多发送者：克隆发送者，其余的线程拿走拷贝</span><br><span class="line">let tx1 &#x3D; tx.clone();</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    tx1.send(String::from(&quot;hi from cloned tx&quot;)).unwrap();</span><br><span class="line">&#125;); </span><br><span class="line">for received in rx &#123;</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;&#x2F;&#x2F; 需要所有的发送者都被drop掉后，接收者rx才会收到错误，进而跳出for循环，最终结束主线程；</span><br><span class="line">&#x2F;&#x2F; 两个子线程谁先创建完成是未知的，哪条消息先发送也是未知的</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步通道设置</span><br><span class="line">let (tx, rx)&#x3D; mpsc::sync_channel(n); &#x2F;&#x2F; n用来指定同步通道的消息缓存条数</span><br></pre></td></tr></table></figure>

<ul>
<li><code>tx</code>,<code>rx</code>对应发送者和接收者，它们的类型由编译器自动推导: <code>tx.send(1)</code>发送了整数，因此它们分别是<code>mpsc::Sender&lt;i32&gt;</code>和<code>mpsc::Receiver&lt;i32&gt;</code>类型，(一旦类型被推导确定，该通道就只能传递对应类型的值)</li>
<li>接收消息的操作<code>rx.recv()</code>会阻塞当前线程，直到读取到值，或者通道被关闭</li>
<li>需要使用<code>move</code>将<code>tx</code>的所有权转移到子线程的闭包中</li>
<li>使用通道来传输数据，一样要遵循 Rust 的所有权规则：<ul>
<li>若值的类型实现了<code>Copy</code>特征，则直接复制一份该值，然后传输过去，例如之前的<code>i32</code>类型</li>
<li>若值没有实现<code>Copy</code>（如<code>String</code>类型），则它的所有权会被转移给接收端，在发送端继续使用该值将报错</li>
</ul>
</li>
<li>异步中只有接收者会被阻塞，同步中发送者也会因为接收者接收不到消息被阻塞</li>
<li>所有发送者被<code>drop</code>或者所有接收者被<code>drop</code>后，通道会自动关闭</li>
</ul>
<h5 id="锁、Condvar"><a href="#锁、Condvar" class="headerlink" title="锁、Condvar"></a>锁、<code>Condvar</code></h5><p>使用共享内存来实现同步性</p>
<p>面临问题：多个线程同时修改同一数据时，结果不可预测；线程执行顺序影响最终结果</p>
<p><strong>互斥锁<code>Mutex</code></strong></p>
<p>同一时间，只允许一个线程<code>A</code>访问该值，其它线程需要等待<code>A</code>访问完成后才能继续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建实例：锁的容器</span><br><span class="line">let m &#x3D; Mutex::new(5);</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; lock返回的是Result</span><br><span class="line">    let mut num &#x3D; m.lock().unwrap(); &#x2F;&#x2F; .lock()向m申请锁的所有权（简称“锁”）：在获取锁之前会阻塞线程。同时只能有一个线程获得锁</span><br><span class="line">    &#x2F;&#x2F; 当拥有锁的线程panic，其他线程永远得不到这个锁</span><br><span class="line">    *num &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 锁自动被drop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多线程中使用锁</span><br><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">let counter &#x3D; Arc::new(Mutex::new(0));</span><br><span class="line">let mut handles &#x3D; vec![];</span><br><span class="line"></span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">    let counter &#x3D; Arc::clone(&amp;counter);</span><br><span class="line">    &#x2F;&#x2F; 创建子线程，并将&#96;Mutex&#96;的所有权拷贝传入到子线程中，子线程需要通过move拿走锁的所有权</span><br><span class="line">    let handle &#x3D; thread::spawn(move || &#123;</span><br><span class="line">        let mut num &#x3D; counter.lock().unwrap();</span><br><span class="line">		*num +&#x3D; 1;</span><br><span class="line">    &#125;);</span><br><span class="line">    handles.push(handle);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 等待所有子线程完成</span><br><span class="line">for handle in handles &#123;</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>m.lock()</code>返回一个智能指针<code>MutexGuard&lt;T&gt;</code>，拥有<code>Deref</code>特征（自动解引用获取引用类型）与<code>Drop</code>特征（超出作用域自动释放锁）</li>
<li><code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code>用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutex&lt;T&gt;</code>用于多线程内部可变性</li>
</ul>
<p><strong>死锁</strong></p>
<ul>
<li>在另一个锁还未被释放时去申请新的锁，就会触发</li>
<li>当我们拥有两个锁的容器，且两个线程各自使用了其中一个锁，然后试图去访问另一个锁时，就可能发生死锁</li>
<li><code>try_lock()</code>: 尝试去获取一次锁，如果无法获取会返回一个错误，因此不会发生阻塞</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let guard &#x3D; MUTEX2.lock().unwrap();</span><br><span class="line">let guard &#x3D; MUTEX2.try_lock(); &#x2F;&#x2F; 返回错误</span><br></pre></td></tr></table></figure>

<p><strong>读写锁<code>RwLock</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Mutex&#96;会对每次读写都进行加锁，但某些时候，我们需要大量的并发读，&#96;Mutex&#96;就无法满足需求了，此时就可以使用&#96;RwLock</span><br><span class="line">use std::sync::RwLock;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let lock &#x3D; RwLock::new(5);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同一时间允许多个读</span><br><span class="line">    &#123;</span><br><span class="line">        let r1 &#x3D; lock.read().unwrap();</span><br><span class="line">        let r2 &#x3D; lock.read().unwrap();</span><br><span class="line">        assert_eq!(*r1, 5);</span><br><span class="line">        assert_eq!(*r2, 5);</span><br><span class="line">    &#125; &#x2F;&#x2F; 读锁在此处被drop</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同一时间只允许一个写</span><br><span class="line">    &#123;</span><br><span class="line">        let mut w &#x3D; lock.write().unwrap();</span><br><span class="line">        *w +&#x3D; 1;</span><br><span class="line">        assert_eq!(*w, 6);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以下代码会阻塞发生死锁，因为读和写不允许同时存在</span><br><span class="line">        &#x2F;&#x2F; 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于&#96;w&#96;的作用域中</span><br><span class="line">        &#x2F;&#x2F; let r1 &#x3D; lock.read();</span><br><span class="line">        &#x2F;&#x2F; println!(&quot;&#123;:?&#125;&quot;,r1);</span><br><span class="line">    &#125;&#x2F;&#x2F; 写锁在此处被drop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>try_write</code>和<code>try_read</code>来尝试进行一次写/读，若失败则返回错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Err(&quot;WouldBlock&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>条件变量<code>Condvar</code>控制线程同步</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex, Condvar&#125;;</span><br><span class="line"></span><br><span class="line">let pair &#x3D; Arc::new((Mutex::new(false), Condvar::new()));</span><br><span class="line">let (lock, cvar) &#x3D; &amp;*pair;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消费者线程（等待条件成立）</span><br><span class="line">let consumer &#x3D; thread::spawn(move || &#123;</span><br><span class="line">    let mut condition &#x3D; lock.lock().unwrap();</span><br><span class="line">    while !*condition &#123;</span><br><span class="line">        condition &#x3D; cvar.wait(condition).unwrap(); &#x2F;&#x2F; 释放锁并等待</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;Condition is now true!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产者线程（修改条件并通知）</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    let mut condition &#x3D; lock.lock().unwrap();</span><br><span class="line">    *condition &#x3D; true;          &#x2F;&#x2F; 修改条件</span><br><span class="line">    cvar.notify_one();          &#x2F;&#x2F; 唤醒消费者</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">consumer.join().unwrap();</span><br></pre></td></tr></table></figure>

<p>消费者线程需等待条件成立才可执行：获取互斥锁检查条件是否成立 =&gt; 不成立则进入循环 =&gt; <code>cvar.wait(condition).unwrap()</code>执行时立即释放互斥锁（交由其他线程修改） =&gt; 其他线程修改后使用<code>cvar.notify_one()</code>唤醒该线程 =&gt; 返回条件重新检查</p>
<p>注：</p>
<ul>
<li><pre><code>notify_one()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">随机唤醒一个正在</span><br></pre></td></tr></table></figure>
wait()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  的线程（由操作系统调度决定）。</span><br><span class="line"></span><br><span class="line">  - 如果有多个线程在等待，不保证顺序（可能是最早等待的，也可能是随机的）。</span><br><span class="line">  - 如果没有线程在等待，这次通知会被丢弃（无效果）。</span><br><span class="line"></span><br><span class="line">- &#96;notify_all()&#96;： 唤醒所有正在 &#96;wait()&#96; 的线程，它们会竞争锁并依次检查条件。</span><br><span class="line"></span><br><span class="line">##### &#96;Atomic&#96;原子类型与内存顺序</span><br><span class="line"></span><br><span class="line">为解决锁的性能问题而生，通过 CPU 的原子指令实现无锁线程安全操作</span><br><span class="line"></span><br><span class="line">| 特性             | 说明                                                         |</span><br><span class="line">| ---------------- | ------------------------------------------------------------ |</span><br><span class="line">| **不可分割性**   | 操作一旦开始，不会被其他线程或 CPU 中断。                    |</span><br><span class="line">| **线程安全**     | 多线程同时执行同一原子指令时，结果依然正确                   |</span><br><span class="line">| **硬件直接支持** | 由 CPU 通过特定指令（如 &#96;LOCK&#96; 前缀）实现，而非软件模拟。    |</span><br><span class="line">| **内存顺序控制** | 通过 &#96;Ordering&#96; 参数指定操作前后的指令重排规则（如 &#96;SeqCst&#96;）。 |</span><br></pre></td></tr></table></figure>
use std::sync::atomic::AtomicUsize;
</code></pre></li>
</ul>
<p>let counter = AtomicUsize::new(0); // 常用场景是作为全局变量</p>
<p>counter.store(100, Ordering::Relaxed); // 存储值（写入）</p>
<p>let current = counter.load(Ordering::SeqCst);<br>println!(“Current value: {}”, current); // 加载值（读取）</p>
<p>let old = counter.fetch_add(10, Ordering::SeqCst); // 原子加法（返回旧值）旧值=100，新值=110</p>
<p>counter.fetch_sub(5, Ordering::Relaxed); // 原子减法 新值=105</p>
<p>counter.fetch_or(0b1, Ordering::Relaxed); // 原子位操作 按位或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**内存顺序**</span><br><span class="line"></span><br><span class="line">面临问题：编译器可能导致指令重排</span><br></pre></td></tr></table></figure>
<p>X = 1;<br>Y = 3;<br>X = 2; // 直接变成</p>
<p>X = 2;<br>Y = 3;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内存顺序指定</span><br><span class="line"></span><br><span class="line">| **Ordering** | 作用                                                         |</span><br><span class="line">| ------------ | ------------------------------------------------------------ |</span><br><span class="line">| &#96;Relaxed&#96;    | 仅保证原子性，不保证顺序（性能最高）                         |</span><br><span class="line">| &#96;Release&#96;    | 写入操作：确保之前的指令不会被重排到它之后，（在这条指令前写入的数据）对其他线程可见 |</span><br><span class="line">| &#96;Acquire&#96;    | 读取操作：确保之后的指令不会被重排到它之前，能读到其他线程的修改 |</span><br><span class="line">| &#96;SeqCst&#96;     | 严格顺序一致性（性能最低，但最安全）                         |</span><br></pre></td></tr></table></figure>
<p>use std::sync::atomic::{AtomicBool, Ordering};</p>
<p>let ready = AtomicBool::new(false);<br>let data = 42;</p>
<p>// 线程1：发布数据<br>thread::spawn(move || {<br>    data = 100;                        // 非原子写入<br>    ready.store(true, Ordering::Release); // 保证 data 写入对其他线程可见<br>});</p>
<p>// 线程2：读取数据<br>thread::spawn(move || {<br>    while !ready.load(Ordering::Acquire) {} // 等待并同步内存<br>    println!(“Data: {}”, data);        // 保证看到 data=100<br>});</p>
<p>// 多线程需要用到Arc与clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 全局变量</span><br><span class="line"></span><br><span class="line">全局变量的生命周期肯定是&#96;&#39;static&#96;，但是不代表它需要用&#96;static&#96;来声明</span><br><span class="line"></span><br><span class="line">- 编译期初始化的全局变量，&#96;const&#96;创建常量，&#96;static&#96;创建静态变量，&#96;Atomic&#96;创建原子类型</span><br><span class="line">- 运行期初始化的全局变量，&#96;lazy_static&#96;用于懒初始化，&#96;Box::leak&#96;利用内存泄漏将一个变量的生命周期变为&#96;&#39;static&#96;</span><br><span class="line"></span><br><span class="line">#### 编译期初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**静态常量**</span><br></pre></td></tr></table></figure>
<p>const MAX_ID: usize =  usize::MAX / 2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关键字是&#96;const&#96;而不是&#96;let&#96;</span><br><span class="line">- 定义常量必须指明类型（如 i32）不能省略</span><br><span class="line">- 定义常量时变量的命名规则一般是全部大写</span><br><span class="line">- 常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址</span><br><span class="line">- 常量的赋值只能是常量表达式&#x2F;数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式</span><br><span class="line">- 对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义</span><br><span class="line"></span><br><span class="line">**静态变量**</span><br></pre></td></tr></table></figure>
<p>static mut REQUEST_RECV: usize = 0;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 必须使用&#96;unsafe&#96;语句块才能访问和修改&#96;static&#96;变量</span><br><span class="line">- 定义静态变量的时候必须赋值为在编译期就可以计算出的值(常量表达式&#x2F;数学表达式)，不能是运行时才能计算出的值(如函数)</span><br><span class="line"></span><br><span class="line">**原子类型**</span><br><span class="line"></span><br><span class="line">想要全局计数器、状态控制等功能，又想要线程安全的实现</span><br></pre></td></tr></table></figure>
<p>use std::sync::atomic::{AtomicUsize, Ordering};<br>static REQUEST_RECV: AtomicUsize  = AtomicUsize::new(0);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 运行期初始化</span><br><span class="line"></span><br><span class="line">解决问题：无法用函数进行静态初始化</span><br><span class="line"></span><br><span class="line">**&#96;lazy_static&#96;**</span><br><span class="line"></span><br><span class="line">用于懒初始化（直到使用时才开始初始化）静态变量的宏，允许我们在运行期初始化静态变量</span><br></pre></td></tr></table></figure>
<p>use lazy_static::lazy_static;<br>lazy_static! {<br>    static ref NAMES: Mutex<String> = Mutex::new(String::from(“Sunface, Jack, Allen”));<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;lazy_static&#96;宏，匹配的是&#96;static ref&#96;，所以定义的静态变量都是不可变引用</span><br><span class="line"></span><br><span class="line">**&#96;Box::leak&#96;**</span><br><span class="line"></span><br><span class="line">将一个变量从内存中漏出来，变为&#96;&#39;static&#39;&#96;生命周期</span><br></pre></td></tr></table></figure>
<p>#[derive(Debug)]<br>struct Config {<br>    a: String,<br>    b: String<br>}<br>static mut CONFIG: Option&lt;&amp;mut Config&gt; = None;</p>
<p>fn main() {<br>    let c = Box::new(Config {<br>        a: “A”.to_string(),<br>        b: “B”.to_string(),<br>    });</p>
<pre><code>unsafe {
    // 将`c`从内存中泄漏，变成`&apos;static`生命周期(正常情况下，一个局部变量不可赋给全局变量)
    CONFIG = Some(Box::leak(c));
    println!(&quot;{:?}&quot;, CONFIG);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 错误处理</span><br><span class="line"></span><br><span class="line">#### 组合器</span><br><span class="line"></span><br><span class="line">**&#96;or()&#96;和&#96;and()&#96;**</span><br><span class="line"></span><br><span class="line">对两个表达式做逻辑组合，最终返回 &#96;Option&#96; &#x2F; &#96;Result&#96;</span><br><span class="line"></span><br><span class="line">- &#96;or()&#96;，表达式按照顺序求值，若任何一个表达式的结果是 &#96;Some&#96; 或 &#96;Ok&#96;，则该值会立刻返回</span><br><span class="line">- &#96;and()&#96;，若两个表达式的结果都是 &#96;Some&#96; 或 &#96;Ok&#96;，则第二个表达式中的值被返回。若任何一个的结果是 &#96;None&#96; 或 &#96;Err&#96; ，则立刻返回。</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“some1”);<br>let s2 = Some(“some2”);<br>let n: Option&lt;&amp;str&gt; = None;<br>assert_eq!(s1.or(s2), s1);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注：&#96;or&#x2F;and()&#96;的两个表达式要是同一类型，不能一边是&#96;Option&#96;一边是&#96;Result&#96;</span><br><span class="line"></span><br><span class="line">**&#96;or_else()和and_then()&#96;**</span><br><span class="line"></span><br><span class="line">跟 &#96;or()&#96; 和 &#96;and()&#96; 类似，但第二个表达式是一个闭包</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“some1”);<br>let fn_some = || Some(“some2”);<br>let fn_none = || None;<br>assert_eq!(s1.or_else(fn_some), s1);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;fliter&#96;**</span><br><span class="line"></span><br><span class="line">用于对 &#96;Option&#96; 进行过滤</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(3);<br>let n = None;<br>let fn_is_even = |x: &amp;i8| x % 2 == 0;<br>assert_eq!(s1.filter(fn_is_even), n);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;map()&#96;和&#96;map_err()&#96;**</span><br><span class="line"></span><br><span class="line">&#96;map&#96; 可以将 &#96;Some&#96; 或 &#96;Ok&#96; 中的值映射为另一个（转化容器内的值）</span><br><span class="line"></span><br><span class="line"> 如果&#96;a&#96;的值是&#96;Some(n)&#96;，&#96;a.map(f)&#96;将&#96;a&#96;的值变为&#96;Some(f(n))&#96;</span><br><span class="line"></span><br><span class="line">用 &#96;map_err&#96;将 &#96;Err&#96; 中的值进行改变（效果同上）</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“abcde”);<br>let s2 = Some(5);<br>let fn_character_count = |s: &amp;str| s.chars().count();<br>assert_eq!(s1.map(fn_character_count), s2);</p>
<p>let e1: Result&lt;&amp;str, &amp;str&gt; = Err(“404”);<br>let e2: Result&lt;&amp;str, isize&gt; = Err(404);<br>let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() };<br>assert_eq!(e1.map_err(fn_character_count), e2);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**&#96;map_or()&#96;和&#96;map_or_else()&#96;**</span><br><span class="line"></span><br><span class="line">&#96;map_or&#96; 在 &#96;map&#96; 的基础上提供了一个默认值</span><br><span class="line"></span><br><span class="line">&#96;map_or_else&#96; 与 &#96;map_or&#96; 类似，但是它是通过一个闭包来提供默认值</span><br></pre></td></tr></table></figure>
<p>const V_DEFAULT: u32 = 1; // 默认值<br>let s: Result&lt;u32, ()&gt; = Ok(10);<br>let fn_closure = |v: u32| v + 2;<br>assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);</p>
<p>let s = Some(10);<br>let fn_closure = |v: i8| v + 2;<br>let fn_default = || 1; // 默认值<br>assert_eq!(s.map_or_else(fn_default, fn_closure), 12);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;ok_or()&#96;和&#96;ok_or_else&#96;**</span><br><span class="line"></span><br><span class="line">可以将 &#96;Option&#96; 类型转换为 &#96;Result&#96; 类型</span><br><span class="line"></span><br><span class="line">&#96;ok_or&#96; 接收一个默认的 &#96;Err&#96; 参数，&#96;ok_or_else&#96; 接收一个闭包作为 &#96;Err&#96; 参数</span><br></pre></td></tr></table></figure>
<p>const ERR_DEFAULT: &amp;str = “error message”;<br>// let fn_err_message = || “error message”;</p>
<p>assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)<br>assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 自定义错误类型</span><br></pre></td></tr></table></figure>
<p>use std::fmt::{Debug, Display};</p>
<p>pub trait Error: Debug + Display {<br>    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + ‘static)&gt; { … }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当自定义类型实现该特征后，该类型就可以作为 &#96;Err&#96; 来使用，同时可以归一化为&#96;Box&lt;dyn std::error:Error&gt;&#96;</span><br><span class="line"></span><br><span class="line">**将其他错误类型转化为自定义错误类型**</span><br><span class="line"></span><br><span class="line">只要实现&#96;From&#96;特征，即可使用&#96;?&#96;强制把返回的错误类型转换（同时返回）</span><br></pre></td></tr></table></figure>
<p>// std::convert::From特征<br>pub trait From<T>: Sized {<br>  fn from(_: T) -&gt; Self;<br>} // T为原本的错误类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**归一化不同错误类型**</span><br><span class="line"></span><br><span class="line">面临问题：要在一个函数中返回不同的错误</span><br><span class="line"></span><br><span class="line">解决方案：将不同的错误类型归一化为一种</span><br><span class="line"></span><br><span class="line">- 使用特征对象 &#96;Box&lt;dyn Error&gt;&#96;：需要实现&#96;Debug + Display&#96; 特征（存在问题：一个没有&#96;Error&#96;特征的类型同样可以用作&#96;Result&lt;T, E&gt;&#96;中的&#96;E&#96;）</span><br><span class="line">- 自定义错误类型：需要实现&#96;Error&#96;特征才能被转换出来</span><br><span class="line">- 使用 &#96;thiserror&#96;（一种三方库函数）</span><br><span class="line"></span><br><span class="line">### &#96;UnSafe&#96;</span><br><span class="line"></span><br><span class="line">面临问题：</span><br><span class="line"></span><br><span class="line">- 编译器过强且保守</span><br><span class="line">- 特定功能如底层硬件操作本就不安全</span><br><span class="line"></span><br><span class="line">&#96;unsafe&#96;功能</span><br><span class="line"></span><br><span class="line">- 解引用裸指针</span><br><span class="line">- 调用一个 &#96;unsafe&#96; 或外部的函数</span><br><span class="line">- 访问或修改一个可变的静态变量</span><br><span class="line">- 实现一个 &#96;unsafe&#96; 特征</span><br><span class="line">- 访问 &#96;union&#96; 中的字段</span><br><span class="line"></span><br><span class="line">#### 功能解析</span><br><span class="line"></span><br><span class="line">##### 解引用裸指针</span><br><span class="line"></span><br><span class="line">裸指针在功能上跟引用类似，同时它也需要显式地注明可变性。</span><br><span class="line"></span><br><span class="line">&#96;*const T&#96; 和 &#96;*mut T&#96;分别代表了不可变和可变（&#96;*&#96; 是类型名称的一部分而非解引用）</span><br><span class="line"></span><br><span class="line">裸指针的功能（类似于C的指针）：</span><br><span class="line"></span><br><span class="line">- 可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</span><br><span class="line">- 并不能保证指向合法的内存</span><br><span class="line">- 可以是 &#96;null&#96;</span><br><span class="line">- 没有实现任何自动的回收 (drop)</span><br></pre></td></tr></table></figure>
<p>// 基于引用创建裸指针<br>let mut num = 5;<br>let r1 = &amp;num as *const i32;<br>let r2 = &amp;mut num as *mut i32;</p>
<p>// 使用*解引用<br>unsafe {<br>    println!(“{}”, *r1);<br>}</p>
<p>// 基于智能指针创建裸指针<br>let a: Box<i32> = Box::new(10);<br>let b: <em>const i32 = &amp;</em>a; // 需要先解引用a<br>let c: *const i32 = Box::into_raw(a); // 使用 into_raw 来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">- 创建裸指针是安全的行为，使用不是</span><br><span class="line">- 使用裸指针可以创建两个可变指针都指向同一个数据（需要自己处理数据竞争）</span><br><span class="line"></span><br><span class="line">##### 调用&#96;unsafe&#96;函数或方法</span><br></pre></td></tr></table></figure>
<p>// unsafe函数：外表唯一不同就是需要unsafe fn来定义，在调用时需要放在unsafe块<br>// 在unsafe函数中使用unsafe来注明块是多余的行为<br>unsafe fn dangerous() {}<br>fn main() {<br>    unsafe {<br>        dangerous();<br>    }<br>}</p>
<p>// 在函数中使用了unsafe声明块不代表函数要声明为unsafe fn:同样可以使用用安全的抽象包裹unsafr代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### &#96;FFI&#96;</span><br><span class="line"></span><br><span class="line">用来与其它语言进行交互</span><br><span class="line"></span><br><span class="line">面临问题：使用一个其他语言编写的库</span><br><span class="line"></span><br><span class="line">- 对该库进行重写或者移植</span><br><span class="line">- 使用 &#96;FFI&#96;</span><br></pre></td></tr></table></figure>
<p>// 调用C标准库中的abs函数<br>extern “C” { // C定义了外部函数所使用的应用二进制接口ABI<br>    fn abs(input: i32) -&gt; i32;<br>}<br>fn main() {<br>    unsafe { // 必须使用unsafe<br>        println!(“Absolute value of -3 according to C: {}”, abs(-3));<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 访问&#96;union&#96;中的字段</span><br><span class="line"></span><br><span class="line">&#96;union&#96;主要用于和&#96;C&#96;代码交互，访问其字段是不安全的</span><br></pre></td></tr></table></figure>
<p>#[repr(C)]<br>union MyUnion {<br>    f1: u32,<br>    f2: f32,<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &#96;Macro&#96;宏编程</span><br><span class="line"></span><br><span class="line">宏的参数可以使用 &#96;()&#96;、&#96;[]&#96; 以及 &#96;&#123;&#125;&#96;：虽然三种使用形式皆可，但是 Rust 内置的宏都有自己约定俗成的使用方式，例如 &#96;vec![...]&#96;、&#96;assert_eq!(...)&#96; 等</span><br><span class="line"></span><br><span class="line">宏分为两类：</span><br><span class="line"></span><br><span class="line">- 声明式宏</span><br><span class="line">- 三种过程宏</span><br><span class="line">  - &#96;#[derive]&#96;，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 &#96;Debug&#96; 特征</span><br><span class="line">  - 类属性宏(Attribute-like macro)，用于为目标添加自定义的属性</span><br><span class="line">  - 类函数宏(Function-like macro)，看上去就像是函数调用</span><br><span class="line"></span><br><span class="line">#### 宏与函数的区别</span><br><span class="line"></span><br><span class="line">元编程：通过一种代码来生成另一种代码，可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本</span><br><span class="line"></span><br><span class="line">可变参数：相比于&#96;Rust&#96;中函数参数个数的固定，宏的参数个数可变</span><br><span class="line"></span><br><span class="line">宏展开：宏展开过程是发生在编译器对代码进行解释之前，即编译期前；函数直到运行时才调用</span><br><span class="line"></span><br><span class="line">#### 声明式宏&#96;macro_rules&#96;</span><br><span class="line"></span><br><span class="line">声明式宏用来编写可以生成代码的代码，即可以编写自己的宏</span><br><span class="line"></span><br><span class="line">类似于&#96;match&#96;进行模式匹配，类似于函数可以传入参数</span><br></pre></td></tr></table></figure>
<p>// 基本形式<br>macro_rules! macro_name {<br>    (pattern) =&gt; { expansion };<br>    // 可以有多个匹配模式<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**模式匹配**的模式可以包括：字面量、元变量（以 &#96;$&#96; 开头的捕获，如 &#96;$x:expr&#96;）、重复（使用 &#96;$(...)*&#96; 或 &#96;$(...)+&#96; 等表示重复）</span><br><span class="line"></span><br><span class="line">**元变量类型**（类似于函数定义中形参的类型声明）</span><br><span class="line"></span><br><span class="line">- &#96;expr&#96;：表达式</span><br><span class="line">- &#96;ident&#96;：标识符（变量名、函数名等）</span><br><span class="line">- &#96;ty&#96;：类型</span><br><span class="line">- &#96;path&#96;：路径（如 &#96;std::collections::HashMap&#96;）</span><br><span class="line">- &#96;pat&#96;：模式</span><br><span class="line">- &#96;stmt&#96;：语句</span><br><span class="line">- &#96;block&#96;：代码块</span><br><span class="line">- &#96;item&#96;：项（函数、结构体、模块等）</span><br><span class="line">- &#96;meta&#96;：元项（&#96;#[...]&#96; 和 &#96;#![...]&#96; 属性内部的内容）</span><br><span class="line">- &#96;tt&#96;：标记树（单个标记或括号内的标记）</span><br><span class="line"></span><br><span class="line">**重复操作符**</span><br><span class="line"></span><br><span class="line">- &#96;*&#96;：0 次或多次</span><br><span class="line">- &#96;+&#96;：1 次或多次</span><br><span class="line">- &#96;?&#96;：0 次或 1 次</span><br></pre></td></tr></table></figure>
<p>#[macro_export] // 将宏进行了导出，其它的包就可以将该宏引入到当前作用域中<br>macro_rules! create_function { // 宏的名称是c_f，在调用时才需要加上！<br>    ($func_name:ident) =&gt; {<br>        fn $func_name() {<br>            println!(“You called {}”, stringify!($func_name));<br>        }<br>    };<br>}<br>// 使用<br>create_function!(foo); // 传入一个合法标识符，创建了一个函数<br>foo(); // 输出: You called foo</p>
<p>// 重复模式<br>#[macro_export]<br>macro_rules! vec {<br>    ( $( $x:expr ),* ) =&gt; {<br>        {<br>            let mut temp_vec = Vec::new();<br>            $(<br>                temp_vec.push($x);<br>            )* // 此处相当于一个循环<br>            temp_vec<br>        }<br>    };<br>}<br>// 使用<br>let v = vec!(“a”, “b”, “c”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 过程宏</span><br><span class="line"></span><br><span class="line">1. **派生宏（Derive Macros）** *&quot;自动为结构体&#x2F;枚举生成 trait 实现的代码扩展器。&quot;* → **用途**：如 &#96;#[derive(Serialize)]&#96; 为类型实现序列化逻辑。</span><br><span class="line">2. **属性宏（Attribute Macros）** *&quot;编译时代码加工器，能修改或增强被标记的项（如函数&#x2F;结构体）。&quot;* → **用途**：如 &#96;#[tokio::main]&#96; 将普通函数异步化。</span><br><span class="line">3. **函数式宏（Function-like Macros）** *&quot;将其他语法编译时转换为 Rust 代码的翻译器。&quot;* → **用途**：如 &#96;sql!(SELECT * FROM table)&#96; 生成类型安全的查询构建器。</span><br><span class="line"></span><br><span class="line">##### 自定义&#96;derive&#96;过程宏</span><br><span class="line"></span><br><span class="line">注：目前只能在单独的包中定义宏，包名以&#96;derive&#96;为后缀</span><br><span class="line"></span><br><span class="line">假设有一个特征 &#96;HelloMacro&#96;，现在有两种方式让用户使用它：</span><br><span class="line"></span><br><span class="line">- 为每个类型手动实现该特征，就像之前特征章节所做的</span><br><span class="line">- 使用过程宏来统一实现该特征，这样用户只需要对类型进行标记即可：&#96;#[derive(HelloMacro)]&#96;</span><br></pre></td></tr></table></figure>
<p>// hello_macro项目目录<br>hello_macro<br>├── Cargo.toml<br>├── src<br>│   ├── main.rs<br>│   └── lib.rs<br>└── hello_macro_derive // 此包中实现宏<br>    ├── Cargo.toml<br>    ├── src<br>        └── lib.rs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在项目的&#96;src&#x2F;main.rs&#96;中引用宏包中的内容：</span><br><span class="line"></span><br><span class="line">- 将 &#96;hello_macro_derive&#96; 发布到 &#96;crates.io&#96; 或 &#96;GitHub&#96; 中（类似于正常的依赖）</span><br><span class="line">- 使用相对路径引入的本地化方式</span><br></pre></td></tr></table></figure>
<p>// 修改 hello_macro/Cargo.toml 文件添加以下内容<br>[dependencies]<br>hello_macro_derive = { path = “../hello_macro/hello_macro_derive” }</p>
<h1 id="也可以使用下面的相对路径"><a href="#也可以使用下面的相对路径" class="headerlink" title="也可以使用下面的相对路径"></a>也可以使用下面的相对路径</h1><h1 id="hello-macro-derive-path-“-hello-macro-derive”"><a href="#hello-macro-derive-path-“-hello-macro-derive”" class="headerlink" title="hello_macro_derive = { path = “./hello_macro_derive” }"></a>hello_macro_derive = { path = “./hello_macro_derive” }</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">定义过程宏的过程</span><br></pre></td></tr></table></figure>
<p>// 1、在 hello_macro_derive/Cargo.toml 文件中添加<br>[lib]<br>proc-macro = true</p>
<p>[dependencies]<br>syn = “1.0”<br>quote = “1.0” // 这两个依赖包是定义中必须的</p>
<p>// 2、在 hello_macro_derive/src/lib.rs 中添加<br>extern crate proc_macro; // 过程宏核心库，提供 TokenStream 类型（表示宏的输入/输出）<br>use proc_macro::TokenStream;<br>use quote::quote;<br>use syn;<br>use syn::DeriveInput;</p>
<p>#[proc_macro_derive(HelloMacro)]<br>pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {<br>    // 基于 input 构建 AST 语法树<br>    let ast:DeriveInput = syn::parse(input).unwrap();</p>
<pre><code>// 构建特征实现代码
impl_hello_macro(&amp;ast)</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RCore学习记录</span><br><span class="line"></span><br><span class="line">顺序：&#96;bulid.rs&#96;文件会生成一个&#96;link_app.S&#96;（里面包含有各个程序标识起始地址的变量、名称和完整的ELF文件嵌入），这个文件由&#96;linker.S&#96;塞入内核镜像（编译链接后的程序文件），最后由&#96;load&#96;来执行</span><br><span class="line"></span><br><span class="line">任务切换的实质：切换任务上下文（即更改对应的寄存器为想执行的任务上下文中保存的数值）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 批处理系统</span><br><span class="line"></span><br><span class="line">**系统调用的基础函数：**</span><br><span class="line"></span><br><span class="line">&#96;syscall&#96; （用户文件中，标准库函数的基础） 和&#96;sbicall&#96; （系统文件中）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;rust</span><br><span class="line"> 3fn syscall(id: usize, args: [usize; 3]) -&gt; isize &#123;</span><br><span class="line"> 4   let mut ret: isize;</span><br><span class="line"> 5   unsafe &#123;</span><br><span class="line"> 6       core::arch::asm!(</span><br><span class="line"> 7           &quot;ecall&quot;,</span><br><span class="line"> 8           inlateout(&quot;x10&quot;) args[0] &#x3D;&gt; ret,</span><br><span class="line"> 9           in(&quot;x11&quot;) args[1],</span><br><span class="line">10           in(&quot;x12&quot;) args[2],</span><br><span class="line">11           in(&quot;x17&quot;) id</span><br><span class="line">12       );</span><br><span class="line">13   &#125;</span><br><span class="line">14   ret</span><br><span class="line">15&#125;</span><br></pre></td></tr></table></figure>



<p><strong>批处理系统的应用管理器：</strong></p>
<p>（从系统文件中一个记录了应用数量、各应用起始位置、最后一个应用结束位置的<code>link_app.S</code>中获取）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppManager</span></span> &#123;</span><br><span class="line">    num_app: <span class="built_in">usize</span>,</span><br><span class="line">    current_app: <span class="built_in">usize</span>,</span><br><span class="line">    app_start: [<span class="built_in">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法： <code>print_app_info/get_current_app/move_to_next_app</code> </p>
<p><code>load_app</code>将参数 <code>app_id</code> 对应的应用程序的二进制镜像加载到物理内存以 <code>0x80400000</code> 起始的位置</p>
<p><strong><code>batch</code>子模块暴露的接口</strong></p>
<ul>
<li><code>init</code> ：初始化 <code>APP_MANAGER</code> </li>
<li><code>run_next_app</code> ：加载并运行下一个应用程序</li>
</ul>
<p><strong>用户栈与内核栈</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">// os/src/batch.rs</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"> <span class="number">4</span><span class="keyword">struct</span> KernelStack &#123;</span><br><span class="line"> <span class="number">5</span>  data: [<span class="built_in">u8</span>; KERNEL_STACK_SIZE],</span><br><span class="line"> <span class="number">6</span>&#125;</span><br><span class="line"> <span class="number">7</span></span><br><span class="line"> <span class="number">8</span><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"> <span class="number">9</span><span class="keyword">struct</span> UserStack &#123;</span><br><span class="line"><span class="number">10</span>  data: [<span class="built_in">u8</span>; USER_STACK_SIZE],</span><br><span class="line"><span class="number">11</span>&#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span><span class="keyword">static</span> KERNEL_STACK: KernelStack = KernelStack &#123;</span><br><span class="line"><span class="number">14</span>  data: [<span class="number">0</span>; KERNEL_STACK_SIZE],</span><br><span class="line"><span class="number">15</span>&#125;;</span><br><span class="line"><span class="number">16</span><span class="keyword">static</span> USER_STACK: UserStack = UserStack &#123;</span><br><span class="line"><span class="number">17</span>  data: [<span class="number">0</span>; USER_STACK_SIZE],</span><br><span class="line"><span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>实现了 <code>get_sp</code> 方法来获取栈顶地址</p>
<p><strong>特权级切换</strong></p>
<table>
<thead>
<tr>
<th>CSR 名</th>
<th>该 CSR 与 Trap 相关的功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>sstatus</code></td>
<td><code>SPP</code> 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息</td>
</tr>
<tr>
<td><code>sepc</code></td>
<td>当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址</td>
</tr>
<tr>
<td><code>scause</code></td>
<td>描述 Trap 的原因</td>
</tr>
<tr>
<td><code>stval</code></td>
<td>给出 Trap 附加信息</td>
</tr>
<tr>
<td><code>stvec</code></td>
<td>控制 Trap 处理代码的入口地址</td>
</tr>
</tbody></table>
<p>硬件自动完成：</p>
<ul>
<li><code>sstatus</code> 的 <code>SPP</code> 字段会被修改为 CPU 当前的特权级（U/S）。</li>
<li><code>sepc</code> 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。</li>
<li><code>scause/stval</code> 分别会被修改成这次 Trap 的原因以及相关的附加信息。</li>
<li>CPU 会跳转到 <code>stvec</code> 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。</li>
</ul>
<p>处理完成后通过S特权级<code>sret</code>指令：</p>
<ul>
<li>CPU 会将当前的特权级按照 <code>sstatus</code> 的 <code>SPP</code> 字段设置为 U 或者 S ；</li>
<li>CPU 会跳转到 <code>sepc</code> 寄存器指向的那条指令，然后继续执行。</li>
</ul>
<p><strong><code>Trap</code>上下文</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="number">4</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line"><span class="number">6</span>    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line"><span class="number">7</span>    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line"><span class="number">8</span>&#125; <span class="comment">// 包含所有的通用寄存器 `x0~x31` ，还有 `sstatus` 和 `sepc`</span></span><br><span class="line"><span class="comment">// 从内存栈底分配34个空间保存</span></span><br></pre></td></tr></table></figure>

<p>实现 Trap 上下文保存和恢复的汇编代码<code>os/src/trap/trap.S</code>,用（汇编中的）外部符号 <code>__alltraps</code> 和 <code>__restore</code> 标记为函数</p>
<p>Trap 处理的总体流程如下：首先通过 <code>__alltraps</code> 将 Trap 上下文保存在内核栈上，然后跳转到使用 Rust 编写的 <code>trap_handler</code> 函数 完成 Trap 分发及处理。当 <code>trap_handler</code> 返回之后，使用 <code>__restore</code> 从保存在内核栈上的 Trap 上下文恢复寄存器。最后通过一条 <code>sret</code> 指令回到应用程序执行</p>
<p>使用<code>sp</code>表示当前的栈，<code>sscratch</code>代表另一个栈</p>
<p>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_sp</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="built_in">usize</span>) </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>(entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> </span><br><span class="line">    <span class="comment">// 修改其中的 sepc 寄存器为应用程序入口点 entry， sp 寄存器为我们设定的 一个栈指针，并将 sstatus 寄存器的 SPP 字段设置为 User</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="分时多任务"><a href="#分时多任务" class="headerlink" title="分时多任务"></a>分时多任务</h3><p><code>user/build.py</code>为每个应用定制各自的起始地址，.text 段的地址为 <code>0x80400000 + app_id * 0x20000</code></p>
<p><code>batch</code> 被拆分为 <code>loader</code> 和 <code>task</code> ， 前者负责启动时加载应用程序，后者负责切换和调度。</p>
<p><code>loader</code> 模块的 <code>load_apps</code> 函数负责将所有用户程序在内核初始化的时一并加载进内存</p>
<p><strong>任务切换</strong></p>
<p>当一个应用在内核态时，其 Trap 控制流可以调用一个特殊的 <code>__switch</code> 函数，函数调用时运行另一个任务，返回后运行原来的任务</p>
<p>在 <code>__switch</code> 中保存 CPU 的某些寄存器，它们就是任务上下文</p>
<p>函数拥有两个参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> __switch(</span><br><span class="line">    current_task_cx_ptr: *<span class="keyword">mut</span> TaskContext,</span><br><span class="line">    next_task_cx_ptr: *<span class="keyword">const</span> TaskContext</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>内核先把 <code>current_task_cx_ptr</code> 中包含的寄存器值逐个保存，再把 <code>next_task_cx_ptr</code> 中包含的寄存器值逐个恢复</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">// os/src/task/context.rs</span></span><br><span class="line"><span class="number">2</span><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="number">3</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span></span> &#123;</span><br><span class="line"><span class="number">4</span>    ra: <span class="built_in">usize</span>, <span class="comment">// 任务恢复后执行地址</span></span><br><span class="line"><span class="number">5</span>    sp: <span class="built_in">usize</span>, <span class="comment">// 该任务内核栈地址(当前是内核态)</span></span><br><span class="line"><span class="number">6</span>    s: [<span class="built_in">usize</span>; <span class="number">12</span>], <span class="comment">// 被调用者保存寄存器</span></span><br><span class="line"><span class="number">7</span>&#125; <span class="comment">// TaskContext 里包含的寄存器</span></span><br></pre></td></tr></table></figure>



<p><strong>管理多道程序</strong></p>
<ul>
<li>任务运行状态：未初始化、准备执行、正在执行、已退出</li>
<li>任务控制块：维护任务状态和任务上下文</li>
<li>任务相关系统调用：程序主动暂停 <code>sys_yield</code> 和主动退出 <code>sys_exit</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">TaskStatus</span></span> &#123; <span class="comment">// 任务状态</span></span><br><span class="line">    UnInit, <span class="comment">// 未初始化</span></span><br><span class="line">    Ready, <span class="comment">// 准备运行</span></span><br><span class="line">    Running, <span class="comment">// 正在运行</span></span><br><span class="line">    Exited, <span class="comment">// 已退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123; <span class="comment">// 任务控制块</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 任务状态</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 任务上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局的任务管理器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    num_app: <span class="built_in">usize</span>,</span><br><span class="line">    inner: UPSafeCell&lt;TaskManagerInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskManagerInner</span></span> &#123;</span><br><span class="line">    tasks: [TaskControlBlock; MAX_APP_NUM],</span><br><span class="line">    current_task: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TaskManager</code>方法：<code>mark_current_suspended</code>（暂停当前程序）/  <code>mark_current_exited</code> / <code>run_next_task</code> / <code>find_next_task</code>（找到下一个<code>Ready</code>状态的应用）</p>
<p><strong>时钟中断</strong></p>
<p>处理器维护时钟计数器 <code>mtime</code>，还有另外一个 CSR <code>mtimecmp</code> 。 一旦计数器 <code>mtime</code> 的值超过了 <code>mtimecmp</code>，就会触发一次时钟中断</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_time</span></span>() -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获得mtime值</span></span><br><span class="line">    time::read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_timer</span></span>(timer: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    sbi_call(SBI_SET_TIMER, timer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_next_trigger</span></span>() &#123; <span class="comment">// 设置时钟中断</span></span><br><span class="line">    set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>非叶节点（页目录表，非末级页表）的表项标志位含义和叶节点（页表，末级页表）相比有一些不同：</p>
<ul>
<li>当 <code>V</code> 为 0 的时候，代表当前指针是一个空指针，无法走向下一级节点，即该页表项对应的虚拟地址范围是无效的；</li>
<li>只有当 <code>V</code> 为1 且 <code>R/W/X</code> 均为 0 时，表示是一个合法的页目录表项，其包含的指针会指向下一级的页表；</li>
<li>注意: 当 <code>V</code> 为1 且 <code>R/W/X</code> 不全为 0 时，表示是一个合法的页表项，其包含了虚地址对应的物理页号。</li>
</ul>
<p><strong>物理地址与物理页号转换</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span><span class="keyword">impl</span> PhysAddr &#123;</span><br><span class="line"> <span class="number">4</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">page_offset</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="keyword">self</span>.<span class="number">0</span> &amp; (PAGE_SIZE - <span class="number">1</span>) &#125; <span class="comment">// 从自己的物理地址0x12345000得到偏移为0x000（末三位）</span></span><br><span class="line"> <span class="number">5</span>&#125;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span><span class="keyword">impl</span> <span class="built_in">From</span>&lt;PhysAddr&gt; <span class="keyword">for</span> PhysPageNum &#123;</span><br><span class="line"> <span class="number">8</span>    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(v: PhysAddr) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"> <span class="number">9</span>        <span class="built_in">assert_eq!</span>(v.page_offset(), <span class="number">0</span>);</span><br><span class="line"><span class="number">10</span>        v.floor()</span><br><span class="line"><span class="number">11</span>    &#125; <span class="comment">// 只有偏移为0（即对齐）才能从0x12345000得到物理页号0x12345</span></span><br><span class="line"><span class="number">12</span>&#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span><span class="keyword">impl</span> <span class="built_in">From</span>&lt;PhysPageNum&gt; <span class="keyword">for</span> PhysAddr &#123;</span><br><span class="line"><span class="number">15</span>    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(v: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123; <span class="keyword">Self</span>(v.<span class="number">0</span> &lt;&lt; PAGE_SIZE_BITS) &#125;</span><br><span class="line"><span class="number">16</span>&#125; <span class="comment">// 从物理页号0x12345还原回物理地址0x12345000</span></span><br></pre></td></tr></table></figure>

<p><strong>页表项的数据结构抽象与类型定义</strong></p>
<p>页表项共8个字节：</p>
<ul>
<li>V(0)    仅当 V(Valid) 位为 1 时，页表项才是合法的；</li>
<li>R(1)/W(2)/X(3)    R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；</li>
<li>U(4)    U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li>
<li>G(5)    G 我们不理会；</li>
<li>A(6)    A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li>
<li>D(7)    D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。</li>
<li>RSW(8-9)    </li>
<li>PPN[0] (10-18)    </li>
<li>PPN[1] (19-27)    </li>
<li>PPN[2] (28-53)    </li>
<li>Reserved(54-63)    </li>
</ul>
<p>前八位的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitflags!</span> &#123; <span class="comment">// 用来表示比特位的宏</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTEFlags</span></span>: <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> V = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> R = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> W = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> X = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> U = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">const</span> G = <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">const</span> A = <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">const</span> D = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的实现与方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"> <span class="number">4</span><span class="meta">#[repr(C)]</span></span><br><span class="line"> <span class="number">5</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTableEntry</span></span> &#123; <span class="comment">// 一个页表项</span></span><br><span class="line"> <span class="number">6</span>    <span class="keyword">pub</span> bits: <span class="built_in">usize</span>,</span><br><span class="line"> <span class="number">7</span>&#125;</span><br><span class="line"> <span class="number">8</span></span><br><span class="line"> <span class="number">9</span><span class="keyword">impl</span> PageTableEntry &#123;</span><br><span class="line"><span class="number">10</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum, flags: PTEFlags) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="number">11</span>        PageTableEntry &#123;</span><br><span class="line"><span class="number">12</span>            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line"><span class="number">13</span>        &#125;</span><br><span class="line"><span class="number">14</span>    &#125;</span><br><span class="line"><span class="number">15</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">empty</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="number">16</span>        PageTableEntry &#123;</span><br><span class="line"><span class="number">17</span>            bits: <span class="number">0</span>,</span><br><span class="line"><span class="number">18</span>        &#125;</span><br><span class="line"><span class="number">19</span>    &#125;</span><br><span class="line"><span class="number">20</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ppn</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123;</span><br><span class="line"><span class="number">22</span>    &#125;</span><br><span class="line"><span class="number">23</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">flags</span></span>(&amp;<span class="keyword">self</span>) -&gt; PTEFlags &#123;</span><br><span class="line"><span class="number">25</span>    &#125;</span><br><span class="line">     <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">26</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>页帧管理器</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackFrameAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,</span><br><span class="line">    end: <span class="built_in">usize</span>,</span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;PhysPageNum&gt; <span class="comment">// 分配物理页</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) <span class="comment">// 回收物理页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用以调用的接口</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">frame_alloc</span></span>() -&gt; <span class="built_in">Option</span>&lt;FrameTracker&gt;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">frame_dealloc</span></span>(ppn: PhysPageNum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表一个物理页帧</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameTracker</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> FrameTracker &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">		<span class="comment">// 将这个物理页帧上的所有字节清零</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        frame_dealloc(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>多级页表</strong></p>
<p>正常情况可以依靠MMU直接翻译，手动翻译是由于操作系统是不能直接靠MMU来访问用户地址程序的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个应用所有的页表</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTable</span></span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum, <span class="comment">// 某应用的根节点物理页号</span></span><br><span class="line">    frames: <span class="built_in">Vec</span>&lt;FrameTracker&gt;, <span class="comment">// 页表中所有节点（包括根）的物理页帧，不包括叶节点指向的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 新建时只需要分配一个根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表：维护虚拟物理地址的映射</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags);</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问特定物理页帧</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> PhysPageNum &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_pte_array</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [PageTableEntry] &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回的是一个页表项定长数组的可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_bytes_array</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &#125; <span class="comment">//  返回的是一个字节数组的可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取一个恰好放在一个物理页帧开头的类型为 T 的数据的可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立/拆除虚实地址映射</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> VirtPageNum &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">indexes</span></span>(&amp;<span class="keyword">self</span>) -&gt; [<span class="built_in">usize</span>; <span class="number">3</span>] &#123; <span class="comment">// 返回虚拟页号的三级索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fn</span> <span class="title">find_pte_create</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt;  <span class="comment">// 给定虚拟页号，找到/创建页表项及中间层页表</span></span><br><span class="line">&#125; <span class="comment">// 注意，这个只返回最后一级的页表项，所以还要通过map/unmap来判断或创建最后的物理地址</span></span><br></pre></td></tr></table></figure>

<p>只查询，不建立</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_token</span></span>(satp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 从satp寄存器中读此时的根页表地址</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_pte</span></span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;&amp;PageTableEntry&gt; &#123;&#125; <span class="comment">// 查找对应的页表是否存在（没有也不新建）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translate</span></span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;PageTableEntry&gt; &#123;&#125; <span class="comment">// 如果存放就返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户虚拟地址 =&gt; 可写物理内存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_byte_buffer</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>地址空间抽象</strong></p>
<p>逻辑段：虚拟地址连续，虚拟地址映射到物理地址的方式相同（物理页帧具有的属性相同而非物理地址连续）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑段结构体</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapArea</span></span> &#123;</span><br><span class="line">    vpn_range: VPNRange, <span class="comment">// 一段虚拟页号的连续区间，是一个迭代器</span></span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;, <span class="comment">// 绑定生命周期，到期自动回收</span></span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">MapType</span></span> &#123; <span class="comment">// 逻辑段内虚拟页面映射的方式</span></span><br><span class="line">    Identical, <span class="comment">// 恒等映射</span></span><br><span class="line">    Framed, <span class="comment">// 分配物理页帧（随机）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitflags!</span> &#123; <span class="comment">// 该逻辑段的访问方式</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapPermission</span></span>: <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> R = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> W = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> X = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> U = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> MapArea &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>( start_va: VirtAddr, end_va: VirtAddr, map_type: MapType, map_perm: MapPermission ) -&gt; <span class="keyword">Self</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map_one</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;&#125;; <span class="comment">// 在确定了虚拟页号之后，先在逻辑的页表管理MapArea里面加入虚拟页号和StackFrameAllocator分配的物理页帧，然后在pagetable里完善各级页表里面的指向路径</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap_one</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;&#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;&#125; <span class="comment">// 把当前结构体中的所有虚拟地址挨个map_one物理地址</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">copy_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;PageTable, data: &amp;[<span class="built_in">u8</span>]) &#123;&#125; <span class="comment">// 复制data到逻辑段开头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地址空间：一个进程能够访问的所有内存地址的集合，通常被组织为多个逻辑段</p>
<p><code>pagetable</code>    实际上查找虚拟/物理地址映射的方法（存储各级节点，可以手动搜索），供CPU/MMU使用</p>
<p><code>areas</code>    逻辑上管理的方法（管理虚拟内存、映射数组来直接寻找）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个地址空间的结构体</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemorySet</span></span> &#123; <span class="comment">// PageTable 下挂着所有多级页表的节点所在的物理页帧，而每个 MapArea 下则挂着对应逻辑段中的数据所在的物理页帧，这两部分合在一起构成了一个地址空间所需的所有物理页帧（绑定，自动回收）</span></span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="built_in">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_bare</span></span>() -&gt; <span class="keyword">Self</span> </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;) <span class="comment">// 插入新的逻辑段，还可以在物理页帧上写入data</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">insert_framed_area</span></span>( &amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start_va: VirtAddr, end_va: VirtAddr, permission: MapPermission )  <span class="comment">// 新建并插入一段Framed方式映射的逻辑段</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_kernel</span></span>() -&gt; <span class="keyword">Self</span>; <span class="comment">// 生成内核的地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_elf</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; (<span class="keyword">Self</span>, <span class="built_in">usize</span>, <span class="built_in">usize</span>); <span class="comment">// 分析应用的ELF文件(并且根据这个文件建立新的地址空间，返回栈顶和执行入口)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">activate</span></span>(&amp;<span class="keyword">self</span>) &#123;&#125; <span class="comment">// 第一次使用会开启分页，并且进入当前地址空间的页表</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map_trampoline</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;&#125; <span class="comment">// 直接插入一个空间地址中最高位置到跳板的键值对（注：所有地址空间中的跳板都是指向trap.S文件）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内核的地址空间排布</strong>    </p>
<p>跳板、各应用的内核栈（栈间有空洞区域防溢出）</p>
<p>四个逻辑段<code>.text/.rodata/.data/.bss</code>（恒等映射）、恒等映射（除之前内核已使用）所有物理页帧的页表 （即是内核页表）（注：后面两项都是恒等映射建立的三级页表<code>MapArea</code>）</p>
<p><strong>应用程序的地址空间排布</strong>    </p>
<p>跳板、<code>trap</code>上下文（用户不可访问）</p>
<p>用户栈、保护页<code>guard page</code>、各逻辑段</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批处理系统升级：加载应用进入内存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_num_app</span></span>() -&gt; <span class="built_in">usize</span> &#123;&#125; <span class="comment">// 获取程序数量</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_app_data</span></span>(app_id: <span class="built_in">usize</span>) -&gt; &amp;<span class="symbol">'static</span> [<span class="built_in">u8</span>] &#123;&#125; <span class="comment">// 获得某个应用的全部数据</span></span><br></pre></td></tr></table></figure>



<p><strong>基于空间地址的分时多任务</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; <span class="comment">// 内核地址全局实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123; <span class="comment">// trap上下文</span></span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="comment">// 以下为新增字段，在初始化时写入，便于保存完成寄存器后切换</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="built_in">usize</span>, <span class="comment">// 本来sp指向用户栈，sscratch指向内核栈，交换后在内核栈中保存上下文；但现在由于要更新页表寄存器不够，sscratch指向用户空间中trap上下文处保存，然后根据保存的内存栈顶直接更改sp</span></span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="number">3</span><span class="keyword">impl</span> TrapContext &#123;</span><br><span class="line"> <span class="number">4</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_sp</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="built_in">usize</span>) &#123; &#125;</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>( entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>, kernel_satp: <span class="built_in">usize</span>, kernel_sp: <span class="built_in">usize</span>, trap_handler: <span class="built_in">usize</span> ) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 从任务上下文中初始化trap上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>跳板就是执行<code>trap</code>时保存上下文的汇编代码<code>_alltraps</code>和<code>_restore</code>，由于其在内核与应用地址空间的位置相同，所以无论哪种页表都可以在同一位置访问</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务上下文</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet, <span class="comment">// 应用地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用trap上下文的实际物理页帧</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>, <span class="comment">// 应用地址空间大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>], app_id: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_trap_cx</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> TrapContext &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局应用管理器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskManagerInner</span></span> &#123;</span><br><span class="line">    tasks: <span class="built_in">Vec</span>&lt;TaskControlBlock&gt;,</span><br><span class="line">    current_task: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: TaskManager = &#123;&#125;; <span class="comment">// 初始化时根据loader提供的app数量和ELF文件来初始化所有任务上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>新增系统调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 功能：当前进程 fork 出来一个子进程。</span></span><br><span class="line"><span class="comment">/// 返回值：对于子进程返回 0，对于当前进程则返回子进程的 PID 。</span></span><br><span class="line"><span class="comment">/// syscall ID：220</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：当前进程等待一个子进程变为僵尸进程，回收其全部资源并收集其返回值。</span></span><br><span class="line"><span class="comment">/// 参数：pid 表示要等待的子进程的进程 ID，如果为 -1 的话表示等待任意一个子进程；</span></span><br><span class="line"><span class="comment">/// exit_code 表示保存子进程返回值的地址，如果这个地址为 0 的话表示不必保存。</span></span><br><span class="line"><span class="comment">/// 返回值：如果要等待的子进程不存在则返回 -1；否则如果要等待的子进程均未结束则返回 -2；</span></span><br><span class="line"><span class="comment">/// 否则返回结束的子进程的进程 ID。</span></span><br><span class="line"><span class="comment">/// syscall ID：260</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waitpid</span></span>(pid: <span class="built_in">isize</span>, exit_code: *<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：将当前进程的地址空间清空并加载一个特定的可执行文件，返回用户态后开始它的执行。</span></span><br><span class="line"><span class="comment">/// 参数：path 给出了要加载的可执行文件的名字；</span></span><br><span class="line"><span class="comment">/// 返回值：如果出错的话（如找不到名字相符的可执行文件）则返回 -1，否则不应该返回。</span></span><br><span class="line"><span class="comment">/// syscall ID：221</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：从文件中读取一段内容到缓冲区。</span></span><br><span class="line"><span class="comment">/// 参数：fd 是待读取文件的文件描述符，切片 buffer 则给出缓冲区。</span></span><br><span class="line"><span class="comment">/// 返回值：如果出现了错误则返回 -1，否则返回实际读到的字节数。</span></span><br><span class="line"><span class="comment">/// syscall ID：63</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buffer: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; <span class="built_in">isize</span>;</span><br></pre></td></tr></table></figure>

<p>在用户级中，在最最开始（即在<code>main</code>函数中）会初始化一个<code>initproc</code>用户初始进程，</p>
<p>其只会初始化一个<code>shell</code>进程，之后就持续循环+时间片轮转来回收进程（注：所有父进程被回收的进程都会变成其子进程）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于应用名的应用加载器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ref</span> APP_NAMES: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_app_data_by_name</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="symbol">'static</span> [<span class="built_in">u8</span>]&gt; <span class="comment">// 根据名字查找ELF数据</span></span><br></pre></td></tr></table></figure>



<p>进程标识符</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程标识符PID</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PidHandle</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> PidHandle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; <span class="comment">// 自动回收</span></span><br><span class="line">        PID_ALLOCATOR.exclusive_access().dealloc(<span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程分配器，类似于FrameAllocator</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PidAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>, <span class="comment">// 当前已分配到多少</span></span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PidAllocator &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// current为0，数组为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; PidHandle &#123; <span class="comment">// 分配一个新的PIDHandle(其他啥也没有)，优先从回收中选取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, pid: <span class="built_in">usize</span>) &#123; <span class="comment">// 在PID已分配、未回收的情况下丢进回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ref</span> PID_ALLOCATOR : UPSafeCell&lt;PidAllocator&gt; <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure>



<p>内核栈</p>
<p>原本每个程序一个，固定大小按程序顺序排列，中间穿插守护页防止溢出</p>
<p>现在将应用编号替换为进程标识符<code>PTD</code>，在内核栈中保存</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KernelStack</span></span> &#123;</span><br><span class="line">    pid: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> KernelStack &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(pid_handle: &amp;PidHandle) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 为一个已分配的进程标识符生成内核栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_on_top</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, value: T) -&gt; *<span class="keyword">mut</span> T <span class="keyword">where</span></span><br><span class="line">        T: <span class="built_in">Sized</span>, &#123; <span class="comment">// 将一个类型为 T 的变量压入内核栈顶并返回其裸指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_top</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获取当前内核栈顶在内核地址空间中的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> KernelStack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_stack_position</span></span>(app_id: <span class="built_in">usize</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line"> <span class="comment">// 得到pid进程内核栈的起始/终止虚拟地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进程控制块</strong></p>
<p>之前的<code>TaskControlBlock</code>分离为</p>
<p><code>Processor</code>处理器管理结构：管理CPU正在运行的任务</p>
<p><code>TaskManager</code>任务管理器：管理未在运行的所有任务</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123; <span class="comment">// 不可变</span></span><br><span class="line">    <span class="comment">// 不可变</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    <span class="keyword">pub</span> kernel_stack: KernelStack,</span><br><span class="line">    <span class="comment">// 可变</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">inner_exclusive_access</span></span>(&amp;<span class="keyword">self</span>) -&gt; RefMut&lt;<span class="symbol">'_</span>, TaskControlBlockInner&gt; &#123; <span class="comment">// 内层 TaskControlBlockInner 的可变引用</span></span><br><span class="line">        <span class="keyword">self</span>.inner.exclusive_access() </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">getpid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pid.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;...&#125; <span class="comment">// 仅用于内核中手动创建唯一一个初始进程 initproc</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;...&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;TaskControlBlock&gt;) -&gt; Arc&lt;TaskControlBlock&gt; &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用地址空间中的 Trap 上下文被放在的物理页帧的物理页号</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>, <span class="comment">// 应用数据仅有可能出现在应用地址空间低于 base_size 字节的区域中</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 暂停的任务的任务上下文</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 当前进程的执行状态</span></span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet, <span class="comment">// 应用地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="built_in">Option</span>&lt;Weak&lt;TaskControlBlock&gt;&gt;, <span class="comment">// Arc的非拥有引用，可访问但不拥有</span></span><br><span class="line">    <span class="keyword">pub</span> children: <span class="built_in">Vec</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 多个Arc拥有一个不可变值，计数为0时才释放</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlockInner &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_trap_cx</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">        <span class="keyword">self</span>.trap_cx_ppn.get_mut()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_user_token</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.memory_set.token()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_status</span></span>(&amp;<span class="keyword">self</span>) -&gt; TaskStatus &#123;</span><br><span class="line">        <span class="keyword">self</span>.task_status</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_zombie</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.get_status() == TaskStatus::Zombie</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务管理器与处理器管理器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 双端队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 新建一个空任务表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;) &#123; <span class="comment">// 在末尾新增一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123; <span class="comment">// 从开头拿取一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器管理结构</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Processor</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    idle_task_cx: TaskContext, <span class="comment">// 当前处理器上的 idle 控制流的任务上下文（调度器上下文）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Processor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 初始化为None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_current</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 取出当前正在执行的任务</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">current</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回当前执行的任务的一份拷贝，可以用于获得token/trap_cx等等</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_idle_task_cx_ptr</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; *<span class="keyword">mut</span> TaskContext &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取当前处理器上的 idle 控制流的任务上下文指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> PROCESSOR: UPSafeCell&lt;Processor&gt; <span class="comment">// 单核只创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程转换</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run_tasks</span></span>() &#123; <span class="comment">// 负责在taskManager中获取要执行的任务并执行</span></span><br><span class="line">&#125; <span class="comment">// 持续循环，只要进程让出CPU回到调度器中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">schedule</span></span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">&#125; <span class="comment">// 在进程交出控制权后，用于回到run_tasks()执行循环中的函数</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>将<code>Processer</code>的任务上下文分离并且单独存储，是为了把调度和存储分离开，并无其他意义</li>
<li><code>Processer</code>由内核中的结构体和上下文组成，相当于一个没有进程控制块的进程来用于调度</li>
</ul>
<p><strong>进程机制实现</strong></p>
<ul>
<li>创建初始进程：创建第一个用户态进程 <code>initproc</code>；</li>
<li>进程调度机制：当进程主动调用 <code>sys_yield</code> 交出 CPU 使用权或者内核把本轮分配的时间片用尽的进程换出且换入下一个进程；</li>
<li>进程生成机制：进程相关的两个重要系统调用 <code>sys_fork/sys_exec</code> 的实现；</li>
<li>进程资源回收机制：当进程调用 <code>sys_exit</code> 正常退出或者出错被内核终止之后如何保存其退出码，其父进程通过 <code>sys_waitpid</code> 系统调用收集该进程的信息并回收其资源。</li>
<li>字符输入机制：为了支持shell程序-user_shell获得字符输入，介绍 <code>sys_read</code> 系统调用的实现；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建初始进程</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> INITPROC: Arc&lt;TaskControlBlock&gt; <span class="comment">// 懒加载全局的initproc进程控制块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_initproc</span></span>() &#123; <span class="comment">// 在taskManager中加入initproc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程调度机制</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">suspend_current_and_run_next</span></span>() &#123;</span><br><span class="line">&#125; <span class="comment">// Process::取出当前执行的任务，修改状态为Ready后放入taskmanager末尾；然后schedule触发调度并切换任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程生成机制</span></span><br><span class="line"><span class="keyword">impl</span> MapArea &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_another</span></span>(another: &amp;MapArea) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 创建一模一样的结构体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_existed_user</span></span>(user_space: &amp;MemorySet) -&gt; MemorySet &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建一模一样的结构体，并且物理地址按页复制数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;TaskControlBlock&gt;) -&gt; Arc&lt;TaskControlBlock&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 与new类似，不过不是从ELF中获取信息而是从memory_set复制后获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 完全复制任务控制块，但是物理页帧不能直接复制，而且新的线程trap_cx中的a[0]（返回值寄存器）要改成0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;</span><br><span class="line">    &#125; <span class="comment">// 从一个ELF文件中获得Memory全部当前memory_set，然后更改控制块中信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_str</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 传递给调用的只有要执行的应用的名称字符串的起始地址，要以此在内存中查询得到整个字符串</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程退出机制</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exit</span></span>(exit_code: <span class="built_in">i32</span>) -&gt; ! &#123;</span><br><span class="line">&#125; <span class="comment">// 调用exit_current_and_run_next()</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exit_current_and_run_next</span></span>(exit_code: <span class="built_in">i32</span>) &#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waitpid</span></span>(pid: <span class="built_in">isize</span>, exit_code_ptr: *<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 等待某个子进程退出，返回它的 pid，并把它的退出码写到指定地址</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(exit_code: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 调用sys_waitpid，成功则返回退出码；失败（返回-2）则yield继续等待</span></span><br></pre></td></tr></table></figure>

<p>在执行<code>exit_current_and_run_next(exit_code: i32)</code>时</p>
<ul>
<li>修改当前进程控制块的状态为<code>TaskStatus::Zombie</code> 即僵尸进程</li>
<li>将退出码传入控制块等待父进程收集</li>
<li>将所有子进程挂载在<code>initproc</code>下面</li>
<li>对当前进程早期回收（回收<code>Memory_set</code>中的<code>areas</code>即数据页，不回收<code>pagetable</code>即页表页）</li>
</ul>
<p><strong>user_shell读入机制</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 仅支持从标准输入 FD_STDIN 即文件描述符 0 读入，且单次读入的长度限制为 1</span></span><br></pre></td></tr></table></figure>







<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><strong>文件与文件描述符</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件接口：只要实现了这个接口，就是文件</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">File</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户缓冲区：用户进程在系统调用的时候传给内核的地址空间（以内核为中转，用户缓冲区 &lt;=&gt; 文件）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_byte_buffer</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">UserBuffer</span></span> &#123; <span class="comment">// 将t_b_b中的切片进一步包装，即几页数据的数组</span></span><br><span class="line">    <span class="keyword">pub</span> buffers: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> UserBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(buffers: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 传入数据来新建缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">len</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获得总字节数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准输入/输出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stdin</span></span>;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Stdin &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区只能为一个字节大小，循环读取标准输入中的char，读取到则跳出循环写入缓冲区，未读取到则挂起继续循环，返回1 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, _user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123; </span><br><span class="line">    &#125; <span class="comment">// 直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stdout</span></span>;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Stdout &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, _user_buf: UserBuffer) -&gt; <span class="built_in">usize</span>&#123;</span><br><span class="line">    &#125; <span class="comment">// 直接panic</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区无大小限制，读出数据并print!,返回缓冲区字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件描述符：（文件描述符首先是一个非负整数）对于某一个进程，代表了其打开的一个文件对象，在要对文件进行操作时传入该整数即可（由内核来分配和记录，因为所有文件都在内核中）</p>
<p>文件描述符表：每个进程都有，记录所有其打开且可读写的文件集合（可以以表的下标作为描述符）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">	……</span><br><span class="line">    <span class="keyword">pub</span> fd_table: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 建立新的TCB时要创建三个fd_table: </span></span><br><span class="line">    <span class="comment">// vec！[Some(Arc::new(Stdin)),Some(Arc::new(Stdout)),Some(Arc::new(Stdout))] 0，1，2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的数据结构：</p>
<ul>
<li><p><code>Vec</code> 无需设置一个固定的文件描述符数量上限；</p>
</li>
<li><p><code>Option</code> 区分一个文件描述符当前是否空闲：当它是 <code>None</code> 的时候是空闲的，而 <code>Some</code> 则代表它已被占用；</p>
</li>
<li><p><code>Arc</code> 提供了共享引用能力：可能会有多个进程共享同一个文件对它进行读写；</p>
<pre><code>被它包裹的内容会被放到内核堆而不是栈上，不需要在编译期有确定的大小</code></pre></li>
<li><p><code>dyn</code> 关键字表明 <code>Arc</code> 里面的类型实现了 <code>File/Send/Sync</code> 三个 Trait ，</p>
<pre><code>编译期无法知道它具体是哪个类型需要等到运行时才能知道它的具体类型。</code></pre></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_write</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁使用write/read访问当前进程符表中标识符（下标）为fd的文件，返回值为w/r的返回值</span></span><br></pre></td></tr></table></figure>



<p><strong>文件系统接口</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开/读写的系统调用</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sys_openat</span></span>(dirfd: <span class="built_in">usize</span>, path: &amp;<span class="built_in">str</span>, flags: <span class="built_in">u32</span>, mode: <span class="built_in">u32</span>) -&gt; <span class="built_in">isize</span> </span><br><span class="line"><span class="comment">// 打开文件并返回描述符，否则返回-1；dirfd/mode无视；path为文件名；flags描述打开文件的标志</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpenFlags</span></span>: <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> RDONLY = <span class="number">0</span>; <span class="comment">// 只读</span></span><br><span class="line">        <span class="keyword">const</span> WRONLY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 只写</span></span><br><span class="line">        <span class="keyword">const</span> RDWR = <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// 可读写</span></span><br><span class="line">        <span class="keyword">const</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>; <span class="comment">// 在找不到时允许创建</span></span><br><span class="line">        <span class="keyword">const</span> TRUNC = <span class="number">1</span> &lt;&lt; <span class="number">10</span>; <span class="comment">// 打开时清空文件并将大小归零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>简易文件系统</strong></p>
<ul>
<li><code>easy-fs</code> 是简易文件系统的本体</li>
<li><code>easy-fs-fuse</code> 是能在开发环境（如 Ubuntu）中运行的应用程序，用于将应用打包为 easy-fs 格式的文件系统镜像，也可以用来对 <code>easy-fs</code> 进行测试</li>
</ul>
<p>文件系统层次化（共分为五层，上层可以调用下层的接口）：</p>
<p>1、磁盘块设备接口层：以块为单位对磁盘块设备进行读写的 trait 接口</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">BlockDevice</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> + Any &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]); <span class="comment">// 将编号为 block_id 的块从磁盘读入内存中的缓冲区 buf</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]); <span class="comment">// 将内存中的缓冲区 buf 中的数据写入磁盘编号为 block_id 的块</span></span><br><span class="line">&#125; <span class="comment">// 以实现了该特征的结构体为磁盘外设的模拟，在实现该特征时写入真正对硬件的操作</span></span><br></pre></td></tr></table></figure>

<p>2、块缓存层：在内存中缓存磁盘块的数据，避免频繁读写磁盘</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块缓存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> BLOCK_SZ: <span class="built_in">usize</span> = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ], <span class="comment">// 512字节数组，内存中的缓冲区</span></span><br><span class="line">    block_id: <span class="built_in">usize</span>, <span class="comment">// 这个块的编号</span></span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;, <span class="comment">// 块所属的底层设备</span></span><br><span class="line">    modified: <span class="built_in">bool</span>, <span class="comment">// 从磁盘进入内存后是否被修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(block_id: <span class="built_in">usize</span>, block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 新建时从某个磁盘中读入一个块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">addr_of_offset</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获得cache中偏移量offset的地址</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_ref</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; &amp;T <span class="keyword">where</span> T: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取缓冲区中偏移量为offset的一个T类型值的不可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut</span></span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; &amp;<span class="keyword">mut</span> T <span class="keyword">where</span> T: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>&lt;T, V&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;T) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125; <span class="comment">// 把闭包函数传入这个函数，在这个函数里面调用闭包直接返回其返回值，unsafe的T指针就不会给出去</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">modify</span></span>&lt;T, V&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset:<span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> T) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区被回收，由modified决定是否写回磁盘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块缓存全局管理器：一个磁盘拥有一个</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCacheManager</span></span> &#123;</span><br><span class="line">    queue: VecDeque&lt;(<span class="built_in">usize</span>, Arc&lt;Mutex&lt;BlockCache&gt;&gt;)&gt;, <span class="comment">// 共享引用&amp;互斥访问 磁盘块编号&amp;块缓存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCacheManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_cache</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,block_id: <span class="built_in">usize</span>,block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,) -&gt; Arc&lt;Mutex&lt;BlockCache&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果这里存储了block_id的块则返回其副本，没找到且队列未满则新建并插入返回，已满则丢出去未被使用（引用计数为1）的第一个块然后插入返回，否则panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、磁盘数据结构层：磁盘上的超级块、位图、索引节点、数据块、目录项等核心数据结构和相关处理</p>
<p>easy-fs 磁盘按照块编号从小到大顺序分成 5 个连续区域：</p>
<ul>
<li>第一个区域只包括一个块，它是超级块，用于定位其他连续区域的位置，检查文件系统合法性</li>
<li>第二个区域是一个索引节点位图，长度为若干个块：记录索引节点区域中有哪些索引节点已经被分配出去使用了(每个<code>bit</code>表示一个节点)</li>
<li>第三个区域是索引节点区域，长度为若干个块，其中的每个块都存储了若干个索引节点（每个节点描述一个“文件”/“目录”）</li>
<li>第四个区域是一个数据块位图，长度为若干个块：记录后面的数据块区域中有哪些已经被分配出去使用</li>
<li>最后的区域则是数据块区域：每个被分配出去的块保存了文件或目录的具体内容</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个区域：超级块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span></span> &#123;</span><br><span class="line">    magic: <span class="built_in">u32</span>, <span class="comment">// 魔数：验证有效性</span></span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="built_in">u32</span>, <span class="comment">// 文件系统总块数</span></span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="built_in">u32</span>, <span class="comment">// 索引节点位图块数</span></span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="built_in">u32</span>, <span class="comment">// 索引节点区域块数</span></span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="built_in">u32</span>, <span class="comment">// 数据块位图区域块数</span></span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="built_in">u32</span>, <span class="comment">// 数据库区域块数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> SuperBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">initialize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, total_blocks: <span class="built_in">u32</span>, inode_bitmap_blocks: <span class="built_in">u32</span>, inode_area_blocks: <span class="built_in">u32</span>, data_bitmap_blocks: <span class="built_in">u32</span>, data_area_blocks: <span class="built_in">u32</span> ); <span class="comment">// 更上层初始化</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="comment">// 根据魔数判断合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二/四个区域：位图-索引节点 / 位图-数据块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitmap</span></span> &#123; <span class="comment">// 位图区域管理器：区域起始编号+块数</span></span><br><span class="line">    start_block_id: <span class="built_in">usize</span>,</span><br><span class="line">    blocks: <span class="built_in">usize</span>,</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BitmapBlock</span></span> = [<span class="built_in">u64</span>; <span class="number">64</span>]; <span class="comment">// 一个块数据（划分方便操作）</span></span><br><span class="line"><span class="keyword">const</span> BLOCK_BITS: <span class="built_in">usize</span> = BLOCK_SZ * <span class="number">8</span>; <span class="comment">// 一个块中有多少个bit</span></span><br><span class="line"><span class="keyword">impl</span> Bitmap &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 遍历Bitmap中每个块，再遍历这个块中的每一个[u64]找到第一个为 0 的位置，该位置置1，返回该位的位置（在位图中的第n个比特位），以此作为分配的索引节点/数据块的编号；否则返回None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个区域：索引节点（包含文件/目录的元数据，以下仅写“文件”）</span></span><br><span class="line"><span class="keyword">const</span> INODE_DIRECT_COUNT: <span class="built_in">usize</span> = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>, <span class="comment">// 文件内容的字节数</span></span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT], <span class="comment">// 直接索引，数据块里是文件数据</span></span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>, <span class="comment">// 一级间接索引，该块上每一个u32指向一个文件数据块</span></span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>, <span class="comment">// 二级间接索引，该块上每一个指向一个一级间接索引</span></span><br><span class="line">    type_: DiskInodeType, <span class="comment">// 索引节点类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DiskInodeType</span></span> &#123;</span><br><span class="line">    File,</span><br><span class="line">    Directory,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> DiskInode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">initialize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, type_: DiskInodeType) &#123;</span><br><span class="line">    &#125; <span class="comment">// 一 / 二级索引全部置为0</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_dir</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_file</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="comment">// 确定文件类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_id</span></span>(&amp;<span class="keyword">self</span>, inner_id: <span class="built_in">u32</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 获得索引中的第inner_id数据块的block_id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">data_blocks</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 返回文件内容字节数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">_data_blocks</span></span>(size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 容纳size个字节需要多少数据块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">total_blocks</span></span>(size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 返回文件块+索引块数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">blocks_num_needed</span></span>(&amp;<span class="keyword">self</span>, new_size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 扩容到new_size个字节需要新增多少数据块</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">increase_size</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: <span class="built_in">u32</span>, new_blocks: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;);</span><br><span class="line">    <span class="comment">// 扩容函数，size为扩容后大小，blocks为扩容所需块编号（由上层分配）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clear_size</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;; <span class="comment">//清空文件并且回收数据块</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>], block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">usize</span> &#123; </span><br><span class="line">    &#125; <span class="comment">// 将文件内容从 offset 字节开始的部分读到内存中的缓冲区 buf 中，返回读到字节数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_at</span></span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目录项结构（文件项无结构）</span></span><br><span class="line"><span class="keyword">const</span> NAME_LENGTH_LIMIT: <span class="built_in">usize</span> = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DirEntry</span></span> &#123; <span class="comment">// 该结构保存在数据块中</span></span><br><span class="line">    name: [<span class="built_in">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>], <span class="comment">// 这一级目录/这个文件的名字</span></span><br><span class="line">    inode_number: <span class="built_in">u32</span>, <span class="comment">// 这一级目录/这个文件的索引序号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DIRENT_SZ: <span class="built_in">usize</span> = <span class="number">32</span>; <span class="comment">// 每个数据块可以存储16个</span></span><br><span class="line"><span class="keyword">impl</span> DirEntry &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">empty</span></span>() -&gt; <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="built_in">str</span>, inode_number: <span class="built_in">u32</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">name</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">inode_number</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_bytes</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;[<span class="built_in">u8</span>] &#123; <span class="comment">// 为了符合read/write_at接口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_bytes_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、磁盘块管理器层：合并了上述核心数据结构和磁盘布局所形成的磁盘文件系统数据结构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个文件系统对应一个磁盘（分区）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EasyFileSystem</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap: Bitmap, <span class="comment">// 索引节点位图</span></span><br><span class="line">    <span class="keyword">pub</span> data_bitmap: Bitmap, <span class="comment">// 数据块位图</span></span><br><span class="line">    inode_area_start_block: <span class="built_in">u32</span>, <span class="comment">// 索引区域起始块编号</span></span><br><span class="line">    data_area_start_block: <span class="built_in">u32</span>, <span class="comment">// 数据块区域起始块编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;, total_blocks: <span class="built_in">u32</span>, inode_bitmap_blocks: <span class="built_in">u32</span>,) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 传入 总共的块数量/索引位图的块数量 规划好整个磁盘，创建新文件系统并清理内存</span></span><br><span class="line">      <span class="comment">// 同时初始化内存中的超级块、创建根目录</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open</span></span>(block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 从一个写入了easy-fs镜像（即按照该格式排布的数据块集合）的块设备block_device上打开文件系统</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_disk_inode_pos</span></span>(&amp;<span class="keyword">self</span>, inode_id: <span class="built_in">u32</span>) -&gt; (<span class="built_in">u32</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 根据索引的编号，返回它所在磁盘块编号block_id和块内偏移</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_data_block_id</span></span>(&amp;<span class="keyword">self</span>, data_block_id: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 得到某数据块的磁盘块编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_inode</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 分配一个索引返回其编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 分配一个数据块返回其磁盘块编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_id: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：只要知道了数据所在的具体磁盘块号和块内偏移，可以以任意结构体方式操作这一段数据<code>get_block_cache(block_id, device).lock().modify(offset, |变量名: &amp;mut 结构体| {})</code></p>
<p>5、索引节点层：管理索引节点，实现了文件创建/文件打开/文件读写等成员函数</p>
<p>便于直接看到目录树结构中逻辑上的文件和目录</p>
<ul>
<li><code>DiskInode</code> 放在磁盘块中比较固定的位置</li>
<li><code>Inode</code> 是放在内存中的记录文件索引节点信息的数据结构</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_offset: <span class="built_in">usize</span>, <span class="comment">// 前两个用于记录具体位置</span></span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;, <span class="comment">// 便于操作传参</span></span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化 get_block_cache.lock.read/modify 流程</span></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125; <span class="comment">// 读取数据并且用闭包f处理</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">modify_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> DiskInode) -&gt; V) -&gt; V &#123; <span class="comment">// 读取可修改数据并且用闭包f处理（都是更改索引节点 DiskInode 的值）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">root_inode</span></span>(efs: &amp;Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt;) -&gt; Inode &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取根目录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(block_id: <span class="built_in">u32</span>, block_offset: <span class="built_in">usize</span>, fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;, block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建</span></span><br><span class="line">    <span class="comment">// 文件索引（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">find</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回本索引指向的目录下名称为name的文件的索引的新建Inode</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_inode_id</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>, disk_inode: &amp;DiskInode) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; &#123; <span class="comment">// 找到传入的索引节点指向的目录下名称为name的文件的索引序号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件列举（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ls</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回该目录下所有文件的文件名的数组</span></span><br><span class="line">    <span class="comment">// 文件创建（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建新的文件并返回其Inode，若存在则返回None</span></span><br><span class="line">    <span class="comment">// 文件清空</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clear</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 以某些方式打开时需要先传入文件Inode清空</span></span><br><span class="line">    <span class="comment">// 文件读写</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 从offset偏移处开始读</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 注意：在写之前需要先扩容为offset+buf.len()容量</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">increase_size</span></span>(&amp;<span class="keyword">self</span>, new_size: <span class="built_in">u32</span>, disk_inode: &amp;<span class="keyword">mut</span> DiskInode, fs: &amp;<span class="keyword">mut</span> MutexGuard&lt;EasyFileSystem&gt;) &#123;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内核中的easy-fs</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内核块设备实例</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BlockDeviceImpl</span></span> = virtio_blk::VirtIOBlock; <span class="comment">// 一个实现了BlockDevice类特征的结构体</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> BLOCK_DEVICE: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt; = Arc::new(BlockDeviceImpl::new());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核索引节点层</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInode</span></span> &#123; <span class="comment">// 表示进程中一个被打开的常规文件或目录</span></span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    inner: UPSafeCell&lt;OSInodeInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInodeInner</span></span> &#123;</span><br><span class="line">    offset: <span class="built_in">usize</span>, <span class="comment">// 读写过程中的偏移量</span></span><br><span class="line">    inode: Arc&lt;Inode&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> OSInode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="keyword">self</span>.readable &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="keyword">self</span>.writable &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 直接使用inode的read/write_at</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核文件系统实现</span></span><br><span class="line"><span class="comment">// 文件系统初始化</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">    &#125;; <span class="comment">// 打开efs并且获取根目录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpenFlags</span></span>: <span class="built_in">u32</span> &#123; <span class="comment">// 打开文件的方式</span></span><br><span class="line">        <span class="keyword">const</span> RDONLY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> WRONLY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> RDWR = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">const</span> TRUNC = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> OpenFlags &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_write</span></span>(&amp;<span class="keyword">self</span>) -&gt; (<span class="built_in">bool</span>, <span class="built_in">bool</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回（可读，可写）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open_file</span></span>(name: &amp;<span class="built_in">str</span>, flags: OpenFlags) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;OSInode&gt;&gt; &#123;</span><br><span class="line">&#125; <span class="comment">// 根据flags的要求打开文件并且返回inode</span></span><br></pre></td></tr></table></figure>



<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><strong>管道</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用：为当前进程打开一个管道（包含一个只读、一个只写文件）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_pipe</span></span>(pipe: *<span class="keyword">mut</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>;<span class="comment">// pipe:应用地址空间中一个长度为2的usize数组的起始地址，内核负责讲管道读端、写端的文件描述符写入</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_close</span></span>(fd: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>; <span class="comment">// 关闭一个文件</span></span><br></pre></td></tr></table></figure>

<p>基于文件的管道</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道的一端（读/写）：会实现File特征，作为文件访问</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span></span> &#123;</span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Pipe &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_end_with_buffer</span></span>(buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;) -&gt; <span class="keyword">Self</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_end_with_buffer</span></span>(buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 根据一个已有的管道创建其读端和写端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Pipe &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 从文件中最多读取应用缓冲区大小那么多字符：如果文件中没有字符且没有写端则返回，否则任务挂起</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RingBufferStatus</span></span> &#123; FULL, EMPTY, NORMAL &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PipeRingBuffer</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">u8</span>; RING_BUFFER_SIZE],</span><br><span class="line">    head: <span class="built_in">usize</span>,</span><br><span class="line">    tail: <span class="built_in">usize</span>, <span class="comment">// 维护循环队列</span></span><br><span class="line">    status: RingBufferStatus, <span class="comment">// 缓冲区状态</span></span><br><span class="line">    write_end: <span class="built_in">Option</span>&lt;Weak&lt;Pipe&gt;&gt;, <span class="comment">// 写端的弱引用计数，来确认是否还有写端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 全部置为0，写端置为None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_write_end</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, write_end: &amp;Arc&lt;Pipe&gt;) &#123; </span><br><span class="line">    &#125; <span class="comment">// 保留其写端的弱引用计数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_byte</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 读取管道中的一个字节，并且更新队头（如果与队尾重合则改为empty）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">available_read</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 计算管道中还有多少个字节可以读取</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">all_write_ends_closed</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 判断管道的所有写端是不是都被关闭了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">make_pipe</span></span>() -&gt; (Arc&lt;Pipe&gt;, Arc&lt;Pipe&gt;) &#123; <span class="comment">// 创建一个管道并返回其读写端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlockInner &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_fd</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 在进程控制块中分配一个最小的空闲文件描述符来访问新打开的文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>命令行参数与标准I/O重定向</strong></p>
<p>命令行参数</p>
<p>在user_shell中读取一行后，根据空格分隔成<code>Vec&lt;String&gt;</code>，然后手动在每个字符串后面加上<code>\0</code>，在最后加上<code>0 as *const u8</code>，将字符串数组的起始地址传入<code>sys_exec()</code>内核调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用更新</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>, <span class="keyword">mut</span> args: *<span class="keyword">const</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 依次转换地址并取出参数，在调用TCB::exec时传入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">     <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>], args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) &#123;</span><br><span class="line">    &#125; <span class="comment">// 在从ELF文件创建进程后把参数压入用户栈（此时用户栈为空）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据TCB创建时从ELF中读出来的内容，所有进程第一次进入用户态都是从<code>_start</code>进入：这个函数会依次取出命令行参数并且放入一个数组中</p>
<p>标准输入输出重定向</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用：将进程中一个已经打开的文件复制一份并分配到一个新的文件描述符中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_dup</span></span>(fd: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>; <span class="comment">//（在符表中分配一个新的描述符指向一个复制）</span></span><br></pre></td></tr></table></figure>

<p>在用户态的<code>user_shell</code>程序中，要检查是否存在通过<code>&lt;</code>/<code>&gt;</code>进行输入输出重定向：</p>
<p>存在则移除，并记录输入/输出的文件名并打开；</p>
<p>这时候关掉<code>0/1</code>的文件描述符，给打开的文件<code>dup</code>一个新的，由于<code>alloc_fd()</code>一定会分配最小的可用文件描述符（先扫描符表中有无可用的，再push一个），所以这个文件就可以顶替掉<code>0/1</code></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li>存在线程前：进程是程序的基本执行实体，是程序关于某数据集合上的一次运行活动，是            系统进行资源（处理器、 地址空间和文件等）分配和调度的基本单位。</li>
<li>存在线程后：进程是线程的资源容器， 线程成为了程序的基本执行实体。</li>
</ul>
<p><strong>并发相关术语</strong></p>
<ul>
<li>共享资源（shared resource）：不同的线程/进程都能访问的变量或数据结构。</li>
<li>临界区（critical section）：访问共享资源的一段代码。</li>
<li>竞态条件（race condition）：多个线程/进程都进入临界区时，都试图更新共享的数据结构，导致产生了不期望的结果。</li>
<li>不确定性（indeterminate）： 多个线程/进程在执行过程中出现了竞态条件，导致执行结果取决于哪些线程在何时运行， 即执行结果不确定，而开发者期望得到的是确定的结果。</li>
<li>互斥（mutual exclusion）：一种操作原语，能保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的执行结果。</li>
<li>原子性（atomic）：一系列操作要么全部完成，要么一个都没执行，不会看到中间状态。在数据库领域， 具有原子性的一系列操作称为事务（transaction）。</li>
<li>同步（synchronization）：多个并发执行的进程/线程在一些关键点上需要互相等待，这种相互制约的等待称为进程/线程同步。</li>
<li>死锁（dead lock）：一个线程/进程集合里面的每个线程/进程都在等待只能由这个集合中的其他一个线程/进程 （包括他自身）才能引发的事件，这种情况就是死锁。</li>
<li>饥饿（hungry）：指一个可运行的线程/进程尽管能继续执行，但由于操作系统的调度而被无限期地忽视，导致不能执行的情况。</li>
</ul>
<p><strong>线程</strong>（一个进程在一个时刻有多个执行点）</p>
<ul>
<li>程序计数器寄存器来记录当前的执行位置</li>
<li>一组通用寄存器记录当前的指令的操作数据</li>
<li>一个栈来保存线程执行过程的函数调用栈和局部变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_thread_create</span></span>(entry: <span class="built_in">usize</span>, arg: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> </span><br><span class="line"><span class="comment">// 创建新的线程（entry:入口函数地址， arg:参数）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waittid</span></span>(tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line"><span class="comment">// 等待线程结束：进程/主线程回收资源（tid:线程id，由主线程调用）</span></span><br></pre></td></tr></table></figure>

<p>线程管理由进程而来</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="keyword">pub</span> kernel_stack: KernelStack,</span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;, <span class="comment">// 可变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用地址空间中线程的 Trap 上下文被放在的物理页帧的物理页号</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 暂停线程的线程上下文，用于线程切换</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 当前线程的执行状态</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;, <span class="comment">// 线程退出码</span></span><br><span class="line">    <span class="keyword">pub</span> res: <span class="built_in">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskUserRes</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> tid: <span class="built_in">usize</span>, <span class="comment">// 线程标识符</span></span><br><span class="line">    <span class="keyword">pub</span> ustack_base: <span class="built_in">usize</span>, <span class="comment">// 线程栈顶</span></span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;, <span class="comment">// 所属进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>进程控制块</code></pre><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> tasks: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> task_res_allocator: RecycleAllocator,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>锁</strong></p>
<p>相关数据结构：使用锁来包裹共享资源</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> mutex_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt;&gt;, <span class="comment">// 进程可能存在多个互斥资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Mutex</span></span>: <span class="built_in">Sync</span> + <span class="built_in">Send</span> &#123; <span class="comment">// 互斥锁特征</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MutexBlocking</span></span> &#123; <span class="comment">// 实现互斥锁特征的结构</span></span><br><span class="line">    inner: UPSafeCell&lt;MutexBlockingInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MutexBlockingInner</span></span> &#123;</span><br><span class="line">    locked: <span class="built_in">bool</span>, <span class="comment">// 是否上锁</span></span><br><span class="line">    wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 上锁的等待队列 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关系统调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_create</span></span>(blocking: <span class="built_in">bool</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 创建一个新的锁：当前mutex_list是否有空位/锁的类型来创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_lock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 只负责调用当前线程的第id个锁的lock()方法</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果已经上锁则加入等待队列，否则上锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_unlock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;<span class="comment">// 只负责调用当前线程的第id个锁的unlock()方法</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果有等待的线程则唤醒，否则释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>信号量</strong>：适用于一个共享资源可以被有限个线程同时访问的情况（互斥锁即为N=1）</p>
<p>P操作：尝试进入，失败则阻塞</p>
<p>V操作：信号量的值+1，如果有线程等待则唤醒</p>
<p>（注意，以上两个操作都应该有原子性）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> semaphore_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Semaphore&gt;&gt;&gt;, <span class="comment">// 进程可能有多个信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Semaphore</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;SemaphoreInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SemaphoreInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> count: <span class="built_in">isize</span>, <span class="comment">// 信号量值（count &lt;= 0时代表有线程在等待）</span></span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 等待序列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Semaphore &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(res_count: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建新的信号量，置放初始信号值</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">up</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// V操作：count++, count &lt;= 0时从等待队列中取队头唤醒</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">down</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// P操作：count--, count &lt; 0时进入等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>条件变量</strong></p>
<p>线程在检查满足某一条件后才会执行（条件变量时一个线程等待队列）</p>
<p><code>wait</code>操作：释放锁 =&gt; 挂起自己 =&gt; 被唤醒后获取锁</p>
<p><code>signal</code>操作：找到挂在条件变量上面的线程并唤醒</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> condvar_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Condvar&gt;&gt;&gt;, <span class="comment">// 进程中的条件变量列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Condvar</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;CondvarInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CondvarInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 条件变量：等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Condvar &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建空的等待队列</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">signal</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 唤醒条件变量的等待队列的队头</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(&amp;<span class="keyword">self</span>, mutex:Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">    &#125; <span class="comment">// 释放互斥锁（线程在进入前获取），挂起当前进程，恢复后获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="ArceOS学习记录"><a href="#ArceOS学习记录" class="headerlink" title="ArceOS学习记录"></a>ArceOS学习记录</h1><p>第三阶段时间比较紧张，就只能写写测试写不了挑战题了</p>
<p><strong>第一部分<code>UniKernel</code></strong></p>
<p><code>print_with_color</code></p>
<p>在输出println宏的实现处加上标识颜色的<code>ASCⅡ</code>码即可，需要注意（本人踩过坑）的是如果不想引入<code>format!</code>来直接把颜色字符拼接进入要打印字符中而是分别打印，需要注意字符打印导致的换行问题，这个会导致后边测试脚本在读取数据时检测不通过的问题</p>
<p><code>support_hashmap</code></p>
<p>这个去网上查了一下资料，还以为有什么高级实现的方法</p>
<p>结果最后还是使用了最朴实无华的取模插入</p>
<p>果然所有的数据结构都很难想</p>
<p><code>alt_alloc</code></p>
<p>在怎么实现上还是纠结了挺久的，是存储字符数转化成页还是存储页转化成字符、如果有新加入的内存怎么在其中表示……后面不得不去找了一下，发现原来可以不支持新加入内存（）</p>
<p>其实还是学到了很多的，在上操作系统理论课的时候根本没有想过这些内存是由一个统一初始化的内存管理器来进行管理，就只是单纯的知道了一下页表是什么</p>
<p><strong>第二部分宏内核</strong></p>
<p><code>sys_mmap</code></p>
<p>难度还可以，好像在这里没有花很久时间</p>
<p><code>ramfs_rename</code></p>
<p>因为没有什么大项目的经验导致对依赖很不敏感，在实现了之后一直进入不了我想用的DirNode的trait里面</p>
<p>后面不断调试才终于在偶然中发现如果不在根目录的<code>cargo.toml</code>中使用patch的话需要改两个cargo.toml</p>
<p><strong>第三部分<code>Hypervisor</code></strong></p>
<p><code>simple_hv</code></p>
<p>这个其实挺简单的，但是卡了我很久很久。遇到的问题是我在一开始就触发不了<code>panic</code>程序会直接卡死，然后依然是不断通过打印去定位错误，竟然发现卡死在了<code>_run_guest</code>的汇编代码里面，就硬着头皮去看汇编。还是一直发现不了卡死的原因……</p>
<p>总之就是试了很久，分析<code>qemu</code>的日志才发现是<code>store_page_fault</code>和时钟错误交替出现，拷打了一下AI之后才发现是没有</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/29/Lfan-ke%EF%BC%9AArceOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/29/Lfan-ke%EF%BC%9AArceOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">穿越操作系统的迷雾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-29 10:38:44" itemprop="dateCreated datePublished" datetime="2025-05-29T10:38:44+00:00">2025-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/" itemprop="url" rel="index"><span itemprop="name">ArceOS</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E4%B8%89/" itemprop="url" rel="index"><span itemprop="name">阶段三</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E4%B8%89/2025S/" itemprop="url" rel="index"><span itemprop="name">2025S</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E4%B8%89/2025S/%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">补完计划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lfan-ke：第三阶段总结报告"><a href="#Lfan-ke：第三阶段总结报告" class="headerlink" title="Lfan-ke：第三阶段总结报告"></a>Lfan-ke：第三阶段总结报告</h1><p>about-me: <a href="https://gitee.com/heke1228" target="_blank" rel="noopener">heke1228@gitee</a>, <a href="https://atomgit.com/heke1228" target="_blank" rel="noopener">heke1228@atom</a>, <a href="https://github.com/Lfan-ke" target="_blank" rel="noopener">Lfan-ke@github</a>, <a href="https://codeberg.org/heke1228" target="_blank" rel="noopener">heke1228@codeberg</a></p>
<h2 id="内核发展史"><a href="#内核发展史" class="headerlink" title="内核发展史"></a>内核发展史</h2><blockquote>
<p>很早很早以前~，并不区分应用与操作系统。所有功能都绑定在一起，负责开发的也是同一批人。某些底层功能被频繁复用，慢慢的常用功能形成了特定的模块，通过接口与其他模块交互。比如：储存模块就是一个大数组。那么，为什么不能把系统作为一个库呢？</p>
</blockquote>
<p>多道操作系统通过分时复用的方式在一台计算机上同时运行多个应用程序。但是出现了安全问题：如果每个应用都可以控制全局资源，如何保证不同应用之间的隔离？不会出现A想格式化，B想重启……所以必须限制应用不允许直接改变全局的系统状态。所以应用与系统分离，至少需要两种权限。</p>
<p>低权限的不允许改变全局系统状态，用来运行应用，高权限的集中运行能改变全局系统状态的操作（特权操作），分化出操作系统内核。</p>


<p>CPU对软件提供的接口：ISA - Instruction Set Architecture - 指令集架构 ：：： RV64、x86、mips、<a href="https://www.loongson.cn/system/loongarch" target="_blank" rel="noopener">LoongArch</a>等等。软硬件的分界线以及交互规范标准。</p>
<p><a href="https://riscv.org/" target="_blank" rel="noopener">RISC-V</a>指令集 = 基础指令集 + 标准扩展指令集 + 用户自定义扩展指令集，比如RV32IM就是RV32的拥有整数以及乘除法指令的配置。RV64GC的G是一个省略书写，实际GC = IMAFD + C。RV32E是一个16个寄存器的嵌入式精简指令集。在gcc编译时使用<a href="https://gcc.gnu.org/onlinedocs/gcc/RISC-V-Options.html" target="_blank" rel="noopener">march</a>指定。使用mabi指定应用程序二进制接口对应类型的字长，比如ilp指的是int/long/usize_t(void*ptr)为32位，lp64f指的是int32位，long/usize_t为64位，支持单精度浮点采用浮点寄存器传递，但是双精度浮点仍然采用栈传递（即硬件指令集得支持F/D扩展，不然你硬件只有整数寄存器，没有对应精度的浮点寄存器）。在未支持的扩展，比如RV64I中书写乘法，则会以软件替代的形式出现，比如使用循环和移位的函数<a href="https://gcc.gnu.org/onlinedocs/gcc-3.4.0/gccint/Integer-library-routines.html" target="_blank" rel="noopener">__mulsi3</a>来替代（当然，如果target=RVxIM但是运行在RVxI，M系指令也会通过trap的形式硬件兜底执行，但是效率低，其他扩展类似）。2020年，RISC-V发展的优先级从体系结构驱动切换为<a href="https://open-src-soc.org/2022-05/media/slides/RISC-V-International-Day-2022-05-05-11h05-Calista-Redmond.pdf" target="_blank" rel="noopener">软件</a>驱动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -o program.elf program.c</span><br><span class="line">riscv64-unknown-elf-g++ -march=rv64gc -mabi=lp64 -o program.elf program.cpp</span><br><span class="line">rustc --target=riscv32imac-unknown-none-elf -C target-feature=+m,+a,+c program.rs</span><br><span class="line">GOOS=linux GOARCH=riscv64 go build -o program program.go</span><br><span class="line">tinygo build -target=riscv32-unknown-elf -o program.elf program.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> cargo.toml：</span></span><br><span class="line">[build]</span><br><span class="line">target="riscv64gc-unknown-none-elf"</span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    "-C", "link-arg=-Tlink.x",              # 可选：自定义链接脚本</span><br><span class="line">    "-C", "target-feature=+m,+a,+f,+d,+c",  # 显式启用扩展</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>ISA包含：指令、寄存器等软件可见可操作的接口，从上到下切换的过程通常被称为陷入(trap)，比如S-sbicall-&gt;M/U-syscall-&gt;S/V&lt;-syscall-&gt;H都是ecall和trap。其中trap是由硬件监测的，比如检测到某些错误就陷入M-Mode：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> trap_detector (</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        clk,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        rst,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] current_pc,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] instruction,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        page_fault,         <span class="comment">// 页错误</span></span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        illegal_instr,      <span class="comment">// 非法指令</span></span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        timer_interrupt,    <span class="comment">// 定时器中断</span></span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]  trap_cause          <span class="comment">// 陷阱原因（scause 编码）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        trap_triggered = <span class="number">0</span>;</span><br><span class="line">        trap_cause     = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步异常检测 - 异常 - Exception</span></span><br><span class="line">        <span class="keyword">if</span> (xxx异常) <span class="keyword">begin</span></span><br><span class="line">            trap_triggered = <span class="number">1</span>;</span><br><span class="line">            trap_cause     = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步中断检测 - 中断 - Interrupt</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (计时器等等) <span class="keyword">begin</span></span><br><span class="line">            trap_triggered = <span class="number">1</span>;</span><br><span class="line">            trap_cause     = &#123;<span class="number">1'b1</span>, timer_interrupt ? <span class="number">3'd5</span> : <span class="number">3'd9</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测到之后trap_handler触发硬件(trap)特权级切换，但是像跳板页是软件(ecall)特权级切换</span></span><br><span class="line"><span class="comment">// 补充：trap - riscv将ECF(异常控制流(Exceptional Control Flow))统称为trap</span></span><br><span class="line"><span class="comment">// 补充：无论是ecall还是trap，都是增删改部分csr与pc，处理结束后通常会逆增删改回到原位/+4</span></span><br><span class="line"><span class="comment">// 补充：ecall-U-&gt;S -&gt; crud: scause/sepc等等   ecall-S-&gt;M -&gt; crud: mcause/mepc等等   trap -&gt; crud: mcause/mepc等等</span></span><br><span class="line"><span class="comment">// 可以是硬件处理，也可以是软件处理，比如编写中断处理函数并将地址刷入中断向量表</span></span><br><span class="line"><span class="comment">// 主打一个硬件可以做的软件也可以做，软件可以做的硬件也可以做，软慢成本低，硬快成本高……</span></span><br></pre></td></tr></table></figure>

<p>操作系统在启动前需要先对部分寄存器赋予初值（初始化），以及传递设备等等硬件信息，这部分工作由SBI来完成。OS若需要M支持需要调用sbicall（比如操作定时器、关闭中断等等）。</p>
<p>定义底层固件与OS的接口：SBI - Supervisor Binary Interface - 监管层二进制接口 ：：： x86-UEFI/BIOS-Grub、RV-opensbi/rustsbi等等。</p>
<p>在SBI初始化结束，PC会被安置到OS的执行入口，开始操作系统初始化，比如开启页表、虚拟空间映射、启动第一个进程等等。比如RISC-V架构通常被放置在<code>0x8020_0000</code>。</p>
<p>操作系统：OS - 用来管理硬件资源并向上层应用提供统一的服务。除了最基础的存储、运行外，还有诸多如：网络、设备、显示等等扩展，以及：运行时环境、集成开发环境、基础库、编译工具链、编程语言、调试工具等等基础设施。</p>
<p>操作系统启动之后，如RISC-V架构，通常为三个特权级：MSU（虚拟化有五个，新增：VS VU，原S-&gt;HS）。用户程序运行在最上层。用户程序若需要S特权级支持需要调用syscall。基于操作系统的标准库，如GNUlibC，通常封装好了一部分syscall的便捷的调用方式，比如fork、printf -&gt; write -&gt; sys_write等等。</p>
<p>操作系统进行了内外两种演化：</p>
<ul>
<li>外部接口：POSIX接口演化、系统调用的增删改、分布式软总线（鸿蒙）等等</li>
<li>内部架构：宏、微、外、多，以及在扩展性安全性性能等等方面的改进</li>
</ul>


<p>宏内核：整个系统分为内核和应用两层，常见比如Linux的主体是宏内核。用户进程通过系统调用使用内核的各项功能。但是系统过于庞大。大量共享状态位于内核态。</p>
<p>微内核：最小化内核功能，将操作系统功能迁移到用户态，称之为”服务“，用户模块之间使用消息传递机制通信。常见比如：WinNT。WinNT实际上是混合内核，但其大部分功能采用微内核实现。共享数据状态部分在内核态，部分在用户态。</p>
<p>混内核：比如上述的WinNT以及MacOS/iOS，将需要性能的模块（线程调度、虚拟内存、IPC-进程间通信、图形子系统）放在内核态，扩展功能（文件系统、网络协议栈）放于用户态。</p>
<p>外核库：Exokernel不管理资源，只管理应用（计算资源、隔离等等），库OS则对硬件的抽象以库的形式提供，不通应用可以使用不通的LibOS。将管理与保护分离。</p>


<p>单内核：Unikernel（单/联内核），使用组件扩展操作系统的功能，在编译时确定系统组件。可看作虚拟化环境下的LibOS。应用与内核位于同一特权级。通过扩展，联内核可扩展为宏内核以及支持虚拟化。常见比如：ArceOS、Rumprun、Drawbridge、OSv等等。以及一个可以将Linux作为联内核的项目：<a href="[https://github.com/lkl](https://github.com/lkl)">LKL</a>。</p>
<p>多内核：又称：复内核。OS整体是一个分布式系统，应用程序仍然运行在OS之上。默认的状态是划分而非共享，显式的核间通信机制。支持设备（比如NPU/GPU等等）上的异构CPU。常见的如：Barrelfish、Popcorn Linux。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/05/29/Lfan-ke%EF%BC%9AArceOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/26/2025summercamp-%E5%AD%99%E5%AE%87%E8%88%AA-%E4%BA%8C%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/26/2025summercamp-%E5%AD%99%E5%AE%87%E8%88%AA-%E4%BA%8C%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2025summercamp 孙宇航-二三阶段总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-26 20:20:15" itemprop="dateCreated datePublished" datetime="2025-05-26T20:20:15+00:00">2025-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h1><p>这个阶段给我最大的感受是学习，因为很多函数都被事先书写好了，这几个实验基本都是在已有的框架上进行相关的函数调用即可，在明白每个函数的实现逻辑以及每个lab实验要实现的功能即可完成实验。同时这个阶段给我的感受是有许多深层次的知识仍需要学习，有许多一知半解的知识需要实践，看到学习群里面大家对于实验的讨论的诸多见解，受益匪浅，完完全全的拓宽了我的眼界，许多从未听过的名词出现在我的面前，只感到纸上得来终觉浅，绝知此事要躬行。可惜时间所迫，没办法对于每个lab实验进行进一步的深究。<br>第二阶段我重点理会到了操作系统的一步步发展以及实现的功能，在进行每个实验的时候，感受到学校里面的讲解十分片面，并且浅薄（也是我没有认真学习的缘故，学校里面的课检验的只有期末突击而已）。<br>非常重要的一点是这次的理论和实践一起进行，让我极大的认识到了抽象和具体之间的联系，有时候理论上很复杂并且难以理解的东西，转化到实践上面竟然可能只是一个数组，一个函数栈而已，这让欠缺实践的我大开眼界。<br>非常期待第三阶段带来的挑战，也非常希望可以通过第三阶段（哈哈哈）。</p>
<h1 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h1><p>这个阶段我做的十分仓促，并且没有详细做挑战题的内容，arceos组件化的设计思路让我受益匪浅，项目的设计理念和一些细节都要比rcore要好很多，也复杂很多。四阶段项目阶段我没有什么了解，只能希望自己可以投入进去，获得一些成果吧。<br>临近毕业，对于未来仍然十分迷茫，写下三阶段总结时，我刚刚完成我的本科毕业设计，对未来没有一个清晰的规划，没想到这么快就要毕业了。原计划我准备这个训练营和毕业一起做完，可惜并没有达成我原先的目标，最后一个月的时间，希望可以再接再厉吧，这可能也是我仅剩的校园时光了…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/26/%E5%90%84%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-yuanyiboyyb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/26/%E5%90%84%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-yuanyiboyyb/" class="post-title-link" itemprop="url">各阶段总结_yuanyiboyyb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-26 00:36:06" itemprop="dateCreated datePublished" datetime="2025-05-26T00:36:06+00:00">2025-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="各阶段总结"><a href="#各阶段总结" class="headerlink" title="各阶段总结"></a>各阶段总结</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>rust的基本学习，挺多有用的函数记不住，还需要多写代码</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><ul>
<li>Chapter 1: 应用程序与基本执行环境</li>
</ul>
<p>删除了标准库，适应一下内核级别的编程，不过其实core库很多都是直接引用std库的哈哈哈</p>
<ul>
<li>Chapter 2: 批处理系统</li>
</ul>
<p>操作系统必须负责保存所有的通用寄存器以及一系列关键的控制状态寄存器（CSRs），例如sstatus（记录CPU当前的特权级别）、sepc（记录发生trap时的指令地址，即trap返回后应继续执行的地址）、scause/stval（分别记录trap发生的原因及相关的附加信息）。这些CSRs对于用户态程序而言通常是透明的。出于安全性的考量，操作系统必须为内核态的执行维护一个独立的内核栈，而非在用户栈的基础上进行扩展。RISC-V架构为此提供了sscratch寄存器，可用于保存内核栈的地址。当陷入（trap）发生时，操作系统可以从sscratch寄存器中获取内核栈的起始地址，并切换至内核栈上开始后续处理。另外，在此阶段，所有的内存操作均基于物理地址进行，尚未实现内核态与用户态之间的内存隔离。理论上，应用程序能够访问包括内核栈在内的所有物理内存区域，这具有极大的潜在风险。此内存隔离问题将在后续实现虚拟内存机制时得到解决。</p>
<ul>
<li>Chapter 3: 多道程序与分时多任务</li>
</ul>
<p>当初学操作系统时对中断说实话没什么概念，原来真的是中中又断断啊，真的中断触发时直接跳转到中断处理程序。当然中断处理程序的地址由一个专门的寄存器来储存</p>
<ul>
<li>Chapter 4: 地址空间</li>
</ul>
<p>由于内核与应用程序的地址空间通常是不同的（或者说，它们各自拥有不同部分的内存映射），在从用户态陷入内核态之前，往往需要借助一个位于固定虚拟地址的“跳板页”（trampoline page）来实现上下文的平滑、安全切换。是的，也会有一个寄存器用来存储根页表的地址，将根页表的地址放到寄存器里之后，mmu会接管地址访问，也就是说，之后的地址转换由硬件完成，而不是软件。</p>
<ul>
<li>Chapter 5: 进程</li>
</ul>
<p>我原以为最为复杂的进程与shell机制，原来如次简单。</p>
<ul>
<li>Chapter 6: 文件系统</li>
</ul>
<p>其实文件系统的底层还是客户操作系统的read write系统调用，只不过封装成block的形式，真实操作系统里应该会依赖与硬件特性以及驱动的实现</p>
<ul>
<li>Chapter 7: 进程间通信</li>
</ul>
<p>这一章虽然没有题，但是我还是建议好好看看代码，解答了过往我的很多疑惑</p>
<ul>
<li>Chapter 8: 并发</li>
</ul>
<p>“纸上得来终觉浅，绝知此事要躬行”，当初操作系统课上我觉得银行家算法是一个没有实际应用价值的东西，通过实验的一点点试错尝试，我还是最终推导出了银行家算法，其解决的不是所有死锁问题，只是解决死锁中的a进程获得a锁，b进程获得了b锁，然后a想获得b锁，b想获得a锁这种问题，受益匪浅啊</p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>这一块的由于杂事颇多还需好好研究一下代码以及项目组织架构，几道题中有意思的是Hipervisor，其通过一个循环不多进入虚拟机状态，如果虚拟机有解决不了或权限不足无法执行的指令，就通过陷入由陷入处理函数来帮助虚拟机执行，然后在进入虚拟机模式，挺有意思，需要好好研究一下之后的东西。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/2025%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%89%8D%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/2025%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%89%8D%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" class="post-title-link" itemprop="url">2025春季开源操作系统训练营前三阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 17:16:56" itemprop="dateCreated datePublished" datetime="2025-05-25T17:16:56+00:00">2025-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="各阶段总结"><a href="#各阶段总结" class="headerlink" title="各阶段总结"></a>各阶段总结</h1><h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><p>rustling，对rust语言的引入，很不错的一个仓库，很久没用了，边写边复习，如果题目更多一点就更好了</p>
<h2 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h2><h3 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h3><p>对系统调用的计数，遇到了比较神奇的bug，调用数组设置太大导致获取时间的调用出现异常，卡了挺久，本来是挺简单的，如果遇到类似bug的可以试试限制调用数组的长度</p>
<h3 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h3><p>引入了虚存，工作主要集中在memory_set部分，在实现采用了RAIL机制，加上rust的所有权及drop trait自动实现页表项的释放</p>
<h3 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h3><p>迁移三个函数，主要变化就是taskmanager多分出了一个processor，关于spawn，结合TaskControlBlock的fork和exec方法，从中选出直接spawn应该如何构造TaskContext和TrapContext<br>值得一提的是stride调度算法在筛选task的时候其实可以用优先级队列筛的，然而没时间了只能用个暴力遍历，对自己手搓的能力感到无奈</p>
<h3 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h3><p>简单的文件系统，主要是理解inode的相关机制吧，首先对于创建硬链接来说，得先在diskinode加一个nlink用于引用计数，创建硬链接就先find_inode_id，然后modify_disk_inode为根增加direntry，name就是链接名，然后就创建完成，在通过目标文件的inode用modify增加引用计数nlink即可</p>
<p>unlinkat类似，先删direntry然后找到对应inode，引用计数-1，加一个判断如果nlink为0了就删文件回收inode和数据块</p>
<p>对sys_fstat来说，在Inode中增加get_inode_id、get_mode、get_nlink等函数，从fd_table中我们能拿到OSInode，OSInode中能拿到Inode，从而可以调用增加的函数获取文件信息</p>
<h3 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h3><p>死锁检测，在每一次 sys_mutex_lock 以及 sys_semaphore_down时判断，会死锁则 return -0xdead;</p>
<p>对于 mutex<br>遍历一遍有没有别的 thread 正在拿这个 mutex 就行<br>其实就相当于 semaphore 里面的可用资源只有 1 个<br>主要思路还是遍历并逐个判断</p>
<h2 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h2><h3 id="exercise1"><a href="#exercise1" class="headerlink" title="exercise1"></a>exercise1</h3><p>没有太多好说的，主要也是偷懒了涉及axhal层的不想修改，直接在axstd层次做一个ANSI转义</p>
<h3 id="exercise2"><a href="#exercise2" class="headerlink" title="exercise2"></a>exercise2</h3><p>支持hashmap类型，看exercise文件可以知道要在axstd创建个collections文件夹模块，内部一个hashmap.rs和一个mod.rs把hashmap公布出去，hashmap的具体实现偷懒抄了下hashbrown，拿来简化了一下，再次对自己的手搓能力感到无奈，以后有时间再好好实现一次</p>
<h3 id="exercise3"><a href="#exercise3" class="headerlink" title="exercise3"></a>exercise3</h3><p>实现新的内存算法bump，把arceos/modules/bump_allocator/src/lib.rs中的EarlyAllocator类实现即可。</p>
<p>实际上还是偷懒了，对于字节分配，不去记录已分配的字节区域的开始位置及长度，仅仅记录一个分配次数count，alloc时count + 1，dealloc时count - 1，当count为0时才回收所有ByteAllocator的区域(b_pos收到start那里)；</p>
<h3 id="exercise4"><a href="#exercise4" class="headerlink" title="exercise4"></a>exercise4</h3><p>支持ramfs的rename操作，主要注意一下把cargo里的包换成arceos下面的(不然文件系统的包永远是网上拉下来的)(搞了挺久，恼)，找到对trait<code>VfsOps</code>和<code>VfsNodeOps</code>的实现之后，搞清楚记录文件的数据结构，实现<code>rename</code>就可以了。</p>
<h3 id="exercise5"><a href="#exercise5" class="headerlink" title="exercise5"></a>exercise5</h3><p>为宏内核支持sys_mmap系统调用，实现对文件的映射,参考 arceos/tour/m_2_0/src/main.rs handle_page_fault() 和 arceos/tour/m_2_0/src/loader.rs,除此之外，注意一下musl-gcc的环境变量</p>
<h3 id="exercise6"><a href="#exercise6" class="headerlink" title="exercise6"></a>exercise6</h3><p>实现最简单的Hypervisor，响应VM_EXIT常见情况，感觉像是面向测例的编程，csrr a1, mhartid 和 ld a0, 64(zero) 触发异常后，手动完成其功能</p>
<p>希望后续实习能增强动手能力，还有很多底层细节实现感觉不熟悉，调试代码的能力也不足，经常被一些很基础的问题卡住（笑）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/2025s-os-camp-123-summary-noah/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/2025s-os-camp-123-summary-noah/" class="post-title-link" itemprop="url">2025年春夏开源操作系统训练营三阶段总结-noah</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 14:33:00" itemprop="dateCreated datePublished" datetime="2025-05-25T14:33:00+00:00">2025-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025-春季开源操作系统训练营前三阶段总结报告"><a href="#2025-春季开源操作系统训练营前三阶段总结报告" class="headerlink" title="2025 春季开源操作系统训练营前三阶段总结报告"></a>2025 春季开源操作系统训练营前三阶段总结报告</h1><h2 id="学习背景"><a href="#学习背景" class="headerlink" title="学习背景"></a>学习背景</h2><p>在进行网络编程的时候，如果要提高程序的并发性能会用到 io 多路复用和协程，很多框架和语言都会有自己的实现，在逐渐深入的过程中，就会提出一些问题：</p>
<ul>
<li>io 多路复用 select、epoll、io_uring 是如何做到可以提高并发性的</li>
<li>阻塞和非阻塞又是如何做到的</li>
<li>到底什么是同步什么是异步</li>
<li>协程底层是如何实现的</li>
</ul>
<p>这些问题虽然网上有很多资料，但如果自己不亲自去写一些 case 去验证，感觉是很难理解透彻的。而这些技术的实现都是直接或者间接的依赖操作系统才可以做到，也就是说要理解这些知识点，那就必须要学操作系统的知识。</p>
<p>正好我也在模仿着想实现一个协程框架(有栈的)，发现要用到汇编知识，发现写操作系统也需要汇编知识，于是顺手查了下比较好的操作系统课程：</p>
<ul>
<li>南京大学的操作系统</li>
<li>清华大学操作系统 - ucore &amp; rcore</li>
<li>MIT xv6 操作系统</li>
</ul>
<p>在视频网站上看到有人分享参加了开源操作系统训练营，于是便在今年 1 月份就定计划要专供下操作系统的知识，来参与下开源操作系统训练营了，也算是补上十多年前没学好的专业课吧(出来混，早晚都要还的)</p>
<p>另外，也想通过这次的学习，寻找一些志同道合的朋友，一起进步。</p>
<h2 id="学习仓库"><a href="#学习仓库" class="headerlink" title="学习仓库"></a>学习仓库</h2><p>跟着老师和同学们一起学习用的代码仓库，里面包含了每次作业的提交内容</p>
<ul>
<li><a href="https://github.com/LearningOS/2025s-rustling-CreatorMetaSky" target="_blank" rel="noopener">rustling</a></li>
<li><a href="https://github.com/LearningOS/2025s-rcore-CreatorMetaSky" target="_blank" rel="noopener">rcore</a></li>
<li><a href="https://github.com/LearningOS/2025s-arceos-CreatorMetaSky" target="_blank" rel="noopener">ucore</a></li>
<li><a href="https://github.com/osxspace/qhos" target="_blank" rel="noopener">qhos</a> - 记录了一些学习笔记 - 记录的有些凌乱</li>
</ul>
<h2 id="各阶段学习内容总结"><a href="#各阶段学习内容总结" class="headerlink" title="各阶段学习内容总结"></a>各阶段学习内容总结</h2><h3 id="第一阶段-rustling"><a href="#第一阶段-rustling" class="headerlink" title="第一阶段 rustling"></a>第一阶段 rustling</h3><p>rustling 很久之前曾经刷过一遍了，这次是温故知新，复习了以下知识点：</p>
<ul>
<li>rust 的基本语法</li>
<li>模式匹配</li>
<li>所有权转移</li>
<li>容器智能指针</li>
<li>包管理机制</li>
<li>使用 async await</li>
</ul>
<h3 id="第二阶段-rcore"><a href="#第二阶段-rcore" class="headerlink" title="第二阶段 rcore"></a>第二阶段 rcore</h3><p>在学习 rCore 的过程中，首先通读了一遍 <a href="https://learningos.cn/rCore-Tutorial-Guide-2025S" target="_blank" rel="noopener">rCore-Tutorial-Guide</a>， 发现其中大部分章节只是罗列了代码的改动，对于基础知识原理，并没有过多的介绍。<br>又开始阅读学习 <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3" target="_blank" rel="noopener">rCore-Book</a>，后续配合陈渝老师导学阶段的视频(2022年教学视频)，才逐渐走上了学习的正轨。学到了以下知识：</p>
<p><strong>构建操作系统的步骤</strong></p>
<ul>
<li>env setup - 模拟器搭建裸机运行环境</li>
<li>libos - 在内核上跑一个最简单的程序</li>
<li>batchos - 支持批量运行多个程序 - 引入特权级机制</li>
<li>taskos - 实现分时多任务执行</li>
<li>asos - 地址空间以及映射</li>
<li>pos - 进程 - 从 TCB 到 PCB 的进化</li>
<li>fos - 支持文件系统 - 从文件读取程序执行</li>
<li>ipcos - 进程间通信 - shell 的方式进行进程切换</li>
<li>tcos - 线程、协程 - 进程对应资源，线程对应调度</li>
</ul>
<p><strong>操作系统内核核心组件</strong></p>
<ul>
<li>地址空间</li>
<li>进程管理和切换</li>
<li>文件系统</li>
</ul>
<p><strong>学到的具体知识点</strong></p>
<ul>
<li>程序的内存布局结构、如何通过 linker.ld 去修改程序布局</li>
<li>页表机制以及虚拟地址到物理地址的映射方式</li>
<li>进程的协作式调度和抢占式调度以及不同的调度算法的历史演进</li>
<li>文件系统 inode 的结构组织方式，逐层递进的调用方式，为深入理解一切皆 io 打下基础</li>
<li>从进程发展的角度去理解 fork exec spawn</li>
<li>进程间通信 pipe 和 shell</li>
<li>从操作系统源码层面深入的理解进程、线程、绿色线程以及它们的异同</li>
<li>理解互斥、同步的概念，锁、信号量、条件变量</li>
</ul>
<p><strong>帮助理解的知识点</strong></p>
<ul>
<li>操作系统的启动流程</li>
<li>中断和崩溃信号量机制的实现</li>
<li>内存分配和管理机制</li>
<li>IO 多路复用技术</li>
<li>协程以及调度实现</li>
<li>各种锁的实现原理</li>
<li>RingBuffer</li>
<li>LRU</li>
</ul>
<p>通过上述知识的学习，终于明白了操作系统是为上层应用开发提供硬件抽象的一种系统软件实现这句话，也为我揭开了操作系统的神秘面纱</p>
<h3 id="第三阶段-arceos"><a href="#第三阶段-arceos" class="headerlink" title="第三阶段 arceos"></a>第三阶段 arceos</h3><p>arceos 这部分主要是把老师的上课视频给走了一遍，个人理解就是把 rCore 中的各部分代码用 rust 的包管理机制打散，最终做到通过拼装组件就可以形成操作系统的效果，类似应用开发中的模块化和组件化。</p>
<p><strong>学到的知识点</strong></p>
<ul>
<li>unikernel 调用流程，如何从应用层通过系统调用调用内核的实现</li>
<li>如何拼装新的模块到 unikernel 中</li>
<li>理解 unikernel 到 宏内核的转变过程 - 解决特权级切换(用户态到内核态的切换)、地址空间的问题是关键</li>
<li>能够运行标准 linux 二进制 - 这块还是挺感兴趣的</li>
<li>hypervisor 这块牵扯到在虚拟环境中运行 rCore 操作系统 - 个人理解相当于在操作系统中再次嵌套操作系统 - 学的有点吃力了</li>
</ul>
<h2 id="总结学习方法"><a href="#总结学习方法" class="headerlink" title="总结学习方法"></a>总结学习方法</h2><h3 id="渐进式的学习"><a href="#渐进式的学习" class="headerlink" title="渐进式的学习"></a>渐进式的学习</h3><ul>
<li>what - 某个技术是什么，有个初步的认识</li>
<li>when - 什么时候用，在什么情况下或者说上下文下使用这种技术</li>
<li>how - 如何用这种技术，如何写代码</li>
<li>why - 为什么要用，为什么要使用这种技术</li>
<li>build - 内部是如何实现的，自己写一个</li>
</ul>
<h3 id="如何高效学习"><a href="#如何高效学习" class="headerlink" title="如何高效学习"></a>如何高效学习</h3><p>就像面试自己一样，不断地向自己提问题是最好的学习方式，这样才能加深理解，才算是真正理解</p>
<h2 id="遗憾之处"><a href="#遗憾之处" class="headerlink" title="遗憾之处"></a>遗憾之处</h2><ol>
<li>时间上的原因，并没有把自己提问的问题以及理解，全部深入的汇总出来</li>
<li>我们目前是学的 Risc-V 架构的操作系统，但是目前 x86 架构依然是主流，之前 uCore 的操作系统实现就是基于 x86 的，后续还要学习下 uCore 的实现。</li>
<li>在参加这次训练营的过程中，只是走马观花的看和了解了一些基础知识和概念，虽然也做了课后作业，但是跟自己实际上手去实现还是差着十万八千里，对于一些用到的库，基本都是拿来主义，也没有深入的去探索其内部的实现原理，如：内存分配算法，进程调度算法、rust-sbi，希望自己以后还是能脚踏实地的从头跟着 rCore-Book 手搓一个真正自己的操作系统。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/2025%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%9B%B9%E8%BE%B0%E5%AE%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/2025%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%9B%B9%E8%BE%B0%E5%AE%87/" class="post-title-link" itemprop="url">前三阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 10:12:26" itemprop="dateCreated datePublished" datetime="2025-05-25T10:12:26+00:00">2025-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/os/" itemprop="url" rel="index"><span itemprop="name">os</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="各阶段总结"><a href="#各阶段总结" class="headerlink" title="各阶段总结"></a>各阶段总结</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>rust的基本筛查，没什么说的。rust的诸多库日后再学，目前就系统库使用比较多。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>这里是一个简单的小操作系统</p>
<p>好的，这是参照您提供的原文，并进行书面化、精炼化处理后的中文版本：</p>
<h3 id="Chapter-1-应用程序与基本执行环境"><a href="#Chapter-1-应用程序与基本执行环境" class="headerlink" title="Chapter 1: 应用程序与基本执行环境"></a>Chapter 1: 应用程序与基本执行环境</h3><p>本章旨在阐明操作系统作为系统软件与应用层软件在执行环境层面存在的本质差异，而非对操作系统自身的复杂理论进行深入剖析。<br>同时，通过具体的代码范例，演示了在操作系统此种独特的执行环境下构建可执行程序的途径。</p>
<p>用户态程序的运行普遍依赖于特定的语言运行时环境及其附带的标准库。所谓运行时，通常包含预先编译的代码片段，用以实现诸如数组边界检查等基础功能；<br>标准库则对底层系统调用进行了封装，例如，常见的打印函数其内部便是通过<code>write</code>系统调用将数据输出至显示设备。<br>操作系统亦承担了程序运行的准备与善后职责，涵盖虚拟内存空间的辟配、程序代码的加载以及退出时的资源清理等环节。<br>但是，操作系统是直接运行于硬件之上的，并无现成的系统调用或预置软件可供利用，一切功能从零开始编码实现。</p>
<h3 id="Chapter-2-批处理系统"><a href="#Chapter-2-批处理系统" class="headerlink" title="Chapter 2: 批处理系统"></a>Chapter 2: 批处理系统</h3><p>本章的核心议题集中于系统调用的具体实现过程，此过程涉及较多工程实践层面的细节。从上下文保存与恢复的视角来看，系统调用与常规的函数调用具有相似性：<br>两者均要求在调用发生前保存当前的执行上下文（主要指寄存器状态），并在调用返回时予以恢复，<br>这与编译原理中函数调用的序言（prologue）和尾声（epilogue）机制异曲同工。</p>
<p>其主要差异体现在以下两个方面：</p>
<ol>
<li>操作系统必须负责保存所有的通用寄存器（因为用户态的调用约定对此并无保障）以及一系列关键的控制状态寄存器（CSRs），例如<code>sstatus</code>（记录CPU当前的特权级别）、<code>sepc</code>（记录发生trap时的指令地址，即trap返回后应继续执行的地址）、<code>scause</code>/<code>stval</code>（分别记录trap发生的原因及相关的附加信息）。这些CSRs对于用户态程序而言通常是透明的。</li>
<li>出于安全性的考量，操作系统必须为内核态的执行维护一个独立的内核栈，而非在用户栈的基础上进行扩展。RISC-V架构为此提供了<code>sscratch</code>寄存器，可用于保存内核栈的地址。当陷入（trap）发生时，操作系统可以从<code>sscratch</code>寄存器中获取内核栈的起始地址，并切换至内核栈上开始后续处理。</li>
</ol>
<p>另外，在此阶段，所有的内存操作均基于物理地址进行，尚未实现内核态与用户态之间的内存隔离。<br>理论上，应用程序能够访问包括内核栈在内的所有物理内存区域，这具有极大的潜在风险。此内存隔离问题将在后续实现虚拟内存机制时得到解决。</p>
<h3 id="Chapter-3-多道程序与分时多任务"><a href="#Chapter-3-多道程序与分时多任务" class="headerlink" title="Chapter 3: 多道程序与分时多任务"></a>Chapter 3: 多道程序与分时多任务</h3><p>第三章引入了抢占式（preemptive）机制。这使得操作系统能够以分时复用的方式交替运行多个程序，从而显著提升了系统的交互体验。</p>
<p>实现分时系统的关键技术在于引入了时钟（timer）中断。定时器会周期性地产生中断信号，使操作系统得以重新获得CPU的控制权，<br>并依据预设的调度策略来决定是否需要切换到另一个应用程序执行。这种应用程序间的切换过程，与系统调用的处理流程相似，均涉及到中断当前应用的执行并在稍后某个时刻恢复其运行，<br>因此同样需要对应用程序的运行上下文进行细致的保存与恢复。</p>
<p>在本章中，应用程序被抽象为“任务”（Task）的实体，并通过“任务控制块”（Task Control Block, TCB）的数据结构来进行统一的调度与管理。<br>实验任务之一是实现<code>trace</code>系统调用。一个值得注意的实现细节是，若实验要求分别统计每个应用程序的系统调用次数，这通常需要借助特定的数据结构<br>（例如二维数组）来实现。在设计实现时，若将此统计结构直接置于<code>TaskControlBlock</code>内部，可能会因<code>TaskControlBlock</code>自身内存布局或大小的限制而引发内核崩溃。<br>因此，将此类统计结构设计在更高层级的<code>TaskManager</code>中，通常是更为稳妥和健壮的方案。</p>
<h3 id="Chapter-4-地址空间"><a href="#Chapter-4-地址空间" class="headerlink" title="Chapter 4: 地址空间"></a>Chapter 4: 地址空间</h3><p>本章的核心内容围绕虚拟内存的实现展开。通过引入虚拟内存机制，每个应用程序都能拥有各自独立的、私有的地址空间，从而无需关心其在物理内存中的实际存储位置。<br>虚拟内存的管理主要依赖于诸如<code>MemorySet</code>和<code>MapArea</code>（原文提及<code>MemoryMap</code>，但在教程实践中<code>MapArea</code>更为常用）等精心设计的数据结构，<br>其核心设计思想与Linux等成熟操作系统中的虚拟内存管理机制存在共通之处。</p>
<p>硬件层面，内存管理单元（MMU）承担了虚拟地址到物理地址的自动翻译工作。操作系统仅需将页表的根节点指针（例如在RISC-V架构中，<br>此指针存放于<code>satp</code>寄存器）加载到特定的控制寄存器中，即可启用地址翻译功能。</p>
<p>虚拟内存机制的引入，对内核的整体结构进行了一次较大规模的重构。其主要原因在于，先前在系统调用处理和程序切换过程中所保存的上下文内容，<br>由于地址空间的根本性变革，必须进行相应的调整以适应新的内存模型。此过程涉及到若干复杂的技术细节：<br>例如，在启用虚拟内存之后，当程序从用户态陷入（trap）到内核态时，内核需要借助应用态的页表（或预设的内核自身映射关系）来访问并保存用户程序的上下文信息。<br>此外，由于内核与应用程序的地址空间通常是不同的（或者说，它们各自拥有不同部分的内存映射），在从用户态陷入内核态之前，<br>往往需要借助一个位于固定虚拟地址的“跳板页”（trampoline page）来实现上下文的平滑、安全切换。这些具体的设计考量与实现细节，<br>可能是在先前纯理论学习阶段未曾深入探究的。</p>
<p>本章实验中的一个难点可能在于<code>sys_trace</code>函数的移植。当需要向目标地址写入数据时，<br>一个常见的理解误区涉及对物理页号（Physical Page Number, PPN）的认知：PPN本身并非一个带有零填充的完整物理地址，它仅仅是物理页帧的一个编号。<br>正确的物理地址应通过将PPN左移页大小对应的位数（PAGE_SIZE，通常为12位，即乘以$2^{12}$），再加上页内偏移（offset）来计算得到。</p>
<h3 id="Chapter-5-进程"><a href="#Chapter-5-进程" class="headerlink" title="Chapter 5: 进程"></a>Chapter 5: 进程</h3><p>本章正式引入了“进程”（Process）这一核心概念。进程可以被视为前四章所学知识（例如内存管理、任务调度等）的进一步抽象、封装与整合。<br>进程抽象使得操作系统能够支持更为丰富和高级的语义，例如实现更为灵活多样的进程调度策略，<br>以及通过<code>fork()</code>和<code>exec()</code>等经典的系统调用来创建新进程和加载执行新程序。本章还通过实现一个简易的Shell，使得该实验性操作系统在功能完备性上又迈进了一步。</p>
<p>本章内容主要在于如何有机地结合前述章节所介绍的技术手段来实现进程这一核心概念，并补充了进程管理相关的诸多细节，<br>例如初始进程（init process）的启动流程、进程正常或异常退出后的资源回收（reap）机制等。</p>
<p>本章的实验内容可能包括：</p>
<ul>
<li><code>spawn</code>系统调用：其实现可视为<code>fork</code>与<code>exec</code>系统调用的某种组合。但其区别在于，<code>spawn</code>通常用于创建一个全新的进程来执行一个指定的程序，</li>
<li>它会为新进程创建全新的地址空间（<code>MemorySet</code>）并加载目标程序，而不是像<code>fork</code>那样完全复制父进程的地址空间。</li>
<li>stride调度算法：其实现主要是在调度器（例如<code>TaskManager</code>）的数据结构中为每个进程维护其步长（stride）和优先级（priority）等属性，</li>
<li>并依据这些属性进行调度决策。在透彻理解相关数据结构之后，该算法的实现过程相对较为清晰。</li>
</ul>
<h3 id="Chapter-6-文件系统"><a href="#Chapter-6-文件系统" class="headerlink" title="Chapter 6: 文件系统"></a>Chapter 6: 文件系统</h3><p>本章介绍了文件系统的具体实现，这一机制使得程序和数据能够持久化地存储在块设备（如磁盘）之上，而不仅仅是暂时驻留在易失性的内存之中。<br>尽管文件系统的基本理论可能已在其他课程中有所涉猎，但通过本章的实际动手实现，学习者可以深入了解到诸多实践层面的细节，<br>例如操作系统是如何与磁盘驱动程序进行交互的。由于磁盘驱动程序通常已经提供了一层硬件抽象（例如通过<code>BlockDevice</code> trait定义接口），<br>文件系统的实现便主要集中在遵循这些预定义的接口规范，并构建文件系统自身的逻辑结构（例如inode、dentry、superblock等核心概念的实现）。</p>
<p>在实验中实现硬链接（hard link）功能时，正确的处理方式是在目录条目（directory entry）中将新的文件名链接到目标文件的inode之上，<br>而不是为每一个硬链接都创建一个全新的inode副本。</p>
<p>实验过程中可能的问题：在向<code>DiskInode</code>等核心数据结构中添加过多字段时，有时可能会偶发性地触发与虚拟内存相关的<code>LoadPageError</code>或类似的错误，<br>且这种错误行为可能表现出一定的随机性或平台依赖性。其深层原因可能与数据结构在内存中的对齐方式、大小变化触及了某些边界条件，<br>或是与底层内存管理模块之间存在一些微妙的交互问题有关，这类问题通常具有较高的调试难度。</p>
<p>此外，由于引入了标准输入（stdin）和标准输出（stdout）的概念（它们通常作为文件描述符0和1存在），在通过<code>spawn</code>或类似机制创建新进程时，<br>必须确保正确初始化其文件描述符表，特别是<code>stdin</code>和<code>stdout</code>的指向，<br>否则可能导致新创建的进程无法正常进行输入输出操作（例如，测试程序可能无法打印任何内容到控制台）。</p>
<h3 id="Chapter-7-进程间通信"><a href="#Chapter-7-进程间通信" class="headerlink" title="Chapter 7: 进程间通信"></a>Chapter 7: 进程间通信</h3><p>本章内容有助于加深对Shell命令执行机制的理解，特别是关于管道（pipe）和重定向（redirection）的处理方式。例如，对于形如<code>a | b</code>的管道命令，<br>以及包含输入/输出重定向的复杂命令（如<code>cmd xx &gt; yy &lt;&lt; zz</code>），<br>其解析和执行流程并非简单的串行化处理，而是由Shell进行统一的调度与编排，从而在不同程序（进程）之间建立起正确的数据流。</p>
<p>本章的核心技术在于，通过为不同类型的IPC（Inter-Process Communication，进程间通信）资源（例如管道Pipe）实现一个统一的<code>File</code><br>trait（可理解为接口或特性），使得进程可以使用与文件操作相一致的文件描述符来管理这些IPC资源。举例来说，标准输出可以被视为一个实现了<code>File</code><br>trait的对象，对其执行<code>write</code>操作最终会将数据导向屏幕显示或传递给管道的下一级。</p>
<p>I/O重定向（例如使用<code>&gt;</code>和<code>&lt;</code>符号）也遵循相似的原理：操作系统层面通过修改目标进程文件描述符表中的相应条目，<br>使其指向特定的文件或其他I/O端点，从而实现数据流向的改变。</p>
<p>对于其他形式的进程间通信机制，例如基于环形缓冲区（ring buffer）实现的管道，同样可以为其封装<code>read</code>和<code>write</code>等文件操作接口。<br>当进程调用这些接口时，数据被读入或写入共享的环形缓冲区，以此方式实现了进程间的数据交换。</p>
<h3 id="Chapter-8-并发"><a href="#Chapter-8-并发" class="headerlink" title="Chapter 8: 并发"></a>Chapter 8: 并发</h3><p>本章探讨了操作系统与并发编程中的若干经典并发控制机制，例如锁（包括互斥锁Mutex、自旋锁SpinLock）、信号量（Semaphore）以及条件变量（Condition Variable）。</p>
<p>本章关于线程（Thread）管理的具体实现尤为值得关注。在此阶段，rCore的调度模型进一步向类Linux系统演进：线程成为基本的调度单位，<br>而进程（Process）则更多地扮演资源容器的角色，负责管理诸如文件描述符表（<code>fd_table</code>）、地址空间（<code>MemorySet</code>）等由同一进程内所有线程共享的资源。</p>
<p>为了支持多线程，进程需要为每一个在其内部运行的线程维护独立的运行上下文（Trap Context）和内核栈（Kernel Stack）。<br>由于同一进程内的所有线程共享相同的地址空间，它们的线程栈（用户态栈）通常被统一分配和管理在进程用户地址空间内的特定区域<br>（或者由内核统一管理，但对用户而言是透明的）。线程切换的机制，在保存和恢复上下文方面，与早期章节中描述的任务切换机制基本一致。<br>若发生跨进程的线程切换（即从一个进程中的线程切换到另一个不同进程中的线程），<code>switch</code>函数除了需要切换线程的上下文外，<br>还必须负责切换地址空间（即更换当前生效的页表），以确保线程能够在新的目标进程的地址空间中正确运行。</p>
<p>本章的实验任务之一是实现银行家算法（Banker’s Algorithm），这是一个经典的用于避免死锁的算法。</p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>arcore 阶段，这是另一个更严谨也更复杂一点的系统</p>
<h3 id="组件化基础-Unikernel内核"><a href="#组件化基础-Unikernel内核" class="headerlink" title="组件化基础 - Unikernel内核"></a>组件化基础 - Unikernel内核</h3><h4 id="课堂"><a href="#课堂" class="headerlink" title="课堂"></a>课堂</h4><p>组件化内核设计，即通过选择和组合可复用的软件模块来构建内核。这种方法使得构建各种类型的内核（从简单的 Unikernel<br>到更复杂的宏内核或 Hypervisor）具有灵活性，可以通过增量添加或扩展组件来实现。系统的启动过程也正体现了这一理念：<br>首先由特定于体系结构的硬件抽象层 (axhal) 进行早期设置（如 MMU 和栈初始化），然后转换到通用运行时环境 (axruntime)，<br>后者会初始化日志、内存分配器和调度器等更多系统，并最终运行主应用程序。通过features可以实现定制化，允许开发者编译仅包含特定应用所需组件的内核。</p>
<p>之后我们讲了内存管理。</p>
<p>内存管理 是一个关键方面，包含两个核心领域：</p>
<p><strong>分页 (paging)</strong> 是分阶段实现的。这类似于现代操作系统（如 Linux 或 Windows）中的虚拟内存机制。<br>一个强制的初始阶段建立基本的内存映射（例如，内核代码和数据的直接映射）；<br>一个可选的第二阶段则重建更完整、更细粒度的虚拟到物理地址映射 ，这对于管理更大的地址空间（如整个物理内存上限）和设备 MMIO（内存映射 I/O，例如 UART、VirtIO 插槽的物理地址 0x1000_0000 等被映射到虚拟地址 0xffff_ffc0_1000_0000 ）至关重要。</p>
<p>通过 axalloc 组件引入了 动态内存分配，它提供了一个 GLOBAL_ALLOCATOR 。这与 C 语言中的 malloc/free 或 C++ 中的 new/delete 作用类似。该分配器支持字节和页分配，并采用了多种算法（如文稿中提到的 TLSF、Buddy、Slab 算法 ），从而能够支持像 Rust 的 Vec（动态数组）或 HashMap（哈希表）这类需要动态调整大小的数据结构 。</p>
<p><strong>任务管理与调度</strong>对于实现并发至关重要。系统定义了任务状态（如图中所示的运行、就绪、阻塞、退出 ），并使用 TaskContext（保存了如 ra 返回地址、sp 栈指针以及 s0-s11等被调用者保存寄存器 ）在上下文切换期间保存和恢复任务状态。探讨了多种调度算法：</p>
<p>协作式 FIFO调度：任务会一直运行，直到完成或主动调用 yield_now  放弃 CPU。这与早期单任务操作系统或者一些需要应用明确出让控制权的系统（如早期的 Windows）相似。<br>但是，如果一个任务陷入死循环或长时间不调用 yield_now，其他任务将得不到执行机会，造成系统“假死”。</p>
<p>抢占式轮询 (Round Robin, RR) 调度：为任务分配时间片（如 MAX_TIME_Slice ），当定时器中断发生，发现当前任务时间片耗尽时，调度器可以抢占该任务，并将其移至就绪队列的末尾 。这常见于简单的实时操作系统或分时系统。<br>注意时间片设置过短会导致频繁的上下文切换，增加系统开销；设置过长则会降低系统的响应速度。<br>完全公平调度器 (Completely Fair Scheduler, CFS)：这种抢占式算法使用一个名为 vruntime (虚拟运行时间) 的概念来确定任务优先级 。vruntime 最小的任务将下一个运行，而 vruntime 的值受任务实际运行时间和其 ‘nice’ 值（优先级）的影响 。Linux 当前的默认调度器就是 CFS 的一种实现。</p>
<p>最后是设备交互与文件系统：</p>
<p>设备管理框架 (AllDevices)  为访问不同类型的设备（如块设备、网络设备和显示设备 ）提供统一途径，类似于 Windows 中的设备管理器或 Unix 系统中的 /dev 目录。例如，当需要访问某个 VirtIO 块设备时，上层会通过 AllDevices 查找对应的驱动实例。<br>注意，设备驱动在 probe 阶段（如 probe_bus_devices  或针对 QEMU VirtIO MMIO 的地址范围探测 ）如果未能正确识别硬件或初始化失败，设备将无法使用。我在做题时因为漏了一个参数卡了半天（真半天）</p>
<p>VirtIO 模型被用作设备驱动程序的示例，突出了 vring（一种共享内存环形缓冲区）在客户机和主机之间高效通信以及中断处理方面的应用 。这是一种在虚拟化环境中（如 QEMU ）常用的半虚拟化设备接口。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>大部分题都在这一阶段，print_color更改下宏的定义就可以。hashmap我参考了hashbrown</p>
<p><strong>hashbrown</strong></p>
<p>hashbrown 之所以高效，主要归功于其精妙的SwissTable算法实现，该算法源自 Google。其核心优势在于缓存友好 (cache-friendliness) 和SIMD (Single Instruction, Multiple Data) 指令集的有效利用。</p>
<p>下面是一些核心要点：</p>
<p>开放寻址 (Open Addressing)：与链式哈希表（separate chaining）不同，hashbrown 使用开放寻址策略，将所有条目直接存储在主哈希表数组中。这减少了指针间接寻址带来的开销，并提高了缓存局部性。当发生哈希冲突时，它会探测（probe）数组中的其他位置，直到找到一个空槽。</p>
<p>二次探测：简单易懂，就是遇到冲突后再次探测</p>
<p>元数据与主数据分离存储: hashbrown 将每个槽的元数据（例如哈希值的高位和控制字节）与实际的键值对分开存储。元数据通常更小，可以更紧凑地排列。</p>
<p>SIMD 优化查找: hashbrown 利用 SIMD 指令并行地检查多个元数据槽。它将哈希值的一部分（通常是高7位）存储在控制字节中。在查找、插入或删除操作时，可以加载一组控制字节（例如16个字节），并使用单个 SIMD 指令与目标哈希值的高位进行比较。这极大地加速了匹配过程，尤其是在哈希表密集的情况下。</p>
<p>特殊控制字节 (Special Control Bytes)：控制字节不仅存储部分哈希值，还用于标记槽的状态，例如：</p>
<p>EMPTY: 槽为空。<br>DELETED (或称 TOMBSTONE): 槽之前被占用但现在已删除。这对于开放寻址的正确探测至关重要。<br>FULL: 槽已占用，并存储了部分哈希值。<br>低开销的元数据: 每个条目仅需要1字节的元数据开销（控制字节），这比许多其他哈希表实现要低得多，从而提高了内存效率。</p>
<p>默认使用快速的非加密哈希算法: hashbrown （以及现在 Rust 标准库中的 HashMap）通常默认使用像 FxHash 或类似的快速非加密哈希算法。这类哈希算法对于整数等简单键类型非常快，但可能不适用于需要抵抗哈希洪水攻击 (HashDoS) 的场景。</p>
<p><strong>bump内存算法</strong><br>这里我们的bump_allocator是一个双端分配器，一边是零散的小字节分配，一边是整页分配。只要注意好内存检查（插入内存有没有侵入已分配的这端的，以及<br>如果分配的特别多会不会影响到另一端的），然后两个标记指明当前内存分配位置即可。</p>
<h3 id="Monolithic-Kernel宏内核"><a href="#Monolithic-Kernel宏内核" class="headerlink" title="Monolithic Kernel宏内核"></a>Monolithic Kernel宏内核</h3><h4 id="课堂-1"><a href="#课堂-1" class="headerlink" title="课堂"></a>课堂</h4><p><strong>异构内核扩展</strong></p>
<p>核心目标是在保证可扩展性和高性能的前提下，让不同内核架构（如Unikernel、宏内核、Hypervisor）能够复用核心组件（称为”Backbone”）和系统服务 。</p>
<p>任务（Task）单元的扩展 是关键，因为任务是内核资源的集合体 。Unikernel的任务可能仅包含基本的上下文信息，而宏内核任务需要页表信息和文件描述符，Hypervisor任务则需要VCPU状态等 。<br>为了优雅地处理这些差异，而不直接修改核心Task结构（这会降低可读性和异构扩展性 ），或者避免像旧版Starry那样通过TaskID索引外部结构（这会带来性能开销 ），ArceOS引入了 extension域机制 。<br>这类似于在C语言结构体中预留一个void*指针，具体类型由使用者定义。具体做法是在Task结构中增加一个extension指针，外部模块可以预先定义好特定于某种内核模式的扩展对象（例如，宏内核的进程控制块），<br>然后在创建任务时在堆上分配内存给这个扩展对象，并将extension指针指向它 。这样，访问扩展域的开销接近于普通结构体成员访存，同时保证了不同内核模式按需扩展的灵活性 。<br>例如，宏内核的扩展可以包含指向其独立地址空间（页表）的引用和文件描述符表。未来的工作甚至设想了扩展的泛型化，使得不同类型的任务（Unikernel任务、宏内核进程、自定义任务）<br>可以携带不同的扩展，并在同一套调度、文件系统、网络框架下运行，例如在众核处理器上，某些核心运行Unikernel任务进行高性能计算，另一些核心运行宏内核任务负责管理和交互 。</p>
<p>系统服务的复用 也是一个重要议题，特别是如何让Unikernel已经提供的服务（如文件描述符表 Fd_table、虚拟内存管理、API处理器）方便地被其他架构（如宏内核）复用 。<br>挑战在于资源的隔离与共享：Unikernel中资源通常是全局唯一的，而宏内核中资源则归属于进程，并通过clone等机制控制共享 。<br>一个具体的复用目标是arceos_posix_api，它原本为Unikernel提供POSIX接口适配，但在宏内核场景下，可以直接复用其复杂的语义检查逻辑作为SYSCALL层的一部分，而无需为宏内核重新实现一套，从而减少冗余和开发精力 。<br>为了实现这种复用，引入了Resource（定义资源，使用Arc指针管理以支持共享）和NameSpace（保存所有Resource的集合）的概念 。对于Unikernel，NameSpace是全局唯一的；对于宏内核，每个任务（进程）拥有一份NameSpace，可以动态分配 。<br>Global namespace的布局可以在编译期通过link_section将所有全局Resource集中在特定段（如axns_resource段）来确定 。<br>当宏内核需要独有的NameSpace时，可以在堆上分配空间并将全局NameSpace拷贝过去；需要共享时，则利用Arc指针指向全局或父进程的Resource，<br>这样修改对共享的线程间可见，同时避免了不必要的拷贝开销 。这种设计使得新功能（如新的系统调用或资源类型）更容易接入，并与组件化思想联动。</p>
<p>总结来说，面对未来多样化的应用场景（如智能家居中需要高性能Unikernel的边缘节点和需要安全性的微内核或宏内核的控制中枢 ），组件化为异构内核的快速构建提供了有力支持，<br>它通过Unikernel基座和精心设计的扩展机制（如Task extension和Namespace），在最大化组件复用和灵活性的同时，兼顾了不同内核模式的特性需求 。<br><strong>宏内核演进</strong></p>
<p>核心在于引入用户特权级、独立的用户地址空间以及系统调用机制，最终目标是能够直接运行原始的Linux应用程序（二进制）。</p>
<p>从未经修改的Linux应用（通常使用glibc或musl-libc编译）的角度看，它期望运行在一个与内核隔离的用户地址空间，并通过标准的系统调用（syscall）接口与内核交互 。<br>为了实现这种兼容性，组件化宏内核需要在几个层面进行适配：</p>
<p>用户地址空间的创建与管理：与Unikernel共享单一地址空间不同，宏内核为每个用户应用（进程）创建独立的页表和地址空间（AddrSpace对象）。<br>通常，页表的高端部分映射内核空间（所有进程共享），低端部分则映射独立的用户应用空间 。这意味着加载应用时，<br>内核会将ELF文件的代码段和数据段加载到用户地址空间的预定虚拟地址 。</p>
<p>ELF格式应用的加载：大多数应用编译为ELF格式。内核需要解析ELF头获取入口点（Entry point）以及各个段（Segment）的信息，<br>特别是类型为LOAD的段（代码段和数据段）。需要注意，ELF文件中段的偏移（Offset）和文件大小（FileSiz）可能与加载到内存后的虚拟地址（VirtAddr）<br>和内存大小（MemSiz）不同，尤其是BSS段（未初始化数据段），它在ELF文件中不占空间，但加载时需要在内存中预留并清零 。</p>
<p>用户栈的初始化：Linux应用（尤其是使用标准C库的应用）的main函数执行前，C库的启动代码会检查用户栈上的参数，如argc（参数个数）、<br>argv（参数指针数组）和envp（环境变量指针数组），甚至auxv（辅助向量）。因此，内核在切换到用户态执行应用首条指令前，<br>必须在用户栈上按照约定的布局准备好这些信息，并正确设置用户栈指针（SP寄存器）。<br>特权级切换与系统调用处理：应用通过特定的指令（如RISC-V的ecall ）陷入内核态发起系统调用。内核需要在异常处理流程中识别出系统调用，<br>并根据调用号分发到相应的处理函数 。例如，示例m_3_0中涉及的set_tid_address (96), ioctl (29), writev (66), exit_group (94)等都是具体的系统调用 。<br>对于从内核态首次启动用户任务，由于多数架构没有直接的“切换到用户态”指令，一种常见的做法是在内核态伪造一个来自用户态的异常上下文现场（包括用户态的PC、SP、状态寄存器等），<br>然后通过异常返回指令（如RISC-V的sret）“返回”到用户态开始执行应用 。</p>
<p>任务属性扩展：为了在复用Unikernel调度机制的同时支持宏内核的进程概念，TaskInner结构通过ext成员进行了扩展 。<br>这个ext可以是一个空结构体（对于Unikernel），也可以是一个包含进程特有信息（如指向其用户地址空间AddrSpace的引用、进程ID等）的结构体（对于宏内核）。<br>这使得调度器只关注通用的任务属性，而将资源管理等模式相关的特性封装在扩展中 。</p>
<p>为了支持更高级的内存管理特性，如 缺页加载（Lazy Loading）和内存映射（mmap），内核需要处理页错误（Page Fault）异常 。<br>当应用访问一个尚未建立有效物理映射的虚拟地址时（例如，通过init_user_stack(&amp;mut uspace, false)设置用户栈为Lazy映射 ），会触发页错误。<br>内核的页错误处理函数（如handle_page_fault）会介入，它通常会查找该虚拟地址所属的MemoryArea（内存区域）。每个MemoryArea关联一个Backend，<br>负责具体的映射操作 。Backend可以有两种主要类型 ：</p>
<p>Linear Backend：用于已存在的、连续的物理内存区域的直接映射，例如设备MMIO或共享内存。</p>
<p>Alloc Backend：用于按需分配物理页帧并建立映射。在缺页异常发生时，Alloc后端会申请物理页帧，然后在页表中补齐映射 。<br>sys_mmap系统调用的实现也与此类似：如果populate参数为true，则立即分配并映射；如果为false，则仅建立空映射，<br>等待后续访问时通过缺页异常来实际分配物理页面 。</p>
<p>此外，为了更好地兼容Linux生态，还需要支持像ProcFS、SysFS这样的 伪文件系统，它们提供内核和进程信息的接口（如/proc）或暴露设备信息（如/sys）。<br>在ArceOS中，这些可以通过axfs_ramfs的实例或专门的axfs_devfs组件来实现 。</p>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><strong>page_fault</strong></p>
<p>缺页相应，这里其实系统里已经有不少实现了，我们只需要获取当前用户空间，然后调用find_free_area和map_alloc就可以了</p>
<p><strong>ramfs_rename</strong></p>
<p>这里首先要修正依赖，让测试依赖本地的axramfs（笑），这里依赖本地的库之后，在dir.rs中添加rename的函数，这里底层是用了BTreeMap来保存<br>已经申请过的文件，然后值对应着在内存中的物理节点。更改BTreeMap就可以了，字符串处理仿照其他实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/24/rcore-study-report-by-mio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/24/rcore-study-report-by-mio/" class="post-title-link" itemprop="url">rcore-study-report-by-mio</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-24 23:48:45" itemprop="dateCreated datePublished" datetime="2025-05-24T23:48:45+00:00">2025-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="rustling-阶段总结"><a href="#rustling-阶段总结" class="headerlink" title="rustling 阶段总结"></a>rustling 阶段总结</h2><p>先来一份 C++ 转 Rust 急救指南（</p>
<h3 id="Mutable-Borrow-amp-take-ownership"><a href="#Mutable-Borrow-amp-take-ownership" class="headerlink" title="/ Mutable Borrow &amp; take ownership"></a>/ Mutable Borrow &amp; take ownership</h3><p>rust 中函数传递参数有三种方式，不可变借用，可变借用以及获取所有权。这三种方式贯穿了 rust 的设计思想。<br>它们的定义对应了 <code>&amp;T, &amp;mut T, T</code> 三种类型。与 C++ 不同，rust 中值传递的默认行为是 <code>move</code> 而非 <code>copy</code>，对于 <code>copy</code> 需要实现 <code>Copy</code> 的 trait。 且类型一旦实现 <code>Copy</code> trait 之后，默认行为就变为 <code>copy</code>。</p>
<h3 id="Borrow-amp"><a href="#Borrow-amp" class="headerlink" title="Borrow &amp;"></a>Borrow &amp;</h3><p>rust 中的 <code>&amp;T</code> 应等同于 C++ 中的指针，只是 rust 对于 <code>&amp;T</code> 实现了隐式 <code>Deref</code>，在大部分情况下避免了显式 <code>* / &amp;</code>。<br>迭代器有三种类型：<code>iter(), iter_mut(), into_iter()</code>，分别对应了 <code>&amp;T, &amp;mut T, T</code> 三种类型。</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>rust 中迭代器的成员函数被分为两类，<strong>Non-Consuming Adaptors</strong> 返回对应的迭代器，是惰性的，<strong>Consuming Adaptors</strong> 返回结果，会消耗迭代器的所有权，在使用后无法再次使用该迭代器。</p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p><code>[]</code> 应返回 <code>&amp;T</code> 或 <code>&amp;mut T</code>，不应获取所有权，这是为了避免通过 index 访问而隐式获得所有权的情况。</p>
<h3 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a>Deref</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Deref</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span>: ?<span class="built_in">Sized</span>;  <span class="comment">// 关联类型，表示解引用后的目标类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Self::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 rust 中关于 Deref 的定义，通过在 impl 的时候指定相关的类型，就可以无需像泛型定义那样显式指定类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Deref <span class="keyword">for</span> <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = <span class="built_in">str</span>; <span class="comment">// 指定解引用目标为 `str`</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="built_in">str</span>::from_utf8_unchecked(&amp;<span class="keyword">self</span>.as_bytes()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此我们也知道了，对于一个 <code>Deref</code> 实现来说，它所返回的类型是 single 的，并不会出现解引用可以返回不同类型的情况。对 <code>&amp;String</code> 解引用可以得到 <code>&amp;str</code>，是因为 <code>Target = str</code>。<br>正因如此，编译器可以通过 <code>T, U</code> 类型推断这两个类型是否可以通过 <code>Deref</code> 转换。</p>
<h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h3><p><code>Drop::drop()</code> 会在变量离开作用域后由编译器隐式调用，不应显式调用该函数。<br><code>Drop</code> trait 被实现用于回收资源，若需要显式调用，可使用 <code>std::mem::drop(x)</code> 通过消耗 <code>x</code> 的所有权来提前触发析构。</p>
<h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h3><p>在编译时允许同时存在多个可变引用，但运行时仍会检查是否存在多个可变引用，通过 <code>borrow(), borrow_mut()</code> 中的引用计数来实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RefCell</span></span>&lt;T&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">    borrow_count: <span class="built_in">usize</span>,</span><br><span class="line">    is_mut_borrowed: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; RefCell&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">borrow</span></span>(&amp;<span class="keyword">self</span>) -&gt; Ref&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_mut_borrowed &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Already mutably borrowed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.borrow_count += <span class="number">1</span>;</span><br><span class="line">        Ref &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">borrow_mut</span></span>(&amp;<span class="keyword">self</span>) -&gt; RefMut&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.borrow_count &gt; <span class="number">0</span> || <span class="keyword">self</span>.is_mut_borrowed &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Already borrowed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.is_mut_borrowed = <span class="literal">true</span>;</span><br><span class="line">        RefMut &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RefCell&lt;T&gt;</code> 会返回 <code>Ref&lt;T&gt;</code> 或者 <code>RefMut&lt;T&gt;</code>。<code>Ref&lt;T&gt;</code> 的所有权检查发生在运行时，且可以通过 <code>map</code> 来拆分借用，更加灵活。<br>可以通过 <code>RefCell</code> 来实现内部可变性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cache</span></span> &#123;</span><br><span class="line">    data: RefCell&lt;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cache &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_data</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="comment">// 检查缓存</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cache = <span class="keyword">self</span>.data.borrow_mut();</span><br><span class="line">        <span class="keyword">if</span> cache.is_none() &#123;</span><br><span class="line">            *cache = <span class="literal">Some</span>(<span class="string">"Expensive result"</span>.to_string());</span><br><span class="line">        &#125;</span><br><span class="line">        cache.as_ref().unwrap().clone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> cache = Cache &#123; data: RefCell::new(<span class="literal">None</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Data: &#123;&#125;"</span>, cache.get_data()); <span class="comment">// 计算并缓存</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Cached: &#123;&#125;"</span>, cache.get_data()); <span class="comment">// 直接读取缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>borrow_mut()</code> 时，由于变量的生命周期与临时值不同，应谨慎与变量进行绑定。</p>
<h3 id="Lifetime"><a href="#Lifetime" class="headerlink" title="Lifetime"></a>Lifetime</h3><p>rust 的临时值会在表达式结束后析构，因此允许存在这样的情况。在 <code>clone2.borrow_mut()</code> 语句执行的时候，<code>clone1.borrow_mut()</code> 已经被析构，所以 <code>borrow_mut()</code> 不会因为引用计数 <code>&gt; 1</code> 而崩溃。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shared_data = Rc::new(RefCell::new(<span class="number">42</span>)); <span class="comment">// 克隆 Rc（共享所有权） </span></span><br><span class="line"><span class="keyword">let</span> clone1 = Rc::clone(&amp;shared_data); </span><br><span class="line"><span class="keyword">let</span> clone2 = Rc::clone(&amp;shared_data);</span><br><span class="line">*clone1.borrow_mut() += <span class="number">10</span>; <span class="comment">// 步骤1：获取可变借用，修改后立即释放</span></span><br><span class="line">*clone2.borrow_mut() *= <span class="number">2</span>;  <span class="comment">// 步骤2：前一个可变借用已释放，安全获取新借用</span></span><br></pre></td></tr></table></figure>
<p>作为对比，如果改成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shared_data = Rc::new(RefCell::new(<span class="number">42</span>)); <span class="comment">// 克隆 Rc（共享所有权） </span></span><br><span class="line"><span class="keyword">let</span> clone1 = Rc::clone(&amp;shared_data); </span><br><span class="line"><span class="keyword">let</span> clone2 = Rc::clone(&amp;shared_data);</span><br><span class="line"><span class="keyword">let</span> longer_lifetime = clone1.borrow_mut();</span><br><span class="line">*longer_lifetime += <span class="number">10</span>; </span><br><span class="line">*clone2.borrow_mut() *= <span class="number">2</span>;  <span class="comment">// 前一个可变借用未释放，程序崩溃</span></span><br></pre></td></tr></table></figure>
<p>就无法正常运行，因为 <code>longer_lifetime</code> 作为 <code>RefCell</code> 和 <code>NLL</code> 的交互，其行为表现为它的生命周期持续到该作用域结束。</p>
<h3 id="Non-Lexical-Lifetime"><a href="#Non-Lexical-Lifetime" class="headerlink" title="Non-Lexical Lifetime"></a>Non-Lexical Lifetime</h3><p>Non-Lexical Lifetimes (NLL) 是 Rust 编译器的一项核心特性，通过更精细的生命周期分析，允许变量在其<strong>最后一次使用后</strong>立即释放（而非必须等到词法作用域结束），但与某些类型的交互具有其他的表现。</p>
<h3 id="Copy-amp-Clone"><a href="#Copy-amp-Clone" class="headerlink" title="Copy &amp; Clone"></a>Copy &amp; Clone</h3><p><code>Copy</code> trait 是面向编译器实现的，<code>Clone</code> trait 是面向程序员实现的。一旦实现 <code>Copy</code> trait 默认行为将变为 <code>copy</code> 而非 <code>move</code>。在语义上，如果实现了 <code>Copy</code>，实现的 <code>Clone</code> 应当与之相容，可以通过调用 <code>[#derived(Copy, Clone)]</code> 获取默认实现。<br>并没有对于 <code>Clone</code> trait 实现的硬性约束。</p>
<p>这些是我觉得印象比较深刻的点，除此之外感觉似乎不太难。rust 唯一能折磨我的数据结构只有 <code>Box&lt;T&gt;</code>，但归根到底还是没有完全学会语言底层逻辑，没有完全学会用 rust 的方式写代码。</p>
<h2 id="rcore-阶段总结"><a href="#rcore-阶段总结" class="headerlink" title="rcore 阶段总结"></a>rcore 阶段总结</h2><p>进入到这个阶段之后意识到，之前学的 xv6 还是有些太玩具了，尽管 rcore-os 也是一个教学用途的操作系统，但它的深度似乎是远大于 xv6 的，你可以在这里面接触到链接器是如何编写的，如何用自己的一套交叉编译工具链来编译并且运行 kernel 以及裸机程序。</p>
<p>Chapter1 给我的印象很深刻，上来就告诉我们要写一个裸机程序，要抛弃 std 库，但彼时的我还是连 rustling 都没有写明白的完全的 rust 萌新，看到这些东西未免觉得有些难以下手，好在 rcore-os 提供的简明 Tutorial 十分清晰，静下心来读基本上没有不理解的地方。</p>
<p>整个 rcore 阶段最困扰我也是让我思考了最久的一个问题：</p>
<blockquote>
<p>为什么一个物理页不会同时被分配为页表和供内存使用？</p>
</blockquote>
<p>因为在创建页表的过程中会使用 <code>PageTable.map()</code>，该函数会调用 <code>PageTable().find_pte_create()</code>，在这一创建多层页表的过程中会使用 <code>frame_alloc()</code>。<br>而在分配内存的部分，<code>MemorySet</code> 的 <code>Framed</code> 映射会调用 <code>frame_alloc()</code> 分配新的物理页供其使用，这是除了创建页表之外我们唯一能使用到 <code>[ekernel, MEMORY_END)</code> 这段内存的部分。<br>而在 <code>MemorySet</code> 里，主要是 <code>KERNEL_SPACE</code> 会产生一个恒等映射 <code>[ekernel, MEMORY_END)</code>。这部分恒等映射被用于寻找页表。<br>即使开启虚拟内存映射后，我们在 <code>PhysPageNum.get_pte_array()</code> 处也可以直接将 <code>pa</code> 转为 <code>*mut PageTableEntry</code>，就是因为此处的恒等映射会直接将 <code>pa</code> 对应的虚拟地址映射为物理地址。</p>
<p>我觉得愿意去弄明白这些，不给自己留有太多的疑惑，这个阶段的收获基本是不小的。</p>
<p>rcore-os 阶段让我印象最深刻的 lab 还是 filesystem 相关的部分，要求我们试着给文件维护一个引用计数。这个引用计数维护起来并不困难，但对于这样持久化的数据来说，在什么抽象层来维护十分重要，如果在视图层维护，那么是无法维护的。具体来说 <code>OSInode</code> 和 <code>Inode</code> 便是对于 <code>DiskInode</code> 的视图，而看明白这一点，需要对整个代码的结构有比较好的了解。</p>
<h2 id="arceos-阶段总结"><a href="#arceos-阶段总结" class="headerlink" title="arceos 阶段总结"></a>arceos 阶段总结</h2><p>这个阶段是我过的比较急的一个阶段。但其实这个阶段的代码质量远高于 rcore-os 阶段，因为是接近工业级别的代码，解耦合等各种设计思想也能学到不少。</p>
<p>lab2 的实现 HashMap 是我耗时最长的一个 lab，因为对于 Box<T> 的特性不太熟悉，而且在不可变引用迭代器中，又很容易涉及到 second borrow 的问题。</p>
<p>感觉这个阶段的 lab 都是很贴近实际工程环境的 lab，但难度相较于 rcore-os 阶段来说其实下降了一些，因为通过 demo 并不要求效率，也不考虑 corner case。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blog/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/76/">76</a><a class="extend next" rel="next" href="/blog/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
