<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/23/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/23/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">635</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">564</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/05/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-Zoneshiyi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/05/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-Zoneshiyi/" class="post-title-link" itemprop="url">2024秋冬季训练营第二阶段总结-Zoneshiyi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-05 13:30:37" itemprop="dateCreated datePublished" datetime="2024-11-05T13:30:37+00:00">2024-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rCore"><a href="#rCore" class="headerlink" title="rCore"></a>rCore</h1><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p><strong>目标三元组</strong></p>
<p>目标三元组 (Target Triplet) 描述了目标平台的 CPU 指令集、操作系统类型和标准运行时库。</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code>：CPU 架构是 x86_64，CPU 厂商是 unknown，操作系统是 linux，运行时库是 gnu libc。</li>
<li><code>riscv64gc-unknown-none-elf</code>：CPU 架构是 riscv64gc，厂商是 unknown，无操作系统， elf 表示没有标准的运行时库。没有任何系统调用的封装支持，但可以生成 ELF 格式的执行程序。</li>
</ul>
<p>通过cargo配置文件指定目标平台。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># os/.cargo/config</span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">"riscv64gc-unknown-none-elf"</span></span><br></pre></td></tr></table></figure>

<p><strong>移除std依赖</strong></p>
<p>RUST默认使用了标准库std，std提供了许多高级功能，如文件系统访问、线程、网络等，这些功能依赖于操作系统的支持。因此，std只能在支持这些功能的平台上使用。对于不支持操作系统功能的平台（如裸机编程或嵌入式系统），需要显式指定使用core。core是std的一个子集，不依赖于操作系统，提供了Rust语言的核心功能。</p>
<ul>
<li><code>#![no_std]</code>：告诉 Rust 编译器不使用 Rust 标准库 std。</li>
<li><code>#![no_main]</code>：告诉编译器我们没有一般意义上的 main 函数， 并将原来的 main 函数删除。这样编译器也就不需要考虑初始化工作了。</li>
</ul>
<p><strong>panic_handler</strong></p>
<p>Rust编译器在编译程序时，处于安全性考虑，要求有 panic! 宏的具体实现。</p>
<p><code>#[panic_handler]</code> 是一种编译指导属性，用于标记核心库core中的 panic! 宏要对接的函数（该函数实现对致命错误的具体处理）。该编译指导属性所标记的函数需要具有 <code>fn(&amp;PanicInfo) -&gt; !</code> 函数签名，函数可通过 PanicInfo 数据结构获取致命错误的相关信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结合汇编代码</strong></p>
<p>在裸机编程或嵌入式系统开发中，通常需要定义一个自定义的入口点函数。在Rust中，这个入口点函数通常被命名为_start。</p>
<p>在 fn 关键字之前增加 extern 关键字可以用来导入外部符号。<br>#[no_mangle] 注解来告诉 Rust 编译器不要 mangle 此函数的名称。Mangling 发生于当编译器将我们指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读。每一个编程语言的编译器都会以稍微不同的方式 mangle 函数名，所以为了使 Rust 函数能在汇编代码中使用，必须禁用 Rust 编译器的 name mangling。</p>
<p><strong>Qemu启动流程</strong></p>
<ol>
<li>将必要文件载入Qemu模拟的物理内存后，PC被初始化为0x1000。然后执行一段指令后跳转到0x80000000。</li>
<li>运行位于0x80000000的bootloader（这里使用的是rustsbi-qemu.bin），RustSBI将下一阶段的入口地址设置为0x80200000。</li>
<li>运行0x80200000开始的程序。</li>
</ol>
<p><strong>调整内核的内存布局</strong></p>
<p>链接器默认的内存布局并不能符合我们的要求，为了实现与 Qemu 正确对接，我们可以通过链接脚本(Linker Script)调整链接器的行为。</p>
<p>首先通过cargo配置文件指定链接脚本：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// os/.cargo/config</span><br><span class="line">...</span><br><span class="line"><span class="section">[target.riscv64gc-unknown-none-elf]</span></span><br><span class="line"><span class="attr">rustflags</span> = [</span><br><span class="line">    <span class="string">"-Clink-arg=-Tsrc/linker.ld"</span>, <span class="string">"-Cforce-frame-pointers=yes"</span></span><br><span class="line">    <span class="comment"># 强制打开 fp 选项，避免 fp 相关指令被编译器优化掉</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在链接脚本中指定起始地址为0x80200000，：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">BASE_ADDRESS &#x3D; 0x80200000;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . &#x3D; BASE_ADDRESS;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>elf文件中除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。需要通过<code>rust-objcopy --strip-all</code>丢弃这些元数据。</p>
<p><strong>函数调用栈</strong></p>
<p><img src="/blog/.io//StackFrame.png" alt></p>
<h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><p>配置环境一章给了 GDB 预编译二进制的下载链接，但版本不支持Python脚本。为了提高调试效率，需要自己编译新版本的 GDB。</p>
<p>查看汇编代码发现在rust_main函数中找不到对trap::init函数的调用，初始化CSR stvec的代码被直接内联汇编到了rust_main中。（相比与C语言，要将RUST源码与对应的汇编代码对应起来的难度明显更大，也可能是因为目前对RUST的机制还不太熟悉）</p>
<p><code>#[link_section = &quot;.text.entry&quot;]</code>宏将编译后的汇编代码放在名为 .text.entry 的代码段中， 供链接脚本使用。</p>
<p><code>#![feature(linkage)]</code>启用弱链接特性</p>
<p><code>#[linkage = &quot;weak&quot;]</code>在有多个同名符号时优先使用其他符号</p>
<p><strong>将应用程序链接到内核</strong></p>
<p>在本章中，通过<code>global_asm!(include_str!(&quot;link_app.S&quot;));</code>将应用程序的二进制镜像文件作为内核的数据段链接到内核里面。</p>
<p><strong>UPSafeCell</strong></p>
<p>有一些变量（例如本章中的APP_MANAGER）需要作为全局变量使用，但有需要在运行时修改部分成员变量。我们为这些变量将RefCell封装成了UPSafeCell，并为UPSafeCell添加了Sync标记，从而允许我们在<strong><em>单核</em></strong>上安全使用可变全局变量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/sync/up.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">UPSafeCell</span></span>&lt;T&gt; &#123;</span><br><span class="line">    inner: RefCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> UPSafeCell&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lazy_static!</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> APP_MANAGER: UPSafeCell&lt;AppManager&gt; = <span class="keyword">unsafe</span> &#123; UPSafeCell::new(&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手动实现全局变量初始化有诸多不便之处，比如需要把这种全局变量声明为 <code>static mut</code> 并衍生出很多 unsafe 代码。在这里借助lazy_static!宏来简化代码。</p>
<p><strong>刷新指令缓存（i-cache）</strong></p>
<p> OS 在加载完应用代码后必须使用取指屏障指令 <code>fence.i</code> ，它的功能是保证 <strong>在它之后的取指过程必须能够看到在它之前的所有对于取指内存区域的修改</strong> ，这样才能保证 CPU 访问的应用代码是最新的而不是 i-cache 中过时的内容。</p>
<p><strong>特权级切换</strong></p>
<p>RISC-V 提供了新的机器指令：执行环境调用指令（Execution Environment Call，简称 <code>ecall</code> ）和一类执行环境返回（Execution Environment Return，简称 <code>eret</code> ）指令。其中：</p>
<ul>
<li><code>ecall</code> 具有<strong>用户态到内核态</strong>的执行环境切换能力的函数调用指令；</li>
<li><code>sret</code> ：具有<strong>内核态到用户态</strong>（从Superivisor模式返回）的执行环境切换能力的函数返回指令。</li>
</ul>
<p>操作系统需要负责特权级切换时的上下文保存和恢复。</p>
<p>相关的控制状态寄存器：</p>
<ul>
<li>sstatus：<code>SPP</code>等字段给出切换前的特权级等信息</li>
<li>sepc：当Trap是异常时，记录Trap发生前的最后一条指令地址</li>
<li>scause：Trap原因</li>
<li>stval：Tral附加信息</li>
<li>stvec：Trap处理代码的入口地址</li>
</ul>
<p>当 CPU 执行完一条指令并准备从用户特权级 陷入（ Trap ）到 S 特权级的时候，硬件会自动完成如下这些事情：</p>
<ul>
<li>sstatus 的 SPP 字段会被修改为 CPU 当前的特权级（U/S）。</li>
<li>sepc 会被修改为Trap发生前的最后一条指令地址</li>
<li>scause/stval 分别会被修改成这次 Trap 的原因以及相关的附加信息。</li>
<li>CPU 会跳转到 stvec 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。</li>
</ul>
<p><strong>Trap上下文</strong></p>
<p>与函数调用类似，在处理Trap之前，需要在某些地方（由操作系统决定）保存必要的寄存器，并在Trap处理结束后恢复这些寄存器。</p>
<p>Trap发生时需要保存的内容：</p>
<ul>
<li>32个通用寄存器的值（部分寄存器如x0可以不作保存，预留空间主要是为了方便后续编码）</li>
<li>sstatus</li>
<li>sepc<br>  scause/stval 的情况是：它总是在 Trap 处理的第一时间就被使用或者是在其他地方保存下来了，因此它没有被修改并造成不良影响的风险。</li>
</ul>
<p><strong>Trap处理流程</strong></p>
<ol>
<li>通过__alltraps保存Trap上下文到内核栈上</li>
<li>跳转到trap_handler处理Trap</li>
<li>通过__restore恢复上下文</li>
<li>sret返回</li>
</ol>
<p>思考：sscratch 是何时被设置为内核栈顶的？<br>在第一次执行<strong>restore时，通过a0传入的参数实际是<code>(KERNEL_STACK.get_sp() - core::mem::size_of::&lt;TrapContext&gt;()) as *mut TrapContext;</code>，并将a0的值赋给了sp。在</strong>restore返回之前，先将sp+34*8即TrapContext的大小，然后交换sp和sscratch，从而设置为内核栈顶。</p>
<p>KERNEL_STACK栈顶的TrapContext中，x[1](ra)存储了第一个程序的入口地址,x[2](sp)存储了用户栈顶地址，在__restore执行过程中分别被加载到ra和sp寄存器中，因此当sret返回时就会进入用户态执行第一个程序。</p>
<h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><p><img src="/blog/.io//time-task-multiprog-os-detail.png" alt></p>
<p>把应用程序的一次执行过程（也是一段控制流）称为一个 <strong>任务</strong> ，把应用执行过程中的一个时间片段上的执行片段或空闲片段称为 “ <strong>计算任务片</strong> ” 或“ <strong>空闲任务片</strong> ” 。当应用程序的所有任务片都完成后，应用程序的一次任务也就完成了。从一个程序的任务切换到另外一个程序的任务称为 <strong>任务切换</strong> 。</p>
<p>Task切换与Trap切换主要有以下异同：</p>
<ul>
<li>与 Trap 切换不同，它不涉及特权级切换；</li>
<li>与 Trap 切换不同，它的<strong>一部分是由编译器完成</strong>的（可以看作编译时插入额外的汇编代码）；</li>
<li>与 Trap 切换相同，它对应用是透明的。</li>
</ul>
<p><strong>Task上下文</strong></p>
<p>Task切换时需要手动保存的内容：</p>
<ul>
<li>s0~s11</li>
<li>ra</li>
<li>sp</li>
</ul>
<p><strong>Task处理流程</strong></p>
<ol>
<li>保存当前Task上下文</li>
<li>加载下一个Task上下文</li>
<li>ret返回</li>
</ol>
<p>每个任务的TaskContext中，保存的ra初始值都是<code>__restore</code>，因此在第一次通过<code>__switch</code>切换到该任务时，都会跳转到<code>__restore</code>，然后从该任务对应的初始TrapContext中读取程序入口(载入spec寄存器)，从而开始运行。</p>
<p>相比于Chapter 2，这里的<code>__restore</code>中不需要<code>mv sp, a0</code>，因为在<code>__switch</code>之后，CPU从TaskContext中读取对应内核栈的栈顶地址，并加载到了sp寄存器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"><span class="keyword">impl</span> TaskManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">run_next_task</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(next) = <span class="keyword">self</span>.find_next_task() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">            <span class="keyword">let</span> current = inner.current_task;</span><br><span class="line">            inner.tasks[next].task_status = TaskStatus::Running;</span><br><span class="line">            inner.current_task = next;</span><br><span class="line">            <span class="keyword">let</span> current_task_cx_ptr = &amp;<span class="keyword">mut</span> inner.tasks[current].task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">            <span class="keyword">let</span> next_task_cx_ptr = &amp;inner.tasks[next].task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">            <span class="built_in">drop</span>(inner);</span><br><span class="line">            <span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                __switch(</span><br><span class="line">                    current_task_cx_ptr,</span><br><span class="line">                    next_task_cx_ptr,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// go back to user mode</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"All applications completed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在run_netx_task中，需要手动在<code>__switch</code>前drop获取的TaskManagerInner实例（实际上是通过RefCell的borrow_mut方法获取的TASK_MANAGER.inner的可变借用）。</p>
<p>因为编译器帮我们自动插入的drop会位于作用域的尾部，而在此之前我们就通过<code>__switch</code>切换到了其他任务的执行流中，而在处理其他任务时也可能需要获取TASK_MANAGER.inner的可变借用，因此需要提前调用drop。</p>
<p><strong>中断</strong></p>
<p>当中断产生并进入某个特权级之后，在中断处理的过程中<strong>同特权级的中断都会被屏蔽。</strong></p>
<h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><p><strong>资源获取即初始化</strong> (RAII, Resource Acquisition Is Initialization，指将一个使用前必须获取的资源的生命周期绑定到一个变量上，变量释放时，对应的资源也一并释放。) </p>
<p><img src="/blog/.io//rust-containers.png" alt></p>
<p><code>alloc</code> 库需要提供给它一个 <code>全局的动态内存分配器</code> 来管理堆空间，从而使得与堆相关的智能指针或容器数据结构可以正常工作。动态内存分配器需要实现它提供的 <code>GlobalAlloc</code> Trait，这个 Trait 有两个必须实现的抽象接口：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc::alloc::GlobalAlloc</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, layout: Layout) -&gt; *<span class="keyword">mut</span> <span class="built_in">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">self</span>, ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span>, layout: Layout);</span><br></pre></td></tr></table></figure>

<p>然后只需将我们的动态内存分配器类型<strong>实例化为一个全局变量</strong>，并使用 <code>#[global_allocator]</code> 语义项标记即可。由于该分配器的实现比较复杂，我们这里直接使用一个已有的伙伴分配器(buddy_system_allocator)实现。<code>#[alloc_error_handler]</code>标识内存分配失败时的处理函数。</p>
<p><strong>分页内存管理</strong></p>
<ul>
<li>可用的物理内存被分为若干个（物理）<strong>页帧（Frame）</strong>，用<strong>物理页号 (PPN, Physical Page Number)</strong>标识</li>
<li>每个应用的地址空间可以被分成若干个（虚拟） <strong>页面 (Page)</strong> ，用 <strong>虚拟页号 (VPN, Virtual Page Number)</strong> 标识</li>
<li>根据VPN可以在<strong>页表（Page Table）</strong>中查询到<strong>页表项 (PTE, Page Table Entry)</strong>，satp寄存器记录了当前所用的一级页表的物理页</li>
<li>PTE记录了对应的PPN和相关的控制信息</li>
<li>手动修改PTE后，需要使用 sfence.vma 指令刷新整个 TLB。注：可以在 sfence.vma 指令后面加上一个虚拟地址，这样 sfence.vma 只会刷新TLB中关于这个虚拟地址的单个映射项。</li>
</ul>
<p><strong>物理页帧管理</strong></p>
<p>栈式物理页帧管理策略</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackFrameAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,  <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    end: <span class="built_in">usize</span>,      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>物理页帧的生命周期绑定的一个<code>FrameTracker</code>实例上</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameTracker</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> FrameTracker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        frame_dealloc(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些 <code>FrameTracker</code> 的生命周期进一步绑定到 <code>PageTable</code> 下面。当 <code>PageTable</code> 生命周期结束后，向量 <code>frames</code> 里面的那些 <code>FrameTracker</code> 也会被回收，也就意味着存放多级页表节点的那些物理页帧被回收了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTable</span></span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="built_in">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PageTable提供了<code>from_token</code> 方法可以临时创建一个专用来手动查页表的 <code>PageTable</code> ，它仅有一个从传入的 <code>satp</code> token 中得到的多级页表根节点的物理页号，它的 <code>frames</code> 字段为空，也即不实际控制任何资源。from_token创建的PageTable<strong>不能用来修改地址映射</strong>。</p>
<p><strong>地址空间</strong></p>
<p> <code>PageTable</code> 下挂着所有多级页表的节点所在的物理页帧，而每个 <code>MapArea</code> 下则挂着对应逻辑段中的数据所在的物理页帧，这两部分合在一起构成了一个地址空间所需的所有物理页帧。这同样是一种 RAII 风格，当一个地址空间 <code>MemorySet</code> 生命周期结束后，这些物理页帧都会被回收。</p>
<p>Frame-&gt;FrameTracker-&gt;PageTable/MapArea-&gt;MemorySet</p>
<p>应用地址空间：</p>
<p><img src="/blog/.io//app-as-full.png" alt></p>
<p>跳板（<strong>Trapmpoline</strong>）和TrapContext位于用户栈栈顶，但是并不包含U标志位，只在地址空间切换时才会用到。因为有了分支机制，在Trap上下文保存和恢复时需要同时完成<strong>换栈和换页表</strong>。</p>
<p>在内核代码和应用代码看来，trap.S中的汇编代码都放在最高虚拟页面中（也就是Trapmpoline中），因此进入trap处理流程时CPU指令能够连续执行。</p>
<h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><p><strong>fork</strong></p>
<p>实现fork时，需要复制父进程的当前状态创建新的TaskControlBlock，主要是复制进程空间、栈和寄存器数据。</p>
<p><strong>exec</strong></p>
<p>实现exec时，直接在当前进程的TaskControlBlock上进行修改。对于系统调用 sys_exec 来说，一旦调用它之后， trap_handler 原来上下文中的 cx 失效了——因为它是用来访问之前地址空间中 Trap 上下文被保存在的那个物理页帧的，而现在它已经被回收掉了。</p>
<p><strong>spawn</strong></p>
<p>实现spawn时，与fork类似的是创建了新的TaskControlBlock，但没有复制父进程的当前状态，而是类似exec从elf文件中读取信息来创建地址空间。</p>
<h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><p><strong>块与扇区</strong></p>
<p>扇区 (Sector) 是块设备随机读写的数据单位，通常每个扇区为 512 字节。而块是文件系统存储文件时的数据单位，每个块的大小等同于一个或多个扇区。Linux的Ext4文件系统的单个块大小默认为 4096 字节。在 easy-fs 实现中一个块和一个扇区同为 512 字节。</p>
<p><strong>块缓存</strong></p>
<ul>
<li>位于内存中的缓冲区</li>
<li>内存中同时只能驻留有限个磁盘块的映射</li>
<li>需要写回磁盘才能真正修改持久性存储的数据</li>
</ul>
<p><strong>easy-fs磁盘布局</strong></p>
<p><img src="/blog/.io//%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.png" alt></p>
<ul>
<li><p>超级块 (Super Block)在内存中对应数据结构SuperBlock，SuperBlock与磁盘上的数据结构一致，没有额外的元数据。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span></span> &#123;</span><br><span class="line">    magic: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="comment">// 文件系统的总块数，包括非数据块</span></span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="comment">// 索引节点位图区域占据的块数</span></span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引节点位图和数据块位图在内存中对应数据结构Bitmap，但Bitmap本是只存储了相关的元数据，即位图的<strong>起始块编号</strong>以及<strong>占据的块数</strong>。实际磁盘上的数据载入到内存中的BitmapBlock实例中。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/bitmap.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitmap</span></span> &#123;</span><br><span class="line">    start_block_id: <span class="built_in">usize</span>,</span><br><span class="line">    blocks: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BitmapBlock</span></span> = [<span class="built_in">u64</span>; <span class="number">64</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引节点在内存中对应数据结构DiskInode，SuperBlock与磁盘上的数据结构一致，没有额外的元数据。索引节点本身存储的是对应文件/目录的元数据，即大小、数据块索引、类型。DiskInode大小为128字节。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据块在内存中对应DataBlock，DataBlock与磁盘上的数据结构一致，没有额外的元数据。数据块中可能是文件的数据，也可能是目录项DirEntry。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">DataBlock</span></span> = [<span class="built_in">u8</span>; BLOCK_SZ];</span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DirEntry</span></span> &#123;</span><br><span class="line">    name: [<span class="built_in">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>],</span><br><span class="line">    inode_number: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  Inode 是放在内存中的记录文件索引节点信息的数据结构。block_id 和 block_offset 记录该 Inode 对应的 DiskInode 保存在磁盘上的具体位置方便我们后续对它进行访问。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="comment">// 偏移量单位是字节</span></span><br><span class="line">    block_offset: <span class="built_in">usize</span>,</span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文件描述符</strong></p>
<p>文件描述符表 (File Descriptor Table) ，其中的每个 文件描述符 (File Descriptor) 代表了一个特定读写属性的I/O资源。</p>
<p>为简化操作系统设计实现，可以让每个进程都带有一个线性的 文件描述符表 ，记录该进程请求内核打开并读写的那些文件集合。而 文件描述符 (File Descriptor) 则是一个非负整数，表示文件描述符表中一个打开的 文件描述符 所处的位置（可理解为数组下标）。</p>
<h2 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h2><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><h3 id="RISC-V-Notes"><a href="#RISC-V-Notes" class="headerlink" title="RISC-V Notes"></a>RISC-V Notes</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>RISC-V 的寄存器集由 32 个通用寄存器和一些特殊寄存器组成。</p>
<p><strong>通用寄存器</strong></p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>x0</td>
<td>zero</td>
<td>常数 0</td>
</tr>
<tr>
<td>x1</td>
<td>ra</td>
<td>返回地址寄存器</td>
</tr>
<tr>
<td>x2</td>
<td>sp</td>
<td>栈指针</td>
</tr>
<tr>
<td>x3</td>
<td>gp</td>
<td>全局指针</td>
</tr>
<tr>
<td>x4</td>
<td>tp</td>
<td>线程指针</td>
</tr>
<tr>
<td>x5</td>
<td>t0</td>
<td>临时寄存器 0</td>
</tr>
<tr>
<td>x6</td>
<td>t1</td>
<td>临时寄存器 1</td>
</tr>
<tr>
<td>x7</td>
<td>t2</td>
<td>临时寄存器 2</td>
</tr>
<tr>
<td>x8</td>
<td>s0/fp</td>
<td>保存寄存器 0 / 帧指针</td>
</tr>
<tr>
<td>x9</td>
<td>s1</td>
<td>保存寄存器 1</td>
</tr>
<tr>
<td>x10</td>
<td>a0</td>
<td>函数参数 / 返回值 0</td>
</tr>
<tr>
<td>x11</td>
<td>a1</td>
<td>函数参数 / 返回值 1</td>
</tr>
<tr>
<td>x12</td>
<td>a2</td>
<td>函数参数 2</td>
</tr>
<tr>
<td>x13</td>
<td>a3</td>
<td>函数参数 3</td>
</tr>
<tr>
<td>x14</td>
<td>a4</td>
<td>函数参数 4</td>
</tr>
<tr>
<td>x15</td>
<td>a5</td>
<td>函数参数 5</td>
</tr>
<tr>
<td>x16</td>
<td>a6</td>
<td>函数参数 6</td>
</tr>
<tr>
<td>x17</td>
<td>a7</td>
<td>函数参数 7</td>
</tr>
<tr>
<td>x18</td>
<td>s2</td>
<td>保存寄存器 2</td>
</tr>
<tr>
<td>x19</td>
<td>s3</td>
<td>保存寄存器 3</td>
</tr>
<tr>
<td>x20</td>
<td>s4</td>
<td>保存寄存器 4</td>
</tr>
<tr>
<td>x21</td>
<td>s5</td>
<td>保存寄存器 5</td>
</tr>
<tr>
<td>x22</td>
<td>s6</td>
<td>保存寄存器 6</td>
</tr>
<tr>
<td>x23</td>
<td>s7</td>
<td>保存寄存器 7</td>
</tr>
<tr>
<td>x24</td>
<td>s8</td>
<td>保存寄存器 8</td>
</tr>
<tr>
<td>x25</td>
<td>s9</td>
<td>保存寄存器 9</td>
</tr>
<tr>
<td>x26</td>
<td>s10</td>
<td>保存寄存器 10</td>
</tr>
<tr>
<td>x27</td>
<td>s11</td>
<td>保存寄存器 11</td>
</tr>
<tr>
<td>x28</td>
<td>t3</td>
<td>临时寄存器 3</td>
</tr>
<tr>
<td>x29</td>
<td>t4</td>
<td>临时寄存器 4</td>
</tr>
<tr>
<td>x30</td>
<td>t5</td>
<td>临时寄存器 5</td>
</tr>
<tr>
<td>x31</td>
<td>t6</td>
<td>临时寄存器 6</td>
</tr>
</tbody></table>
<p><strong>特殊寄存器</strong></p>
<ul>
<li>PC（程序计数器）：保存当前执行指令的地址。</li>
<li>CSR（控制和状态寄存器）：用于存储控制和状态信息，如异常处理、性能计数等。</li>
</ul>
<p><strong>寄存器分类</strong></p>
<ul>
<li>零寄存器（x0）：始终为零。</li>
<li>返回地址寄存器（ra）：用于保存函数返回地址。</li>
<li>栈指针寄存器（sp）：指向当前栈顶。</li>
<li>全局指针寄存器（gp）：指向全局变量区域。</li>
<li>线程指针寄存器（tp）：指向线程本地存储。</li>
<li>临时寄存器（t0-t6）：用于临时数据存储，不需要在函数调用间保存。</li>
<li>保存寄存器（s0-s11）：需要在函数调用间保存的数据。</li>
<li>函数参数寄存器（a0-a7）：用于传递函数参数和返回值。</li>
</ul>
<p><strong>C语言调用规范</strong></p>
<ul>
<li>a0<del>a7（ x10</del>x17 ）调用者保存，用来传递输入参数。其中的 a0 和 a1 还用来保存返回值。</li>
<li>t0<del>t6( x5</del>x7,x28~x31 )调用者保存，作为临时寄存器使用，在被调函数中可以随意使用无需保存。</li>
<li>s0<del>s11( x8</del>x9,x18~x27 )被调用者保存，作为临时寄存器使用，被调函数保存后才能在被调函数中使用。</li>
<li>ra( x1 ) 是被调用者保存的。</li>
<li>sp( x2 ) 是被调用者保存的。这个是之后就会提到的栈指针 (Stack Pointer) 寄存器，它指向下一个将要被存储的栈顶位置。</li>
<li>fp( s0 )，它既可作为s0临时寄存器，也可作为栈帧指针（Frame Pointer）寄存器，表示当前栈帧的起始位置，是一个被调用者保存寄存器。fp 指向的栈帧起始位置 和 sp 指向的栈帧的当前栈顶位置形成了所对应函数栈帧的空间范围。</li>
<li>gp( x3 ) 和 tp( x4 ) 在一个程序运行期间都不会变化，因此不必放在函数调用上下文中。</li>
</ul>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li>Load Immediate: li x16, 0</li>
<li>Load Address: la rd, symbol</li>
<li>Store Word: sw value, dst_addr</li>
<li>Wait For Interrupt: wfi   </li>
<li>Add Upper Immediate to PC: auipc rd, imm</li>
<li>Jump And Link Register： jalr rd, (imm[11:0])rs</li>
</ul>
<h3 id="Rust-Notes"><a href="#Rust-Notes" class="headerlink" title="Rust Notes"></a>Rust Notes</h3><p><strong>胖指针(Fat Pointer)</strong></p>
<p><code>sys_write</code> 使用了一个 <code>&amp;[u8]</code> 切片类型来描述缓冲区，这是一个 <strong>胖指针</strong> (Fat Pointer)，里面既包含缓冲区的起始地址，还包含缓冲区的长度。可以分别通过 <code>as_ptr</code> 和 <code>len</code> 方法取出它们并独立地作为实际的系统调用参数。</p>
<p><strong>#[derive]</strong></p>
<p>通过 <code>#[derive(...)]</code> 可以让编译器为自定义类型提供一些 Trait 的默认实现。</p>
<ul>
<li>实现了 <code>Clone</code> Trait 之后就可以调用 <code>clone</code> 函数完成拷贝；</li>
<li>实现了 <code>PartialEq</code> Trait 之后就可以使用 <code>==</code> 运算符比较该类型的两个实例。</li>
<li><code>Copy</code> 是一个<strong>标记 Trait</strong>，决定该类型在按值传参/赋值的时候采用移动语义还是复制语义。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/05/2024fall-%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-XiangyuTu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/05/2024fall-%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-XiangyuTu/" class="post-title-link" itemprop="url">2024秋冬开源操作系统训练营第二阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-05 09:00:00" itemprop="dateCreated datePublished" datetime="2024-11-05T09:00:00+00:00">2024-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很早之前在翻一个朋友的 GitHub 的时候偶然看见了 rCore-Tutorial-V3 这个项目，今年 9 月便趁着空闲开始学习。因为 rCore-Tutorial-V3 中有不少的测试用例缺失，所以我便试着在 LearningOS 的仓库中找以前训练营的测试用例，然后偶然发现今年的训练营已经开营了，便毫不犹豫参加了。</p>
<p>因为很早就已经学过 Rust 并且运用在项目当中了，第一阶段算是对 Rust 的复习了，因此花了大改四个小时就完成了。</p>
<p>前三个实验总体来说还是比较容易的，只有在 Lab3 中需要为进程TCB实现 <code>core::cmp::Ord</code> 遇到了一点麻烦，通过查阅官方文档解决了。在第四个实验的时候就感觉有些不太理解了，因此我查阅了一些操作系统的教材和教学视频才能理解。而第五个实验中的算法，一开始我误认为是银行家算法，然后发现程序没有也无法提供最大需求资源 Max，因此稍稍转变思路成功完成了实验。</p>
<p>经过第二阶段的学习我学习了操作系统的基本概念，并且动手实践编写了一些操作系统功能，我觉得受益良多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/05/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-NoahNieh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/05/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-NoahNieh/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营一阶段总结-NoahNieh</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-05 08:17:23" itemprop="dateCreated datePublished" datetime="2024-11-05T08:17:23+00:00">2024-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024秋冬季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h1><p>第一阶段主要目标是熟悉<code>Rust</code>的语法，对我来说做<code>rustlings</code>没有太大的困难，因为<code>Rust</code>也是我自己开发小工具的常用语言之一。</p>
<p>比较有趣的是，仓库中加了一部分算法的题目，而且给出的框架是用<code>unsafe</code>的方法实现的，这让我对<code>Rust</code>在<code>unsafe</code>下的使用有了更深的了解。<br>但是这一部分使用到的<code>unsafe</code>大多是如何去获得一个对象的裸指针或者引用，而到了第二阶段正式开始<code>rCore</code>之后在项目中用的更多的是如何获取对象的切片引用，或者是硬转成<code>*mut T</code>/<code>*const T</code>。<br>似乎在第一阶段学到的<code>unsafe</code>相关的东西并没有在第二阶段用到很多。</p>
<p>但无论如何，完成了<code>rustlings</code>之后，对平时没有用到的一些<code>Rust</code>边角知识更加清晰了，在第二阶段也能更加顺利，不会被语言困住。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/04/2024%E7%A7%8B%E5%86%AC%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%83%91%E8%B6%85%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/04/2024%E7%A7%8B%E5%86%AC%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%83%91%E8%B6%85%E7%BE%A4/" class="post-title-link" itemprop="url">2024秋冬开源操作系统训练营第二阶段总结报告-郑超群</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-04 21:40:58" itemprop="dateCreated datePublished" datetime="2024-11-04T21:40:58+00:00">2024-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在导师的介绍下，了解到开源操作系统训练营这样一个平台。在那之后一直在关注，直到这次秋冬季训练营的开营，我毫不犹豫地选择了报名参与，并与导师一同号召学校的本科生、研究生积极参与。最后，有超过 50 名同学进行了报名，同时通过一阶段的同学有 20 名之多，晋级率大大超过平均水平。</p>
<p>说回到这次训练营的第二阶段，也就是 rCore 实验的部分。由于前段时间正好做了一下 MIT 的操作系统内核课程 MIT6.s081，并且过了一遍知名操作系统入门教材——《Operating Systems Three Easy Pieces》，因此我在本次实验的理论部分准备还算比较充分，在这方面没有花多少时间，而是主要投身于理解 rCore 的代码架构设计和与此相关的 Rust 语言的一些特性（我在此之前并没有接触过 Rust）。不得不感叹，Rust 语言虽然在写一些数据结构与算法题时非常痛苦，但在用于这种工程项目，尤其是系统软件时，却显得十分优雅，个人认为代码可读性上相比用 C 语言编写的 xv6 来说更高。</p>
<p>rCore 一共有 5 个实验，基本都是实现系统调用，但是涉及的操作系统模块各不相同，涵盖虚拟内存、进程管理、文件系统和并发控制部分，还算比较全面，题目难度比较适中，给操作系统内核编程入门提供了一个很好的途径。</p>
<p>尽管 rCore 实验的设计已经很好了，但也仍存在一些不足，最突出的莫过于 <strong>测试用例的不全面</strong>。很多样例都只检测一个非常表层的信息，而不对其所完成的具体功能进行测试。例如 <code>sys_set_priority</code> 只对返回值进行检测。另一个我的切身体会是，我在完成所有实验后，尝试撰写题解并进行复盘，便把之前写的一些已经“OK”的代码仔细读了一遍，发现从中找出了不少错误，而这些都成功“逃离”了测试样例的“法眼”。当然，编写全面细致的测试具备一定的技术难度与繁琐性，但我还是希望未来能够尽可能的对其进行完善。</p>
<p>最后，虽然 rCore 的学习暂时结束了，但操作系统学习的道路还远未到达终点，也不可能到达终点，期待三、四阶段与 ArceOS 的故事。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/01/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-zymatrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/01/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-zymatrix/" class="post-title-link" itemprop="url">第二阶段总结-zymatrix</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-01 00:24:36" itemprop="dateCreated datePublished" datetime="2024-11-01T00:24:36+00:00">2024-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第二阶段总结"><a href="#第二阶段总结" class="headerlink" title="第二阶段总结"></a>第二阶段总结</h2><p>这是我第一次接触完整的操作系统实验，一路走下来可谓是收获颇多。苦于学校教学质量之差，我到处寻找教学资源，例如csdiy，但是从来没有坚持完成过较难的课程。这次rCore也算是弥补了一些遗憾吧。</p>
<ol>
<li>学习RISC-V的特权级机制</li>
<li>Rust风格编程</li>
<li>学会阅读文档，lab提示，以及参考源码，面向源码和测例编程（x）</li>
<li>gdb调试技巧和配置</li>
<li>认识到和大佬们的差距</li>
<li>受大家的鼓舞，希望能坚持在sys的路上一直走下去</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/01/2024%E7%A7%8B%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-zymatrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/01/2024%E7%A7%8B%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-zymatrix/" class="post-title-link" itemprop="url">2024秋开源操作系统训练营第一阶段-zymatrix</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-01 00:06:41" itemprop="dateCreated datePublished" datetime="2024-11-01T00:06:41+00:00">2024-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Rustlings-总结"><a href="#Rustlings-总结" class="headerlink" title="Rustlings 总结"></a>Rustlings 总结</h2><p>接触训练营之前，一直在写C++，Rust名声在外，因此接触Rust更像是换一种视角来观察C++的好方法。<br>为了快速上手Rustlings，我先花了几十分钟粗略阅读了一遍菜鸟教程，对Rust的语法和基本概念有了基本的了解。<br>为了快速上手Rustlings，我先花了几十分钟浏览了一下菜鸟教程，对Rust的语法和基本概念有了一个初步的认识。Rustlings是了解一门语言的极佳途径，它通过练习题的形式，使我深入接触到Rust的各个方面，包括其核心设计理念，以及C++缺少的、非常重要的功能——例如Cargo包管理器等Rust相关生态。如果当初我在学习C++时也能有这样的资源，那该有多好！<br>当然，作为一门系统级编程语言，Rust对程序员的要求非常高。相比之下，Rust的入门难度确实和C++不在一个层次。然而，在Rust的发展过程中可以明显看到它吸取了C++的一些设计理念，这也让这两门优秀的语言在不断借鉴中相互提升。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/10/31/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E5%AD%99%E6%B5%B7%E5%8D%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/10/31/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E5%AD%99%E6%B5%B7%E5%8D%8E/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营第一阶段总结报告-孙海华</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-31 21:18:19" itemprop="dateCreated datePublished" datetime="2024-10-31T21:18:19+00:00">2024-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h1><blockquote>
<p>我的rust入门</p>
</blockquote>
<p>学了很久编程，但是终究不是科班出身，感觉对很多问题理解还不是很到位，本科毕业的暑假，被老师叫去提前进组，基础有点薄弱，于是也开始学起了操作系统，恰巧看到了rcore这个教程，可惜时间有限没有看太多，这次训练营算是重新跟着复习一遍。</p>
<p>rustlings的题目并不是很难，很快就刷完了，感觉难点主要在rust语法的不熟悉。在此之前，听说过很多次rust是新时代的c语言，rust重写内核，rust重写一切….真正学习来才发现rust相较于其他语言的优势。</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>rust与c语言一样，都是偏向于底层开发，能够生成裸机直接运行的机器码，执行效率高（网上有许多rust嵌入式教程，或许后面应该再学学这方面）。</p>
<p>在开发效率方面，相比于c语言，rust的现代化语法，真的要舒服很多。自我感觉rust有很多用起来很爽的部分，比如说模式匹配。相比于c语言，rust也有现代化的包管理工具cargo。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>在学习rust之前，看到很多博主说rust安全，用了之后才一点一点感悟到。rust的所有权机制，还有生命周期的概念，避免了一系列问题。</p>
<h3 id="现代"><a href="#现代" class="headerlink" title="现代"></a>现代</h3><p>现代化的编程语言概念，现代化的包管理工具，舒服！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/10/22/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E7%8E%8B%E4%B8%80%E5%B0%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/10/22/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E7%8E%8B%E4%B8%80%E5%B0%A7/" class="post-title-link" itemprop="url">2024秋冬开源操作系统训练营第二阶段总结报告-王一尧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-22 11:58:15" itemprop="dateCreated datePublished" datetime="2024-10-22T11:58:15+00:00">2024-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rCore-二阶段总结报告"><a href="#rCore-二阶段总结报告" class="headerlink" title="rCore 二阶段总结报告"></a>rCore 二阶段总结报告</h1><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>因为有Rust基础，所以在第一阶段大概花了三四个小时完成了Rustlings。但是是第一次参加rCore训练营，所以在进入第二阶段后，感觉到了进展十分缓慢，在每个Lab中都或多或少被一些问题所困扰。</p>
<h2 id="得到的收获"><a href="#得到的收获" class="headerlink" title="得到的收获"></a>得到的收获</h2><p>第二阶段的几个Lab相互衔接，在完成一个个Lab的过程中能感觉到对于操作系统的逐渐了解和深入，做完了后面的部分回过头来看前面的部分有时候还会有新的理解。在熟读文档和完成实验的互相作用下，我相信自己的能力得到了一定的提升。但是有些实验虽然通过了，但是仔细一想还是有侥幸的部分，在以后可能需要小心注意。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/10/21/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-chy669086/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/10/21/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-chy669086/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营第二阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-21 17:40:38" itemprop="dateCreated datePublished" datetime="2024-10-21T17:40:38+00:00">2024-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" itemprop="url" rel="index"><span itemprop="name">第二阶段总结报告</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一阶段报告"><a href="#第一阶段报告" class="headerlink" title="第一阶段报告"></a>第一阶段报告</h2><p>在加入这个课程的时候已经学习 rust 小半年了，rustling 原项目也是完整的写过一次，所以第一阶段很快就通过了。第一阶段的 rustling 是魔改版，确实让我学到了很多我之前不太了解的东西。</p>
<h2 id="第二阶段报告"><a href="#第二阶段报告" class="headerlink" title="第二阶段报告"></a>第二阶段报告</h2><p>这个阶段的学习直接戳中我的知识盲区，汇编、操作系统这些我是一点不会。</p>
<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><p>应该说都是困难？</p>
<p>卡我最久的应该是内存分页和文件系统了，这种一层一层抽象上来的我看的是眼花缭乱，物理结构和程序结构的转换，在此基础上的再一层抽象在当时给了我很大的阅读困难。</p>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>首先这几次学习解开了我之前的误区和疑惑，特别是系统调用这一方面，我之前都不知道原来特权级这个概念，不知道为什么汇编需要在操作系统支持下运行。现在我知道很多操作是需要系统提供接口，需要用户态和内核态的切换。</p>
<p>这是我第二次写这个体量的 rust 项目，编写过程中经常写出很多哭笑不得的代码，比如在持有锁的前提下再次请求锁导致死锁，在单次借用后不 drop 再次借用导致 panic。<br>通过这次的学习，我的 rust 编程能力无疑得到了提升，我可以明显感觉到我的代码可读性比之前好不少，对于写注释也更加得心应手。</p>
<p>在学习过程中与群友的讨论中，我也对其中的汇编代码理解更深，通过我在本机的多次测试，也加深了我对任务切换、特权级跳转的认识。</p>
<p>这五个 lab 的代码难度确实不是很高，主要难点都在于理解 os 的组织形式，没有搞清楚 os 的其他代码就难以下手，但是理清思路之后写起来就没有什么难度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/10/15/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E7%8E%8B%E7%BF%8A%E5%98%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/10/15/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E7%8E%8B%E7%BF%8A%E5%98%89/" class="post-title-link" itemprop="url">abcd1234-rust-os</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-15 18:32:19" itemprop="dateCreated datePublished" datetime="2024-10-15T18:32:19+00:00">2024-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:55:06" itemprop="dateModified" datetime="2025-05-15T07:55:06+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/rust-stage-1/" itemprop="url" rel="index"><span itemprop="name">rust-stage-1</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Rust-OS-一阶段学习总结"><a href="#Rust-OS-一阶段学习总结" class="headerlink" title="Rust OS 一阶段学习总结"></a>Rust OS 一阶段学习总结</h1><p>@FinishTime: 2024-09-19 00:35:51</p>
<h2 id="个人背景概述"><a href="#个人背景概述" class="headerlink" title="个人背景概述"></a>个人背景概述</h2><p>我是一名软件工程专业的大三本科生，曾参与过 2023 年秋冬季训练营和 2024 年春夏季训练营。并且在 2024 季春夏训练营中，取得了通过的成绩。<br>今年的秋冬季训练营，我想冲一冲优秀，多做一些项目，多为国内操作系统和开源做出贡献。</p>
<h2 id="今年一阶段学习时间表"><a href="#今年一阶段学习时间表" class="headerlink" title="今年一阶段学习时间表"></a>今年一阶段学习时间表</h2><ul>
<li>2024-09-18 大约 3.5 小时，重新完成 rustlings 的官方基础习题(前 94 题)。之后，又用了大约 2 小时，完成了后续的习题(95-110)。</li>
</ul>
<h2 id="一阶段学习内容概述"><a href="#一阶段学习内容概述" class="headerlink" title="一阶段学习内容概述"></a>一阶段学习内容概述</h2><p>我按照<a href="https://course.rs/about-book.html" target="_blank" rel="noopener">“rust 语言圣经”</a>上的讲解顺序，复习之前的知识点。<br>由于我在那段时间之前，在参加 InfiniTensor 的 AI 训练营，所以 rust 的基础语法等根本没有落下，这使得我在完成 rustlings 的习题时，几乎没有遇到什么问题。</p>
<p>只有到后续的习题中，我遇到了一些问题，主要是和 <code>智能指针</code> 有关的内容。这些部分我一直不是很理解的。但是因为我的经验，我还是能写出代码的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在第一阶段的学习中，我巩固了我所掌握的 rust 基础，我更是深深的意识到：<code>Talk is cheap, show me the code!</code>。实践是最好的老师！</p>
<h1 id="Rust-rCore-二阶段学习总结"><a href="#Rust-rCore-二阶段学习总结" class="headerlink" title="Rust rCore 二阶段学习总结"></a>Rust rCore 二阶段学习总结</h1><p>@FinishTime: 2024-10-15 18:44:32</p>
<h2 id="二阶段学习时间表"><a href="#二阶段学习时间表" class="headerlink" title="二阶段学习时间表"></a>二阶段学习时间表</h2><ul>
<li>2024-10-08 开始实验，轻车熟路，一天晚上完事了大部分的 ch3。</li>
<li>2024-10-09 凌晨 ch3 debug 完毕，下午进行提交完毕。</li>
<li>2024-10-09 晚上 ch4 提交完毕。</li>
<li>2024-10-11 ch5 提交完毕。</li>
<li>2024-10-13 ch6 提交完毕。</li>
<li>2024-10-15 ch8 提交完毕。撰写报告完毕。</li>
</ul>
<h2 id="问题复盘"><a href="#问题复盘" class="headerlink" title="问题复盘"></a>问题复盘</h2><p>通过上面的学习时间表可以看出，我虽然是第二次做大实验，但仍然每一部分都需要 1 到 2 天时间。虽然不是将大段时间全部投入，但可能也是比较慢了。<br>以下是我实验过程中的问题复盘。</p>
<h3 id="ch3-本地测例初始化问题"><a href="#ch3-本地测例初始化问题" class="headerlink" title="ch3: 本地测例初始化问题"></a>ch3: 本地测例初始化问题</h3><p>在 ch3 里，我遇到了两个问题，第一个是本地测例的初始化问题。</p>
<p>由于我是第二次参与训练营，所以在实验时，我就直接去看指导书的习题部分，在尝试开始实现时，在 rust-anaylzer 的使用上时发生了错误，插件因为找不到某些依赖库，拒绝提供服务。</p>
<p>我去查看了插件的报错信息，发现找不到 <code>user</code> 目录。而我在源代码仓库，也确实没看到源代码里有 <code>user</code> 目录。后续，我在自行尝试解决无果后，去微信群问了助教。得到的回答是 <code>看文档</code>。然后我去重新看了文档，找到了一个下载 <code>user</code> 的方法。这个问题是由于我的粗心导致的。</p>
<h3 id="ch3-时间初始化问题"><a href="#ch3-时间初始化问题" class="headerlink" title="ch3: 时间初始化问题"></a>ch3: 时间初始化问题</h3><p>ch3 的第二个问题是，os 时间初始化问题。</p>
<p>在我实现的 os 里，在时间初始化，采用的是 <code>直接在任务加载时便初始化为当前系统时间</code>。这显然是错误的。但它的报错并不友好。</p>
<p>此问题的表现为：在直接指定 <code>BASE=1</code> 执行测试用例时，能够通过测试用例。指定 <code>BASE=0</code> 时，也能够通过测试。但指定 <code>BASE=2</code> 时，竟然不能通过测试！？同时，这种情况下，qemu 会出现“卡死”，让人一直等下去。</p>
<p>我通过细细阅读报错，发现 qemu 卡死是因为有一个用户测例 panic 导致的。经过分析的测例执行逻辑为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我分析，ch3里，qemu在跑测试用例的时候，qemu的退出机制是，当全部测试用例成功时，才会退出。</span><br><span class="line"></span><br><span class="line">如果有测例没过，他会接着执行别的测试用例，但最后全部测试用例执行完后，就不会退出了，还没有信息提示。</span><br></pre></td></tr></table></figure>

<p>能够定位位置，之后的工作就要简单多了。我发现了问题所在，然后将时间改为 <code>Option</code> 类型，以 <code>None</code> 来初始化，在为某任务进行 sys_call 计数时进行判断，如果为 <code>None</code>，则进行初始化。这样，问题就解决了。</p>
<p>后续，我看到交流群里有个同学，和我遇到了一样的问题，于是，我也帮助了他。</p>
<h3 id="ch6-又一次卡了一小点"><a href="#ch6-又一次卡了一小点" class="headerlink" title="ch6: 又一次卡了一小点"></a>ch6: 又一次卡了一小点</h3><p>在 ch6 时，平心而论，要求实现的逻辑并不是很复杂，只是需要层层的传递，最后由“easy-fs”进行实际干活即可。但我再次遇到了一个极为恶心的问题。</p>
<p>在春夏季训练营，我曾经遇到了“File is shorter than the first ELf header part”的问题，翻译过来就是，文件比文件描述符还短。我发现，只有 ch5_spawn0，也就是 helloworld 的测例出现了这个问题。</p>
<p>而这一次，我又遇到了这个问题。然后，我通过微信群的聊天记录，找到了当时一位热心同学给我的解答，即，此情况可能是由于 rust 的智能优化导致的，只需要把一个位置，由 <code>[u8; 512]</code> 改为一个 Vec 即可。</p>
<p>还好我留有聊天记录，再次感谢当时的那位同学！</p>
<h3 id="ch8-系统时间系统调用未实现"><a href="#ch8-系统时间系统调用未实现" class="headerlink" title="ch8: 系统时间系统调用未实现"></a>ch8: 系统时间系统调用未实现</h3><p>来到了 ch8，我没有看到指导书文档里，写着的 “除 sys_get_time 以外”，所以，我就没有合并我之前的代码。但问题是，在我实现了 ch8 的内容后，进行测例，有两个始终过不去，就是那两个死锁相关的。而且，它没有报错提醒。这使我很懵，是不是我的银行家算法写的有问题？</p>
<p>在一次又一次地尝试为银行家算法进行 debug 后，我发现，好像我的算法没问题啊。于是，我又一次详细阅读测试代码，发现：这里面有个<code>sleep(500)</code>，这是调了哪个 sys_call？我查了，发现是获得系统时间的那个。但我没有合并之前的代码，导致其会进入死循环。由此，我才改好了问题。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>第二次来 rCore，感觉熟能生巧了一些，之前很多不太理解的部分，已经慢慢构不成威胁了。果然，实践能够带动理论！但我也因为自己的粗心，导致了一些不必要的麻烦。这是需要我进行反省的。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>这一次的三阶段，将会涉及到“组件化”。希望我能尽快完成相关内容，及早进入后续项目内容的学习！希望能够冲一冲优秀！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/22/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/blog/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/64/">64</a><a class="extend next" rel="next" href="/blog/page/24/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
