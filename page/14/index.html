<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/14/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/14/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">742</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">646</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap7-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap7-1/" class="post-title-link" itemprop="url">rcore-handnote-7-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-7-1"><a href="#Chapter-7-1" class="headerlink" title="Chapter 7-1"></a>Chapter 7-1</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We gonna abstract <code>Stdin</code> and <code>Stdout</code> by file, and insert into file descriptor. Therefore support <strong>Pipe</strong> operation and <strong>IO Redirection</strong> across each process.</p>
<h3 id="Everything-Is-a-File"><a href="#Everything-Is-a-File" class="headerlink" title="Everything Is a File"></a>Everything Is a File</h3><p>The design philosophy of <strong>Everything is a file</strong> will generalize everything to file based on IO operations while omit concrete content semantics.</p>
<p>Abstraction of IO hardware:</p>
<ul>
<li>read-only: s.t. keyboard</li>
<li>write-only: s.t. screen</li>
<li>read-write: s.t. serial device</li>
</ul>
<p>Abstraction of IO operations(based on file descriptor):</p>
<ul>
<li>open: open file while possessing it by certain process.</li>
<li>close: close file while discarding it by certain process.</li>
<li>read: read file into memory.</li>
<li>write: write file from memory.</li>
</ul>
<p>When a process is created, it owns three file as operation abstraction:</p>
<ul>
<li>0: Stdin</li>
<li>1: Stdout</li>
<li>2: Stderr(which we will merge with Stdout)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> task_control_block = <span class="keyword">Self</span> &#123;</span><br><span class="line">            pid: pid_handle,</span><br><span class="line">            kernel_stack,</span><br><span class="line">            inner: Mutex::new(TaskControlBlockInner &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">                fd_table: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="comment">// 0 -&gt; stdin</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdin)),</span><br><span class="line">                    <span class="comment">// 1 -&gt; stdout</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdout)),</span><br><span class="line">                    <span class="comment">// 2 -&gt; stderr</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdout)),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>In usual shell, <code>|</code> is the symbolic of pipe. Manage input from left and output to right. If we abstract everything to file, s.t. <code>Stdin</code> or <code>Stdout</code>, so does <strong>Pipe</strong>, it has <code>read</code> and <code>write</code> ends, user could read thing from this end and write thing(often in child process) to other end, transfer those underneath thing.</p>
<p>We already has file descriptor as the indication of file, we will implement same operation for pipe.</p>
<p><code>sys_pipe</code> get the ptr of a array with <code>len = 2</code>, output the write and the read ends of descriptors of pipe in the ptr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_PIPE: <span class="built_in">usize</span> = <span class="number">59</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_pipe</span></span>(pipe: &amp;<span class="keyword">mut</span> [<span class="built_in">usize</span>]) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    syscall(SYSCALL_PIPE, [pipe.as_mut_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>So What’s the basic design of pipe?</p>
<p>It should has write and read ends which means ends share the same data, and record read and write informations on this data. We will construct <code>RingBuffer</code> to achieve this. <code>Pipe</code> owns a buffer control read and write, buffer will record data from head to tail index. Why we can’t just use two piece of data or <code>Queue</code>?</p>
<p>Because there’s no copy and suitable for our restriction! We will read data from head and move forward and push data to end in a fixed array rather allocation for <code>Queue</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/pipe.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span></span> &#123;</span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RING_BUFFER_SIZE: <span class="built_in">usize</span> = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RingBufferStatus</span></span> &#123;</span><br><span class="line">    FULL,</span><br><span class="line">    EMPTY,</span><br><span class="line">    NORMAL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PipeRingBuffer</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">u8</span>; RING_BUFFER_SIZE],</span><br><span class="line">    head: <span class="built_in">usize</span>, <span class="comment">// head index of ring buffer</span></span><br><span class="line">    tail: <span class="built_in">usize</span>, <span class="comment">// tail index of ring buffer</span></span><br><span class="line">    status: RingBufferStatus,</span><br><span class="line">    write_end: <span class="built_in">Option</span>&lt;Weak&lt;Pipe&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_write_end</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, write_end: &amp;Arc&lt;Pipe&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.write_end = <span class="literal">Some</span>(Arc::downgrade(write_end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Return (read_end, write_end)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">make_pipe</span></span>() -&gt; (Arc&lt;Pipe&gt;, Arc&lt;Pipe&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> buffer = Arc::new(Mutex::new(PipeRingBuffer::new()));</span><br><span class="line">    <span class="keyword">let</span> read_end = Arc::new(</span><br><span class="line">        Pipe::read_end_with_buffer(buffer.clone())</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> write_end = Arc::new(</span><br><span class="line">        Pipe::write_end_with_buffer(buffer.clone())</span><br><span class="line">    );</span><br><span class="line">    buffer.lock().set_write_end(&amp;write_end);</span><br><span class="line">    (read_end, write_end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_byte</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.status = RingBufferStatus::NORMAL;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="keyword">self</span>.arr[<span class="keyword">self</span>.head];</span><br><span class="line">		<span class="comment">// move forward</span></span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="number">1</span>) % RING_BUFFER_SIZE;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.head == <span class="keyword">self</span>.tail &#123;</span><br><span class="line">            <span class="keyword">self</span>.status = RingBufferStatus::EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">available_read</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.status == RingBufferStatus::EMPTY &#123;</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// data from head to tail!</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.tail &gt; <span class="keyword">self</span>.head &#123;</span><br><span class="line">                <span class="keyword">self</span>.tail - <span class="keyword">self</span>.head</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.tail + RING_BUFFER_SIZE - <span class="keyword">self</span>.head</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">all_write_ends_closed</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.write_end.as_ref().unwrap().upgrade().is_none()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In one process, there’s a possible that can’t read all thing in once, if so, we will pause and run other thing until the write end is finished.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/pipe.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Pipe &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(<span class="keyword">self</span>.readable());</span><br><span class="line">        <span class="keyword">let</span> want_to_read = buf.len();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> buf_iter = buf.into_iter();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> already_read = <span class="number">0usize</span>;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> ring_buffer = <span class="keyword">self</span>.buffer.exclusive_access();</span><br><span class="line">            <span class="keyword">let</span> loop_read = ring_buffer.available_read();</span><br><span class="line">            <span class="keyword">if</span> loop_read == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ring_buffer.all_write_ends_closed() &#123;</span><br><span class="line">                    <span class="keyword">return</span> already_read;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">drop</span>(ring_buffer);</span><br><span class="line">                suspend_current_and_run_next();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..loop_read &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(byte_ref) = buf_iter.next() &#123;</span><br><span class="line">                    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                        *byte_ref = ring_buffer.read_byte();</span><br><span class="line">                    &#125;</span><br><span class="line">                    already_read += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> already_read == want_to_read &#123;</span><br><span class="line">                        <span class="keyword">return</span> want_to_read;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> already_read;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h3><p>We will combine our pipe with our shell.</p>
<p>First, parse our arguments and push <code>0</code> to end to indicated end.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/bin/user_shell.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;_&gt; = line.as_str().split(<span class="string">' '</span>).collect();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> args_addr: <span class="built_in">Vec</span>&lt;*<span class="keyword">const</span> <span class="built_in">u8</span>&gt; = args</span><br><span class="line">	.iter()</span><br><span class="line">	.map(|&amp;arg| &#123;</span><br><span class="line">		<span class="keyword">let</span> s = arg.to_string();</span><br><span class="line">		s.push(<span class="string">'\0'</span>);</span><br><span class="line">		s.as_ptr()</span><br><span class="line">	&#125;)</span><br><span class="line">	.collect();</span><br><span class="line">args_addr.push(<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>)</span><br></pre></td></tr></table></figure>

<p>Now task will accept a series of args rather than solely one string. So make <code>sys_exec</code> to:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>, <span class="keyword">mut</span> args: *<span class="keyword">const</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> args_vec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">	<span class="comment">// args would be a ptr of array contains ptr of string.</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arg_str_ptr = *translated_ref(token, args);</span><br><span class="line">        <span class="keyword">if</span> arg_str_ptr == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        args_vec.push(translated_str(token, arg_str_ptr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>));</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; args = args.add(<span class="number">1</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(app_inode) = open_file(path.as_str(), OpenFlags::RDONLY) &#123;</span><br><span class="line">        <span class="keyword">let</span> all_data = app_inode.read_all();</span><br><span class="line">        <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">        <span class="keyword">let</span> argc = args_vec.len();</span><br><span class="line">        task.exec(all_data.as_slice(), args_vec);</span><br><span class="line">        <span class="comment">// return argc because cx.x[10] will be covered with it later</span></span><br><span class="line">        argc <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we really gonna use user stack to store these args!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">	<span class="comment">// notice exec will allocate a new memory set!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>], args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// first allocate memory for ptr of strings.</span></span><br><span class="line">        user_sp -= (args.len() + <span class="number">1</span>) * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;();</span><br><span class="line">        <span class="keyword">let</span> argv_base = user_sp;</span><br><span class="line">		<span class="comment">// allocate new memory in user stack addr as a vector of strings </span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> argv: <span class="built_in">Vec</span>&lt;_&gt; = (<span class="number">0</span>..=args.len())</span><br><span class="line">            .map(|arg| &#123;</span><br><span class="line">                translated_refmut(</span><br><span class="line">                    memory_set.token(),</span><br><span class="line">                    (argv_base + arg * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">usize</span></span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect();</span><br><span class="line">        *argv[args.len()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..args.len() &#123;</span><br><span class="line">			<span class="comment">// allocate for strings themselves.</span></span><br><span class="line">            user_sp -= args[i].len() + <span class="number">1</span>;</span><br><span class="line">            *argv[i] = user_sp;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> p = user_sp;</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> args[i].as_bytes() &#123;</span><br><span class="line">                *translated_refmut(memory_set.token(), p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>) = *c;</span><br><span class="line">                p += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *translated_refmut(memory_set.token(), p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// make the user_sp aligned to 8B for k210 platform</span></span><br><span class="line">        user_sp -= user_sp % core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **** hold current PCB lock</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.acquire_inner_lock();</span><br><span class="line">        <span class="comment">// substitute memory_set</span></span><br><span class="line">        inner.memory_set = memory_set;</span><br><span class="line">        <span class="comment">// update trap_cx ppn</span></span><br><span class="line">        inner.trap_cx_ppn = trap_cx_ppn;</span><br><span class="line">        <span class="comment">// initialize trap_cx</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> trap_cx = TrapContext::app_init_context(</span><br><span class="line">            entry_point,</span><br><span class="line">            user_sp,</span><br><span class="line">            KERNEL_SPACE.lock().token(),</span><br><span class="line">            <span class="keyword">self</span>.kernel_stack.get_top(),</span><br><span class="line">            trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">		<span class="comment">// a[0] be args len</span></span><br><span class="line">        trap_cx.x[<span class="number">10</span>] = args.len();</span><br><span class="line">		<span class="comment">// a[1] be args base addr</span></span><br><span class="line">        trap_cx.x[<span class="number">11</span>] = argv_base;</span><br><span class="line">        *inner.get_trap_cx() = trap_cx;</span><br><span class="line">        <span class="comment">// **** release current PCB lock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we provide receive operation in <code>_start</code>, in which <code>main</code> could use it at first time S-level reading data and passing to U-level:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="meta-string">".text.entry"</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>(argc: <span class="built_in">usize</span>, argv: <span class="built_in">usize</span>) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP.lock()</span><br><span class="line">            .init(HEAP_SPACE.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>, USER_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..argc &#123;</span><br><span class="line">        <span class="keyword">let</span> str_start = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            ((argv + i * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">usize</span>).read_volatile()</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> len = (<span class="number">0usize</span>..).find(|i| <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            ((str_start + *i) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>).read_volatile() == <span class="number">0</span></span><br><span class="line">        &#125;).unwrap();</span><br><span class="line">        v.push(</span><br><span class="line">            core::<span class="built_in">str</span>::from_utf8(<span class="keyword">unsafe</span> &#123;</span><br><span class="line">                core::slice::from_raw_parts(str_start <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>, len)</span><br><span class="line">            &#125;).unwrap()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    exit(main(argc, v.as_slice()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h3><p>Redirection usually represent using <code>&gt;</code> and <code>&lt;</code> for output and input.</p>
<p>If we really want to redirect IO, we will combine <code>user_shell</code> and <code>sys_dup</code>.</p>
<p>First, <code>sys_dup</code> will duplicate a new file descriptor already opened in this process.</p>
<p>Then we parse user arguments, if there exist <code>&gt;</code> or <code>&lt;</code>, fork a new child process, open the file and close our corresponding <code>Stdin</code> and <code>Stdout</code> descriptor, using <code>dup</code> to hold the place of it by <code>file</code> itself! Then <code>exec</code> by original parsed arguments, and receive results in parent process.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap7-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap7-2/" class="post-title-link" itemprop="url">rcore-handnote-7-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-7-2"><a href="#Chapter-7-2" class="headerlink" title="Chapter 7-2"></a>Chapter 7-2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>If a process want to notify other process with event semantics, such one-side mechanism called <strong>Signal</strong>, one process received specific event will pause and implement corresponding operation to handle the notification.</p>
<p>For example, a program could receive the stop event sended by <code>Ctrl+C</code>, and stop itself.</p>
<p>The abstraction of handling of signal:</p>
<ul>
<li>ignore: do own thing and ignore signal</li>
<li>trap: call corresponding operation of the received signal</li>
<li>stop: stop itself</li>
</ul>
<p>Now, beside this raw idea, we want to classify such abstraction with specified data.</p>
<hr>
<h3 id="Signal-Data"><a href="#Signal-Data" class="headerlink" title="Signal Data"></a>Signal Data</h3><p>First, we define raw info for each possible event.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGDEF: <span class="built_in">i32</span> = <span class="number">0</span>; <span class="comment">// Default signal handling</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGHUP: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGINT: <span class="built_in">i32</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGQUIT: <span class="built_in">i32</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGILL: <span class="built_in">i32</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGTRAP: <span class="built_in">i32</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGABRT: <span class="built_in">i32</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGBUS: <span class="built_in">i32</span> = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGFPE: <span class="built_in">i32</span> = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGKILL: <span class="built_in">i32</span> = <span class="number">9</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>So, what if a process want to omit the signal, what should this process do? We will introduce <strong>Mask</strong> in bit design, which means higher number contains lower number, indicating higher priority.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SignalFlags</span></span>: <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> SIGDEF = <span class="number">1</span>; <span class="comment">// Default signal handling</span></span><br><span class="line">        <span class="keyword">const</span> SIGHUP = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> SIGINT = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> SIGQUIT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> SIGILL = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">const</span> SIGTRAP = <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">const</span> SIGSYS = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In a task block, it should record its current mask and current signal priority and each action corresponding to each flags, so we need a fixed array contains ptrs and its priority. After that, we need to record current flag it should implement.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Action for a signal</span></span><br><span class="line"><span class="meta">#[repr(C, align(16))]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SignalAction</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> handler: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> mask: SignalFlags,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/signal.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MAX_SIG: <span class="built_in">usize</span> = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/action.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SignalActions</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> table: [SignalAction; MAX_SIG + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">pub</span> handling_sig: <span class="built_in">isize</span>,</span><br><span class="line">	<span class="comment">// priority allowed</span></span><br><span class="line">	<span class="keyword">pub</span> signals: SignalFlags,</span><br><span class="line">	<span class="comment">// priority forbidden</span></span><br><span class="line">    <span class="keyword">pub</span> signal_mask: SignalFlags,</span><br><span class="line">    <span class="keyword">pub</span> signal_actions: SignalActions,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then our task know which signal should be implemented, which should be omitted.</p>
<hr>
<h3 id="Signal-Handle"><a href="#Signal-Handle" class="headerlink" title="Signal Handle"></a>Signal Handle</h3><p>Recall that, each process should receive signal and trap into possible level, some may be in S-level, some may be in U-level. And some of them may be illegal or atrocious that we should <code>stop</code> or <code>frozen</code> to wait. If so, we should backup our <code>trap_ctx</code>, because handler contains different environement.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">pub</span> killed: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> frozen: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> handling_sig: <span class="built_in">isize</span>,</span><br><span class="line">    <span class="keyword">pub</span> trap_ctx_backup: <span class="built_in">Option</span>&lt;TrapContext&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some signals are severe and handled by kernel.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">call_kernel_signal_handler</span></span>(signal: SignalFlags) &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">match</span> signal &#123;</span><br><span class="line">        SignalFlags::SIGSTOP =&gt; &#123;</span><br><span class="line">            task_inner.frozen = <span class="literal">true</span>;</span><br><span class="line">            task_inner.signals ^= SignalFlags::SIGSTOP;</span><br><span class="line">        &#125;</span><br><span class="line">        SignalFlags::SIGCONT =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> task_inner.signals.contains(SignalFlags::SIGCONT) &#123;</span><br><span class="line">                task_inner.signals ^= SignalFlags::SIGCONT;</span><br><span class="line">                task_inner.frozen = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// println!(</span></span><br><span class="line">            <span class="comment">//     "[K] call_kernel_signal_handler:: current task sigflag &#123;:?&#125;",</span></span><br><span class="line">            <span class="comment">//     task_inner.signals</span></span><br><span class="line">            <span class="comment">// );</span></span><br><span class="line">            task_inner.killed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some signals are normal and handled by user.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">call_user_signal_handler</span></span>(sig: <span class="built_in">usize</span>, signal: SignalFlags) &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handler = task_inner.signal_actions.table[sig].handler;</span><br><span class="line">    <span class="keyword">if</span> handler != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// register signal into task</span></span><br><span class="line">        task_inner.handling_sig = sig <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line">        task_inner.signals ^= signal;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// backup</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> trap_ctx = task_inner.get_trap_cx();</span><br><span class="line">        task_inner.trap_ctx_backup = <span class="literal">Some</span>(*trap_ctx);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// modify current trap for our event handler</span></span><br><span class="line">        trap_ctx.sepc = handler;</span><br><span class="line">        trap_ctx.x[<span class="number">10</span>] = sig;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// default action</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"[K] task/call_user_signal_handler: default action: ignore it or kill process"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on this, we could check our pending signal based on priority of <code>signals</code>, <code>signal_mask</code> of task and <code>signal_mask</code> of signal itself of table.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_pending_signals</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> sig <span class="keyword">in</span> <span class="number">0</span>..(MAX_SIG + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">        <span class="keyword">let</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">let</span> signal = SignalFlags::from_bits(<span class="number">1</span> &lt;&lt; sig).unwrap();</span><br><span class="line">        <span class="keyword">if</span> task_inner.signals.contains(signal) &amp;&amp; (!task_inner.signal_mask.contains(signal)) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> masked = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">let</span> handling_sig = task_inner.handling_sig;</span><br><span class="line">            <span class="keyword">if</span> handling_sig == -<span class="number">1</span> &#123;</span><br><span class="line">                masked = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> handling_sig = handling_sig <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">                <span class="keyword">if</span> !task_inner.signal_actions.table[handling_sig]</span><br><span class="line">                    .mask</span><br><span class="line">                    .contains(signal)</span><br><span class="line">                &#123;</span><br><span class="line">                    masked = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !masked &#123;</span><br><span class="line">                <span class="built_in">drop</span>(task_inner);</span><br><span class="line">                <span class="built_in">drop</span>(task);</span><br><span class="line">                <span class="keyword">if</span> signal == SignalFlags::SIGKILL</span><br><span class="line">                    || signal == SignalFlags::SIGSTOP</span><br><span class="line">                    || signal == SignalFlags::SIGCONT</span><br><span class="line">                    || signal == SignalFlags::SIGDEF</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// signal is a kernel signal</span></span><br><span class="line">                    call_kernel_signal_handler(signal);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// signal is a user signal</span></span><br><span class="line">                    call_user_signal_handler(sig, signal);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then record a loop function to handle repeatedly while changing the state of task.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">handle_signals</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        check_pending_signals();</span><br><span class="line">        <span class="keyword">let</span> (frozen, killed) = &#123;</span><br><span class="line">            <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">            <span class="keyword">let</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">            (task_inner.frozen, task_inner.killed)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> !frozen || killed &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        suspend_current_and_run_next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="System-Operation"><a href="#System-Operation" class="headerlink" title="System Operation"></a>System Operation</h3><p>Finally, we will design <code>sys</code> operations to construct interface.</p>
<ul>
<li>procmask: set mask of current process</li>
<li>sigaction: set handler of a signal of current process and move original handler to our input <code>old_action</code> ptr.</li>
<li>kill: current process send signal to the other</li>
<li>sigreturn: clear current signal and back to original trap state</li>
</ul>
<p>We will construct it one by one.</p>
<p><code>procmask</code> is simple, we just set it directly and return original one.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_sigprocmask</span></span>(mask: <span class="built_in">u32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = current_task() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">let</span> old_mask = inner.signal_mask;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(flag) = SignalFlags::from_bits(mask) &#123;</span><br><span class="line">            inner.signal_mask = flag;</span><br><span class="line">            old_mask.bits() <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sigaction</code> is a bit harder but still easy, however, notice that the ptr may be null.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_sigaction_error</span></span>(signal: SignalFlags, action: <span class="built_in">usize</span>, old_action: <span class="built_in">usize</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> action == <span class="number">0</span></span><br><span class="line">        || old_action == <span class="number">0</span></span><br><span class="line">        || signal == SignalFlags::SIGKILL</span><br><span class="line">        || signal == SignalFlags::SIGSTOP</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_sigaction</span></span>(</span><br><span class="line">    signum: <span class="built_in">i32</span>,</span><br><span class="line">    action: *<span class="keyword">const</span> SignalAction,</span><br><span class="line">    old_action: *<span class="keyword">mut</span> SignalAction,</span><br><span class="line">) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> signum <span class="keyword">as</span> <span class="built_in">usize</span> &gt; MAX_SIG &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(flag) = SignalFlags::from_bits(<span class="number">1</span> &lt;&lt; signum) &#123;</span><br><span class="line">        <span class="keyword">if</span> check_sigaction_error(flag, action <span class="keyword">as</span> <span class="built_in">usize</span>, old_action <span class="keyword">as</span> <span class="built_in">usize</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> prev_action = inner.signal_actions.table[signum <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">        *translated_refmut(token, old_action) = prev_action;</span><br><span class="line">        inner.signal_actions.table[signum <span class="keyword">as</span> <span class="built_in">usize</span>] = *translated_ref(token, action);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kill</code> is simple, we will extract the task from <code>pid</code>, and insert flag to it if there’s no flag has been set.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_sigaction_error</span></span>(signal: SignalFlags, action: <span class="built_in">usize</span>, old_action: <span class="built_in">usize</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> action == <span class="number">0</span></span><br><span class="line">        || old_action == <span class="number">0</span></span><br><span class="line">        || signal == SignalFlags::SIGKILL</span><br><span class="line">        || signal == SignalFlags::SIGSTOP</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_sigaction</span></span>(</span><br><span class="line">    signum: <span class="built_in">i32</span>,</span><br><span class="line">    action: *<span class="keyword">const</span> SignalAction,</span><br><span class="line">    old_action: *<span class="keyword">mut</span> SignalAction,</span><br><span class="line">) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> signum <span class="keyword">as</span> <span class="built_in">usize</span> &gt; MAX_SIG &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(flag) = SignalFlags::from_bits(<span class="number">1</span> &lt;&lt; signum) &#123;</span><br><span class="line">        <span class="keyword">if</span> check_sigaction_error(flag, action <span class="keyword">as</span> <span class="built_in">usize</span>, old_action <span class="keyword">as</span> <span class="built_in">usize</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> prev_action = inner.signal_actions.table[signum <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">        *translated_refmut(token, old_action) = prev_action;</span><br><span class="line">        inner.signal_actions.table[signum <span class="keyword">as</span> <span class="built_in">usize</span>] = *translated_ref(token, action);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sigreturn</code> is simple, because we only need to restore our backup one.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_sigreturn</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = current_task() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">        inner.handling_sig = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// restore the trap context</span></span><br><span class="line">        <span class="keyword">let</span> trap_ctx = inner.get_trap_cx();</span><br><span class="line">        *trap_ctx = inner.trap_ctx_backup.unwrap();</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phew! We finish our <strong>Signal</strong> mechanism!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap8-1/" class="post-title-link" itemprop="url">rcore-handnote-8-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-8-1"><a href="#Chapter-8-1" class="headerlink" title="Chapter 8-1"></a>Chapter 8-1</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>As the growth of OS, dispatch resource could be divided to smaller piece for more efficient operations. Now, process can’t satisfied our demand, we want some programs could be implemented in parallel. Then, we introduce <strong>Thread</strong>.</p>
<p>Therefore, process will be the container of threads, each threads contain its <code>id</code>, <code>state</code>, current instruction ptr, registers, stack. However, it will share data(which means same memory and addr) in the same process. So, we will develop a accompany exclusion mechanism for parallel operations by each threads.</p>
<h3 id="Design-Data"><a href="#Design-Data" class="headerlink" title="Design Data"></a>Design Data</h3><p>Now, clarify our resource dispatch for one thread:</p>
<p>Immutable:</p>
<ul>
<li>kernel stack</li>
</ul>
<p>Mutable:</p>
<ul>
<li>thread id</li>
<li>user stack</li>
<li>trap context</li>
<li>trap status</li>
<li>exit code</li>
</ul>
<p>Every tasks is a thread unit and contained in one process, so now, process is really a process rather a task, it can owns many tasks.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    <span class="comment">// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">pub</span> task_res_allocator: RecycleAllocator,</span><br><span class="line">    <span class="keyword">pub</span> tasks: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice, we should separate user stack and kernel stack, we shouldn’t allocate user stack and kernel stack by same logic. Kernel stack is immutable, we only need its top place for trap context.</p>
<p><img src="/rCore-Blog/assets/Lab8-1.png" alt=""></p>
<p>Because every thread use the same memory set, so each user stack and its trampoline would be allocated by its thread id. We encapsulate these to <code>TaskUserRes</code> data.</p>
<p>We can see many structure need a id allocation, we could design a general id allocator.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/id.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">RecycleAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,</span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> RecycleAllocator &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        RecycleAllocator &#123;</span><br><span class="line">            current: <span class="number">0</span>,</span><br><span class="line">            recycled: <span class="built_in">Vec</span>::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(id) = <span class="keyword">self</span>.recycled.pop() &#123;</span><br><span class="line">            id</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">self</span>.current - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, id: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(id &lt; <span class="keyword">self</span>.current);</span><br><span class="line">        <span class="built_in">assert!</span>(</span><br><span class="line">            !<span class="keyword">self</span>.recycled.iter().any(|i| *i == id),</span><br><span class="line">            <span class="string">"id &#123;&#125; has been deallocated!"</span>,</span><br><span class="line">            id</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">self</span>.recycled.push(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Kernel-Stack-Allocation"><a href="#Kernel-Stack-Allocation" class="headerlink" title="Kernel Stack Allocation"></a>Kernel Stack Allocation</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/id.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> KSTACK_ALLOCATOR: UPSafeCell&lt;RecycleAllocator&gt; =</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; UPSafeCell::new(RecycleAllocator::new()) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KernelStack</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Return (bottom, top) of a kernel stack in kernel space.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_stack_position</span></span>(kstack_id: <span class="built_in">usize</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = TRAMPOLINE - kstack_id * (KERNEL_STACK_SIZE + PAGE_SIZE);</span><br><span class="line">    <span class="keyword">let</span> bottom = top - KERNEL_STACK_SIZE;</span><br><span class="line">    (bottom, top)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kstack_alloc</span></span>() -&gt; KernelStack &#123;</span><br><span class="line">    <span class="keyword">let</span> kstack_id = KSTACK_ALLOCATOR.exclusive_access().alloc();</span><br><span class="line">    <span class="keyword">let</span> (kstack_bottom, kstack_top) = kernel_stack_position(kstack_id);</span><br><span class="line">    KERNEL_SPACE.exclusive_access().insert_framed_area(</span><br><span class="line">        kstack_bottom.into(),</span><br><span class="line">        kstack_top.into(),</span><br><span class="line">        MapPermission::R | MapPermission::W,</span><br><span class="line">    );</span><br><span class="line">    KernelStack(kstack_id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> KernelStack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> (kernel_stack_bottom, _) = kernel_stack_position(<span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> kernel_stack_bottom_va: VirtAddr = kernel_stack_bottom.into();</span><br><span class="line">        KERNEL_SPACE</span><br><span class="line">            .exclusive_access()</span><br><span class="line">            .remove_area_with_start_vpn(kernel_stack_bottom_va.into());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will do the same for user stack:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> TRAMPOLINE: <span class="built_in">usize</span> = <span class="built_in">usize</span>::MAX - PAGE_SIZE + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> TRAP_CONTEXT_BASE: <span class="built_in">usize</span> = TRAMPOLINE - PAGE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/id.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trap_cx_bottom_from_tid</span></span>(tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    TRAP_CONTEXT_BASE - tid * PAGE_SIZE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ustack_bottom_from_tid</span></span>(ustack_base: <span class="built_in">usize</span>, tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    ustack_base + tid * (PAGE_SIZE + USER_STACK_SIZE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then, <code>TaskUserRes</code> could be allocated with trap and user stack.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl TaskUserRes</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_user_res</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> process = <span class="keyword">self</span>.process.upgrade().unwrap();</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">	<span class="comment">// alloc user stack</span></span><br><span class="line">	<span class="keyword">let</span> ustack_bottom = ustack_bottom_from_tid(<span class="keyword">self</span>.ustack_base, <span class="keyword">self</span>.tid);</span><br><span class="line">	<span class="keyword">let</span> ustack_top = ustack_bottom + USER_STACK_SIZE;</span><br><span class="line">	process_inner.memory_set.insert_framed_area(</span><br><span class="line">		ustack_bottom.into(),</span><br><span class="line">		ustack_top.into(),</span><br><span class="line">		MapPermission::R | MapPermission::W | MapPermission::U,</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">// alloc trap_cx</span></span><br><span class="line">	<span class="keyword">let</span> trap_cx_bottom = trap_cx_bottom_from_tid(<span class="keyword">self</span>.tid);</span><br><span class="line">	<span class="keyword">let</span> trap_cx_top = trap_cx_bottom + PAGE_SIZE;</span><br><span class="line">	process_inner.memory_set.insert_framed_area(</span><br><span class="line">		trap_cx_bottom.into(),</span><br><span class="line">		trap_cx_top.into(),</span><br><span class="line">		MapPermission::R | MapPermission::W,</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, combine all things together:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="keyword">pub</span> kstack: KernelStack,</span><br><span class="line">    <span class="comment">// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> res: <span class="built_in">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Design-Data-Operation"><a href="#Design-Data-Operation" class="headerlink" title="Design Data Operation"></a>Design Data Operation</h3><p>We still get one task in operation rather process, because it’s the smallest instance unit. However, we need some interface to control process id.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_task</span></span>(task: Arc&lt;TaskControlBlock&gt;);</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_task</span></span>(task: Arc&lt;TaskControlBlock&gt;);</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_task</span></span>() -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pid2process</span></span>(pid: <span class="built_in">usize</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;ProcessControlBlock&gt;&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">insert_into_pid2process</span></span>(pid: <span class="built_in">usize</span>, process: Arc&lt;ProcessControlBlock&gt;);</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_from_pid2process</span></span>(pid: <span class="built_in">usize</span>);</span><br></pre></td></tr></table></figure>

<p>Actually, many thing is same, for example:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ProcessControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> pid_handle = pid_alloc();</span><br><span class="line">        <span class="keyword">let</span> process = ...;</span><br><span class="line">        <span class="keyword">let</span> task = Arc::new(TaskControlBlock::new(</span><br><span class="line">            Arc::clone(&amp;process),</span><br><span class="line">            ustack_base,</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">        ));</span><br><span class="line">		<span class="comment">// initiation of task...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">        process_inner.tasks.push(<span class="literal">Some</span>(Arc::clone(&amp;task)));</span><br><span class="line">        <span class="built_in">drop</span>(process_inner);</span><br><span class="line">        insert_into_pid2process(process.getpid(), Arc::clone(&amp;process));</span><br><span class="line">        <span class="comment">// add main thread to scheduler</span></span><br><span class="line">        add_task(task);</span><br><span class="line">        process</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we <code>fork</code> a process, we only extract the first task which is itself, so no others will be copied.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) -&gt; Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> child = ...;</span><br><span class="line">	parent.children.push(Arc::clone(&amp;child));</span><br><span class="line">	<span class="keyword">let</span> task = Arc::new(TaskControlBlock::new(</span><br><span class="line">		Arc::clone(&amp;child),</span><br><span class="line">		parent</span><br><span class="line">			.get_task(<span class="number">0</span>)</span><br><span class="line">			.inner_exclusive_access()</span><br><span class="line">			.res</span><br><span class="line">			.as_ref()</span><br><span class="line">			.unwrap()</span><br><span class="line">			.ustack_base(),</span><br><span class="line">		<span class="comment">// here we do not allocate trap_cx or ustack again</span></span><br><span class="line">		<span class="comment">// but mention that we allocate a new kstack here</span></span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">	));</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> child_inner = child.inner_exclusive_access();</span><br><span class="line">	child_inner.tasks.push(<span class="literal">Some</span>(Arc::clone(&amp;task)));</span><br><span class="line">	<span class="built_in">drop</span>(child_inner);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Design-System-Operation"><a href="#Design-System-Operation" class="headerlink" title="Design System Operation"></a>Design System Operation</h3><p>If we want to create a thread, as a naive designer, we only need the function entry addr, and arguments, yes! That’s it!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/thread.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_thread_create</span></span>(entry: <span class="built_in">usize</span>, arg: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> process = task.process.upgrade().unwrap();</span><br><span class="line">    <span class="comment">// create a new thread</span></span><br><span class="line">    <span class="keyword">let</span> new_task = Arc::new(TaskControlBlock::new(</span><br><span class="line">        Arc::clone(&amp;process),</span><br><span class="line">        task.inner_exclusive_access().res.as_ref().unwrap().ustack_base,</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">    ));</span><br><span class="line">    <span class="comment">// add new task to scheduler</span></span><br><span class="line">    add_task(Arc::clone(&amp;new_task));</span><br><span class="line">    <span class="keyword">let</span> new_task_inner = new_task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> new_task_res = new_task_inner.res.as_ref().unwrap();</span><br><span class="line">    <span class="keyword">let</span> new_task_tid = new_task_res.tid;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="comment">// add new thread to current process</span></span><br><span class="line">    <span class="keyword">let</span> tasks = &amp;<span class="keyword">mut</span> process_inner.tasks;</span><br><span class="line">    <span class="keyword">while</span> tasks.len() &lt; new_task_tid + <span class="number">1</span> &#123;</span><br><span class="line">        tasks.push(<span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tasks[new_task_tid] = <span class="literal">Some</span>(Arc::clone(&amp;new_task));</span><br><span class="line">    <span class="keyword">let</span> new_task_trap_cx = new_task_inner.get_trap_cx();</span><br><span class="line">    *new_task_trap_cx = TrapContext::app_init_context(</span><br><span class="line">        entry,</span><br><span class="line">        new_task_res.ustack_top(),</span><br><span class="line">        kernel_token(),</span><br><span class="line">        new_task.kstack.get_top(),</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    (*new_task_trap_cx).x[<span class="number">10</span>] = arg;</span><br><span class="line">    new_task_tid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, <code>sys_exit</code> will receive a <code>exit_code</code> and recycle its resource. Notice, if <code>tid == 0</code>, the thread of process itself will make other sub threads moved to <code>init</code> process.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pub fn exit_current_and_run_next(exit_code: i32) &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> initproc_inner = INITPROC.inner_exclusive_access();</span><br><span class="line">	<span class="keyword">for</span> child <span class="keyword">in</span> process_inner.children.iter() &#123;</span><br><span class="line">		child.inner_exclusive_access().parent = <span class="literal">Some</span>(Arc::downgrade(&amp;INITPROC));</span><br><span class="line">		initproc_inner.children.push(child.clone());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> recycle_res = <span class="built_in">Vec</span>::&lt;TaskUserRes&gt;::new();</span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> process_inner.tasks.iter().filter(|t| t.is_some()) &#123;</span><br><span class="line">	<span class="keyword">let</span> task = task.as_ref().unwrap();</span><br><span class="line">	remove_inactive_task(Arc::clone(&amp;task));</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(res) = task_inner.res.take() &#123;</span><br><span class="line">		recycle_res.push(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sys_waittid</code> will check thread state and recycle if could, return <code>-2</code> if it has not exited. Why need it? Because <code>sys_exit</code> can’t recycle itself unless the thread of process, other thread can call <code>waittid</code> to remove it from tasks queue, then it will be cleared by rust!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/thread.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// thread does not exist, return -1</span></span><br><span class="line"><span class="comment">/// thread has not exited yet, return -2</span></span><br><span class="line"><span class="comment">/// otherwise, return thread's exit code</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waittid</span></span>(tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> process = task.process.upgrade().unwrap();</span><br><span class="line">    <span class="keyword">let</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="comment">// a thread cannot wait for itself</span></span><br><span class="line">    <span class="keyword">if</span> task_inner.res.as_ref().unwrap().tid == tid &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> exit_code: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> waited_task = process_inner.tasks[tid].as_ref();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(waited_task) = waited_task &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(waited_exit_code) = waited_task.inner_exclusive_access().exit_code &#123;</span><br><span class="line">            exit_code = <span class="literal">Some</span>(waited_exit_code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// waited thread does not exist</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(exit_code) = exit_code &#123;</span><br><span class="line">        <span class="comment">// dealloc the exited thread</span></span><br><span class="line">        process_inner.tasks[tid] = <span class="literal">None</span>;</span><br><span class="line">        exit_code</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// waited thread has not exited</span></span><br><span class="line">        -<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap8-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap8-2/" class="post-title-link" itemprop="url">rcore-handnote-8-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-8-2"><a href="#Chapter-8-2" class="headerlink" title="Chapter 8-2"></a>Chapter 8-2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We will develop exclusion mechanism previously mentioned.</p>
<p>Beside construction, we need to abstract possible situation of data sharing. A usual native thought is a thread want to modify one thing but due to thread switch, the data is already modified and we get wrong result. So based on this, we want a operation to be <strong>Atomic</strong>, which means the operation excluding others. Now we can alleviate this restriction and generalize this.</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>Generalization:</p>
<ul>
<li>Allow multiple but finite thread can join one atomic operation.</li>
<li>Allow condition of atomic operation.</li>
</ul>
<p>Before such generalization, we want a way to represent atomic operation. We call the content of this operation <strong>Critical Section</strong>, and multiple threads operations in indeterminate time sequence <strong>Race Condition</strong>. So the basic problem of data sharing push us to identify multiple different operations by different threads, we can’t restrict data because the problem is on modification by threads, we need to <strong>Lock</strong> operations!</p>
<p>So, it there’s a lock sharing by threads, each threads can declare <strong>Lock it!</strong>, and no other threads can access this thread again.</p>
<p>Now, back to our generalization. If this lock has a bound of access number, many can access until reaching a bound. That’s also a reasonable design, we call this <strong>Semaphore</strong>; If this lock has a signal which one thread can send it to others to allow others to access it, That’s also a reasonable design, we call this <strong>Condition Variable</strong>.</p>
<p>If the real minimal sharing thing is <strong>Lock</strong> rather than data, we can discard so called data problem, and focus on lock itself, each threads can do anything in this lock and excluding others.</p>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>No matter which kinds of lock, this is shared among threads.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    <span class="comment">// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> lock_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Lock&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;LockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LockInner</span></span> &#123;</span><br><span class="line">	<span class="keyword">pub</span> data: ...</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In such design, one lock can push one thread to  <code>wait_queue</code> to stop it, and pop front to start it. <code>data</code> is a generalization for various locks.</p>
<p>Then, in one process, it owns many locks used in various conditions, one can easily take it as a generalization of many data(actually nothing related to real data) we want to share.</p>
<h3 id="Basic-Lock"><a href="#Basic-Lock" class="headerlink" title="Basic Lock"></a>Basic Lock</h3><p>Now, we want to construct a basic lock allowing simple <code>lock</code>, <code>unlock</code> operation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Mutex</span></span>: <span class="built_in">Sync</span> + <span class="built_in">Send</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, there’s U-level, M-level, S-level implementation. First, we gonna try first one easily, knowing the heuristic design of M-level, and extend basic thought to S-level.</p>
<hr>
<h4 id="U-level"><a href="#U-level" class="headerlink" title="U-level"></a>U-level</h4><p>A naive approach is to declare a global boolean indicating block state. <code>lock</code> will wait if the boolean is true and try to set it to true, and <code>unlock</code> will set it to false to release.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> mutex :<span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(mutex: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (mutex);</span><br><span class="line">    mutex = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(mutex: <span class="built_in">i32</span>)&#123;</span><br><span class="line">    mutex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, that’s wrong! We can’t construct lock by things we want to lock! Threads can jump in any instructions and break it! That’s means we can’t do it in U-level? We should ponder further in real situation, imagine two threads modify one thing in nearly same time, if we could set two global state in a operation that excluding each other(for example, one state set to 1 and another state set to 0), then only one operation can really be implemented and we can check this condition, allow it to get the lock.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> flag : [<span class="built_in">i32</span>;<span class="number">2</span>] = [<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">// 哪个线程想拿到锁？</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> turn : <span class="built_in">i32</span> = <span class="number">0</span>;         <span class="comment">// 排号：轮到哪个线程? (线程 0 or 1?)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>() &#123;</span><br><span class="line">    flag[<span class="keyword">self</span>] = <span class="number">1</span>;             <span class="comment">// 设置自己想取锁 self: 线程 ID</span></span><br><span class="line">    turn = <span class="number">1</span> - <span class="keyword">self</span>;            <span class="comment">// 设置另外一个线程先排号</span></span><br><span class="line">    <span class="keyword">while</span> ((flag[<span class="number">1</span>-<span class="keyword">self</span>] == <span class="number">1</span>) &amp;&amp; (turn == <span class="number">1</span> - <span class="keyword">self</span>)); <span class="comment">// 忙等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>() &#123;</span><br><span class="line">    flag[<span class="keyword">self</span>] = <span class="number">0</span>;             <span class="comment">// 设置自己放弃锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now analyze the code, we find that no matter which flag is 1, or both 1, indicating certain thread want to get lock, <code>turn</code> will be a excluding state to <code>flag</code>, which means if another thread modify <code>turn</code> in same time, the turn can only be in one of the state and only one thread can get the lock.</p>
<hr>
<h4 id="M-level"><a href="#M-level" class="headerlink" title="M-level"></a>M-level</h4><p>Is there any predefined operation in instructions that is atomic? Then we can use it as a lock. The answer is <strong>Yes</strong>, in RISC-V, it’s:</p>
<ul>
<li>AMO: Atomic memory operation</li>
<li>LR/SC: Load Reserved/Store Conditional</li>
</ul>
<p><strong>AMO</strong>: will read the value in memory and write new value, then store the old value to target register(s.t. <code>amoadd.w rd, rs2, (rs1)</code>). </p>
<p><strong>LR/SC</strong>: <strong>LR</strong> will read memory and store in target register, and leave the addr of this memory, then <strong>SC</strong> could check the addr and write data to this addr, output a condition(0/1) to target register.(s.t. <code>lr.w rd, (rs1)</code>, <code>sc.w rd, rs2, (rs1)</code>)</p>
<p>We can use it to implement a atomic function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># RISC-V sequence for implementing a TAS  at (s1)</span><br><span class="line">li t2, 1                 # t2 &lt;-- 1</span><br><span class="line">Try: lr  t1, s1          # t1 &lt;-- mem[s1]  (load reserved)</span><br><span class="line">        bne t1, x0, Try     # if t1 !&#x3D; 0, goto Try:</span><br><span class="line">        sc  t0, s1, t2      # mem[s1] &lt;-- t2  (store conditional)</span><br><span class="line">        bne t0, x0, Try     # if t0 !&#x3D;0 (&#39;sc&#39; Instr failed), goto Try:</span><br><span class="line">Locked:</span><br><span class="line">        ...                 # critical section</span><br><span class="line">Unlock:</span><br><span class="line">        sw x0,0(s1)         # mem[s1] &lt;-- 0</span><br></pre></td></tr></table></figure>

<p>Here the logic of <code>Try</code> is <code>mem[s1]</code> would be zero if it’s unlocked, and would be non-zero if it’s locked. So, <code>Try</code> will compare <code>t1</code> and <code>x0</code>, actually <code>mem[s1]</code> and <code>0</code>, if equal to zero, then try to store <code>t2</code> into <code>s1</code>, if succeed, it will compare it again for the output signal <code>t0</code> and <code>x0</code>, actually the output signal and <code>0</code>, if succeed, it will jump out otherwise repeat.In this process, if the write operation failed, <code>t0</code> would be non-zero, and repeat in <code>Try</code>.</p>
<p>If we want to <code>Unlock</code>, we write <code>x0</code> to <code>s1</code> to set <code>mem[s1]</code> to zero. Which is the unlocked state.</p>
<h4 id="S-level"><a href="#S-level" class="headerlink" title="S-level"></a>S-level</h4><p>Then we could take the function to rust and package it. A simple refactor is when we in repetition loop, we <code>yield</code>, and give CPU to others.</p>
<hr>
<p>Now, for any kinds of locks, we could apply it to our structure.</p>
<p>First, when we create a lock, we create and push it to list or set in empty element.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_create</span></span>(blocking: <span class="built_in">bool</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> mutex: <span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt; = <span class="keyword">if</span> !blocking &#123;</span><br><span class="line">        <span class="literal">Some</span>(Arc::new(MutexSpin::new()))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Some</span>(Arc::new(MutexBlocking::new()))</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(id) = process_inner</span><br><span class="line">        .mutex_list</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .find(|(_, item)| item.is_none())</span><br><span class="line">        .map(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.mutex_list[id] = mutex;</span><br><span class="line">        id <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner.mutex_list.push(mutex);</span><br><span class="line">        process_inner.mutex_list.len() <span class="keyword">as</span> <span class="built_in">isize</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When we call <code>lock</code>, we should provide corresponding id of the lock, if it’s already locked, we push to <code>wait_queue</code>, else we lock it and goes on.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_lock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(process_inner);</span><br><span class="line">    <span class="built_in">drop</span>(process);</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// os/src/sync/mutex.rs</span></span><br><span class="line"><span class="keyword">impl</span> Lock <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> mutex_inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">        <span class="keyword">if</span> ... &#123;</span><br><span class="line">            mutex_inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">			<span class="comment">// ... other operations</span></span><br><span class="line">            <span class="built_in">drop</span>(mutex_inner);</span><br><span class="line">            block_current_and_run_next();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// ... other operations</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Same reverse operation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_unlock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(process_inner);</span><br><span class="line">    <span class="built_in">drop</span>(process);</span><br><span class="line">    mutex.unlock();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// os/src/sync/mutex.rs</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> mutex_inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">		<span class="comment">// ... other operation</span></span><br><span class="line">		<span class="keyword">if</span> ... &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(waking_task) = mutex_inner.wait_queue.pop_front() &#123;</span><br><span class="line">				add_task(waking_task);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>It’s simple, we only need to switch boolean to number and check the bound. So, the initiated count is the bound, if one thread access, it will minus one, and release, add one. We only need to check positive or negative.</p>
<p>Apply our structure:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">up</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = inner.wait_queue.pop_front() &#123;</span><br><span class="line">            add_task(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">down</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt; <span class="number">0</span> &#123;</span><br><span class="line">        inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">        <span class="built_in">drop</span>(inner);</span><br><span class="line">        block_current_and_run_next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the initiated count equal to <code>1</code>, we back to <code>mutex</code>!, which indicates sole thread access!</p>
<p>Actually, we could use it for <strong>synchronization</strong> operation, we set count to <code>0</code>, if one thread access, it will be blocked, and another thread will could release and add one to count, then the original thread finally could access. Then the second thread will always be advanced to first one.</p>
<p>Here, the first is always advanced to second.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SEM_SYNC: <span class="built_in">usize</span> = <span class="number">0</span>; <span class="comment">//信号量ID</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">first</span></span>() -&gt; ! &#123;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"First work and wakeup Second"</span>);</span><br><span class="line">    semaphore_up(SEM_SYNC); <span class="comment">//信号量V操作</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">second</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second want to continue,but need to wait first"</span>);</span><br><span class="line">    semaphore_down(SEM_SYNC); <span class="comment">//信号量P操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second can work now"</span>);</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Conditional-Variable"><a href="#Conditional-Variable" class="headerlink" title="Conditional Variable"></a>Conditional Variable</h3><p>If we want one thread owns the ability of release lock for others, we need the <code>CondVar</code>. We have to dispatch operation in <code>wait_queue</code>, if one thread <code>signal</code> others, it will pop out a thread, which means trigger it <strong>You are free!</strong>. And if one thread <code>wait</code>, it will push itself to queue to <strong>wait</strong>, The unlock and lock is important because in wait operation, it allow other thread to modify <strong>condition</strong>, but it should be after of the push operation, in case that the signal is before the push, then we can never receive the signal again! We won’t encapsulate condition check to <code>CondVar</code> because it should leave to user to design it, we only leave out interface for user.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">signal</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = inner.wait_queue.pop_front() &#123;</span><br><span class="line">		add_task(task);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(&amp;<span class="keyword">self</span>, mutex: Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(inner);</span><br><span class="line">    mutex.unlock();                 </span><br><span class="line">    block_current_and_run_next();</span><br><span class="line">    mutex.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, if condition check is leave out to user, we can’t ensure the condition be violated due to data sharing, so usually we need to append <code>mutex</code> lock for this section.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> A: <span class="built_in">usize</span> = <span class="number">0</span>;   <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONDVAR_ID: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> MUTEX_ID: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">first</span></span>() -&gt; ! &#123;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"First work, Change A --&gt; 1 and wakeup Second"</span>);</span><br><span class="line">    mutex_lock(MUTEX_ID);</span><br><span class="line">    A=<span class="number">1</span>;</span><br><span class="line">    condvar_signal(CONDVAR_ID);</span><br><span class="line">    mutex_unlock(MUTEX_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">second</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second want to continue,but need to wait A=1"</span>);</span><br><span class="line">    mutex_lock(MUTEX_ID);</span><br><span class="line">    <span class="keyword">while</span> A==<span class="number">0</span> &#123;</span><br><span class="line">        condvar_wait(CONDVAR_ID, MUTEX_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(MUTEX_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that if <code>A=1</code>, second won’t <code>wait</code> repeatly, and goes out.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/day-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/day-1/" class="post-title-link" itemprop="url">arceos-handnote-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day-1"></a>Day-1</h2><h2 id="Component-Kernel"><a href="#Component-Kernel" class="headerlink" title="Component Kernel"></a>Component Kernel</h2><p>Based on experiment, we will construct kernel in increment by demand.</p>
<ul>
<li><strong>UniKernel</strong>: Single S-Level, App is within kernel.</li>
</ul>
<p>Each kernel instance can be considered as a construction based on unikernel.</p>
<ul>
<li><strong>MacroKernel</strong>: Manage U-Level with support on multiple apps, process management etc…</li>
<li><strong>Hypervisor</strong>: Virtual state with restricted communication between U-level and S-level.</li>
</ul>
<h2 id="Aceros-Design"><a href="#Aceros-Design" class="headerlink" title="Aceros Design"></a>Aceros Design</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    App &lt;--&gt; Runtime</span><br><span class="line">    Runtime &lt;--&gt; HAL</span><br></pre></td></tr></table></figure>
<p>The design of Aceros is simple, first <strong>HAL</strong>(<code>axhal</code>) is the abstraction of hardware to initiation trap, stack, MMU, registers based on various architectures. Then <strong>Runtime</strong>(<code>ax*</code>) will be classified as many components to support various environments, like net, task, fs etc…</p>
<p>Each arrow is reversible, in boot, it will be from bottom to top to initiate App. Then when App call something, it will be from top to bottom to evoke functionality.</p>
<p>In real situation, we choose thing based on <em>features</em>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">	App --&gt; axstd</span><br><span class="line">	axstd --&gt; |axfeat| aceros_api</span><br><span class="line">	aceros_api --&gt; axruntime</span><br><span class="line">	axruntime --&gt;|alloc| axalloc</span><br><span class="line">	axruntime --&gt; axhal</span><br><span class="line">	axruntime --&gt;|irq| irq</span><br><span class="line">	axruntime --&gt;|multitask| axtask</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/day-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/day-2/" class="post-title-link" itemprop="url">arceos-handnote-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day-2"></a>Day-2</h2><h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>We delve into paging.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Physical address for pflash#1</span></span><br><span class="line"><span class="keyword">const</span> PFLASH_START: <span class="built_in">usize</span> = <span class="number">0x2200_0000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg_attr(feature = <span class="meta-string">"axstd"</span>, no_mangle)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Makesure that we can access pflash region.</span></span><br><span class="line">    <span class="keyword">let</span> va = phys_to_virt(PFLASH_START.into()).as_usize();</span><br><span class="line">    <span class="keyword">let</span> ptr = va <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Try to access dev region [&#123;:#X&#125;], got &#123;:#X&#125;"</span>, va, *ptr);</span><br><span class="line">        <span class="keyword">let</span> magic = mem::transmute::&lt;<span class="built_in">u32</span>, [<span class="built_in">u8</span>; <span class="number">4</span>]&gt;(*ptr);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got pflash magic: &#123;&#125;"</span>, <span class="built_in">str</span>::from_utf8(&amp;magic).unwrap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PFlash</strong> is the simulation of flash memory of qemu. When qemu boot, it will automatically load file to fixed <strong>MMIO</strong>, and can be directly accessed.</p>
<p><strong>Paging</strong>: <code>feature = [&quot;paging&quot;]</code> is the way to evoke virtual memory management tu support <code>MMIO</code>. Located in <code>axruntime</code>.</p>
<p>The workflow would be:</p>
<ul>
<li>qemu fdt: from <code>0x0c00_0000</code> to <code>0x3000_0000</code>. Construct the space of device.</li>
<li>SBI: from <code>0x8000_0000</code> to <code>0x8020_0000</code>. RISC-V <strong>Supervisor Binary Interface</strong>, it construct a interface for programming language to manipulate device level things.</li>
<li>Kernel Image: from <code>0x8020_0000</code>. <code>_skernel</code> contains S-level things like static data, code etc… <code>_ekernel</code> is user thing.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[link_section = <span class="meta-string">".data.boot_page_table"</span>]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> BOOT_PT_SV39: [<span class="built_in">u64</span>; <span class="number">512</span>] = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_boot_page_table</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 0x8000_0000..0xc000_0000, VRWX_GAD, 1G block</span></span><br><span class="line">    BOOT_PT_SV39[<span class="number">2</span>] = (<span class="number">0x80000</span> &lt;&lt; <span class="number">10</span>) | <span class="number">0xef</span>;</span><br><span class="line">    <span class="comment">// 0xffff_ffc0_8000_0000..0xffff_ffc0_c000_0000, VRWX_GAD, 1G block</span></span><br><span class="line">	<span class="comment">// shift 10 bits to store flags</span></span><br><span class="line">    BOOT_PT_SV39[<span class="number">0x102</span>] = (<span class="number">0x80000</span> &lt;&lt; <span class="number">10</span>) | <span class="number">0xef</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_mmu</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> page_table_root = BOOT_PT_SV39.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">    satp::set(satp::Mode::Sv39, <span class="number">0</span>, page_table_root &gt;&gt; <span class="number">12</span>);</span><br><span class="line">    riscv::asm::sfence_vma_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each entry of page table will map 1G(<code>0x4000_0000</code>) memory. From <code>0x8000_0000</code> to <code>0xc0000_0000</code> at <code>pgd_idx = 2</code> to <code>0xffff_ffc0_8000_0000</code> to <code>0xffff_ffc0_c000_0000</code> at <code>pgd_idx = 102</code>. This will map to a bigger range.</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Spawned-thread ..."</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Makesure that we can access pflash region.</span></span><br><span class="line">	<span class="keyword">let</span> va = phys_to_virt(PFLASH_START.into()).as_usize();</span><br><span class="line">	<span class="keyword">let</span> ptr = va <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u32</span>;</span><br><span class="line">	<span class="keyword">let</span> magic = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">		mem::transmute::&lt;<span class="built_in">u32</span>, [<span class="built_in">u8</span>; <span class="number">4</span>]&gt;(*ptr)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(s) = <span class="built_in">str</span>::from_utf8(&amp;magic) &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Got pflash magic: &#123;s&#125;"</span>);</span><br><span class="line">		<span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		-<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Each task will be in concurrency and dispatched by strategy. If it’s blocked, it will be moved to <code>wait_queue</code> to wait. If it’s ready, it will be moved to <code>run_queue</code> which is scheduler to be dispatched.</p>
<h3 id="Message-Communication"><a href="#Message-Communication" class="headerlink" title="Message Communication"></a>Message Communication</h3><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q1 = Arc::new(SpinNoIrq::new(VecDeque::new()));</span><br><span class="line"><span class="keyword">let</span> q2 = q1.clone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> worker1 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"worker1 ..."</span>);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..=LOOP_NUM &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"worker1 [&#123;i&#125;]"</span>);</span><br><span class="line">        q1.lock().push_back(i);</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> If worker1 doesn't yield, others have</span></span><br><span class="line">        <span class="comment">// no chance to run until it exits!</span></span><br><span class="line">        thread::yield_now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"worker1 ok!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> worker2 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"worker2 ..."</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(num) = q2.lock().pop_front() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"worker2 [&#123;num&#125;]"</span>);</span><br><span class="line">            <span class="keyword">if</span> num == LOOP_NUM &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"worker2: nothing to do!"</span>);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> it should sleep and wait for notify!</span></span><br><span class="line">            thread::yield_now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"worker2 ok!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Cooperative Scheduling</strong>: Each tasks kindly yield themselves or exit otherwise it will block everyone because the power of CPU occupation is ownned by each tasks.</p>
<p><strong>Preemptive Scheduling</strong>: Each tasks will be automatically suspended by external condition: No lock, no device access; inner condition: run out of current time slice. We can use a <code>disable_count</code> to record this, even for multiple condition restriction, we can sum them up.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axhal::irq::register_handler(TIMER_IRQ_NUM, || &#123;</span><br><span class="line">    update_timer();</span><br><span class="line">    <span class="meta">#[cfg(feature = <span class="meta-string">"multitask"</span>)]</span></span><br><span class="line">    axtask::on_timer_tick();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable IRQs before starting app</span></span><br><span class="line">axhal::arch::enable_irqs()</span><br></pre></td></tr></table></figure>

<p><code>on_timer_tick</code> will be trigger in time slice. When time ticker ticks, <code>run_queue</code> will check and suspend task if possible.</p>
<p>We can make it more dynamic. Which means each task has priority and during the implementation of cpu, each task has a <code>vruntime</code> to be dynamically adjusted by <code>init_vruntime + (delta/weight(nice))</code> where <code>delta</code> and <code>nice</code> are dynamic adjustment number. <code>delta</code> will be incremented by <code>timer</code>, <code>weight(nice)</code> is actually the priority of the task. We ensure that task with lowest <code>vruntime</code> will be placed at top.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/day-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/day-3/" class="post-title-link" itemprop="url">arceos-handnote-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day-3"></a>Day-3</h2><h2 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h2><p>In common, devices can be separated to <strong>FS</strong>, <strong>Net</strong>, <strong>Dispaly</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A structure that contains all device drivers, organized by their category.</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AllDevices</span></span> &#123;</span><br><span class="line">    <span class="comment">/// All network device drivers.</span></span><br><span class="line">    <span class="meta">#[cfg(feature = <span class="meta-string">"net"</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> net: AxDeviceContainer&lt;AxNetDevice&gt;,</span><br><span class="line">    <span class="comment">/// All block device drivers.</span></span><br><span class="line">    <span class="meta">#[cfg(feature = <span class="meta-string">"block"</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> block: AxDeviceContainer&lt;AxBlockDevice&gt;,</span><br><span class="line">    <span class="comment">/// All graphics device drivers.</span></span><br><span class="line">    <span class="meta">#[cfg(feature = <span class="meta-string">"display"</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> display: AxDeviceContainer&lt;AxDisplayDevice&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Devices will be initiated in <code>axruntime</code>, where <code>axdriver</code> module will be loaded to seek each device and mount drivers.</p>
<p>In qemu, <code>virtio-mmio</code> will send request to probe driver response otherwise return 0 as non-driver.</p>
<h3 id="Block-Driver"><a href="#Block-Driver" class="headerlink" title="Block Driver"></a>Block Driver</h3><p>Block driver provide interface to write and read block providing IO operations and perennial storage.</p>
<p>Aceros use module <code>axfs</code>, with definition of interface <code>vfs</code>, and concrete implementation of <code>ramfs</code> and <code>devfs</code>.</p>
<h2 id="Monolith"><a href="#Monolith" class="headerlink" title="Monolith"></a>Monolith</h2><p>In U-Level, we will separate kernel memory and user memory, allowing user context used for process.</p>
<p>The basic logic would be construct new user space,load file to it and initiate user stack, then spawn user task with app_entry.</p>
<p>The top of page root would be shared as kernel space, and below would be independent as user space.</p>
<p>In user space separation, many kinds of resources can’t be shared as global resources, rather the demand of <code>TaskExt</code> as a reference to those independent resources owned by each user apps.</p>
<p>In <code>TaskInner</code>, we store the ptr of <code>TaskExt</code> by macro declaration of such type.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AxTask</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    task_ext_ptr: *<span class="keyword">mut</span> <span class="built_in">u8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Task extended data for the monolithic kernel.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskExt</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The process ID.</span></span><br><span class="line">    <span class="keyword">pub</span> proc_id: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="comment">/// The user space context.</span></span><br><span class="line">    <span class="keyword">pub</span> uctx: UspaceContext,</span><br><span class="line">    <span class="comment">/// The virtual memory address space.</span></span><br><span class="line">    <span class="keyword">pub</span> aspace: Arc&lt;Mutex&lt;AddrSpace&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// It will expanded as a trait implmentation of reference to ptr as the `TaskExt` type.</span></span><br><span class="line">def_task_ext!(TaskExt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn_user_task</span></span>(aspace: Arc&lt;Mutex&lt;AddrSpace&gt;&gt;, uctx: UspaceContext) -&gt; AxTaskRef &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task = TaskInner::new(</span><br><span class="line">        || &#123;</span><br><span class="line">            <span class="keyword">let</span> curr = axtask::current();</span><br><span class="line">            <span class="keyword">let</span> kstack_top = curr.kernel_stack_top().unwrap();</span><br><span class="line">            ax_println!(</span><br><span class="line">                <span class="string">"Enter user space: entry=&#123;:#x&#125;, ustack=&#123;:#x&#125;, kstack=&#123;:#x&#125;"</span>,</span><br><span class="line">                curr.task_ext().uctx.get_ip(),</span><br><span class="line">                curr.task_ext().uctx.get_sp(),</span><br><span class="line">                kstack_top,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">unsafe</span> &#123; curr.task_ext().uctx.enter_uspace(kstack_top) &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"userboot"</span>.into(),</span><br><span class="line">        crate::KERNEL_STACK_SIZE,</span><br><span class="line">    );</span><br><span class="line">    task.ctx_mut()</span><br><span class="line">        .set_page_table_root(aspace.lock().page_table_root());</span><br><span class="line">    task.init_task_ext(TaskExt::new(uctx, aspace));</span><br><span class="line">    axtask::spawn_task(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h3><p>To reuse resources, we will construct a <code>axns_resource</code> section in compilation to form a global namespace. Each will be shared by <code>Arc::new()</code>.</p>
<p>If there’s a demand of uniqueness, we will allocate space and copy them.</p>
<h3 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h3><p>We could implement lazy allocation of user space memory. We register <code>PAGE_FAULT</code> for our function and call <code>handle_page_fault</code> for <code>AddrSpace</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> AddrSpace</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">handle_page_fault</span></span>(...) -&gt; ...</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(area) = <span class="keyword">self</span>.areas.find(vaddr) &#123;</span><br><span class="line">            <span class="keyword">let</span> orig_flags = area.flags();</span><br><span class="line">            <span class="keyword">if</span> orig_flags.contains(access_flags) &#123;</span><br><span class="line">                <span class="keyword">return</span> area</span><br><span class="line">                    .backend()</span><br><span class="line">                    .handle_page_fault(vaddr, orig_flags, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.pt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>MemoryArea</code> has two way:</p>
<ul>
<li>Linear: direct construct map relation of memory based on physical contiguous mmemory.</li>
<li>Alloc: only construct null-map, and call <code>handle_page_fault</code> to really allocate memory.</li>
</ul>
<h3 id="User-App"><a href="#User-App" class="headerlink" title="User App"></a>User App</h3><p><strong>ELF</strong> is the default format of many apps. Kernel take the responsibility to load app to correct region.</p>
<p>Notice the offset of file and virtual space may be different due to optimization of <strong>ELF</strong>.</p>
<p>In order to load apps from linux, we will construct a <strong>Posix Api</strong> given interface mimic to linux.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/day-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/day-4/" class="post-title-link" itemprop="url">arceos-handnote-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day-4"></a>Day-4</h2><h3 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h3><p>A physical computer system can build multiple virtual computer system with its own virtual resources. Just like apps in U-level, each virtual system will consider themselves uniquely occupies these resources.</p>
<p><strong>Emulator</strong> like a interpretor to stimulate a virtual system while in loose demand of efficiency.</p>
<p><strong>Hypervisor</strong> will execute most instructions directly as a isomorphism of the stimulated virtual system to gain a huge efficiency.</p>
<p><strong>*I</strong> type<em>: Each virtual OS is equal on hardware.<br><strong>*II</strong> type</em>: Virtual OS is on host OS. </p>
<p>Each instance as <strong>Guest(OS Image)</strong> be loaded on our host os kernel.</p>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>Only focus on hypervisor(I type).</p>
<p>Levels are extended, because we need to separate host and guest, so U-Level become U, VU-Level. So does the kernel level because we need to separate host, the hypervisor and guest, the virtual OS. So S-Level become HS, VS-Level.</p>
<h4 id="Communication"><a href="#Communication" class="headerlink" title="Communication"></a>Communication</h4><p>Instructions will be implemented in communication of <code>HS</code> and <code>VS</code>, when there’s a <code>sbi-call</code>, <code>VS</code> will communicate <code>HS</code> to implement.</p>
<p>In <code>hstatus</code> of RISC-V, design the virtualization mode:</p>
<p><code>SPV</code>: the source of <code>HS</code> or <code>VS</code>, which determines the <code>sret</code> to <code>VU</code> or <code>U</code>.<br><code>SPVP</code>: the permission of modification of memory that <code>HS</code> to <code>V</code>.</p>
<p>We need to store guest context and host context, then switch between <code>ret(VM-Exit)</code> and <code>sret</code>. We implement this by <code>run_guest</code> and <code>guest_exit</code> which both is the other’s reverse.</p>
<hr>
<p>Timer will be injected to <code>sbi-call</code> by setting a virtual clock in <code>VS</code>, when <code>set timer</code>, we clear timer of guest and set timer of host; when <code>interrupt</code>, we set clear timer of host and set timer of guest waiting for next request of timer.</p>
<hr>
<p>Memory will be separated based on guest and host too. <code>GVA</code> will be a map of <code>GPA</code> as guest memory. However, <code>HPA</code> take responsibility of handle <code>GPA</code> as the virtualization process.</p>
<hr>
<p>Dev will record each start <code>vaddr</code> and when <code>VM-Exit</code> of <code>PageFault</code>, it will find<code>vmdevs.find(addr)</code> and call <code>handle_mmio</code> for corresponding request.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/25/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A53%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/25/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A53%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/" class="post-title-link" itemprop="url">2025春夏开源操作系统训练营3阶段总结-明扬</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-25 22:33:44" itemprop="dateCreated datePublished" datetime="2025-04-25T22:33:44+00:00">2025-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:28" itemprop="dateModified" datetime="2025-12-04T08:46:28+00:00">2025-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h1><p>十多年前的一个下午，我坐在电脑前，刷完了所有周常任务。游戏公会里最后一位成员下线回老家吃饭。连续在线十几个小时后，我退出游戏、关掉电源，一股巨大的空虚感突然涌上心头。</p>
<p>我毕业于青岛一所专科院校计算机专业，从达内培训班结业后，进入一家对日外包公司，维护着1995年开发的VB6.0程序。在青岛，月薪三千元省吃俭用才能勉强度日。我总觉得自己的能力不止于此，人生不该是这副模样。</p>
<p>想要改变却毫无方向，既缺资源又缺机会。</p>
<p>后来在网上翻帖，听说《计算机程序设计艺术》是计算机领域的圣经。这位没有方向的年轻人，决定啃下这部巨著。它的作者是图灵奖得主、算法领域先驱、被誉为”算法之父”的Donald E. Knuth。为配合本书，作者甚至专门编写了配套教材《具体数学》。我买来这本书，却只坚持读了一天就放弃了。</p>
<p>找不到《具体数学》的公开课，偶然发现其目录与离散数学相似。得知清华大学在学堂在线开设《组合数学》课程，我立即报名并完成学习。同时在知乎了解到，若想补充编译原理知识，可学习《SICP》，便买来这本书跟着上古录像学了前三章。</p>
<p>这两门课让我获得薪资六倍的offer，从青岛搬到上海加入创业公司。如今从业十余年，从外包程序员到前端/全栈工程师，再到系统架构师，甚至担任过CTO。相较于起点，这或许算得上逆袭。</p>
<p>但命运的齿轮究竟何时开始转动？</p>
<p>是关闭游戏感到空虚的那个下午？还是买下《具体数学》翻开扉页的那天？</p>
<p>都不是。我始终认为，命运的齿轮真正转动始于报名《组合数学》课程的那一刻。</p>
<p>现在问参加操作系统训练营的同学们：你们是否已感受到命运齿轮开始转动？</p>
<h1 id="通关攻略"><a href="#通关攻略" class="headerlink" title="通关攻略"></a>通关攻略</h1><p>当今社会被资本构建的信息茧房笼罩，每天被Python编程课广告轰炸，甚至上万的AI课程、数千元的知识星球…所谓大厂高P讲师们坐享时代红利，利用信息不对称收割韭菜，教材却是东拼西凑、充斥大量错误和误导的八股文。</p>
<p>而一流大学的优质课程免费开放却鲜为人知。恭喜诸位突破信息茧房，本次训练营依托清华大学操作系统课程，配有专业师资团队。</p>
<p>登录官网可见先修要求：</p>
<ul>
<li>Rust语言基础</li>
<li>计算机组成与设计</li>
<li>RISC-V 汇编特权指令集</li>
</ul>
<p>但作为注重实践的训练营，最终考核是完成操作系统实现并在QEMU验证。还有一些官网未提及的隐藏门槛：</p>
<ul>
<li>Git：是否熟练掌握<code>commit</code>/<code>checkout</code>/<code>branch</code>/<code>merge</code>/<code>rebase</code>等操作？</li>
<li>Linux：是否有使用经验并熟悉常用命令？</li>
<li>英语：能否阅读英文文档（即使借助翻译工具）？</li>
<li>编码与调试：是否具备万行代码经验，能否将代码拆分到多个函数和文件？</li>
<li>网络：是否能无障碍访问国际互联网，并为开发工具配置代理或镜像源？</li>
<li>提问：能否精准描述问题并明确所需帮助？</li>
</ul>
<p>每项技能至少需要10小时学习投入。若缺少其中任何一项，实验过程中将需要付出更多时间精力来补足。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感谢陈渝、向勇、石磊等教授开设课程，感谢李明老师推广宣传，感谢助教团队的付出。这门课程：</p>
<ul>
<li>于国：培养操作系统人才，助力科技自立自强</li>
<li>于民：促进教育公平，让教育资源匮乏地区的学生获得一流课程</li>
<li>于我：这个专科生终于能与985/211学生站在同一起跑线。过去总抱怨命运不公，如今证明自己的机会就在眼前——我只需全力以赴。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/25/2025OS%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95-%E5%88%98%E7%A7%91%E8%BF%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/25/2025OS%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95-%E5%88%98%E7%A7%91%E8%BF%AA/" class="post-title-link" itemprop="url">2025OS训练营一阶段记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-25 17:21:55" itemprop="dateCreated datePublished" datetime="2025-04-25T17:21:55+00:00">2025-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-04 08:46:27" itemprop="dateModified" datetime="2025-12-04T08:46:27+00:00">2025-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/catogory/" itemprop="url" rel="index"><span itemprop="name"><catogory></span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025OS训练营一阶段记录"><a href="#2025OS训练营一阶段记录" class="headerlink" title="2025OS训练营一阶段记录"></a>2025OS训练营一阶段记录</h1><p>说明一下，我是提前为训练营做准备，所以记录时间比开营要早，毕竟以我这种基础不笨鸟先飞怕跟不上哈哈。</p>
<h2 id="3-12"><a href="#3-12" class="headerlink" title="3.12"></a>3.12</h2><p>今天开始学Rust，之前对这个语言也没咋接触过，但是之前学过点go，都是函数式编程，应该有相通处吧。</p>
<p>我找了经验贴都说看course.rs的Rust圣经，于是按照提示搭建了下环境，我用的是ubuntu20.04，装起环境没有碰到什么问题。还跟着作者用vscode，装了几个推荐的插件。</p>
<p>了解了cargo 跑了下helloworld，之前写c++的，每次都被环境折腾的不行，找不到的包还要自己手动编译，而且是win环境下…不会写makefile还要用cmake，这东西更新还快，每种库外部文件导入方式还不一样，可能被折磨习惯了觉得这很正常。原来现在的编程语言能做到这么厉害，不仅不用自己编译，手动导入，连库的可用性也会检测。而且rust还有媲美c++的性能，太厉害了！编译的方式也非常简单，toml的依赖方式也比任何语言的依赖方式都要简单。Rust 原生支持 UTF-8 编码的字符串，可以很容易的使用世界各国文字作为字符串内容，再也不用被msvc的字符集问题折腾了。{}作为占位符，数字、字符串、结构体都能打印。rust有很好的链式编程特性，标准库的函数熟练运用起来应该非常方便优雅。</p>
<p>第一章变量绑定与解构。变量默认不可变 ：Rust变量默认不能修改，必须加<code>mut</code>才能变成可变变量。这个设计挺特别的，一开始不习惯但确实能避免很多意外修改的bug。变量遮蔽：可以用同名变量覆盖之前的变量，实际上是创建了新变量。和<code>mut</code>的区别在于会创建新内存空间，还能用来改变变量类型。解构赋值 ：可以从元组、结构体等复杂类型中提取值赋给变量，写法很简洁。常量 ：用<code>const</code>声明，必须指定类型，命名习惯是全大写加下划线。命名规范 ：下划线开头的变量名可以避免未使用变量的警告。</p>
<p>整体感觉Rust的变量系统设计得很严谨，虽然开始有点不习惯，但这些特性确实能写出更安全的代码。特别是默认不可变这个设计，强迫开发者想清楚哪些变量真的需要修改。</p>
<p>第二章基本类型。基本类型与c++没什么差别，特别的就是单元类型 <code>()</code> ，其唯一的值也是 <code>()</code>。rust编译器必须在编译期知道我们所有变量的类型，但这不意味着需要为每个变量指定类型，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注。在整数上，在release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（<em>two’s complement wrapping</em>）的规则处理，也有一些函数用来检查溢出。在处理浮点数计算时要相当注意。NaN为数学上为定义，与之交互都会成为NaN。</p>
<p>我注意到range for i in 1..=5这样的方式非常有意思和方便，还可以用字母。Rust 拥有相当多的数值类型. 需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及选择的类型是否能表达负数。类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数。</p>
<p>Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，需要区分语句和表达式，表达式总要返回值，分号结尾的是语句。</p>
<p>当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回，这种语法往往用做会导致程序崩溃的函数。</p>
<h2 id="3-13"><a href="#3-13" class="headerlink" title="3.13"></a>3.13</h2><p>今天学习基础第三章所有权和借用。为了解决内存安全问题，rust提出所有权概念，所有权三条规则：Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者；一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者；当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure>

<p>这段代码并没有发生所有权的转移，原因很简单： 代码首先将 <code>5</code> 绑定到变量 <code>x</code>，接着<strong>拷贝</strong> <code>x</code> 的值赋给 <code>y</code>，最终 <code>x</code> 和 <code>y</code> 都等于 <code>5</code>，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过<strong>自动拷贝</strong>的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure>

<p>当 s1 被赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，s1 在被赋予 s2 后就马上失效了。其实类似于c++里的move。如果不想夺取原有的所有权可以使用clone（），rust基本类型自带clone属性。</p>
<p>Rust通过借用(Borrowing) 获取变量的引用，称之为借用。引用分为可变引用和不可变引用，区别就是可不可变，这种限制的好处就是使 Rust 在编译期就避免数据竞争，两个或更多的指针同时访问同一数据，至少有一个指针被用来写入数据，没有同步数据访问的机制。可变引用和不可变引用不可以同时存在，可变引用可以同时存在一个，不可变引用可以同时存在多个。</p>
<p>基础第四章<strong>复合类型</strong>。&amp;s[0..len]切片操作很方便得用到string，字节序等，0..len为range类，左闭右开，在处理字节流时要注意，汉字在utf8占三个字节。字符串字面量也是个切片。</p>
<p>元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。可以通过以下语法创建一个元组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>变量 <code>tup</code> 被绑定了一个元组值 <code>(500, 6.4, 1)</code>，该元组的类型是 <code>(i32, f64, u8)</code>，元组是用括号将多个类型组合到一起，可以使用模式匹配或者 <code>.</code> 操作符来获取元组中的值。</p>
<p>用模式匹配解构元组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br></pre></td></tr></table></figure>

<p>struct结构体和c语言类似，访问字段用 . ,初始化实例时，每个字段都需要进行初始化，初始化时的字段顺序不需要和结构体定义时的顺序一致。结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段，</p>
<p>结构体必须要有名称，但是元组结构体的字段可以没有名称，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。</p>
<p>如果想在结构体里包含一个引用，必须声明生命周期。可以为结构体添加debug属性，实现fmt函数用来自定义打印结构体信息。</p>
<p>枚举类比大多语言要强大，每个元素可以是结构体包含不同信息，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Option 枚举用于处理空值，在其它编程语言中，往往都有一个 null 关键字，当null 异常导致程序的崩溃时我们需要处理这些 null 空值。Rust 吸取了众多教训，决定抛弃 null，而改为使用 Option 枚举变量来表述这种结果。<code>Option</code> 枚举包含两个成员，一个成员表示含有值：<code>Some(T)</code>, 另一个表示没有值：<code>None</code>，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>T</code> 是泛型参数，<code>Some(T)</code>表示该枚举成员的数据类型是 <code>T</code>，换句话说，<code>Some</code> 可以包含任何类型的数据。</p>
<p>在 Rust 中，最常用的数组有两种，第一种是速度很快但是长度固定的 <code>array</code>，第二种是可动态增长的但是有性能损耗的 <code>Vector</code>，在本书中，我们称 <code>array</code> 为数组，<code>Vector</code> 为动态数组。数组的三要素：长度固定、元素必须有相同的类型、依次线性排列。声明方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a: [i32; 5] &#x3D; [1, 2, 3, 4, 5];</span><br></pre></td></tr></table></figure>

<h2 id="3-14"><a href="#3-14" class="headerlink" title="3.14"></a>3.14</h2><p>今天学习基础第五章<strong>流程控制</strong>和第六章<strong>模式匹配</strong>。流程控制就是for … in while loop很容易。模式匹配还是对c++er比较新颖。match的用法和switch相似，强大的点在于可以同时解构内容如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">match action &#123;</span><br><span class="line">            Action::Say(s) &#x3D;&gt; &#123;</span><br><span class="line">                println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">            &#125;,</span><br><span class="line">            _ &#x3D;&gt; &#123;&#125;,</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>if let 相当于单个匹配的match，同样用于获取并解构。</p>
<p><code>matches!</code>，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 <code>true</code> or <code>false</code>。</p>
<p>match 和 if let 都可以触发变量遮蔽，就是可以同名变量优先使用当前作用于下的，在处理时很方便。</p>
<p>Option解构在rust经常用到，返回结果要么是Some（T），要么是None，在处理时解构处理不同情况非常强大。</p>
<p>解构方式还有个while let ，可以循环处理解构，数组和元组也可以用对应的结构来解构，_可以用来忽略这个位置的变量，匹配的范围同样可以使用range。</p>
<p>基础第七章<strong>方法</strong>。可以使用impl 对struct enum实现方法，方法公开需前置pub，方法的函数如若调用结构体的内容需要第一个参数位self，一般情况时&amp;self，在需要对结构体内容更改时为&amp;mut self，当然也可以不是引用，self转让所有权到方法里。在函数里没有结构体的引用时（关联函数）需要使用结构体：：来访问，否则一概使用 . 来访问。impl 内部也可以声明变量、常量等。impl 可以多次进行实现。</p>
<p>第八章泛型与特征。在 Rust 中，泛型参数的名称可以任意起，但是出于惯例都用 <code>T</code> ，使用泛型参数，有一个先决条件，必需在使用前对其进行声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br></pre></td></tr></table></figure>

<p>该泛型函数的作用是从列表中找出最大的值，其中列表中的元素类型为 T。首先 <code>largest&lt;T&gt;</code> 对泛型参数 <code>T</code> 进行了声明，然后才在函数参数中进行使用该泛型参数 <code>list: &amp;[T]</code> ，函数 <code>largest</code> 有泛型类型 <code>T</code>，它有个参数 <code>list</code>，其类型是元素为 <code>T</code> 的数组切片，最后，该函数返回值的类型也是 <code>T</code>。</p>
<p> <code>T</code> 可以是任何类型，但不是所有的类型都能进行比较，编译器建议我们给 <code>T</code> 添加一个类型限制：使用 <code>std::cmp::PartialOrd</code> 特征（Trait）对 <code>T</code> 进行限制。</p>
<p>有时候，编译器无法推断你想要的泛型参数，这时候需要显式地来声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn create_and_print&lt;T&gt;() where T: From&lt;i32&gt; + Display &#123;</span><br><span class="line">    let a: T &#x3D; 100.into(); &#x2F;&#x2F; 创建了类型为 T 的变量 a，它的初始值由 100 转换而来</span><br><span class="line">    println!(&quot;a is: &#123;&#125;&quot;, a);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    create_and_print::&lt;i64&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体和枚举的泛型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line">struct Point&lt;T,U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line">impl&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    fn x(&amp;self) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;self.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中使用泛型：使用泛型参数前要提前声明：<code>impl&lt;T&gt;</code>，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。注意，这里的 <code>Point&lt;T&gt;</code> 不再是泛型声明，而是一个完整的结构体类型，因为我们定义的结构体就是 <code>Point&lt;T&gt;</code> 而不再是 <code>Point</code>。除了结构体中的泛型参数，还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: self.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const泛型：<code>[i32; 3]</code> 和 <code>[i32; 2]</code> 确实是两个完全不同的类型，因此无法用同一个函数调用，const 泛型，也就是针对值的泛型可以用于处理数组长度的问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">display_array</span></span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="built_in">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    display_array(arr);</span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    display_array(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const fn</code>，即常量函数。通常情况下，函数是在运行时被调用和执行的。然而，在某些场景下，我们希望在编译期就计算出一些值，以提高运行时的性能或满足某些编译期的约束条件。例如，定义数组的长度、计算常量值等。有了 <code>const fn</code>，我们可以在编译期执行这些函数，从而将计算结果直接嵌入到生成的代码中。</p>
<p><strong>特征trait：</strong>如果不同的类型具有相同的行为，那么我们就可以定义一个特征，然后为这些类型实现该特征。<strong>定义特征</strong>是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line">pub struct Post &#123;</span><br><span class="line">    pub title: String, &#x2F;&#x2F; 标题</span><br><span class="line">    pub author: String, &#x2F;&#x2F; 作者</span><br><span class="line">    pub content: String, &#x2F;&#x2F; 内容</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary for Post &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;, self.title, self.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Weibo &#123;</span><br><span class="line">    pub username: String,</span><br><span class="line">    pub content: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary for Weibo &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;, self.username, self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于特征实现与定义的位置，有一条非常重要的原则：<strong>如果你想要为类型</strong> <code>A</code> <strong>实现特征</strong> <code>T</code><strong>，那么</strong> <code>A</code> <strong>或者</strong> <code>T</code> <strong>至少有一个是在当前作用域中定义的！</strong> 例如可以为上面的 <code>Post</code> 类型实现标准库中的 <code>Display</code> 特征，这是因为 <code>Post</code> 类型定义在当前的作用域中。同时也可以在当前包中为 <code>String</code> 类型实现 <code>Summary</code> 特征，因为 <code>Summary</code> 定义在当前作用域中.</p>
<p>特征中定义具有<strong>默认实现</strong>的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法.</p>
<p>使用特征作为函数参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;<span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl Summary</code>顾名思义，它的意思是 <strong>实现了<code>Summary</code>特征</strong> 的 <code>item</code> 参数。</p>
<p>如果想要强制函数的两个参数是同一类型只能使特征约束来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类型 <code>T</code> 说明了 <code>item1</code> 和 <code>item2</code> 必须拥有同样的类型，同时 <code>T: Summary</code> 说明了 <code>T</code> 必须实现 <code>Summary</code> 特征。</p>
<p><strong>多重约束:</strong>除了单个约束条件，可以指定多个约束条件，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;(<span class="keyword">impl</span> Summary + Display)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>除了上述的语法糖形式，还能使用特征约束的形式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>特征约束，可以让我们在指定类型 + 指定特征的条件下去实现方法,<strong>也可以有条件地实现特征</strong>，例如，标准库为任何实现了 <code>Display</code> 特征的类型实现了 <code>ToString</code> 特征。</p>
<p>可以通过 <code>impl Trait</code> 来说明一个函数返回了一个类型，该类型实现了某个特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Weibo &#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种 <code>impl Trait</code> 形式的返回值，在一种场景下非常非常有用，那就是返回的真实类型非常复杂，你不知道该怎么声明时。</p>
<p><strong><code>#[derive(Debug)]</code></strong> ：是一种特征派生语法，被 <code>derive</code> 标记的对象会自动实现对应的默认特征代码，继承相应的功能。例如 <code>Debug</code> 特征，它有一套自动实现的默认代码，当你给一个结构体标记后，就可以使用 <code>println!(&quot;{:?}&quot;, s)</code> 的形式打印该结构体的对象。</p>
<p>再如 <code>Copy</code> 特征，它也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现 <code>Copy</code> 特征，进而可以调用 <code>copy</code> 方法，进行自我复制。</p>
<p>总之，<code>derive</code> 派生出来的是 Rust 默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重载该实现</p>
<p><strong>特征对象</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Draw</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要组件实现了 <code>Draw</code> 特征，就可以调用 <code>draw</code> 方法来进行渲染。假设有一个 <code>Button</code> 和 <code>SelectBox</code> 组件实现了 <code>Draw</code> 特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Button</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> Button &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 绘制按钮的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SelectBox</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">    options: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> SelectBox &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 绘制SelectBox的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">draw1</span></span>(x: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;) &#123;</span><br><span class="line">    <span class="comment">// 由于实现了 Deref 特征，Box 智能指针会自动解引用为它所包裹的值，然后调用该值对应的类型上定义的 `draw` 方法</span></span><br><span class="line">    x.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">draw2</span></span>(x: &amp;<span class="keyword">dyn</span> Draw) &#123;</span><br><span class="line">    x.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，还需要一个动态数组来存储这些 UI 对象：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;?&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特征对象**指向实现了 <code>Draw</code> 特征的类型的实例，也就是指向了 <code>Button</code> 或者 <code>SelectBox</code> 的实例，这种映射关系是存储在一张表中，可以在运行时通过特征对象找到具体调用的类型方法。</p>
<ul>
<li><code>draw1</code> 函数的参数是 <code>Box&lt;dyn Draw&gt;</code> 形式的特征对象，该特征对象是通过 <code>Box::new(x)</code> 的方式创建的</li>
<li><code>draw2</code> 函数的参数是 <code>&amp;dyn Draw</code> 形式的特征对象，该特征对象是通过 <code>&amp;x</code> 的方式创建的</li>
<li><code>dyn</code> 关键字只用在特征对象的类型声明上，在创建时无需使用 <code>dyn</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中存储了一个动态数组，里面元素的类型是 <code>Draw</code> 特征对象：<code>Box&lt;dyn Draw&gt;</code>，任何实现了 <code>Draw</code> 特征的类型，都可以存放其中。</p>
<p>再来为 <code>Screen</code> 定义 <code>run</code> 方法，用于将列表中的 UI 组件渲染在屏幕上：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Screen &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型是在编译期完成处理的：编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是<strong>静态分发</strong>，因为是在编译期完成的，对于运行期性能完全没有任何影响。与静态分发相对应的是<strong>动态分发(dynamic dispatch)</strong>，直到运行时，才能确定需要调用什么方法。</p>
<h2 id="3-15"><a href="#3-15" class="headerlink" title="3.15"></a>3.15</h2><p>第九章<strong>集合类型</strong></p>
<p>使用 <code>Vec::new</code> 创建动态数组</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure>

<p>这里，<code>v</code> 被显式地声明了类型 <code>Vec&lt;i32&gt;</code>，这是因为 Rust 编译器无法从 <code>Vec::new()</code> 中得到任何关于类型的暗示信息，因此也无法推导出 <code>v</code> 的具体类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line">v.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>此时，<code>v</code> 就无需手动声明类型，因为编译器通过 <code>v.push(1)</code>，推测出 <code>v</code> 中的元素类型是 <code>i32</code>，因此推导出 <code>v</code> 的类型是 <code>Vec&lt;i32&gt;</code>。</p>
<blockquote>
<p>如果预先知道要存储的元素个数，可以使用 <code>Vec::with_capacity(capacity)</code> 创建动态数组，这样可以避免因为插入大量新数据导致频繁的内存分配和拷贝，提升性能</p>
</blockquote>
<p>还可以使用宏 <code>vec!</code> 来创建数组，与 <code>Vec::new</code> 有所不同，前者能在创建同时给予初始化值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>同样，此处的 <code>v</code> 也无需标注类型，编译器只需检查它内部的元素即可自动推导出 <code>v</code> 的类型是 `Vec<i32></p>
<p>跟结构体一样，<code>Vector</code> 类型在超出作用域范围后，会被自动删除：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// &lt;- v超出作用域并在此处被删除</span></span><br></pre></td></tr></table></figure>

<p>当 <code>Vector</code> 被删除后，它内部存储的所有内容也会随之被删除。</p>
<p><strong>同时借用多个数组元素</strong> 遇到同时借用多个数组元素的情况</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.push(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The first element is: &#123;first&#125;"</span>)；</span><br></pre></td></tr></table></figure>

<p>此时编译器报错。数组的大小是可变的，当旧数组的大小不够用时，Rust 会重新分配一块更大的内存空间，然后把旧数组拷贝过来。这种情况下，之前的引用显然会指向一块无效的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个HashMap，用于存储宝石种类和对应的数量</span><br><span class="line">let mut my_gems &#x3D; HashMap::new();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将宝石类型和对应的数量写入表中</span><br><span class="line">my_gems.insert(&quot;红宝石&quot;, 1);</span><br><span class="line">my_gems.insert(&quot;蓝宝石&quot;, 2);</span><br></pre></td></tr></table></figure>

<h2 id="3-16"><a href="#3-16" class="headerlink" title="3.16"></a>3.16</h2><p>第十章生命周期。</p>
<p><strong>借用检查：</strong>为了保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)来检查程序的借用正确性。</p>
<p><strong>函数中的生命周期：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------</span><br><span class="line"> --&gt; src&#x2F;main.rs:9:33</span><br><span class="line">  |</span><br><span class="line">9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |               ----     ----     ^ expected named lifetime parameter &#x2F;&#x2F; 参数需要一个生命周期</span><br><span class="line">  |</span><br></pre></td></tr></table></figure>

<p>编译器无法知道该函数的返回值到底引用 <code>x</code> 还是 <code>y</code> ，<strong>因为编译器需要知道这些，来确保函数调用后的引用生命周期分析</strong>。在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。</p>
<p><strong>生命周期标注：</strong>生命周期的语法以 <code>&#39;</code> 开头，名称往往是一个单独的小写字母，大多数人都用 <code>&#39;a</code> 来作为生命周期的名称。 如果是引用类型的参数，那么生命周期会位于引用符号 <code>&amp;</code> 之后，并用一个空格来将生命周期和引用参数分隔开</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span>        <span class="comment">// 一个引用</span></span><br><span class="line">&amp;<span class="symbol">'a</span> <span class="built_in">i32</span>     <span class="comment">// 具有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 具有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>

<p>一个生命周期标注，它自身并不具有什么意义，因为生命周期的作用就是告诉编译器多个引用之间的关系。例如，有一个函数，它的第一个参数 <code>first</code> 是一个指向 <code>i32</code> 类型的引用，具有生命周期 <code>&#39;a</code>，该函数还有另一个参数 <code>second</code>，它也是指向 <code>i32</code> 类型的引用，并且同样具有生命周期 <code>&#39;a</code>。此处生命周期标注仅仅说明，<strong>这两个参数 <code>first</code> 和 <code>second</code> 至少活得和’a 一样久，至于到底活多久或者哪个活得更久，我们都无法得知</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">useless</span></span>&lt;<span class="symbol">'a</span>&gt;(first: &amp;<span class="symbol">'a</span> <span class="built_in">i32</span>, second: &amp;<span class="symbol">'a</span> <span class="built_in">i32</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数签名中的生命周期标注</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和泛型一样，使用生命周期参数，需要先声明 <code>&lt;&#39;a&gt;</code></li>
<li><code>x</code>、<code>y</code> 和返回值至少活得和 <code>&#39;a</code> 一样久（因为返回值要么是 <code>x</code>，要么是 <code>y</code>）</li>
</ul>
<p>该函数签名表明对于某些生命周期 <code>&#39;a</code>，函数的两个参数都至少跟 <code>&#39;a</code> 活得一样久，同时函数的返回引用也至少跟 <code>&#39;a</code> 活得一样久。实际上，这意味着返回值的生命周期与参数生命周期中的较小值一致：虽然两个参数的生命周期都是标注了 <code>&#39;a</code>，但是实际上这两个参数的真实生命周期可能是不一样的（生命周期 <code>&#39;a</code> 不代表生命周期等于 <code>&#39;a</code>，而是大于等于 <code>&#39;a</code>）。<strong>在通过函数签名指定生命周期参数时，并没有改变传入引用或者返回引用的真实生命周期，而是告诉编译器当不满足此约束条件时，就拒绝编译通过</strong>。</p>
<p>因此 <code>longest</code> 函数并不知道 <code>x</code> 和 <code>y</code> 具体会活多久，只要知道它们的作用域至少能持续 <code>&#39;a</code> 这么长就行。</p>
<p>该例子证明了 <code>result</code> 的生命周期必须等于两个参数中生命周期较小的那个:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"long string is long"</span>);</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> string2 = <span class="built_in">String</span>::from(<span class="string">"xyz"</span>);</span><br><span class="line">        result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line">error[E0597]: `string2` does not live long enough</span><br><span class="line"> --&gt; src/main.rs:<span class="number">6</span>:<span class="number">44</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">6</span> |         result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">  |                                            ^^^^^^^ borrowed value does not live long enough</span><br><span class="line"><span class="number">7</span> |     &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>result</code> 必须要活到 <code>println!</code>处，因为 <code>result</code> 的生命周期是 <code>&#39;a</code>，因此 <code>&#39;a</code> 必须持续到 <code>println!</code>。</p>
<p><strong>结构体中的生命周期：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    part: &amp;&#39;a str,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImportantExcerpt</code> 结构体中有一个引用类型的字段 <code>part</code>，因此需要为它标注上生命周期。结构体的生命周期标注语法跟泛型参数语法很像，需要对生命周期参数进行声明 <code>&lt;&#39;a&gt;</code>。该生命周期标注说明，<strong>结构体 <code>ImportantExcerpt</code> 所引用的字符串 <code>str</code> 生命周期需要大于等于该结构体的生命周期</strong></p>
<p><strong>生命周期消除：</strong>尽管我们没有显式的为其标注生命周期，编译依然可以通过。其实原因不复杂，<strong>编译器为了简化用户的使用，运用了生命周期消除大法</strong>。</p>
<p>三条消除规则：</p>
<p>编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。</p>
<ol>
<li><p><strong>每一个引用参数都会获得独自的生命周期</strong></p>
<p>例如一个引用参数的函数就有一个生命周期标注: <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code>，两个引用参数的有两个生命周期标注:<code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code>, 依此类推。</p>
</li>
<li><p><strong>若只有一个输入生命周期（函数参数中只有一个引用类型），那么该生命周期会被赋给所有的输出生命周期</strong>，也就是所有返回值的生命周期都等于该输入生命周期</p>
<p>例如函数 <code>fn foo(x: &amp;i32) -&gt; &amp;i32</code>，<code>x</code> 参数的生命周期会被自动赋给返回值 <code>&amp;i32</code>，因此该函数等同于 <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code></p>
</li>
<li><p><strong>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</strong></p>
<p>拥有 <code>&amp;self</code> 形式的参数，说明该函数是一个 <code>方法</code>，该规则让方法的使用便利度大幅提升。</p>
</li>
</ol>
<h2 id="3-17"><a href="#3-17" class="headerlink" title="3.17"></a>3.17</h2><p><strong>方法中的生命周期：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    part: &amp;&#39;a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    fn level(&amp;self) -&gt; i32 &#123;</span><br><span class="line">        3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>impl</code> 中必须使用结构体的完整名称，包括 <code>&lt;&#39;a&gt;</code>，因为<em>生命周期标注也是结构体类型的一部分</em>！</li>
<li>方法签名中，往往不需要标注生命周期，得益于生命周期消除的第一和第三规则</li>
</ul>
<p><strong>静态生命周期：</strong>生命周期 <code>&#39;static</code>，拥有该生命周期的引用可以和整个程序活得一样久。</p>
<p>字符串字面量是被硬编码进 Rust 的二进制文件中，因此这些字符串变量全部具有 <code>&#39;static</code> 的生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"就是活得久，嘿嘿"</span>;</span><br></pre></td></tr></table></figure>

<p>Rust 中的错误主要分为两类：</p>
<ul>
<li><strong>可恢复错误</strong>，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响</li>
<li><strong>不可恢复错误</strong>，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的</li>
</ul>
<p>Rust 提供了 <code>panic!</code> 宏，当调用执行该宏时，<strong>程序会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序</strong>。</p>
<p>当出现 <code>panic!</code> 时，程序提供了两种方式来处理终止流程：<strong>栈展开</strong>和<strong>直接终止</strong>。</p>
<p>其中，默认的方式就是 <code>栈展开</code>，这意味着 Rust 会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘。<code>直接终止</code>，顾名思义，不清理数据就直接退出程序，善后工作交与操作系统来负责。</p>
<p>对于绝大多数用户，使用默认选择是最好的，但是当你关心最终编译出的二进制可执行文件大小时，那么可以尝试去使用直接终止的方式，例如下面的配置修改 <code>Cargo.toml</code> 文件，实现在 <a href="https://course.rs/first-try/cargo.html#手动编译和运行项目" target="_blank" rel="noopener"><code>release</code></a> 模式下遇到 <code>panic</code> 直接终止：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic &#x3D; &#39;abort&#39;</span><br></pre></td></tr></table></figure>

<p>panic后如果是 <code>main</code> 线程，则程序会终止，如果是其它子线程，该线程会终止，但是不会影响 <code>main</code> 线程。</p>
<p>*<em><code>Result&lt;T, E&gt;</code> *</em>是一个枚举类型，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型参数 <code>T</code> 代表成功时存入的正确值的类型，存放方式是 <code>Ok(T)</code>，<code>E</code> 代表错误时存入的错误值，存放方式是 <code>Err(E)</code>，</p>
<p>不想使用 <code>match</code> 去匹配 <code>Result&lt;T, E&gt;</code>以获取其中的 <code>T</code> 值，因为 <code>match</code> 的穷尽匹配特性，你总要去处理下 <code>Err</code> 分支。有个办法简化这个过程就是 <code>unwrap</code> 和 <code>expect</code>。它们的作用就是，如果返回成功，就将 <code>Ok(T)</code> 中的值取出来，如果失败，就直接 panic。<code>expect</code> 跟 <code>unwrap</code> 很像，也是遇到错误直接 <code>panic</code>, 但是会带上自定义的错误提示信息，相当于重载了错误打印的函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;).unwrap();</span><br><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>错误传播：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>该函数返回一个 <code>Result&lt;String, io::Error&gt;</code> 类型，当读取用户名成功时，返回 <code>Ok(String)</code>，失败时，返回 <code>Err(io:Error)</code></li>
<li><code>File::open</code> 和 <code>f.read_to_string</code> 返回的 <code>Result&lt;T, E&gt;</code> 中的 <code>E</code> 就是 <code>io::Error</code></li>
</ul>
<h2 id="3-18"><a href="#3-18" class="headerlink" title="3.18"></a>3.18</h2><ul>
<li><strong>项目(Package)</strong>：可以用来构建、测试和分享包</li>
<li><strong>工作空间(WorkSpace)</strong>：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间</li>
<li><strong>包(Crate)</strong>：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li>
<li><strong>模块(Module)</strong>：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li>
</ul>
<p><strong>包 Crate</strong></p>
<p>对于 Rust 而言，包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p>
<p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。例如标准库中没有提供但是在三方库中提供的 <code>rand</code> 包，它提供了随机数生成的功能，只需要将该包通过 <code>use rand;</code> 引入到当前项目的作用域中，就可以在项目中使用 <code>rand</code> 的功能：<code>rand::XXX</code>。</p>
<p>同一个包中不能有同名的类型，但是在不同包中就可以。例如，虽然 <code>rand</code> 包中，有一个 <code>Rng</code> 特征，可是依然可以在自己的项目中定义一个 <code>Rng</code>，前者通过 <code>rand::Rng</code> 访问，后者通过 <code>Rng</code> 访问，不会存在引用歧义。</p>
<p><strong>项目 Package</strong></p>
<p>由于 <code>Package</code> 就是一个项目，因此它包含有独立的 <code>Cargo.toml</code> 文件，以及因为功能性被组织在一起的一个或多个包。一个 <code>Package</code> 只能包含<strong>一个</strong>库(library)类型的包，但是可以包含<strong>多个</strong>二进制可执行类型的包。</p>
<p><strong>库 Package</strong></p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo new my-lib --lib</span></span><br><span class="line">     Created library `my-lib` package</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls my-lib</span></span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls my-lib/src</span></span><br><span class="line">lib.rs</span><br></pre></td></tr></table></figure>

<p>如果你试图运行 <code>my-lib</code>，会报错：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run</span></span><br><span class="line">error: a bin target must be available for `cargo run`</span><br></pre></td></tr></table></figure>

<p>原因是库类型的 <code>Package</code> 只能作为三方库被其它项目引用，而不能独立运行，只有之前的二进制 <code>Package</code> 才可以运行。</p>
<p>与 <code>src/main.rs</code> 一样，Cargo 知道，如果一个 <code>Package</code> 包含有 <code>src/lib.rs</code>，意味它包含有一个库类型的同名包 <code>my-lib</code>，该包的根文件是 <code>src/lib.rs</code>。</p>
<p><strong>模块</strong></p>
<ul>
<li>使用 <code>mod</code> 关键字来创建新模块，后面紧跟着模块名称</li>
<li>模块可以嵌套，这里嵌套的原因是招待客人和服务都发生在前厅，因此我们的代码模拟了真实场景</li>
<li>模块中可以定义各种 Rust 类型，例如函数、结构体、枚举、特征等</li>
<li>所有模块均定义在同一个文件中</li>
</ul>
<p>模块树为模块的嵌套结构，他们都有一个根模块 <code>crate</code>。如果模块 <code>A</code> 包含模块 <code>B</code>，那么 <code>A</code> 是 <code>B</code> 的父模块，<code>B</code> 是 <code>A</code> 的子模块。</p>
<p>想要调用一个函数，就需要知道它的路径，在 Rust 中，这种路径有两种形式：</p>
<ul>
<li><strong>绝对路径</strong>，从包根开始，路径名以包名或者 <code>crate</code> 作为开头</li>
<li><strong>相对路径</strong>，从当前模块开始，以 <code>self</code>，<code>super</code> 或当前模块的标识符作为开头</li>
</ul>
<p>Rust 出于安全的考虑，默认情况下，所有的类型都是私有化的，包括函数、方法、结构体、枚举、常量，是的，就连模块本身也是私有化的。<strong>父模块完全无法访问子模块中的私有项，但是子模块却可以访问父模块、父父..模块的私有项</strong>。</p>
<p>模块可见性不代表模块内部项的可见性，模块的可见性仅仅是允许其它模块去引用它，但是想要引用它内部的项，还得继续将对应的项标记为 <code>pub</code>。</p>
<p>当外部的模块项 <code>A</code> 被引入到当前模块中时，它的可见性自动被设置为私有的，如果你希望允许其它外部代码引用我们的模块项 <code>A</code>，那么可以对它进行再导出。使用 <code>pub use</code> 即可实现。</p>
<p>引入第三方包中的模块，关于如何引入外部依赖：</p>
<p>修改 <code>Cargo.toml</code> 文件，在 <code>[dependencies]</code> 区域添加一行：<code>rand = &quot;0.8.3&quot;</code></p>
<h2 id="3-21-3-24-rustlings"><a href="#3-21-3-24-rustlings" class="headerlink" title="3.21-3.24 rustlings"></a>3.21-3.24 rustlings</h2><p>关于rustlings，系统学过rust后几乎没有难题，所以我在6号一天就完成了70多道，前两天在熟悉github classroom和rustlings的自检方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/blog/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/75/">75</a><a class="extend next" rel="next" href="/blog/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
