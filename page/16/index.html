<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/16/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/16/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">662</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">575</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/11/%E5%8F%AE%E5%BD%93%E7%8C%AB%E7%9A%84%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/11/%E5%8F%AE%E5%BD%93%E7%8C%AB%E7%9A%84%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">叮当猫的博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-11 03:42:49" itemprop="dateCreated datePublished" datetime="2024-11-11T03:42:49+00:00">2024-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一阶段-Rustlings"><a href="#一阶段-Rustlings" class="headerlink" title="一阶段 Rustlings"></a>一阶段 Rustlings</h1><p>​    机缘巧合之下,对我教育颇深的学长为我介绍了这个训练营,于是一段艰辛的历史就开始了</p>
<p>​    初学rust,被他严格是语法体系给搞傻了,这也不给那也不给,对于写惯C++ 的我来说简直不可理喻。rust语法体系中不允许隐式类型转换,即使是在C++中的非窄化类型转换也不允许。更要命的一点是,所有变量默认全是按const不可变变量来处理的,这极大地降低了我的愉悦性,在C++中此类const操作时显示的,在这变为隐式。还有一点则是类型的特性不会自动从父类继承(C++是这么称呼的,rust学的不太行),必须我去一 一 写出,也是很难受。</p>
<p>​    介绍完了令我不愉快的地方,rust的优势也很明显,不允许随意更改变量,不允许直接操作指针,变量的所有权等等,在重重限制下无疑降低了代码出错率,不过我还是喜欢C++。</p>
<h1 id="二阶段rcore"><a href="#二阶段rcore" class="headerlink" title="二阶段rcore"></a>二阶段rcore</h1><p>​    这一阶段别提多痛苦了,一阶段语法就没学好,大半时间都在调语法错误,章节知识点介绍都挺好的,想一想也容易想出来,over,不过我还是喜欢C++,rust使我痛苦 , 重复可变借用我恨你</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/11/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93_%E6%9D%8E%E5%A4%A7%E5%8D%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/11/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93_%E6%9D%8E%E5%A4%A7%E5%8D%8E/" class="post-title-link" itemprop="url">2024S 开源操作系统训练营总结-李大华</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-11 00:18:00" itemprop="dateCreated datePublished" datetime="2024-11-11T00:18:00+00:00">2024-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024秋冬季季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h1><p>rustlings很有用，年轻人的第一款cpp.</p>
<h1 id="第二阶段总结"><a href="#第二阶段总结" class="headerlink" title="第二阶段总结"></a>第二阶段总结</h1><p>老实说，文档很抽象，框架体验也比较一般……</p>
<p>希望越来越好</p>
<p>希望有更多的工具相关内容，例如gdb和cmake。os相关工作其实相对少，但是学习工具的使用对各方面都很有用。</p>
<p>文档要是能多一些图就更好了，理解起来实在有难处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/11/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-%E9%A9%AC%E4%BF%8A%E9%A3%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/11/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-%E9%A9%AC%E4%BF%8A%E9%A3%9E/" class="post-title-link" itemprop="url">rust体会</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-11T00:00:00+00:00">2024-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/rust-language/" itemprop="url" rel="index"><span itemprop="name">rust language</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Rust编程技巧与示例：宏、算法与类型转换"><a href="#Rust编程技巧与示例：宏、算法与类型转换" class="headerlink" title="Rust编程技巧与示例：宏、算法与类型转换"></a>Rust编程技巧与示例：宏、算法与类型转换</h3><p>在Rust编程中，有许多细节和技巧可以帮助开发者更好地组织代码、优化算法性能，以及确保类型安全。本篇博客汇总了一些Rust编程的核心要点和实用代码示例，涵盖了宏的使用、排序算法、树和图的操作等内容。</p>
<hr>
<h3 id="1-宏与-macro-export-、-macro-use"><a href="#1-宏与-macro-export-、-macro-use" class="headerlink" title="1. 宏与#[macro_export]、#[macro_use]"></a>1. 宏与#[macro_export]、#[macro_use]</h3><p>Rust中的宏非常强大，用于生成重复代码和提升代码的灵活性。使用<code>#[macro_export]</code>可以导出宏，使其在其他模块或包中可用；而<code>#[macro_use]</code>则在现代Rust中被推荐通过<code>use</code>语句显式引入。</p>
<p>示例宏定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[rustfmt::skip]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    () =&gt; &#123; <span class="built_in">println!</span>(<span class="string">"Check out my macro!"</span>); &#125;;</span><br><span class="line">    ($val:expr) =&gt; &#123; <span class="built_in">println!</span>(<span class="string">"Look at this other macro: &#123;&#125;"</span>, $val); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>#[rustfmt::skip]</code>用于避免自动格式化，保持代码样式的灵活性和可读性。</p>
<hr>
<h3 id="2-Rust中的类型与特性"><a href="#2-Rust中的类型与特性" class="headerlink" title="2. Rust中的类型与特性"></a>2. Rust中的类型与特性</h3><p>在实现数据结构或算法时，我们通常需要对泛型类型T施加一些特性约束，例如：</p>
<ul>
<li><code>Ord</code>：使得元素可以比较大小，适用于排序、合并等操作。</li>
<li><code>Clone</code>：便于复制元素值，即使是复杂类型，也可以无所有权转移地复制。</li>
<li><code>Display</code>：实现字符串友好的格式化输出，便于打印和日志记录。</li>
</ul>
<p>这些特性可以通过<code>where</code>语句在泛型实现中指定：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; LinkedList&lt;T&gt; </span><br><span class="line"><span class="keyword">where</span> T: <span class="built_in">Ord</span> + <span class="built_in">Clone</span> + Display</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-内存操作与指针"><a href="#3-内存操作与指针" class="headerlink" title="3. 内存操作与指针"></a>3. 内存操作与指针</h3><p>Rust通过<code>unsafe</code>块支持手动管理内存和指针操作，用于高性能或底层操作。<br>例如，获取节点的指针并解引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node_ptr = <span class="literal">Some</span>(<span class="keyword">unsafe</span> &#123; NonNull::new_unchecked(<span class="built_in">Box</span>::into_raw(node)) &#125;);</span><br><span class="line">res.add((*node_ptr.as_ptr()).val.clone());</span><br><span class="line">cur_a = (*node_ptr.as_ptr()).next;  <span class="comment">// 注意这里直接获取的是ta的next指针</span></span><br></pre></td></tr></table></figure>

<p>指针的安全解包和操作要格外小心，可以使用<code>Option</code>配合<code>unsafe</code>避免空指针风险。</p>
<hr>
<h3 id="4-算法设计示例"><a href="#4-算法设计示例" class="headerlink" title="4. 算法设计示例"></a>4. 算法设计示例</h3><h4 id="4-1-链表与树的操作"><a href="#4-1-链表与树的操作" class="headerlink" title="4.1 链表与树的操作"></a>4.1 链表与树的操作</h4><h5 id="插入与查找"><a href="#插入与查找" class="headerlink" title="插入与查找"></a>插入与查找</h5><p>在链表或树结构中，我们经常用到<code>Option</code>类型来表示节点的存在与否。例如，在插入和查找二叉树中，可以选择使用<code>if let</code>语句来处理<code>Some</code>和<code>None</code>的情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">insert</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: T) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> node) = <span class="keyword">self</span>.root &#123;</span><br><span class="line">        node.insert(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.root = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(TreeNode::new(value)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法在处理可变引用时尤其简洁。</p>
<h4 id="4-2-排序算法与Ord与PartialOrd"><a href="#4-2-排序算法与Ord与PartialOrd" class="headerlink" title="4.2 排序算法与Ord与PartialOrd"></a>4.2 排序算法与Ord与PartialOrd</h4><p>选择排序等算法需要比较泛型元素的大小，通常需要<code>PartialOrd</code>特性来支持部分排序（如非全序关系的情况），而对于要求全序的场景可以使用<code>Ord</code>。</p>
<h4 id="4-3-深度优先与广度优先搜索"><a href="#4-3-深度优先与广度优先搜索" class="headerlink" title="4.3 深度优先与广度优先搜索"></a>4.3 深度优先与广度优先搜索</h4><p>在图算法中，深度优先搜索（DFS）和广度优先搜索（BFS）是两种基础的遍历方式：</p>
<ul>
<li><p>DFS示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dfs_util</span></span>(&amp;<span class="keyword">self</span>, v: <span class="built_in">usize</span>, visited: &amp;<span class="keyword">mut</span> HashSet&lt;<span class="built_in">usize</span>&gt;, visit_order: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;) &#123;</span><br><span class="line">    visited.insert(v);</span><br><span class="line">    visit_order.push(v);</span><br><span class="line">    <span class="keyword">for</span> &amp;nei <span class="keyword">in</span> <span class="keyword">self</span>.adj[v].iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> !visited.contains(&amp;nei) &#123;</span><br><span class="line">            <span class="keyword">self</span>.dfs_util(nei, visited, visit_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BFS示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bfs_with_return</span></span>(&amp;<span class="keyword">self</span>, start: <span class="built_in">usize</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> visit_order = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> visited = <span class="built_in">vec!</span>[<span class="literal">false</span>; <span class="keyword">self</span>.adj.len()];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> queue = VecDeque::new();</span><br><span class="line">    queue.push_back(start);</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(node) = queue.pop_front() &#123;</span><br><span class="line">        visit_order.push(node);</span><br><span class="line">        <span class="keyword">for</span> &amp;neighbor <span class="keyword">in</span> &amp;<span class="keyword">self</span>.adj[node] &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[neighbor] &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                queue.push_back(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visit_order</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-4-平衡堆的插入与调整"><a href="#4-4-平衡堆的插入与调整" class="headerlink" title="4.4 平衡堆的插入与调整"></a>4.4 平衡堆的插入与调整</h4><p>Rust标准库中<code>Vec</code>的<code>swap_remove</code>方法可以高效地删除指定位置的元素，适用于实现优先队列等堆结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="keyword">self</span>.items.swap_remove(<span class="number">1</span>);  <span class="comment">// 移除并返回指定位置的元素</span></span><br></pre></td></tr></table></figure>

<p>在删除元素后，可以通过调整堆结构（如最小/最大堆）来保持堆的性质。</p>
<hr>
<h3 id="5-实现栈与队列"><a href="#5-实现栈与队列" class="headerlink" title="5. 实现栈与队列"></a>5. 实现栈与队列</h3><p>使用双队列实现栈的操作逻辑：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">myStack</span></span>&lt;T&gt; &#123;</span><br><span class="line">    q1: Queue&lt;T&gt;,</span><br><span class="line">    q2: Queue&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; myStack&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, elem: T) &#123;</span><br><span class="line">        <span class="keyword">self</span>.q2.enqueue(elem);</span><br><span class="line">        <span class="keyword">while</span> !<span class="keyword">self</span>.q1.is_empty() &#123;</span><br><span class="line">            <span class="keyword">self</span>.q2.enqueue(<span class="keyword">self</span>.q1.dequeue().unwrap());</span><br><span class="line">        &#125;</span><br><span class="line">        std::mem::swap(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.q1, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.q2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法利用队列的FIFO特性来模拟栈的LIFO特性。</p>
<hr>
<h3 id="6-函数与内存管理"><a href="#6-函数与内存管理" class="headerlink" title="6. 函数与内存管理"></a>6. 函数与内存管理</h3><p>Rust中的<code>Box</code>和<code>unsafe</code>结合用于手动管理堆内存。<code>Box::from_raw</code>可以从裸指针重新创建<code>Box</code>，这在需要手动内存管理的场景中非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">raw_pointer_to_box</span></span>(ptr: *<span class="keyword">mut</span> Foo) -&gt; <span class="built_in">Box</span>&lt;Foo&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ret: <span class="built_in">Box</span>&lt;Foo&gt; = <span class="keyword">unsafe</span> &#123; <span class="built_in">Box</span>::from_raw(ptr) &#125;;</span><br><span class="line">    ret.b = <span class="literal">Some</span>(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法常用于FFI（外部函数接口）中将指针恢复为拥有所有权的Rust类型。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Rust语言通过丰富的内存管理工具和类型系统，确保了在安全性和性能上的平衡。无论是自定义数据结构还是排序、图遍历等基础算法，Rust的特性可以为代码提供极大的灵活性和安全保障。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/11/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-%E9%A9%AC%E4%BF%8A%E9%A3%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/11/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-%E9%A9%AC%E4%BF%8A%E9%A3%9E/" class="post-title-link" itemprop="url">调度与死锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-11T00:00:00+00:00">2024-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/os/" itemprop="url" rel="index"><span itemprop="name">os</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h4 id="三级调度："><a href="#三级调度：" class="headerlink" title="三级调度："></a><strong>三级调度：</strong></h4><p>作业调度、高级调度(频次最低)：主要解决：接纳多少个任务+接纳那哪些任务这两个工作</p>
<p>进程调度、低级调度(频次最高): 必须有、<strong>核心</strong>，<strong>确定哪个进程可以占有CPU并执行</strong></p>
<p>中级调度：将那些暂时不能运行的进程从内存挂起到外存，(阻塞状态下进程实体(程序 + 数据 + PCB)还在内存中，而挂起状态会把进程实体挂到外存，但是PCB会存在系统内核空间中，会记录进程在外存的状态以及位置)，一般在<strong>内存紧张</strong>时使用</p>
<p>高级调度，用于批处理系统中，将任务从外存调度到内存中去。(在分时/实时系统中，任务是直接在内存，因此没有高级调度)</p>
<p>分时系统：<strong>只有进程调度</strong></p>
<p>批处理系统：<strong>进程调度 +  作业调度</strong></p>
<h4 id="调度算法相关"><a href="#调度算法相关" class="headerlink" title="调度算法相关"></a>调度算法相关</h4><p>准则：周转时间(常用于<strong>批处理系统</strong>)、平均周转时间、带权周转时间</p>
<p>响应时间(交互性作业、分时系统)、截止时间的保证(实时系统)、优先权准则</p>
<p>周转时间 = 完成时间 - 到达时间</p>
<p>带权周转时间 = 周转时间 / 服务时间</p>
<p><strong>调度算法</strong></p>
<ul>
<li><p>FCFS(first come first serve), SJ(P)F等等<br>对于抢占式调度，注意<strong>服务时间的更新，然后再比较，看谁抢</strong></p>
</li>
<li><p>高优先权 优先调度算法</p>
<p> 静态优先权：简单，但存在饥饿现象</p>
<p> 动态优先权：eg Rp = （等待时间 + 服务时间）/ 服务时间  作为优先权 1 + tw / ts;</p>
</li>
<li><p>时间片轮转 ……?</p>
<p> 多级反馈队列 S1 &lt; S2 &lt; S3 优先权 S1 &gt; S2 &gt; S3</p>
</li>
</ul>
<ul>
<li><p>实时调度</p>
<p> 非抢占：轮转 || 优先权</p>
<p> 抢占：基于中断时钟，好处是减少了上下文保存切换的次数</p>
<p> ​      立即抢占</p>
<p> 实时调度算法：EDF、LLF，还有例题</p>
</li>
<li><p>其他一些？？</p>
<p> MPS：CPU共享内存，  共享缓存(单个儿独立的，容易出现绑定，忙闲不均)</p>
<p> SMP中进程分配方式：静态分配和动态分配</p>
<p> ​               调度方式： 自调度和成组调度(两种方式就对应了用户级线程和系统级线程)，                       专用处理机分配？</p>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>一些定义</strong>：</p>
<ul>
<li>可剥夺资源：如主存，CPU，可以在使用时被强占的资源</li>
<li>不可剥夺资源：不可被打断抢占的资源，如驱动器，打印机</li>
<li>永久资源(外存)，临时资源(进程运行过程中临时产生的数据资源等等)</li>
</ul>
<p><strong>竞争非剥夺资源，或者竞争临时资源可导致死锁</strong></p>
<h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><ul>
<li>互斥条件：进程互斥的使用临界资源</li>
<li>不剥夺条件(不可抢占)</li>
<li>请求-保持条件：进程在申请新的资源的同时，保持对某些资源的占有</li>
<li>环路等待：循环等待链</li>
</ul>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><p>从严格依次降低，为</p>
<p>预防 -&gt; 避免 -&gt; 检测与解除</p>
<h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><p>上面4个条件是死锁的必要条件  ， Deadlock -&gt; 4  其逆否命题为  !4 -&gt; !Deadlock,所以我们从4个条件入手</p>
<ol>
<li>互斥，并没有好的办法</li>
<li>不抢占：不抢占变成”抢占”，如果进程申请不到全部资源时，主动释放</li>
<li>请求保持条件：使用AND机制，但是有点浪费资源</li>
<li>环路等待：破除环路，资源排序，参考哲学家进餐</li>
</ol>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p><strong>这是比较中庸的做法，既不损耗很多的效率，也比较的严格</strong></p>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>一种是，资源分配表，为</p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Allocation</th>
<th>Need</th>
<th>Available</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>另一种是，计算表</p>
<table>
<thead>
<tr>
<th>Work</th>
<th>Need</th>
<th>Allocation</th>
<th>work + Allocation</th>
<th>Finish</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>对资源进行分配时，分成两步</strong></p>
<ol>
<li>判断分配请求 R是否满足  R &lt; Available &amp;&amp; R &lt; Need</li>
<li>如果满足1，使用表1表示分配后的资源表T1，再次计算是否存在安全序列，如果不安全，退回至T0，否则保存T1，下次分配将从T1开始。</li>
</ol>
<h4 id="检测和解除"><a href="#检测和解除" class="headerlink" title="检测和解除"></a>检测和解除</h4><p>使用方法：<strong>资源分配图</strong></p>
<p><strong>几个结论</strong></p>
<ul>
<li>不可完全简化 =&gt; 存在死锁</li>
<li>分配图中无环 =&gt; 不会存在死锁</li>
<li>分配图中有环 =&gt; 不一定死锁 </li>
</ul>
<p>简化方法，对一个资源分配图，首先考虑持有边，如果持有者线程能够完成(获得所有需要的资源)，将持有边消去后，将资源返回，如果不能完成，边消去后，仍保持资源占有，直到完成。</p>
<p>然后考虑请求边，如果请求的资源有空闲的，可以把边消去，若请求线程能够完成，则可将该资源返回，否则保持占有</p>
<p>重复上述过程，直至卡住，或者全部成孤立。</p>
<p><strong>解除</strong></p>
<p>通过撤销进程或者挂起进程来释放一些资源，进而推动僵持状态。</p>
<p>而具体的对哪些进程，以什么样的顺序进行操作，可以参考<code>Dijkstra</code>之类的算法，找到一种损耗最小、利益最大的方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%9B%B9%E8%BE%B0%E5%AE%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%9B%B9%E8%BE%B0%E5%AE%87/" class="post-title-link" itemprop="url">2024秋冬开源操作系统训练营第一、二阶段总结-曹辰宇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-10 23:53:10" itemprop="dateCreated datePublished" datetime="2024-11-10T23:53:10+00:00">2024-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/blog/" itemprop="url" rel="index"><span itemprop="name">blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="阶段一：rust语言学习阶段"><a href="#阶段一：rust语言学习阶段" class="headerlink" title="阶段一：rust语言学习阶段"></a>阶段一：rust语言学习阶段</h1><pre><code>学了一门新的语言，很是开心，对于Rust这门语言，在使用了一段时间后，虽然编译器折磨了我好久好久，但是，适应后我觉得实在是太贴心了。我不用担心内存
莫名其妙崩溃，不用担心自己的代码“不够快”。对于C++来说，Rust更像工业化的结晶，浑身上下散发着标准化的气息，我认为Rust的未来是光明的，它肯定会逐渐
顶替掉现在几大编程语言的地位。</code></pre><h1 id="阶段二：rCore-OS设计实现阶段"><a href="#阶段二：rCore-OS设计实现阶段" class="headerlink" title="阶段二：rCore OS设计实现阶段"></a>阶段二：rCore OS设计实现阶段</h1><pre><code>这个阶段我获益匪浅，反复修bug也极大增强了我的编程能力，真的很喜欢，就是时间好感呀┭┮﹏┭┮，现在马上时间就截止了</code></pre><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><pre><code>实现了一个TaskInfo的提取，本身难度不大，不过刚接触系统的我写了好久，后面发现关键问题后自然就“迎刃而解”了
。</code></pre><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><pre><code>实现虚拟内存，诶，之前我暑假就学习了CSAPP，对虚拟内存的运作还是比较熟悉的，可是，我没有做实验，呀呀呀呀。做实验时那个TimeVal我一直不确定怎么
处理，还有就是我一开始思路严重有问题，舍弃了已有的封装好的系统，企图自己在写一个全局内存管理器。其实用户空间跟每个任务已经绑定在一起了，轻轻push
一下就好了。在四处求救后TimVal也是解决了</code></pre><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><pre><code>这个实验不理解具体区别，我一遍就过了，嘻嘻</code></pre><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><pre><code>文件IO重定向，这个我全程独立解决，并且我认为很好的实现了最开始的要求，unlinkat能够替换掉close,并且更改到了内存。</code></pre><h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><pre><code>很难，很有跳战，银行家算法也让人眼前一亮，哈哈，写出来了</code></pre><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p>  诶，最后一个实验自己sys_get_time没写，一直卡关，真的好无语</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-MawtoA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-MawtoA/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营第一、二阶段总结报告 - MawtoA</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-10 23:38:30" itemprop="dateCreated datePublished" datetime="2024-11-10T23:38:30+00:00">2024-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>在参加训练营之前，我已经简单学习了一些 Rust 的相关知识，因此 Rustlings 我非常块的就完成了。在这个阶段的学习中，我复习了一些 Rust 的卖点，像是所有权和生命周期模型；除此之外也有一些新东西，尤其是宏和单元测试相关的内容，在之前的入门学习中我只是匆匆略过，到了现在才发现还有许多我没有关注到的重要的细节。</p>
<p>除了对 Rust 的学习，这个阶段对于我熟悉开发工具也提供了很大的帮助。由于学习时基本接触不到现代的项目开发，我对 git 这样的开发工具以及远程仓库、第三方库等等概念都没有了解。通过在设置 Rustling 的过程中反复使用各种命令、配置开发环境，我对接触大型项目也稍微自信起来了。</p>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>第二阶段对我就是非常大的挑战了。这次训练营可以说是我第一次接触操作系统底层，中间很多课程、作业也学的很辛苦，不过看着 ci 一片绿油油的 [PASS] 还是不由得感觉到一些成就感的。</p>
<p>这一阶段的学习我都是按照“看简略版教程 -&gt; 看源代码 -&gt; 参考完整版教程 -&gt; 尝试实现 -&gt; 看群友讨论难点”这样的节奏完成的。中间被别的事情占了一点时间，所以最后变得很仓促，好在是压线过关了，大概我的答案还有很多问题要我回去修改吧。</p>
<p><strong>lab3</strong> 现在看来是其中最基础的一课了，不过刚拿到题目的时候还是让我面对着茫茫代码无从下手。现在想来，这一章最重要的就是推动我大胆行动，不要害怕动已经写好的部分。后面的作业很多需要跨越好几级抽象直接在系统最底层的部分做改动，如果还是按照学校里对着函数填空的思维去做是不可能有办法的。</p>
<p><strong>lab4</strong> 主要关注的是“地址空间”抽象，对于写习惯了应用软件的人来说“解引用指针”突然变成了一个要跨越页面页帧、从好几层字典树中查表的行为，算是一个不小的跨度了，从群友的反馈来看这一篇作业也有一定难度。不过系统已经完成的部分中其实有许多可以类比推广的部分，比如 <code>translated_byte_buffer</code> 的实现稍加修改就能够变成“解引用指针”的 <code>translated_refmut</code>，像是作业中的其它部分也有类似的部分可以借鉴。</p>
<p><strong>lab5</strong> 的 <code>sys_spawn</code> 可以参考 fork 和 exec 两大函数比较轻松的写完，不过 stride 算法就有一些难度了。说实话由于测例无法涵盖算法的所有问题，我在写这一段的时候也是一头雾水，到现在也不知道自己写的有没有问题。</p>
<p><strong>lab6</strong> 是我认为这次作业的另一大难点，文件系统的几个 <code>Inode</code> 一开始让我陷入了混乱，不知不觉就把该磁盘上修改的节点修改到抽象节点上了。最后的实现也有一些偷懒的地方，链接没有和文件分开，擦除链接也有点粗暴，不过我想几个关键的思考方向我是没有搞错的。</p>
<p><strong>lab8</strong> 虽然指导我使用银行家算法，但我的实现采用的是维护资源图、尝试解锁时寻找环的思路，好在从最后的结果来看我想应该是没有太大的问题的。</p>
<p>最后还是很幸运能通过这一阶段的训练营，感觉这两个月因为训练营过的非常充实，也对自己以后很可能投入的领域有了真正的了解，希望能带着这些收获继续走下去吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%A8%8A%E6%99%BA%E5%8A%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%A8%8A%E6%99%BA%E5%8A%9B/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营一二阶段总结-樊智力</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-10 23:08:42" itemprop="dateCreated datePublished" datetime="2024-11-10T23:08:42+00:00">2024-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h1><p>21年冬季就接触过rust，但是后续没有继续学，直到今年5月份劳动节假期看到rust嵌入式群里活跃的气氛才逐渐入门，这次rustlings做第三次了，这次比之前多了算法题环节。<br>一直有人调侃用rust写个链表，这次真就写了一次链表，rust的裸指针乱飞。</p>
<h1 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h1><h2 id="ch1-3"><a href="#ch1-3" class="headerlink" title="ch1-3"></a>ch1-3</h2><p>深刻理解了操作系统的上下文切换，从最开始内核创建用户态程序，到用户态发起系统调用在返回的整个流程。</p>
<h2 id="ch4"><a href="#ch4" class="headerlink" title="ch4"></a>ch4</h2><p>工作第二年接触过内存分配的代码一直不是很明白，尤其是在触发中断时，页表是怎么从进程空间切换到内核空间，以前只是粗略的了解Linux会将内核对应的内存映射到进程空间，在这个实验中又学到“双页表这个概念”，比较两种的优劣</p>
<h2 id="ch5"><a href="#ch5" class="headerlink" title="ch5"></a>ch5</h2><p>以前对进程创建的了解仅限于fork这个系统调用，对其他进程相关的系统调用知之甚少，这次在参考fork、exec两个系统调用实现spwan过程中，理解了为什么</p>
<h2 id="ch6"><a href="#ch6" class="headerlink" title="ch6"></a>ch6</h2><p>这个实验中学习了文件系统在物理存储设备的布局方式，不过，该文件系统较为简单，应该是类似ramdisk的实现，并未考虑磨损均衡，实验中的部分实现也都可以偷懒。<br>实验中最难的部分就是文件相关的那么多结构体，部分是方便操作系统进行管理的，部分是真实存在于块设备中的索引结构以及文件组织结构。<br>在实验代码中也学到了rust trait对象的使用方式，Linux里一切皆文件的概念有了真切的感受。</p>
<h2 id="ch7"><a href="#ch7" class="headerlink" title="ch7"></a>ch7</h2><p>在过去写代码时，对进程间通信没有明确概念，尤其是敲命令行时，并没有想过管道符的实现，操作系统借助文件的概念，通过标准输入输出将管道符的多个程序连接到一起，在流水线处理某一任务时又方便又能充分发挥机器性能。</p>
<h2 id="ch8"><a href="#ch8" class="headerlink" title="ch8"></a>ch8</h2><p>到最后六小时才开始做这个，多亏群里好心人指点，才能赶在最后时间完成，不得不承认rust的静态分析真的不错，哪里变红改哪里。</p>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>在毕业两年后有机会学习清华的操作系统课程倍感荣幸，补上了我本科操作系统选修未开课的遗憾，也补上了我工作两年中知识欠缺的地方。</p>
<p>阶段三我来了！！！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/10/%E5%B0%9A%E4%B9%A6%E7%9A%84rcore%E7%AC%94%E8%AE%B0-%E9%98%B6%E6%AE%B51%EF%BC%8C2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/10/%E5%B0%9A%E4%B9%A6%E7%9A%84rcore%E7%AC%94%E8%AE%B0-%E9%98%B6%E6%AE%B51%EF%BC%8C2/" class="post-title-link" itemprop="url">尚书的rcore笔记-2024Fall阶段1，2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-10 23:03:52" itemprop="dateCreated datePublished" datetime="2024-11-10T23:03:52+00:00">2024-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实在笔者去年大二的时候，就了解了一些系统赛和rCore的相关信息，当时人比现在少很多，笔者也因为课业压力很早就放弃了。今年虽然同样有些别的事要忙，但是也各抽出一周写了前两个阶段。</p>
<p>在此期间，充分感受到了rust的优势，如果换成cpp的话我可能早就放弃或者早就做完了（x，rust有一种被编译器推着前行的感觉，并且rcore的代码组织相当优秀，无论是抽象层还是语法设计，都十分值得学习。</p>
<h2 id="rustlings"><a href="#rustlings" class="headerlink" title="rustlings"></a>rustlings</h2><p>第一阶段是来自rust官方社区的rustlings语法练习，并且经过了一定的增加，加了一些用得到的数据结构算法内容。总体没有什么难度，也并不需要完全弄懂，起到了一个入门的作用。所有权，生命周期，泛型之前就在moderncpp中有所涉猎，所以理解起来没有遇到什么困难。</p>
<h2 id="rCore"><a href="#rCore" class="headerlink" title="rCore"></a>rCore</h2><p>整个第二阶段的质量相当高，除了视频以外可以说感觉做下来不逊于6.1810，题目相当的有代表性并且需要读懂很多部分的代码才能获取正确的思路，起到了很好的引导作用。</p>
<h3 id="ch3"><a href="#ch3" class="headerlink" title="ch3"></a>ch3</h3><p>ch3的潜在难度在于内核栈较小导致无法直接传递较大的数组，导致只能通过引用来传递，即使这里并不涉及地址变换。如果在ch3中遇到了这个坑，就更能理解后续页表的意义。</p>
<h3 id="ch4"><a href="#ch4" class="headerlink" title="ch4"></a>ch4</h3><p>ch4中带领入门了段页式的页表和页帧。需要正确掌握好页表和物理页帧的对应关系，确保这两者是同步的而且是有效的。</p>
<h3 id="ch5"><a href="#ch5" class="headerlink" title="ch5"></a>ch5</h3><p>ch5的编码量较少，只需要找到正确的地方插入pcb的转移和下个task的获取即可。</p>
<h3 id="ch7"><a href="#ch7" class="headerlink" title="ch7"></a>ch7</h3><p>ch7入门了fs的抽象，从OSInode到Inode到diskInode到blockcache的抽象，层层深入，再加上用于查找的dirEnrty和fdtable，使得整个抽象层设计相当清晰。</p>
<h3 id="ch8"><a href="#ch8" class="headerlink" title="ch8"></a>ch8</h3><p>ch8的难度在于语义含糊，我们仅有两类资源，其中mutex每种只有一个，semaphore每种可以有多个。在此基础上需要正确的理解need和alloc对应的语义，并且在阻塞线程被唤醒时及时更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-rjy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-rjy/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营第一、二阶段总结报告-rjy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-10 22:41:54" itemprop="dateCreated datePublished" datetime="2024-11-10T22:41:54+00:00">2024-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/blog/" itemprop="url" rel="index"><span itemprop="name">blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>之前自己写过rustlings的一部分，这次是完整地完成了。rust和其他语言的不同之处在于，所有权、借用和引用检查等，在内存管理、安全性、并发性方面都有其优势和特点。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>这段时间的操作系统学习让我了解了计算机系统中各个模块的结构和交互过程。从搭建实验环境到实现进程管理、文件系统与并发控制，我逐步掌握了操作系统的核心概念与实现方法。</p>
<p>在实验环境配置上，通过熟悉 QEMU 等模拟工具的配置，我能够创建隔离的测试环境，保证了开发过程的安全性和可控性。紧接着，在应用程序与基本执行环境部分，我学习了如何在内存中定位程序的不同部分，了解了程序的加载和执行过程，打下了对操作系统基本管理能力的初步认知。</p>
<p>随着课程深入，我逐渐接触到批处理系统和多道程序设计，进一步理解了操作系统资源分配与调度策略。这帮助我认识到系统资源的有限性，以及多任务分配中提高资源利用率的必要性。在此基础上，我学习了进程及地址空间的相关知识，理解了分时多任务的原理，并学会了如何通过调度算法提升系统响应速度和处理效率。</p>
<p>在进程管理与进程间通信部分，我逐步掌握了如何创建和管理进程，以及进程如何在系统中相互通信。这些内容让我理解了操作系统在多任务处理中的关键作用，也使我了解到不同进程通信方式的特点和应用场景。</p>
<p>最后，通过对文件系统与 I/O 重定向的学习，我了解了数据存储、访问控制与设备交互的基本机制。此外，并发编程的知识让我对线程和同步控制有了更清晰的认识，并学会了如何在多任务环境下避免资源竞争和死锁问题。</p>
<p>总体而言，这次学习不仅使我对操作系统的工作原理有了系统化的理解，还培养了我的编程能力和调试技能。操作系统涉及的原理性问题较多，需要不断在实践中加深理解，也让我认识到学习操作系统的深度和广度，为未来进一步的深入学习打下了坚实的基础。</p>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>因为之前没有学习过操作系统，每个任务对我来讲都很困难，这次算是入门。</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>有很多代码在写lab的时候实际上还没仔细看。<br>有些功能可能写的不够漂亮，test偏弱，可能还有一些错误没有被发现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-lzh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/10/2024%E7%A7%8B%E5%86%AC%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-lzh/" class="post-title-link" itemprop="url">2024秋冬开源操作系统训练营一二阶段总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-10 22:39:56" itemprop="dateCreated datePublished" datetime="2024-11-10T22:39:56+00:00">2024-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:49" itemprop="dateModified" datetime="2025-05-15T08:27:49+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E7%A7%8B%E5%86%AC%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024秋冬开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先非常感谢训练营的主办方为我们提供了交流的平台和详细的文档，也非常感谢群里的助教和各位大佬们。作为一个已经工作了几年的人，如果没有这次训练营的机会，我很难相信自己能把操作系统重新捡起来并坚持学习。</p>
<h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>这个阶段我主要是通过rustlings来零基础学习rust语法，主要参考的的书籍有《Rust圣经》和《Rust程序设计》。感觉rustlings有些过于简单，只能用来粗略地学习一下语法，通过了也谈不上熟练，我就在后面的项目编程中因此浪费了大量的时间去调试一下基础的rust语法问题，后期准备通过斯坦福的cs110l课程来加深下对rust在内存安全方面的理解。此外，在数据结构和算法部分我也主要靠chatGPT提供思路，很受打击，未来准备在leetcode上多刷下题来长长见识。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>再次感谢文档的详细和版本划分的合理，本来之前停留在课本上的内存划分、进程调度、cache、并发等概念都变得触手可用，操作系统的迷雾总算被拨开了一角。</p>
<p>ch1里主要是摆脱了标准库依赖构建了祼机执行环境。通过qemu模拟器加载了最初版本的内核并在屏幕上输出了文字，我第一次感觉到了操作系统其实也和普通的应用程序一样，克服了畏难情绪。在这里也对第一性原理也了进一步的了解，再复杂的程序它的最初版本也是比较精简和易于理解的，从能完成最小功能的初始版本开始，会更有利于进一步学习其它更加抽象的概念。</p>
<p>ch2里的难点在于汇编知识和链接器的使用。我以前对于链接器的认识仅限于使用c++第三方库，但ch2里对于link_app.S的使用让我大开眼界，原来程序链接时每个段的处理可以这么灵活。同时，我也学到了在rust里通过extern c引入外部汇编文件定义的符号，可以直接拿到内存地址。我之前没有学过riscv架构，未来准备通过《RISC-V体系结构编程与实践》系统学习。</p>
<p>ch3里的难点在于汇编写的_switch在任务切换里的作用，例如保存寄存器、切换栈、切换控制流等。内核通过内嵌ecall汇编指令来引发trap异常陷入S特权级。抢占式调度里让我认识了时钟中断，原来轮转调度里的时间片就是通过定时器来触发时钟中断，进行任务切换。</p>
<p>ch4里内存地址空间我认为是最有趣也是最难的部分。通过为用户和内核单独实现的地址空间，解释了虚地址和物理地址的由来。为了实现地址空间，rcore里设计了大量的数据结构，重点要掌握MapArea和MemorySet里接口的使用，查找页表、生成地址空间等核心功能都在里面实现。</p>
<p>ch5里进程的精华主要在于fork和exec等系统调用的实现，本章还实现了一个shell程序，让我理解到了进程怎么从一个程序通过fork和exec运行其它程序的。</p>
<p>ch6里是文件的实现，ch8里是并发，我对这两章的理解不太深，主要还是围绕测试案例来理解的，后续还要再反复多次的看看文档。</p>
<p>现在非常期待下一阶段ArceOS的学习，希望能成为我入门hypervisor的阶梯！！！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/15/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/blog/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/67/">67</a><a class="extend next" rel="next" href="/blog/page/17/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
