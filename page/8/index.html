<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/8/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">694</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">605</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/29/2025%E5%B9%B4%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E8%87%AA%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/29/2025%E5%B9%B4%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E8%87%AA%E7%94%B1/" class="post-title-link" itemprop="url">2025年春夏开源操作系统训练营三阶段总结-自由</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-29 18:55:29" itemprop="dateCreated datePublished" datetime="2025-04-29T18:55:29+00:00">2025-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:35" itemprop="dateModified" datetime="2025-05-23T06:52:35+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025年春夏开源操作系统训练营三阶段总结"><a href="#2025年春夏开源操作系统训练营三阶段总结" class="headerlink" title="2025年春夏开源操作系统训练营三阶段总结"></a>2025年春夏开源操作系统训练营三阶段总结</h1><h2 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h2><p>第一次写rust，被所有权干烂了，不停和编译器搏斗+不停拷问AI终于磕磕绊绊写完了，以前习惯于C++的引用和指针乱飘了，写rust确实比C和C++安全，因为有编译器的所有权机制保障。</p>
<h2 id="第二阶段总结"><a href="#第二阶段总结" class="headerlink" title="第二阶段总结"></a>第二阶段总结</h2><p>因为以前写过NJUPA(极其推荐)，所以对上下文切换有一点概念。rcore-os的上下文切换采用了xv6类似的方式，在内核内部做控制流切换来切换执行的用户程序。对于操作系统中常用的锁，rcore采用了单核中的使用rust所有权机制来实现，上锁的时候将所有权转交给函数，尝试二次获取的时候就会因为所有权引发rust错误，避免了内核的死锁的情况。cargo的编译链接功能确实比GNU那一套方便，rust的属性语法支持也比C++要好很多。</p>
<p>地址空间和页表中极多的用来表示地址组成的结构体，充分体现了rust面向对象的特性和<code>into</code>的语法，增加了代码的可读性，以前用C系的写也就使用各种宏。rcore用了额外的BTreeMap来支持快速查询页表。作业题的实现也大多是调用现有的函数就差不多可以了。</p>
<p>到文件系统这里比较新鲜，因为以前没有怎么接触过，文件系统的实现层层嵌套，层层抽象，一个功能实现往往要修改多层，理解起来比较困难。</p>
<p>并发的作业是用Coffman提出的方法做死锁检测，开始的时候理解成了银行家算法，读作业提示的时候也没有读懂，卡了很长时间，在群u的提示下才通过。后来在上操作系统课的时候翻到书上才知道这是Coffman的死锁检测算法(书上的描述其实和作业里写得差不多)。</p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>第三阶段换了个内核模式叫unikernel,不太习惯这样的组件化操作系统，还是习惯以前的传统宏内核结构。</p>
<p>print_with_color很简单，理解一下arceos提供的axstd模块，为内核应用提供了运行时环境。</p>
<p>support_hash_map在理解了rust可以自定义堆分配器后，唯一要解决的就是rust中如何得到一个hashable值的hash值，然后做简单的映射即可，测试不需要特别追求效率。</p>
<p>alt_alloc主要是实现一下需要的接口，了解如何向arceos添加自己的分配器，<code>bump allocator</code>可以说是最简单的分配器了。</p>
<p>ramfs_rename要把cargo里的包换成arceos下面的(不然文件系统的包永远是网上拉下来的)，找到对trait<code>VfsOps</code>和<code>VfsNodeOps</code>的实现之后，搞清楚记录文件的数据结构，实现<code>rename</code>就可以了。</p>
<p>sys_map同样搞清楚<code>task_ext</code>提供的接口就可以直接调库了，第一次实现忘记输入地址是<code>NULL</code>的话要由内核自己找地址，遂发现了一个叫做<code>find_free_area</code>的妙妙工具。</p>
<p>simple_hv最简单的一次，同样的由操作系统代为执行一些指令的手法可以用来帮用户程序加载一些未对齐的数据（如果处理器不支持）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/28/%E5%88%9D%E6%8E%A2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/28/%E5%88%9D%E6%8E%A2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">初探操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-28 16:40:48" itemprop="dateCreated datePublished" datetime="2025-04-28T16:40:48+00:00">2025-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:36" itemprop="dateModified" datetime="2025-05-23T06:52:36+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%84%9F%E6%82%9F/" itemprop="url" rel="index"><span itemprop="name">感悟</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%84%9F%E6%82%9F/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二阶段总结：操作系统学习的感悟与理解"><a href="#第二阶段总结：操作系统学习的感悟与理解" class="headerlink" title="第二阶段总结：操作系统学习的感悟与理解"></a>第二阶段总结：操作系统学习的感悟与理解</h1><p>经过这一阶段对操作系统核心内容的系统学习和实践，我对操作系统的本质、关键机制以及与 Rust 结合的优势有了更深刻的理解。以下是我的主要体会和总结：</p>
<hr>
<h2 id="一、操作系统的本质与核心任务"><a href="#一、操作系统的本质与核心任务" class="headerlink" title="一、操作系统的本质与核心任务"></a>一、操作系统的本质与核心任务</h2><p>操作系统是管理硬件资源、为上层应用提供抽象和隔离的基础软件。它的核心任务包括：</p>
<ul>
<li><strong>进程与线程管理</strong>：通过进程（资源分配单位）和线程（调度单位）实现多任务并发，保障系统的响应性和资源利用率。PCB（进程控制块）和 TCB（线程控制块）是操作系统调度和管理的核心数据结构。</li>
<li><strong>内存管理</strong>：通过虚拟内存、分页机制和权限控制，实现进程隔离、内存高效分配与回收。页表、TLB、懒分配、写时复制等机制极大提升了系统的安全性和性能。</li>
<li><strong>进程调度</strong>：采用多种调度算法（如时间片轮转、优先级、MLFQ等）实现公平与高效的 CPU 分配。上下文切换和调度策略直接影响系统吞吐和响应速度。</li>
<li><strong>系统调用接口</strong>：为用户程序提供受控访问硬件和内核资源的通道，实现用户态与内核态的安全切换。</li>
<li><strong>硬件抽象与性能优化</strong>：通过缓存、TLB、ASID 等机制优化访问速度，利用中断和异常机制实现高效的事件响应。</li>
</ul>
<hr>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/04/28/%E5%88%9D%E6%8E%A2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/28/OrangeQi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/28/OrangeQi/" class="post-title-link" itemprop="url">OrangeQi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-28 02:39:23" itemprop="dateCreated datePublished" datetime="2025-04-28T02:39:23+00:00">2025-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:36" itemprop="dateModified" datetime="2025-05-23T06:52:36+00:00">2025-05-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前对操作系统有一定理论基础，rcore 和 arceos 项目对我最大的挑战主要包括：</p>
<ol>
<li>risc-v 体系结构的知识，尤其是特权架构。这对理解 trap、context_switch、地址空间相关的代码极其重要。</li>
<li>arceos 项目的组织构建。最底层是 axhal，抽象了硬件架构和运行平台，往上是各个 module 例如 axtask 等，再向上是 axapi 乃至 ulib。这种组件化的设计思想充分利用的 rust 语言的优势，极大方便构建。</li>
</ol>
<p>unikernel 架构是没有特权级切换的，应用程序也运行在 s 态。刚开始没有仔细理解 ppt，给我造成了挺大的困扰。</p>
<p>hashmap 的实验我并没有自己手写代码，而是直接引入了 hashbrown 库。但手撕一下代码应该能更加锻炼能力。</p>
<p>此外，hypervisor 给我带来了挺大的困难，参考其他同学的经验我才得以通过。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap2/" class="post-title-link" itemprop="url">rcore-handnote-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:35" itemprop="dateModified" datetime="2025-05-23T06:52:35+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><img src="/blog/.io//assets/Lab2-1.png" alt="Introduction"></p>
<p>It corresponds to <code>riscv</code>:</p>
<ul>
<li>Privilege for <code>S</code>(guaranteed by <code>Supervisor Execution Environment</code> of <code>RustSBI</code>)</li>
<li>User for <code>U</code>(constructed in current chapter as <code>Application Execution Environment</code>)</li>
</ul>
<p>Reason:</p>
<ul>
<li>Safety(Prevent app from accessing kernel)</li>
<li>Recoverable</li>
</ul>
<p>Workflow:</p>
<ul>
<li>Start application and user-mode context</li>
<li><strong>Trap</strong>(Called by system level) to handle system<ul>
<li>Goes wrong! Kill it!</li>
<li>Finish! Next!</li>
</ul>
</li>
<li><strong>Restore</strong> to user-mode context</li>
</ul>
<p><code>riscv</code> designs following <code>CSR</code>(Control and Status Register) to handle this:</p>
<h3 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h3><p><img src="/blog/.io//assets/Lab2-2.png" alt="CSR"></p>
<p>Begin <strong>Trap</strong>:</p>
<ul>
<li>sstatus: <code>SPP</code> seg to the current level of CPU.</li>
<li>sepc: next addr after Trap finished.</li>
<li>scause/stval: Trap cause and additional info.</li>
<li>stvec: storage of entry addr of Trap</li>
</ul>
<blockquote>
<p><strong>stvec</strong> is a 64-bit CSR, with:</p>
<ul>
<li>MODE(Direct/Vectored) <code>[1:0]</code>(read from right to left): 2-bits</li>
<li>BASE <code>[63:2]</code>: 62-bits</li>
</ul>
</blockquote>
<p>finally, it will return by instruction <code>sret</code> which will change level and jump by <code>sepc</code>.</p>
<h3 id="Construct-Trap"><a href="#Construct-Trap" class="headerlink" title="Construct Trap"></a>Construct Trap</h3><p>Design:</p>
<ul>
<li>General register will be shared by U-level and S-level.</li>
<li>Maintain a reasonable state of <code>CSR</code>.</li>
<li>Separate workflow of U-level and S-level by stack</li>
</ul>
<p>Construct:</p>
<ul>
<li>build <code>KernelStack</code> and <code>UserStack</code> for separation</li>
<li>in <code>KernelStack</code>, we store <code>TrapContext</code> in it, by asm and rust to control dispatch and handle, then store the code to <code>stvec</code> as the entry of Trap.</li>
<li>restore register for <code>UserStack</code> by push a new context refer to <code>UserStack</code>.</li>
</ul>
<p>build stack and push context:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack struct ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// buttom to top</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_sp</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.data.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span> + KERNEL_STACK_SIZE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_context</span></span>(&amp;<span class="keyword">self</span>, cx: TrapContext) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> cx_ptr = (<span class="keyword">self</span>.get_sp() - core::mem::size_of::&lt;TrapContext&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> TrapContext;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *cx_ptr = cx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; cx_ptr.as_mut().unwrap() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>], <span class="comment">// General register</span></span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// set stack pointer to x_2 reg (sp)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_sp</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.x[<span class="number">2</span>] = sp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// init app context</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>(entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sstatus = sstatus::read(); <span class="comment">// CSR sstatus</span></span><br><span class="line">    sstatus.set_spp(SPP::User); <span class="comment">//previous privilege mode: user mode</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cx = <span class="keyword">Self</span> &#123;</span><br><span class="line">        x: [<span class="number">0</span>; <span class="number">32</span>],</span><br><span class="line">        sstatus,</span><br><span class="line">        sepc: entry, <span class="comment">// entry point of app</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cx.set_sp(sp); <span class="comment">// app's user stack pointer</span></span><br><span class="line">    cx <span class="comment">// return initial Trap Context of app</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will design <code>__alltrap</code> and <code>__restore</code> for operation by asm and part of rust:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_GP n</span><br><span class="line">    sd x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_GP n</span><br><span class="line">    ld x\n, \n*8(sp)</span><br><span class="line">.endm</span><br><span class="line">.align_2</span><br><span class="line">__alltraps:</span><br><span class="line">    ...</span><br><span class="line"># set input argument of trap_handler(cx: &amp;mut TrapContext)</span><br><span class="line">    mv a0, sp # sp is point to TrapContext in kernel stack</span><br><span class="line">    call trap_handler # (&amp;mut TrapContext)</span><br><span class="line"></span><br><span class="line">--restore:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>To handle Trap context, we will use <code>riscv</code> lib:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">riscv = &#123; git = <span class="string">"https://github.com/rcore-os/riscv"</span>, features = [<span class="string">"inline-asm"</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">"trap.S"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="function"><span class="keyword">fn</span> <span class="title">__alltraps</span></span>(); &#125;</span><br><span class="line">    <span class="comment">// write to stvec</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::write(__alltraps <span class="keyword">as</span> <span class="built_in">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_handler</span></span>(cx: &amp;<span class="keyword">mut</span> TrapContext) -&gt; &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>restore operation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="function"><span class="keyword">fn</span> <span class="title">__restore</span></span>(cx_addr: <span class="built_in">usize</span>); &#125;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    __restore(KERNEL_STACK.push_context(</span><br><span class="line">        TrapContext::app_init_context(APP_BASE_ADDRESS, USER_STACK.get_sp())</span><br><span class="line"><span class="comment">// This context store the ptr to UserStack for restoration</span></span><br><span class="line">    ) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Construct-User-App"><a href="#Construct-User-App" class="headerlink" title="Construct User App"></a>Construct User App</h3><ul>
<li>Link app binary to kernel with specify memory layout</li>
<li>Read the layout, use <code>AppManager</code> to maintain and store</li>
<li>Load app from memory layout, copy consecutively to <code>APP_BASE_ADDRESS</code>(Currently we have no ability to dynamically read address)</li>
<li>AppManager will run each app</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># os&#x2F;src&#x2F;link_app.S</span><br><span class="line"></span><br><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app # read from the ptr</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 5</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_4_end&#96;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Design it!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppManager</span></span> &#123;</span><br><span class="line">    num_app: <span class="built_in">usize</span>,</span><br><span class="line">    current_app: <span class="built_in">usize</span>,</span><br><span class="line">    app_start: [<span class="built_in">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part of read in static init of AppManager</span></span><br><span class="line"><span class="keyword">let</span> num_app_ptr = _num_app <span class="keyword">as</span> <span class="built_in">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">usize</span>;</span><br><span class="line"><span class="keyword">let</span> num_app = num_app_ptr.read_volatile();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> app_start: [<span class="built_in">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> app_start_raw: &amp;[<span class="built_in">usize</span>] =  core::slice::from_raw_parts(</span><br><span class="line">    num_app_ptr.add(<span class="number">1</span>), num_app + <span class="number">1</span></span><br><span class="line">);</span><br><span class="line">app_start[..=num_app].copy_from_slice(app_start_raw);</span><br></pre></td></tr></table></figure>

<p>Load App:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// part of code of copying to kernel</span></span><br><span class="line">asm!(<span class="string">"fence.i"</span>);</span><br><span class="line"><span class="comment">// clear app area</span></span><br><span class="line">core::slice::from_raw_parts_mut(</span><br><span class="line">    APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>,</span><br><span class="line">    APP_SIZE_LIMIT</span><br><span class="line">).fill(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> app_src = core::slice::from_raw_parts(</span><br><span class="line">    <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id]</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> app_dst = core::slice::from_raw_parts_mut(</span><br><span class="line">    APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>,</span><br><span class="line">    app_src.len()</span><br><span class="line">);</span><br><span class="line">app_dst.copy_from_slice(app_src);</span><br></pre></td></tr></table></figure>

<p>Run each app!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run_next_app</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> app_manager = APP_MANAGER.exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> current_app = app_manager.get_current_app();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        app_manager.load_app(current_app);</span><br><span class="line">    &#125;</span><br><span class="line">    app_manager.move_to_next_app();</span><br><span class="line">    <span class="built_in">drop</span>(app_manager);</span><br><span class="line">    <span class="comment">// before this we have to drop local variables related to resources manually</span></span><br><span class="line">    <span class="comment">// and release the resources</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="function"><span class="keyword">fn</span> <span class="title">__restore</span></span>(cx_addr: <span class="built_in">usize</span>); &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.push_context(</span><br><span class="line">            TrapContext::app_init_context(APP_BASE_ADDRESS, USER_STACK.get_sp())</span><br><span class="line">        ) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Unreachable in batch::run_current_app!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main logic:</span></span><br><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"></span><br><span class="line">...above code</span><br><span class="line"><span class="comment">// load entry for trap</span></span><br><span class="line">trap::init()</span><br><span class="line"><span class="comment">// load app</span></span><br><span class="line">batch::run_next_app()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap3/" class="post-title-link" itemprop="url">rcore-handnote-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:35" itemprop="dateModified" datetime="2025-05-23T06:52:35+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We need to place multiple app to multiple memory address to run app in cycle. Rather run once and clear for next.</p>
<p>First We want to place each app to each isolated addr, due to our kernel restriction, we need to load it with <code>build.py</code>.</p>
<hr>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Task: a workflow process</p>
<p>Define every time slice of <strong>Task</strong> as <strong>Task Slice</strong></p>
<p>Define the switch between app as <strong>Task switching</strong></p>
<p>We need to store <strong>Task Context</strong></p>
<p>Design:<br><img src="/blog/.io//assets/Lab3-1.png" alt="switch"></p>
<p>We will store these register in ctx:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span></span> &#123;</span><br><span class="line">    ra: <span class="built_in">usize</span>,</span><br><span class="line">    sp: <span class="built_in">usize</span>,</span><br><span class="line">    s: [<span class="built_in">usize</span>; <span class="number">12</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line">...</span><br><span class="line"># logic by store previous context and take out the new one to current register</span><br></pre></td></tr></table></figure>

<p>Expose to Rust</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/switch.rs</span></span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">"switch.S"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::TaskContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">__switch</span></span>(</span><br><span class="line">        current_task_cx_ptr: *<span class="keyword">mut</span> TaskContext,</span><br><span class="line">        next_task_cx_ptr: *<span class="keyword">const</span> TaskContext</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will design <code>TaskManager</code>:</p>
<ul>
<li>Store each App state array and current running app.</li>
<li>each state store <code>TaskContext</code> and <code>TaskState</code> for running or exited etc…</li>
<li>Init and ready by store the <code>__restore</code> ctx to <code>TaskContext</code></li>
<li>Run for switch cx if needed.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> current_task_cx_ptr = &amp;<span class="keyword">mut</span> inner.tasks[current].task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line"><span class="keyword">let</span> next_task_cx_ptr = &amp;inner.tasks[next].task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line"><span class="built_in">drop</span>(inner);</span><br><span class="line"><span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">	__switch(</span><br><span class="line">		current_task_cx_ptr,</span><br><span class="line">		next_task_cx_ptr,</span><br><span class="line">	);</span><br><span class="line">&#125;rust</span><br></pre></td></tr></table></figure>


<h3 id="Dispatch-Design"><a href="#Dispatch-Design" class="headerlink" title="Dispatch Design"></a>Dispatch Design</h3><h4 id="Collaboration"><a href="#Collaboration" class="headerlink" title="Collaboration"></a>Collaboration</h4><p>Manually design interface <code>yield</code> for App to use</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_yield</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    syscall(SYSCALL_YIELD, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">yield_</span></span>() -&gt; <span class="built_in">isize</span> &#123; sys_yield() &#125;</span><br></pre></td></tr></table></figure>

<p>But it can be inefficient for some case that app already done its work but reluctant to exit.</p>
<h4 id="Preemptive"><a href="#Preemptive" class="headerlink" title="Preemptive"></a>Preemptive</h4><p>We will design interrupt clock in a fixed time bound to force switch between app.</p>
<ul>
<li>Set timer design and get time</li>
<li>Set timer for trigger</li>
<li>enable timer and handle the interrupt cause of Timer in <code>ecall</code></li>
</ul>
<p>You should know this as a pre-knowledge:</p>
<p><img src="/blog/.io//assets/Lab3-2.png" alt></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SBI_SET_TIMER: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_timer</span></span>(timer: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    sbi_call(SBI_SET_TIMER, timer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/timer.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::config::CLOCK_FREQ;</span><br><span class="line"><span class="keyword">const</span> TICKS_PER_SEC: <span class="built_in">usize</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_next_trigger</span></span>() &#123;</span><br><span class="line">    set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">    Trap::Interrupt(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">        set_next_trigger();</span><br><span class="line">        suspend_current_and_run_next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable supervisor clock</span></span><br><span class="line"><span class="comment">// os/src/trap/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> riscv::register::sie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">enable_timer_interrupt</span></span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; sie::set_stimer(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap4/" class="post-title-link" itemprop="url">rcore-handnote-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:35" itemprop="dateModified" datetime="2025-05-23T06:52:35+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We don’t want a fixed physical addr for allocation, rather, we want a unified abstract interface for dynamic memory layout for app storage. We call it <strong>Virtual Address</strong></p>
<p>Safety: Every app will be allocated in its own virtual memory space, so each can’t interfere others.</p>
<p>Efficiency: Every app can coexist in same time without demand of reading outer peripherals to switch app.(With development of memory size)</p>
<p>We need <strong>MMU</strong>(Memory Management Unit) to achieve <strong>Address Translation</strong> for interview from virtual to physical.</p>
<p>Different designs occur.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h3 id="Segment-Design"><a href="#Segment-Design" class="headerlink" title="Segment Design"></a>Segment Design</h3><p><img src="/blog/.io//assets/Lab4-1.png" alt="alt text"></p>
<p>Each app exist in one fixed slot for one segment as $[0,bound)$, with a linear map by <strong>MMU</strong>.</p>
<p>Problem: Wasteful and inflexible</p>
<p>We may want a different linear map for each app， for example, its allocation for heap, data, code etc… So we can dispatch memory in more finer style, but it can’t resolve the problem because now even slot is dynamically allocated, it may still exist some free memory too small to reuse, cause the <strong>External Fragment</strong> rather than <strong>Internal Fragment</strong> which is the problem due to fixed slot.</p>
<h3 id="Paging-Design"><a href="#Paging-Design" class="headerlink" title="Paging Design"></a>Paging Design</h3><p><img src="/blog/.io//assets/Lab4-2.png" alt="alt text"><br>We could set a <strong>Protection bit</strong> as <code>r</code> for read, <code>w</code> for write, <code>x</code> for execution.</p>
<p>Another way is to inverse our mind, rather take a slot on memory, we take slot on <strong>MMU</strong>, it can map its slot(now we call it <strong>Page</strong>) for real physical memory layout. To adjust, we can take slice for <strong>Page</strong> to form <strong>Frame</strong> which is a smaller unit to suit physical memory layout, each app can take many <strong>Page Number</strong> for a <strong>Page Table</strong>, record the map.</p>
<h2 id="Page-Design"><a href="#Page-Design" class="headerlink" title="Page Design"></a>Page Design</h2><p><img src="/blog/.io//assets/Lab4-3.png" alt="alt text"></p>
<p><strong>SV39</strong> only use lower 39 bits rather whole 64 bits in design even bit width is 64 bits(it’s a fairly large amount!)</p>
<p>In a address, $[11:0]$ called <strong>Page Offset</strong>, and $[38:12]$ is the <strong>VPN</strong> which will be used for location of page and use offset to direct in one page(with 4KiB in one page).</p>
<p>We should modify <code>satp</code> to open Paging for S and U-level memory.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PAGE_SIZE: <span class="built_in">usize</span> = <span class="number">4096</span></span><br><span class="line"><span class="keyword">const</span> PAGE_SIZE_BIT: <span class="built_in">usize</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>Page Size and offset to slice physical addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PhysAddr &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">floor</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123; PhysPageNum(<span class="keyword">self</span>.<span class="number">0</span> / PAGE_SIZE) &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ceil</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123; PhysPageNum((<span class="keyword">self</span>.<span class="number">0</span> + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Page Entry to bundle permission and physical page.</p>
<p><img src="/blog/.io//assets/Lab4-4.png" alt></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ppn</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123;</span><br><span class="line">	(<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).into()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">flags</span></span>(&amp;<span class="keyword">self</span>) -&gt; PTEFlags &#123;</span><br><span class="line">	PTEFlags::from_bits(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="built_in">u8</span>).unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, a simple design for page manager would be a linear map from base addr and follow up. But actually it will take a huge amount of memory due to the storage of offset by base addr for each app.</p>
<p>A finer design is from <strong>Trie</strong>. We will take index slice for each 8 bits(it will fit in to 4KB just right!), it means for each slice has 512 states, and link those state up, form a tree. Usually with 3-level for <strong>Page Index</strong>. Total 27 bits.</p>
<p>Virtual Page will reserve 27 bits for the index slice and 12 bits for offset for certain page. Total 39 bits.</p>
<p>When we transform a virtual addr to physical one, we will do the following exposition reversely.</p>
<h2 id="Page-Management-Design"><a href="#Page-Management-Design" class="headerlink" title="Page Management Design"></a>Page Management Design</h2><p>A simple allocation for page(rather management!) is stack style.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackFrameAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,  <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    end: <span class="built_in">usize</span>,      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on Allocation, we can design <strong>Page Table</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameTracker</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> FrameTracker &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// page cleaning</span></span><br><span class="line">        <span class="keyword">let</span> bytes_array = ppn.get_bytes_array();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bytes_array &#123;</span><br><span class="line">            *i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ppn &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTable</span></span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="built_in">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It means for one physical page, we will record each allocation by vector of FrameTracker as a representation of real <strong>Frame</strong> after the root.</p>
<p>We should design transformation from virtual addr to physical addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each idxs represent index slices of virtual addr.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> pte = &amp;<span class="keyword">mut</span> ppn.get_pte_array()[idxs[i]];</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">		result = <span class="literal">Some</span>(pte);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !pte.is_valid() &#123;</span><br><span class="line">		<span class="keyword">let</span> frame = frame_alloc().unwrap();</span><br><span class="line">		<span class="comment">// create or return None</span></span><br><span class="line">		*pte = PageTableEntry::new(frame.ppn, PTEFlags::V);</span><br><span class="line">		<span class="keyword">self</span>.frames.push(frame);</span><br><span class="line">	&#125;</span><br><span class="line">	ppn = pte.ppn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Page-Map-Design"><a href="#Page-Map-Design" class="headerlink" title="Page Map Design"></a>Page Map Design</h2><p>Based on our abstraction, we need a design for <code>MapArea</code> to given a map from continuous virtual address(no matter their corresponding page!) to physical address.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapArea</span></span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on continuous virtual address map, we can define discontinuous map for one app.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemorySet</span></span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="built_in">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// impl MemorySet</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;) &#123;</span><br><span class="line">	<span class="comment">// map range of virtual addr in allocation in page_table</span></span><br><span class="line">	map_area.map(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table);</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(data) = data &#123;</span><br><span class="line">		map_area.copy_data(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table, data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">self</span>.areas.push(map_area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In Each <code>MapArea</code> allocated for some key-value for virtual-physical addr, it will allocate the same for <code>PageTable</code> for <strong>Frame</strong>.</p>
<hr>
<h2 id="Allocation-Space"><a href="#Allocation-Space" class="headerlink" title="Allocation Space"></a>Allocation Space</h2><p>To open SV39, we should write instruction for <code>satp</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">token</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="number">8usize</span> &lt;&lt; <span class="number">60</span> | <span class="keyword">self</span>.root_ppn.<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">activate</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> satp = <span class="keyword">self</span>.page_table.token();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            satp::write(satp);</span><br><span class="line">            asm!(<span class="string">"sfence.vma"</span> :::: <span class="string">"volatile"</span>);</span><br><span class="line">			<span class="comment">// sfence.vma is a special instruction to clear `Translaton Lookaside Buffer` which is used for quick search for memory addr to reduce performance expenses.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Therefore, it will fill current root of physical page number as activation.</p>
<p>Notice that we should make instruction contigeous for <code>SV39</code> open in physical address to amend the gap of transformation of address before and after open.</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>Initiation for Kernel memory layout.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> memory_set = Self::new_bare();</span><br><span class="line"><span class="comment">// map trampoline</span></span><br><span class="line">memory_set.map_trampoline();</span><br><span class="line">memory_set.push(MapArea::new(</span><br><span class="line">	(stext <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">	(etext <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">	MapType::Identical,</span><br><span class="line">	MapPermission::R | MapPermission::X,</span><br><span class="line">), <span class="literal">None</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"mapping .rodata section"</span>);</span><br><span class="line"><span class="comment">// other layout ...</span></span><br></pre></td></tr></table></figure>

<p>Initiation for App memory layout.</p>
<p>Previously, we will cut off <code>elf</code> part of binary of apps, now we load it and extract useful infos, s.t. Permissions.</p>
<p><code>MemorySet</code> should allocate storage of execution code with its permissions, allocate user stack and trap context at top of the memory layout.</p>
<p>Output <code>MemorySet</code>, user stack top, entry point addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> max_end_vpn = VirtPageNum(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> max_end_va: VirtAddr = max_end_vpn.into();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user_stack_bottom: <span class="built_in">usize</span> = max_end_va.into();</span><br><span class="line"><span class="comment">// guard page</span></span><br><span class="line">user_stack_bottom += PAGE_SIZE;</span><br><span class="line"><span class="keyword">let</span> user_stack_top = user_stack_bottom + USER_STACK_SIZE;</span><br><span class="line">memory_set.push(MapArea::new(</span><br><span class="line">	TRAP_CONTEXT.into(),</span><br><span class="line">	TRAMPOLINE.into(),</span><br><span class="line">	MapType::Framed,</span><br><span class="line">	MapPermission::R | MapPermission::W,</span><br><span class="line">), <span class="literal">None</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="App"><a href="#App" class="headerlink" title="App"></a>App</h3><p>A problem is that separation of Kernel and App will also isolate <strong>Trap</strong>, the process need info from App to Kernel but App can’t see it. Therefore, we need a transfer operation. We achieve this by storing related info in <code>TrapContext</code>.</p>
<p>(Because there’s no more register to store these without breaking state like <code>sscratch</code> designed for kernel stack.)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line">	<span class="comment">// new:</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="built_in">usize</span>, </span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that we also need to modify below to trigger <code>satp</code> and specify corresponding(U-level, S-level <code>satp</code>) physical page number to change state.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># __alltraps:</span><br><span class="line"></span><br><span class="line"># load kernel_satp into t0</span><br><span class="line">ld t0, 34*8(sp)</span><br><span class="line"># load trap_handler into t1</span><br><span class="line">ld t1, 36*8(sp)</span><br><span class="line"># move to kernel_sp</span><br><span class="line">ld sp, 35*8(sp)</span><br><span class="line"># switch to kernel space</span><br><span class="line">csrw satp, t0</span><br><span class="line">sfence.vma</span><br><span class="line"># jump to trap_handler</span><br><span class="line">jr t1</span><br><span class="line"></span><br><span class="line"># __restore:</span><br><span class="line"># a0: *TrapContext in user space(Constant); a1: user space token</span><br><span class="line"># switch to user space</span><br><span class="line">csrw satp, a1</span><br><span class="line">sfence.vma</span><br><span class="line">csrw sscratch, a0</span><br></pre></td></tr></table></figure>

<p>To amend the problem of contigeous instructions after switch, we need to adjust memory layout for <code>trampoline</code> which is in the same location in U-level and S-level(<strong>unified for all app to trap!</strong>). It will be placed at highest virtual page.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># os&#x2F;src&#x2F;linker.ld</span><br><span class="line"></span><br><span class="line">    stext &#x3D; .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">+        . &#x3D; ALIGN(4K);</span><br><span class="line">+        strampoline &#x3D; .;</span><br><span class="line">+        *(.text.trampoline);</span><br><span class="line">+        . &#x3D; ALIGN(4K);</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>We modify rather raw handler and restore, due to virtual address, we need to adjust it for <code>trampoline</code> rather the address we had code!(<strong>it’s virtual!</strong>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_handler</span></span>() -&gt; ! &#123;</span><br><span class="line">    set_kernel_trap_entry();</span><br><span class="line">    <span class="keyword">let</span> cx = current_trap_cx();</span><br><span class="line">    <span class="keyword">let</span> scause = scause::read();</span><br><span class="line">    <span class="keyword">let</span> stval = stval::read();</span><br><span class="line">    <span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    trap_return();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_return</span></span>() -&gt; ! &#123;</span><br><span class="line">    set_user_trap_entry();</span><br><span class="line">    <span class="keyword">let</span> trap_cx_ptr = TRAP_CONTEXT;</span><br><span class="line">    <span class="keyword">let</span> user_satp = current_user_token();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__alltraps</span></span>();</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__restore</span></span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> restore_va = __restore <span class="keyword">as</span> <span class="built_in">usize</span> - __alltraps <span class="keyword">as</span> <span class="built_in">usize</span> + TRAMPOLINE;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">"fence.i"</span>,</span><br><span class="line">            <span class="string">"jr &#123;restore_va&#125;"</span>,</span><br><span class="line">            restore_va = <span class="keyword">in</span>(reg) restore_va,</span><br><span class="line">            <span class="keyword">in</span>(<span class="string">"a0"</span>) trap_cx_ptr,</span><br><span class="line">            <span class="keyword">in</span>(<span class="string">"a1"</span>) user_satp,</span><br><span class="line">            options(noreturn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Unreachable in back_to_user!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then map the virtual address for it up to the physical address for unifying.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> TRAMPOLINE: <span class="built_in">usize</span> = <span class="built_in">usize</span>::MAX - PAGE_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="comment">/// Mention that trampoline is not collected by areas.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map_trampoline</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.page_table.map(</span><br><span class="line">            VirtAddr::from(TRAMPOLINE).into(),</span><br><span class="line">            PhysAddr::from(strampoline <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">            PTEFlags::R | PTEFlags::X,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We should adjust <code>TaskControlBlock</code> for the same reason, record each <code>Trap</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It will read data getting from elf, get trap contexr ppn, its kernel stack bottom and top, and then initiate trap context.</p>
<p>Here the part of task control initiation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskContext &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">goto_trap_return</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            ra: trap_return <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">            s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn new(elf_data: &amp;[u8], app_id: usize) -&gt; Self </span></span><br><span class="line"><span class="keyword">let</span> task_control_block = <span class="keyword">Self</span> &#123;</span><br><span class="line">	task_status,</span><br><span class="line">	task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><br><span class="line">	memory_set,</span><br><span class="line">	trap_cx_ppn,</span><br><span class="line">	base_size: user_sp,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// prepare TrapContext in user space</span></span><br><span class="line"><span class="keyword">let</span> trap_cx = task_control_block.get_trap_cx();</span><br><span class="line">*trap_cx = TrapContext::app_init_context(</span><br><span class="line">	entry_point,</span><br><span class="line">	user_sp,</span><br><span class="line">	KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">	kernel_stack_top,</span><br><span class="line">	trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">);</span><br><span class="line">task_control_block</span><br></pre></td></tr></table></figure>









      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap5/" class="post-title-link" itemprop="url">rcore-handnote-5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:35" itemprop="dateModified" datetime="2025-05-23T06:52:35+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>After the demand of code execution one by one, we want to introduce <strong>Process</strong> which will be a full space-time description of execution process of binary file in OS. It means for one process, it should hold independent resources to be executed.</p>
<p>After <strong>Process</strong>, <strong>Thread</strong> and <strong>Coroutine</strong> are also developed in growth of OS. They are different in resources taken up, usually, <strong>Thread</strong> will be in one process and hold their own independent stack and workflow; <strong>Coroutine</strong> will be in one <strong>Thread</strong> and hold their own independent workflow.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>Every process need independent memory layout, can be dispatch by cpu. It’s the functionality based on <strong>Task</strong>, after that, each process can <strong>Fork</strong> their own children processes, so there’s a workflow in time discrepancy. Its resource can’t be recycled in time due to children processes, we need to mark it as <strong>Zombie Process</strong>.</p>
<p>To clarify which is children, which is parent, and each isolated process, we mark each with <strong>PID-Process Identifier</strong>. Notice if we fork a process, it will be same as parent only <code>a0</code> which is the register called for return will be different, parent process return new PID of child process, child process return 0 as none of fork.</p>
<ul>
<li>fork: copy a process state(like <code>sp</code> etc…) as its child process.</li>
<li>waitpid: wait a child become zombie and recycle all resources.</li>
<li>exec: clear a process state and load a execution file.</li>
</ul>
<hr>
<h3 id="Data-Constructon"><a href="#Data-Constructon" class="headerlink" title="Data Constructon"></a>Data Constructon</h3><p>We will recycle all presumed pid by <code>PidAllocator</code>, No need to worry about previous pid used.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PidHandle</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PidAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,</span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl PidAllocator</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; PidHandle &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(pid) = <span class="keyword">self</span>.recycled.pop() &#123;</span><br><span class="line">		PidHandle(pid)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">		PidHandle(<span class="keyword">self</span>.current - <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Therefore, if one pid recycled, it deallocated memory can be reused, we will define its <code>KernelStack</code> addr by pid.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/pid.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KernelStack</span></span> &#123;</span><br><span class="line">    pid: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_stack_position</span></span>(app_id: <span class="built_in">usize</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = TRAMPOLINE - app_id * (KERNEL_STACK_SIZE + PAGE_SIZE);</span><br><span class="line">    <span class="keyword">let</span> bottom = top - KERNEL_STACK_SIZE;</span><br><span class="line">    (bottom, top)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl KernelStack</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_on_top</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, value: T) -&gt; *<span class="keyword">mut</span> T <span class="keyword">where</span></span><br><span class="line">	T: <span class="built_in">Sized</span>, &#123;</span><br><span class="line">	<span class="keyword">let</span> kernel_stack_top = <span class="keyword">self</span>.get_top();</span><br><span class="line">	<span class="keyword">let</span> ptr_mut = (kernel_stack_top - core::mem::size_of::&lt;T&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> T;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123; *ptr_mut = value; &#125;</span><br><span class="line">	ptr_mut</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_top</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> (_, kernel_stack_top) = kernel_stack_position(<span class="keyword">self</span>.pid);</span><br><span class="line">	kernel_stack_top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> KernelStack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> (kernel_stack_bottom, _) = kernel_stack_position(<span class="keyword">self</span>.pid);</span><br><span class="line">        <span class="keyword">let</span> kernel_stack_bottom_va: VirtAddr = kernel_stack_bottom.into();</span><br><span class="line">        KERNEL_SPACE</span><br><span class="line">            .exclusive_access()</span><br><span class="line">            .remove_area_with_start_vpn(kernel_stack_bottom_va.into());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to construct <code>TaskControlBlock</code> for parent and children process.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// new:</span></span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="built_in">Option</span>&lt;Weak&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> children: <span class="built_in">Vec</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl TaskControlBlockInner</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_zombie</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.get_status() == TaskStatus::Zombie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TaskManager</code> manage all tasks and cpu dispatch, we will separate only tasks management for <code>TaskManager</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/manager.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: UPSafeCell&lt;TaskManager&gt; = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        UPSafeCell::new(TaskManager::new())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_task</span></span>(task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    TASK_MANAGER.exclusive_access().add(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_task</span></span>() -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    TASK_MANAGER.exclusive_access().fetch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And cpu dispatch for newly introduced <strong>Processor</strong>.<br>We introduce a <strong>idle process</strong> that used to call other process.</p>
<ul>
<li>Why not direct call next by previous one? rather use idle process?</li>
<li>Separate idle process for <strong>start</strong> and others for its own, then dispatch data won’t occur in other process and make the dispatch process invisible for <strong>Trap</strong> for each process.</li>
</ul>
<p>The whole workflow would be:</p>
<ul>
<li>idle process fetch task and switch</li>
<li>task run out of its time or finish</li>
<li>task switch to idle process</li>
<li>repeat…</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Processor</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">	<span class="comment">// idle process of current cpu</span></span><br><span class="line">    idle_task_cx: TaskContext,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> PROCESSOR: UPSafeCell&lt;Processor&gt; = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        UPSafeCell::new(Processor::new())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run_tasks() </span></span><br><span class="line"><span class="comment">// loop to fetch task and switch possible task</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = fetch_task() &#123;</span><br><span class="line">    <span class="keyword">let</span> idle_task_cx_ptr = processor.get_idle_task_cx_ptr();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> next_task_cx_ptr = &amp;task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">    task_inner.task_status = TaskStatus::Running;</span><br><span class="line">    <span class="built_in">drop</span>(task_inner);</span><br><span class="line">    processor.current = <span class="literal">Some</span>(task);</span><br><span class="line">    <span class="built_in">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(</span><br><span class="line">            idle_task_cx_ptr,</span><br><span class="line">            next_task_cx_ptr,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch to idle process if one task run out of its time.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">schedule</span></span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> processor = PROCESSOR.exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> idle_task_cx_ptr = processor.get_idle_task_cx_ptr();</span><br><span class="line">    <span class="built_in">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(</span><br><span class="line">            switched_task_cx_ptr,</span><br><span class="line">            idle_task_cx_ptr,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Dispatch-Construction"><a href="#Dispatch-Construction" class="headerlink" title="Dispatch Construction"></a>Dispatch Construction</h3><p>Previously, we use <code>suspend_current_and_run_next</code> to pause task and switch to next, now we need to adapt it to process design.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">suspend_current_and_run_next</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> task = take_current_task().unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- access current TCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> task_cx_ptr = &amp;<span class="keyword">mut</span> task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">    task_inner.task_status = TaskStatus::Ready;</span><br><span class="line">    <span class="built_in">drop</span>(task_inner);</span><br><span class="line">    <span class="comment">// ---- stop exclusively accessing current PCB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to task deque</span></span><br><span class="line">    add_task(task);</span><br><span class="line">    <span class="comment">// change current to idle process</span></span><br><span class="line">    schedule(task_cx_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In previous case, task won’t be created by its parent task, but process will. So, if its <code>TrapContext</code> has been recycled, we need to refactor our <code>trap_handler</code> for such case.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn trap_handler() -&gt; !</span></span><br><span class="line">Trap::Exception(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">    <span class="comment">// jump to next instruction anyway</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cx = current_trap_cx();</span><br><span class="line">    cx.sepc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// syscall may create new process and change trap context.</span></span><br><span class="line">    <span class="keyword">let</span> result = syscall(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]);</span><br><span class="line">    <span class="comment">// wether cx is changed or not, we will refetch it.</span></span><br><span class="line">    cx = current_trap_cx();</span><br><span class="line">    cx.x[<span class="number">10</span>] = result <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Now we will construct <code>fork</code>, <code>exec</code>, <code>waitpid</code>,<code>exit</code>.</p>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><p>We need to copy all memory layout and its task state. Then reallocate new kernel stack for it.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl MemorySet</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_existed_user</span></span>(user_space: &amp;MemorySet) -&gt; MemorySet &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> memory_set = Self::new_bare();</span><br><span class="line">    <span class="comment">// map trampoline</span></span><br><span class="line">    memory_set.map_trampoline();</span><br><span class="line">    <span class="comment">// copy data sections/trap_context/user_stack</span></span><br><span class="line">    <span class="keyword">for</span> area <span class="keyword">in</span> user_space.areas.iter() &#123;</span><br><span class="line">        <span class="keyword">let</span> new_area = MapArea::from_another(area);</span><br><span class="line">        memory_set.push(new_area, <span class="literal">None</span>);</span><br><span class="line">        <span class="comment">// copy data from another space</span></span><br><span class="line">        <span class="keyword">for</span> vpn <span class="keyword">in</span> area.vpn_range &#123;</span><br><span class="line">            <span class="keyword">let</span> src_ppn = user_space.translate(vpn).unwrap().ppn();</span><br><span class="line">            <span class="keyword">let</span> dst_ppn = memory_set.translate(vpn).unwrap().ppn();</span><br><span class="line">            dst_ppn.get_bytes_array().copy_from_slice(src_ppn.get_bytes_array());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl TaskControlBlock</span></span><br><span class="line"><span class="comment">// fn fork</span></span><br><span class="line"><span class="keyword">let</span> trap_cx_ppn = memory_set</span><br><span class="line">    .translate(VirtAddr::from(TRAP_CONTEXT).into())</span><br><span class="line">    .unwrap()</span><br><span class="line">    .ppn();</span><br><span class="line"><span class="comment">// alloc a pid and a kernel stack in kernel space</span></span><br><span class="line"><span class="keyword">let</span> pid_handle = pid_alloc();</span><br><span class="line"><span class="keyword">let</span> kernel_stack = KernelStack::new(&amp;pid_handle);</span><br><span class="line"><span class="keyword">let</span> kernel_stack_top = kernel_stack.get_top();</span><br><span class="line"><span class="keyword">let</span> task_control_block = Arc::new(TaskControlBlock &#123;</span><br><span class="line">    pid: pid_handle,</span><br><span class="line">    kernel_stack,</span><br><span class="line">    inner: <span class="keyword">unsafe</span> &#123; UPSafeCell::new(TaskControlBlockInner &#123;</span><br><span class="line">        trap_cx_ppn,</span><br><span class="line">        base_size: parent_inner.base_size,</span><br><span class="line">        task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><br><span class="line">        task_status: TaskStatus::Ready,</span><br><span class="line">        memory_set,</span><br><span class="line">        parent: <span class="literal">Some</span>(Arc::downgrade(<span class="keyword">self</span>)),</span><br><span class="line">        children: <span class="built_in">Vec</span>::new(),</span><br><span class="line">        exit_code: <span class="number">0</span>,</span><br><span class="line">    &#125;)&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// add child</span></span><br><span class="line">parent_inner.children.push(task_control_block.clone());</span><br><span class="line"><span class="comment">// modify kernel_sp in trap_cx</span></span><br><span class="line"><span class="comment">// **** access children PCB exclusively</span></span><br><span class="line"><span class="keyword">let</span> trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><br><span class="line">trap_cx.kernel_sp = kernel_stack_top;</span><br></pre></td></tr></table></figure>

<p>Finally, implement <code>sys_fork</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current_task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> new_task = current_task.fork();</span><br><span class="line">    <span class="keyword">let</span> new_pid = new_task.pid.<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> trap_cx = new_task.inner_exclusive_access().get_trap_cx();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for child process, fork returns 0</span></span><br><span class="line">    trap_cx.x[<span class="number">10</span>] = <span class="number">0</span>;  <span class="comment">//x[10] is a0 reg</span></span><br><span class="line"></span><br><span class="line">    add_task(new_task);</span><br><span class="line">    new_pid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that if <code>trap_handler</code> call <code>sys_fork</code>, parent process <code>x[10]</code> would be <code>new_pid</code> as return value.</p>
<h4 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h4><p>If we want to execute a task by its name, we need to first load string in app load.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/build.rs</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">writeln!</span>(f, r#<span class="string">"</span></span><br><span class="line"><span class="string">.global _app_names</span></span><br><span class="line"><span class="string">_app_names:"</span>#)?;</span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> apps.iter() &#123;</span><br><span class="line">    <span class="built_in">writeln!</span>(f, <span class="string">r#"    .string "&#123;&#125;""#</span>, app)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># link_app.S</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">_app_names:</span><br><span class="line">    .string &quot;exit&quot;</span><br><span class="line">    .string &quot;fantastic_text&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Construct <code>APP_NAMES</code> as global state in OS.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/loader.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// APP_NAMES: Vec&lt;&amp;'static str&gt; &#123;...</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..num_app &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> end = start;</span><br><span class="line">    <span class="keyword">while</span> end.read_volatile() != <span class="string">'\0'</span> <span class="keyword">as</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        end = end.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slice = core::slice::from_raw_parts(start, end <span class="keyword">as</span> <span class="built_in">usize</span> - start <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">str</span> = core::<span class="built_in">str</span>::from_utf8(slice).unwrap();</span><br><span class="line">    v.push(<span class="built_in">str</span>);</span><br><span class="line">    start = end.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When execute a new binary file, we need to read it and extract all state to replace original one.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><br><span class="line">        <span class="keyword">let</span> trap_cx_ppn = memory_set</span><br><span class="line">            .translate(VirtAddr::from(TRAP_CONTEXT).into())</span><br><span class="line">            .unwrap()</span><br><span class="line">            .ppn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **** access inner exclusively</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner_exclusive_access();</span><br><span class="line">        inner.memory_set = memory_set;</span><br><span class="line">        inner.trap_cx_ppn = trap_cx_ppn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> trap_cx = inner.get_trap_cx();</span><br><span class="line">        *trap_cx = TrapContext::app_init_context(</span><br><span class="line">            entry_point,</span><br><span class="line">            user_sp,</span><br><span class="line">            KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">            <span class="keyword">self</span>.kernel_stack.get_top(),</span><br><span class="line">            trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// **** stop exclusively accessing inner automatically</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will read input <code>str</code> as a ptr and replace current task state.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(data) = get_app_data_by_name(path.as_str()) &#123;</span><br><span class="line">        <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">        task.exec(data);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h4><p>When a task exit, it will return a <strong>exit code</strong> assigned by app if successfully or kernel if anomaly.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn exit_current_and_run_next(exit_code:i32)</span></span><br><span class="line">    inner.task_status = TaskStatus::Zombie;</span><br><span class="line">    inner.exit_code = exit_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move all its children to the initial process</span></span><br><span class="line">    <span class="comment">// ++++++ access initproc TCB exclusively</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> initproc_inner = INITPROC.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> inner.children.iter() &#123;</span><br><span class="line">            child.inner_exclusive_access().parent = <span class="literal">Some</span>(Arc::downgrade(&amp;INITPROC));</span><br><span class="line">            initproc_inner.children.push(child.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ++++++ stop exclusively accessing parent PCB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear all memory.</span></span><br><span class="line">    inner.children.clear();</span><br><span class="line">    inner.memory_set.recycle_data_pages();</span><br><span class="line">    <span class="built_in">drop</span>(inner);</span><br><span class="line">    <span class="comment">// **** stop exclusively accessing current PCB</span></span><br><span class="line">    <span class="comment">// drop task manually to maintain rc correctly</span></span><br><span class="line">    <span class="built_in">drop</span>(task);</span><br><span class="line">    <span class="comment">// use _unused replace original context, which will be recycled by rust.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> _unused = TaskContext::zero_init();</span><br><span class="line">    schedule(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> _);</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exit</span></span>(exit_code: <span class="built_in">i32</span>) -&gt; ! &#123;</span><br><span class="line">    exit_current_and_run_next(exit_code);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Unreachable in sys_exit!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WaitPid"><a href="#WaitPid" class="headerlink" title="WaitPid"></a>WaitPid</h4><p>WaitPid will return <code>-1</code> if there’s no specified pid process exist, if it’s running, return <code>-2</code>, finally, if it finished, recycle it and return <code>0</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sys_waitpid(pid:uisze, exit_code_ptr:*mut i32) -&gt; isize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 case</span></span><br><span class="line"><span class="comment">// search task manager and find (task_block)</span></span><br><span class="line">|p| &#123;pid == -<span class="number">1</span> || pid <span class="keyword">as</span> <span class="built_in">usize</span> == p.getpid()&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pair = <span class="comment">// search task managers and find (idx,task_block)</span></span><br><span class="line">p.inner_exclusive_access().is_zombie() &amp;&amp; (pid == -<span class="number">1</span> || pid <span class="keyword">as</span> <span class="built_in">usize</span> == p.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((idx,_)) = pair &#123;</span><br><span class="line">    <span class="keyword">let</span> child = inner.children.remove(idx);</span><br><span class="line">    <span class="comment">// confirm that child will be deallocated after removing from children list</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(Arc::strong_count(&amp;child), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> found_pid = child.getpid();</span><br><span class="line">    <span class="comment">// ++++ temporarily access child TCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> exit_code = child.inner_exclusive_access().exit_code;</span><br><span class="line">    <span class="comment">// ++++ stop exclusively accessing child PCB</span></span><br><span class="line">    *translated_refmut(inner.memory_set.token(), exit_code_ptr) = exit_code;</span><br><span class="line">    found_pid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// pid process is running</span></span><br><span class="line">    -<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(exit_code: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> sys_waitpid(-<span class="number">1</span>, exit_code <span class="keyword">as</span> *<span class="keyword">mut</span> _) &#123;</span><br><span class="line">            -<span class="number">2</span> =&gt; &#123; yield_(); &#125;</span><br><span class="line">            <span class="comment">// -1 or a real pid</span></span><br><span class="line">            exit_pid =&gt; <span class="keyword">return</span> exit_pid,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap6-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap6-1/" class="post-title-link" itemprop="url">rcore-handnote-6-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:35" itemprop="dateModified" datetime="2025-05-23T06:52:35+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-6-1"><a href="#Chapter-6-1" class="headerlink" title="Chapter 6-1"></a>Chapter 6-1</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The demand of persistent storage is with growth of computer. Currently we can only store things on our map memory, but it’s only exist in running time, which is <strong>Internal Storage</strong>, now we want to store it to <strong>External Storage</strong>.</p>
<h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><h4 id="Regular-File"><a href="#Regular-File" class="headerlink" title="Regular File"></a>Regular File</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> os/src/</span><br><span class="line"><span class="built_in">stat</span> main.rs</span><br><span class="line"></span><br><span class="line">File: main.rs</span><br><span class="line">Size: 940           Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049d  Inode: 4975        Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/   oslab)   Gid: ( 1000/   oslab)</span><br><span class="line">Access: 2021-02-28 23:32:50.289925450 +0800</span><br><span class="line">Modify: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Change: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure>

<p>Beside usual info, if one file is not <code>regular</code>, it’s usually a block device file or character device file, whose major/minor ID will be shown.</p>
<ul>
<li>Links: alias name for one file</li>
<li>Inode: the underneath id used to route</li>
<li>Uid: the file belonged user id.</li>
<li>Gid: the file begloned group id.</li>
<li>Blocks: take amount of blocks(in linux, it’s 4096KB).</li>
</ul>
<h4 id="Dir"><a href="#Dir" class="headerlink" title="Dir"></a>Dir</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> os</span><br><span class="line">File: os</span><br><span class="line">Size: 4096          Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: 801h/2049d  Inode: 4982        Links: 5</span><br><span class="line">Access: (0755/drwxr-xr-x)  Uid: ( 1000/   oslab)   Gid: ( 1000/   oslab)</span><br><span class="line">Access: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Modify: 2021-02-28 23:32:50.129927180 +0800</span><br><span class="line">Change: 2021-02-28 23:32:50.129927180 +0800</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure>

<ul>
<li>Access:<ul>
<li>d: dir</li>
<li>r: allowed to read files and subdir</li>
<li>w: allowed to create and delete files and subdir</li>
<li>x: allowed to “pass” this dir.</li>
</ul>
</li>
</ul>
<h4 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h4><p>Play the role of mapping the given dir tree structure to persistent storage. For example: windows-FAT/NTPS; linux-Ext3/Ext4/Btrfs. Therefore, construct a <strong>VFS-Virtual File System</strong> is necessary to restrict unified interface.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h4><ul>
<li>flatten: only root dir <code>/</code></li>
<li>permission: only user and no restriction on file access</li>
<li>no timestamp</li>
<li>no soft/hard link</li>
<li>many…</li>
</ul>
<p><img src="/blog/.io//assets/Lab6-1.png" alt></p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>For a persistent external storage, it will separate file in basic storage unit. Which is called <strong>sector</strong>(usually 512 bytes, 4KB), rather, file system will set its own storage unit which is called <strong>block</strong>, usually different from sector, but in this implementation, we set it as 512 bytes, same as sector.</p>
<p>A basic interface from device is:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/block_dev.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">BlockDevice</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> + Any &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File will not read and write directly often which will slow down speed, we will construct <strong>Block Cache</strong> to store read data. Then we unify all block cache in to a manager with limit size and used for allocation and deallocation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> BLOCK_SZ: <span class="built_in">usize</span> = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/block_cache.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ],</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    modified: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>&lt;T, V&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;T) -&gt; V) -&gt; V &#123;</span><br><span class="line">        f(<span class="keyword">self</span>.get_ref(offset))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">modify</span></span>&lt;T, V&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset:<span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> T) -&gt; V) -&gt; V &#123;</span><br><span class="line">        f(<span class="keyword">self</span>.get_mut(offset))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/block_cache.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BLOCK_CACHE_SIZE: <span class="built_in">usize</span> = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> alloc::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCacheManager</span></span> &#123;</span><br><span class="line">    queue: VecDeque&lt;(<span class="built_in">usize</span>, Arc&lt;Mutex&lt;BlockCache&gt;&gt;)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BlockCacheManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; queue: VecDeque::new() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl BlockCacheManager</span></span><br><span class="line"><span class="comment">// fn get_block_cache(&amp;mut self, block_id:usize, block_device: Arc&lt;dyn BlockDevice&gt;)</span></span><br><span class="line"><span class="comment">// if reach limit size:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.queue.len() == BLOCK_CACHE_SIZE &#123;</span><br><span class="line">    <span class="comment">// from front to tail</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((idx, _)) = <span class="keyword">self</span>.queue</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .find(|(_, pair)| Arc::strong_count(&amp;pair.<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.queue.drain(idx..=idx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">"Run out of BlockCache!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// load block into mem and push back</span></span><br><span class="line"><span class="keyword">let</span> block_cache = Arc::new(Mutex::new(</span><br><span class="line">    BlockCache::new(block_id, Arc::clone(&amp;block_device))</span><br><span class="line">));</span><br><span class="line"><span class="keyword">self</span>.queue.push_back((block_id, Arc::clone(&amp;block_cache)));</span><br><span class="line">block_cache</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Block-Layout"><a href="#Block-Layout" class="headerlink" title="Block Layout"></a>Block Layout</h4><p><img src="/blog/.io//assets/Lab6-2.png" alt="alt text"></p>
<p>We will design a whole map structure to control block caches.</p>
<p>First is <strong>Super Block</strong> which is a head to control everything, notice <code>magic</code> is magic number in mathematics to check the integrity of structure.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span></span> &#123;</span><br><span class="line">    magic: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.magic == EFS_MAGIC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bit Map</strong> is a nice structure to handle mapping operations, we set each block as 512 bytes(4KB), each bits represent a state of allocation(<code>1/0</code> for allocated/deallocated).</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/bitmap.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// notice it only store the id of start block and the len of blocks in its range.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitmap</span></span> &#123;</span><br><span class="line">    start_block_id: <span class="built_in">usize</span>,</span><br><span class="line">    blocks: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the true structure to map</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BitmapBlock</span></span> = [<span class="built_in">u64</span>; <span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// equal: 4096 bits</span></span><br><span class="line"><span class="keyword">const</span> BLOCK_BITS: <span class="built_in">usize</span> = BLOCK_SZ * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Bitmap &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> block_id <span class="keyword">in</span> <span class="number">0</span>..<span class="keyword">self</span>.blocks &#123;</span><br><span class="line">            <span class="keyword">let</span> pos = get_block_cache(</span><br><span class="line">                block_id + <span class="keyword">self</span>.start_block_id <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device),</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .modify(<span class="number">0</span>, |bitmap_block: &amp;<span class="keyword">mut</span> BitmapBlock| &#123;</span><br><span class="line">                <span class="comment">// core!</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((bits64_pos, inner_pos)) = bitmap_block</span><br><span class="line">                    .iter()</span><br><span class="line">                    .enumerate()</span><br><span class="line">                    .find(|(_, bits64)| **bits64 != <span class="built_in">u64</span>::MAX)</span><br><span class="line">                    .map(|(bits64_pos, bits64)| &#123;</span><br><span class="line">                        (bits64_pos, bits64.trailing_ones() <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">                    &#125;) &#123;</span><br><span class="line">                    <span class="comment">// modify cache</span></span><br><span class="line">                    bitmap_block[bits64_pos] |= <span class="number">1u64</span> &lt;&lt; inner_pos;</span><br><span class="line">                    <span class="literal">Some</span>(block_id * BLOCK_BITS + bits64_pos * <span class="number">64</span> + inner_pos <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="literal">None</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> pos.is_some() &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on such structure, we could exposit what is <strong>Inode</strong> and <strong>Data</strong> Block, not all block will store real data because some of them need to be used as guidance. However, we also need to know where and how these route blocks be allocated. That’s the reason of <strong>Bit Map</strong>! Now we delve into <strong>Inode</strong>.</p>
<p>To make one inode control many data blocks, we will design layer of route for it. Beside direct index, it also store the index of layer 1 and layer 2 to route other index block(which is considered same as data block), and route to real data block. Notice one block contains 512 bytes, which is 512 u8, so it contains 512/4 = 128 u32, so one index block can route 128 * 512 bytes = 128 * 0.5 KB = 64 KB in one layer. In second layer, it can route as much as 128 * 64 KB = 64 MB.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INODE_DIRECT_COUNT: <span class="built_in">usize</span> = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// 128</span></span><br><span class="line"><span class="keyword">const</span> INODE_INDIRECT1_COUNT: <span class="built_in">usize</span> = BLOCK_SZ / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DiskInodeType</span></span> &#123;</span><br><span class="line">    File,</span><br><span class="line">    Directory,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Such <strong>Inode</strong> take 128 bytes, so in one block, it could contains 4 inodes. We should make a data structure could be fit exactly into a block size. Now we design route method.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 28 + 128</span></span><br><span class="line"><span class="keyword">const</span> INDIRECT1_BOUND: <span class="built_in">usize</span> = DIRECT_BOUND + INODE_INDIRECT1_COUNT;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">IndirectBlock</span></span> = [<span class="built_in">u32</span>; BLOCK_SZ / <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> DiskInode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_id</span></span>(&amp;<span class="keyword">self</span>, inner_id: <span class="built_in">u32</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> inner_id = inner_id <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        <span class="keyword">if</span> inner_id &lt; INODE_DIRECT_COUNT &#123;</span><br><span class="line">            <span class="keyword">self</span>.direct[inner_id]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> inner_id &lt; INDIRECT1_BOUND &#123;</span><br><span class="line">            get_block_cache(<span class="keyword">self</span>.indirect1 <span class="keyword">as</span> <span class="built_in">usize</span>, Arc::clone(block_device))</span><br><span class="line">                .lock()</span><br><span class="line">                .read(<span class="number">0</span>, |indirect_block: &amp;IndirectBlock| &#123;</span><br><span class="line">                    indirect_block[inner_id - INODE_DIRECT_COUNT]</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> last = inner_id - INDIRECT1_BOUND;</span><br><span class="line">            <span class="keyword">let</span> indirect1 = get_block_cache(</span><br><span class="line">                <span class="keyword">self</span>.indirect2 <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device)</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .read(<span class="number">0</span>, |indirect2: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect2[last / INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;);</span><br><span class="line">            get_block_cache(</span><br><span class="line">                indirect1 <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device)</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .read(<span class="number">0</span>, |indirect1: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect1[last % INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we design <strong>Data</strong> block, which is simple. Because for file system, any data are just bytes.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BLOCK_SZ = 512</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">DataBlock</span></span> = [<span class="built_in">u8</span>; BLOCK_SZ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl DiskInode</span></span><br><span class="line">    <span class="comment">// pub fn read_at(</span></span><br><span class="line">    <span class="comment">//     &amp;self,</span></span><br><span class="line">    <span class="comment">//     offset: usize,</span></span><br><span class="line">    <span class="comment">//     buf: &amp;mut [u8],</span></span><br><span class="line">    <span class="comment">//     block_device: &amp;Arc&lt;dyn BlockDevice&gt;,</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// calculate end of current block</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> end_current_block = (start / BLOCK_SZ + <span class="number">1</span>) * BLOCK_SZ;</span><br><span class="line">    end_current_block = end_current_block.min(end);</span><br><span class="line">    <span class="comment">// read and update read size</span></span><br><span class="line">    <span class="keyword">let</span> block_read_size = end_current_block - start;</span><br><span class="line">    <span class="keyword">let</span> dst = &amp;<span class="keyword">mut</span> buf[read_size..read_size + block_read_size];</span><br><span class="line">    get_block_cache(</span><br><span class="line">        <span class="keyword">self</span>.get_block_id(start_block <span class="keyword">as</span> <span class="built_in">u32</span>, block_device) <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        Arc::clone(block_device),</span><br><span class="line">    )</span><br><span class="line">    .lock()</span><br><span class="line">    .read(<span class="number">0</span>, |data_block: &amp;DataBlock| &#123;</span><br><span class="line">        <span class="keyword">let</span> src = &amp;data_block[start % BLOCK_SZ..start % BLOCK_SZ + block_read_size];</span><br><span class="line">        dst.copy_from_slice(src);</span><br><span class="line">    &#125;);</span><br><span class="line">    read_size += block_read_size;</span><br><span class="line">    <span class="comment">// move to next block</span></span><br><span class="line">    <span class="keyword">if</span> end_current_block == end &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    start_block += <span class="number">1</span>;</span><br><span class="line">    start = end_current_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="File-System-1"><a href="#File-System-1" class="headerlink" title="File System"></a>File System</h4><p>Due to our consecutive layout, we will store bitmap and start block, then initiate a unified system to control allocation and route. We call it <strong>File System</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EasyFileSystem</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap: Bitmap,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap: Bitmap,</span><br><span class="line">    inode_area_start_block: <span class="built_in">u32</span>,</span><br><span class="line">    data_area_start_block: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(</span><br><span class="line">        block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">        total_blocks: <span class="built_in">u32</span>,</span><br><span class="line">        inode_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    ) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// calculate block size of areas &amp; create bitmaps</span></span><br><span class="line">        <span class="keyword">let</span> inode_bitmap = Bitmap::new(<span class="number">1</span>, inode_bitmap_blocks <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">        <span class="keyword">let</span> inode_num = inode_bitmap.maximum();</span><br><span class="line">        <span class="keyword">let</span> inode_area_blocks =</span><br><span class="line">            ((inode_num * core::mem::size_of::&lt;DiskInode&gt;() + BLOCK_SZ - <span class="number">1</span>) / BLOCK_SZ) <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">        <span class="keyword">let</span> inode_total_blocks = inode_bitmap_blocks + inode_area_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_total_blocks = total_blocks - <span class="number">1</span> - inode_total_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_bitmap_blocks = (data_total_blocks + <span class="number">4096</span>) / <span class="number">4097</span>;</span><br><span class="line">        <span class="keyword">let</span> data_area_blocks = data_total_blocks - data_bitmap_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_bitmap = Bitmap::new(</span><br><span class="line">            (<span class="number">1</span> + inode_bitmap_blocks + inode_area_blocks) <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">            data_bitmap_blocks <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Use <strong>Bit Map</strong>, we finally know which is <strong>Inode</strong> and <strong>Data</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_disk_inode_pos</span></span>(&amp;<span class="keyword">self</span>, inode_id: <span class="built_in">u32</span>) -&gt; (<span class="built_in">u32</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> inode_size = core::mem::size_of::&lt;DiskInode&gt;();</span><br><span class="line">        <span class="keyword">let</span> inodes_per_block = (BLOCK_SZ / inode_size) <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">        <span class="keyword">let</span> block_id = <span class="keyword">self</span>.inode_area_start_block + inode_id / inodes_per_block;</span><br><span class="line">        (block_id, (inode_id % inodes_per_block) <span class="keyword">as</span> <span class="built_in">usize</span> * inode_size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_data_block_id</span></span>(&amp;<span class="keyword">self</span>, data_block_id: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.data_area_start_block + data_block_id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our <strong>Disk Inode</strong> is aims for underneath system, not for user, so we need a real <strong>Inode</strong> as a interface for <strong>Disk Inode</strong> to route, which store its id and offset.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_offset: <span class="built_in">usize</span>,</span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">        get_block_cache(</span><br><span class="line">            <span class="keyword">self</span>.block_id,</span><br><span class="line">            Arc::clone(&amp;<span class="keyword">self</span>.block_device)</span><br><span class="line">        ).lock().read(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">modify_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">        get_block_cache(</span><br><span class="line">            <span class="keyword">self</span>.block_id,</span><br><span class="line">            Arc::clone(&amp;<span class="keyword">self</span>.block_device)</span><br><span class="line">        ).lock().modify(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All methods exposed to user will be root inode.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">root_inode</span></span>(efs: &amp;Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt;) -&gt; Inode &#123;</span><br><span class="line">        <span class="keyword">let</span> block_device = Arc::clone(&amp;efs.lock().block_device);</span><br><span class="line">        <span class="comment">// acquire efs lock temporarily</span></span><br><span class="line">        <span class="keyword">let</span> (block_id, block_offset) = efs.lock().get_disk_inode_pos(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// release efs lock</span></span><br><span class="line">        Inode::new(</span><br><span class="line">            block_id,</span><br><span class="line">            block_offset,</span><br><span class="line">            Arc::clone(efs),</span><br><span class="line">            block_device,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, we still need one special data block which is <strong>DirEntry</strong>, as directory which store <code>inode_number</code> to route inode, <strong>DirEntry</strong> takes 32 bytes, so each block can store 4 <strong>DirEntry</strong>. Thus we can route to inode by <code>&amp;str</code>.</p>
<p>Notice disk_inode contains type for dir and file. So some of inodes will store dir data and some of inodes will store file data, we can get inode of data by inode of dir.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NAME_LENGTH_LIMIT: <span class="built_in">usize</span> = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DirEntry</span></span> &#123;</span><br><span class="line">    name: [<span class="built_in">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>],</span><br><span class="line">    inode_number: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DIRENT_SZ: <span class="built_in">usize</span> = <span class="number">32</span>;</span><br></pre></td></tr></table></figure>

<p>First, we will </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">find</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> fs = <span class="keyword">self</span>.fs.lock();</span><br><span class="line">        <span class="keyword">self</span>.read_disk_inode(|disk_inode| &#123;</span><br><span class="line">            <span class="keyword">self</span>.find_inode_id(name, disk_inode)</span><br><span class="line">            .map(|inode_id| &#123;</span><br><span class="line">                <span class="keyword">let</span> (block_id, block_offset) = fs.get_disk_inode_pos(inode_id);</span><br><span class="line">                Arc::new(Self::new(</span><br><span class="line">                    block_id,</span><br><span class="line">                    block_offset,</span><br><span class="line">                    <span class="keyword">self</span>.fs.clone(),</span><br><span class="line">                    <span class="keyword">self</span>.block_device.clone(),</span><br><span class="line">                ))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_inode_id</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        name: &amp;<span class="built_in">str</span>,</span><br><span class="line">        disk_inode: &amp;DiskInode,</span><br><span class="line">    ) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// assert it is a directory</span></span><br><span class="line">        <span class="built_in">assert!</span>(disk_inode.is_dir());</span><br><span class="line">        <span class="keyword">let</span> file_count = (disk_inode.size <span class="keyword">as</span> <span class="built_in">usize</span>) / DIRENT_SZ;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dirent = DirEntry::empty();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..file_count &#123;</span><br><span class="line">            <span class="comment">// note assert_eq! has side effect: read data to dirent.</span></span><br><span class="line">            <span class="built_in">assert_eq!</span>(</span><br><span class="line">                disk_inode.read_at(</span><br><span class="line">                    DIRENT_SZ * i,</span><br><span class="line">                    dirent.as_bytes_mut(),</span><br><span class="line">                    &amp;<span class="keyword">self</span>.block_device,</span><br><span class="line">                ),</span><br><span class="line">                DIRENT_SZ,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> dirent.name() == name &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Some</span>(dirent.inode_number() <span class="keyword">as</span> <span class="built_in">u32</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, the workflow of create or delete, read or write would be:</p>
<ul>
<li>read/write<ul>
<li>get root inode which is dir type</li>
<li>read/write closure of disk inode through root inode</li>
<li>resize specified inode</li>
</ul>
</li>
<li>create/clear<ul>
<li>allocation/deallocation: alloc/dealloc inode by bitmap and get its index</li>
<li>initialization/clear by get its block cache by its index</li>
<li>resize root inode</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap6-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap6-2/" class="post-title-link" itemprop="url">rcore-handnote-6-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:35" itemprop="dateModified" datetime="2025-05-23T06:52:35+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-6-2"><a href="#Chapter-6-2" class="headerlink" title="Chapter 6-2"></a>Chapter 6-2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We gonna load our <code>easy-fs</code> to kernel. First, we need to know our device interface. Second, our <strong>Inode</strong> should be wrapped in OS as <strong>OSInode</strong> for extended functionality. Then we implement <code>sys_read/write</code> for it.</p>
<h3 id="MMIO-Memory-Mapped-I-O"><a href="#MMIO-Memory-Mapped-I-O" class="headerlink" title="MMIO-Memory-Mapped I/O"></a>MMIO-Memory-Mapped I/O</h3><p>The device registers of peripherals can be accessed through specific physical memory addresses, <strong>VirtIO</strong> MMIO physical address range for the peripheral bus is 4KiB starting at 0X10001000. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"board_qemu"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MMIO: &amp;[(<span class="built_in">usize</span>, <span class="built_in">usize</span>)] = &amp;[</span><br><span class="line">    (<span class="number">0x10001000</span>, <span class="number">0x1000</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="OS-Inode"><a href="#OS-Inode" class="headerlink" title="OS Inode"></a>OS Inode</h3><p>We only take restriction on our operations with <code>readable</code> and <code>writable</code> by <code>OpenFlags</code>. <code>offset</code> and <code>Arc</code> is a way to tackle simple situation of multi processes.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpenFlags</span></span>: <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> RDONLY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> WRONLY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> RDWR = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">const</span> TRUNC = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> OpenFlags &#123;</span><br><span class="line">    <span class="comment">/// Do not check validity for simplicity</span></span><br><span class="line">    <span class="comment">/// Return (readable, writable)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_write</span></span>(&amp;<span class="keyword">self</span>) -&gt; (<span class="built_in">bool</span>, <span class="built_in">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            (<span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.contains(Self::WRONLY) &#123;</span><br><span class="line">            (<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (<span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInode</span></span> &#123;</span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    inner: Mutex&lt;OSInodeInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInodeInner</span></span> &#123;</span><br><span class="line">    offset: <span class="built_in">usize</span>,</span><br><span class="line">    inode: Arc&lt;Inode&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> OSInode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(</span><br><span class="line">        readable: <span class="built_in">bool</span>,</span><br><span class="line">        writable: <span class="built_in">bool</span>,</span><br><span class="line">        inode: Arc&lt;Inode&gt;,</span><br><span class="line">    ) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            readable,</span><br><span class="line">            writable,</span><br><span class="line">            inner: Mutex::new(OSInodeInner &#123;</span><br><span class="line">                offset: <span class="number">0</span>,</span><br><span class="line">                inode,</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File-Descriptor-Table"><a href="#File-Descriptor-Table" class="headerlink" title="File Descriptor Table"></a>File Descriptor Table</h4><p>Now we need to connect file operations with process, each process need a descriptors table(which manage many files!) to indicate file record infos. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">pub</span> fd_table: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember our previous root inode? We load it directly for easy manipulation. So our workflow would be for current process, push a descriptor of allocation, and return the ptr of this allocation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> efs = EasyFileSystem::open(BLOCK_DEVICE.clone());</span><br><span class="line">        Arc::new(EasyFileSystem::root_inode(&amp;efs))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open_file</span></span>(name: &amp;<span class="built_in">str</span>, flags: OpenFlags) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;OSInode&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (readable, writable) = flags.read_write();</span><br><span class="line">    <span class="keyword">if</span> flags.contains(OpenFlags::CREATE) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inode) = ROOT_INODE.find(name) &#123;</span><br><span class="line">            <span class="comment">// clear size</span></span><br><span class="line">            inode.clear();</span><br><span class="line">            <span class="literal">Some</span>(Arc::new(OSInode::new(</span><br><span class="line">                readable,</span><br><span class="line">                writable,</span><br><span class="line">                inode,</span><br><span class="line">            )))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// create file</span></span><br><span class="line">            ROOT_INODE.create(name)</span><br><span class="line">                .map(|inode| &#123;</span><br><span class="line">                    Arc::new(OSInode::new(</span><br><span class="line">                        readable,</span><br><span class="line">                        writable,</span><br><span class="line">                        inode,</span><br><span class="line">                    ))</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ROOT_INODE.find(name)</span><br><span class="line">            .map(|inode| &#123;</span><br><span class="line">                <span class="keyword">if</span> flags.contains(OpenFlags::TRUNC) &#123;</span><br><span class="line">                    inode.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                Arc::new(OSInode::new(</span><br><span class="line">                    readable,</span><br><span class="line">                    writable,</span><br><span class="line">                    inode</span><br><span class="line">                ))</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/fs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_open</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>, flags: <span class="built_in">u32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inode) = open_file(</span><br><span class="line">        path.as_str(),</span><br><span class="line">        OpenFlags::from_bits(flags).unwrap()</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.acquire_inner_lock();</span><br><span class="line">        <span class="keyword">let</span> fd = inner.alloc_fd();</span><br><span class="line">        inner.fd_table[fd] = <span class="literal">Some</span>(inode);</span><br><span class="line">        fd <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/syscall/fs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_close</span></span>(fd: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> fd &gt;= inner.fd_table.len() &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> inner.fd_table[fd].is_none() &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inner.fd_table[fd].take();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The implementation is same for <code>sys_read/write</code>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap7-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap7-1/" class="post-title-link" itemprop="url">rcore-handnote-7-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-23 06:52:35" itemprop="dateModified" datetime="2025-05-23T06:52:35+00:00">2025-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-7-1"><a href="#Chapter-7-1" class="headerlink" title="Chapter 7-1"></a>Chapter 7-1</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We gonna abstract <code>Stdin</code> and <code>Stdout</code> by file, and insert into file descriptor. Therefore support <strong>Pipe</strong> operation and <strong>IO Redirection</strong> across each process.</p>
<h3 id="Everything-Is-a-File"><a href="#Everything-Is-a-File" class="headerlink" title="Everything Is a File"></a>Everything Is a File</h3><p>The design philosophy of <strong>Everything is a file</strong> will generalize everything to file based on IO operations while omit concrete content semantics.</p>
<p>Abstraction of IO hardware:</p>
<ul>
<li>read-only: s.t. keyboard</li>
<li>write-only: s.t. screen</li>
<li>read-write: s.t. serial device</li>
</ul>
<p>Abstraction of IO operations(based on file descriptor):</p>
<ul>
<li>open: open file while possessing it by certain process.</li>
<li>close: close file while discarding it by certain process.</li>
<li>read: read file into memory.</li>
<li>write: write file from memory.</li>
</ul>
<p>When a process is created, it owns three file as operation abstraction:</p>
<ul>
<li>0: Stdin</li>
<li>1: Stdout</li>
<li>2: Stderr(which we will merge with Stdout)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> task_control_block = <span class="keyword">Self</span> &#123;</span><br><span class="line">            pid: pid_handle,</span><br><span class="line">            kernel_stack,</span><br><span class="line">            inner: Mutex::new(TaskControlBlockInner &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">                fd_table: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="comment">// 0 -&gt; stdin</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdin)),</span><br><span class="line">                    <span class="comment">// 1 -&gt; stdout</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdout)),</span><br><span class="line">                    <span class="comment">// 2 -&gt; stderr</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdout)),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>In usual shell, <code>|</code> is the symbolic of pipe. Manage input from left and output to right. If we abstract everything to file, s.t. <code>Stdin</code> or <code>Stdout</code>, so does <strong>Pipe</strong>, it has <code>read</code> and <code>write</code> ends, user could read thing from this end and write thing(often in child process) to other end, transfer those underneath thing.</p>
<p>We already has file descriptor as the indication of file, we will implement same operation for pipe.</p>
<p><code>sys_pipe</code> get the ptr of a array with <code>len = 2</code>, output the write and the read ends of descriptors of pipe in the ptr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_PIPE: <span class="built_in">usize</span> = <span class="number">59</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_pipe</span></span>(pipe: &amp;<span class="keyword">mut</span> [<span class="built_in">usize</span>]) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    syscall(SYSCALL_PIPE, [pipe.as_mut_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>So What’s the basic design of pipe?</p>
<p>It should has write and read ends which means ends share the same data, and record read and write informations on this data. We will construct <code>RingBuffer</code> to achieve this. <code>Pipe</code> owns a buffer control read and write, buffer will record data from head to tail index. Why we can’t just use two piece of data or <code>Queue</code>?</p>
<p>Because there’s no copy and suitable for our restriction! We will read data from head and move forward and push data to end in a fixed array rather allocation for <code>Queue</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/pipe.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span></span> &#123;</span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RING_BUFFER_SIZE: <span class="built_in">usize</span> = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RingBufferStatus</span></span> &#123;</span><br><span class="line">    FULL,</span><br><span class="line">    EMPTY,</span><br><span class="line">    NORMAL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PipeRingBuffer</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">u8</span>; RING_BUFFER_SIZE],</span><br><span class="line">    head: <span class="built_in">usize</span>, <span class="comment">// head index of ring buffer</span></span><br><span class="line">    tail: <span class="built_in">usize</span>, <span class="comment">// tail index of ring buffer</span></span><br><span class="line">    status: RingBufferStatus,</span><br><span class="line">    write_end: <span class="built_in">Option</span>&lt;Weak&lt;Pipe&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_write_end</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, write_end: &amp;Arc&lt;Pipe&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.write_end = <span class="literal">Some</span>(Arc::downgrade(write_end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Return (read_end, write_end)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">make_pipe</span></span>() -&gt; (Arc&lt;Pipe&gt;, Arc&lt;Pipe&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> buffer = Arc::new(Mutex::new(PipeRingBuffer::new()));</span><br><span class="line">    <span class="keyword">let</span> read_end = Arc::new(</span><br><span class="line">        Pipe::read_end_with_buffer(buffer.clone())</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> write_end = Arc::new(</span><br><span class="line">        Pipe::write_end_with_buffer(buffer.clone())</span><br><span class="line">    );</span><br><span class="line">    buffer.lock().set_write_end(&amp;write_end);</span><br><span class="line">    (read_end, write_end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_byte</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.status = RingBufferStatus::NORMAL;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="keyword">self</span>.arr[<span class="keyword">self</span>.head];</span><br><span class="line">		<span class="comment">// move forward</span></span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="number">1</span>) % RING_BUFFER_SIZE;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.head == <span class="keyword">self</span>.tail &#123;</span><br><span class="line">            <span class="keyword">self</span>.status = RingBufferStatus::EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">available_read</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.status == RingBufferStatus::EMPTY &#123;</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// data from head to tail!</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.tail &gt; <span class="keyword">self</span>.head &#123;</span><br><span class="line">                <span class="keyword">self</span>.tail - <span class="keyword">self</span>.head</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.tail + RING_BUFFER_SIZE - <span class="keyword">self</span>.head</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">all_write_ends_closed</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.write_end.as_ref().unwrap().upgrade().is_none()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In one process, there’s a possible that can’t read all thing in once, if so, we will pause and run other thing until the write end is finished.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/pipe.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Pipe &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(<span class="keyword">self</span>.readable());</span><br><span class="line">        <span class="keyword">let</span> want_to_read = buf.len();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> buf_iter = buf.into_iter();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> already_read = <span class="number">0usize</span>;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> ring_buffer = <span class="keyword">self</span>.buffer.exclusive_access();</span><br><span class="line">            <span class="keyword">let</span> loop_read = ring_buffer.available_read();</span><br><span class="line">            <span class="keyword">if</span> loop_read == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ring_buffer.all_write_ends_closed() &#123;</span><br><span class="line">                    <span class="keyword">return</span> already_read;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">drop</span>(ring_buffer);</span><br><span class="line">                suspend_current_and_run_next();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..loop_read &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(byte_ref) = buf_iter.next() &#123;</span><br><span class="line">                    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                        *byte_ref = ring_buffer.read_byte();</span><br><span class="line">                    &#125;</span><br><span class="line">                    already_read += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> already_read == want_to_read &#123;</span><br><span class="line">                        <span class="keyword">return</span> want_to_read;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> already_read;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h3><p>We will combine our pipe with our shell.</p>
<p>First, parse our arguments and push <code>0</code> to end to indicated end.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/bin/user_shell.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;_&gt; = line.as_str().split(<span class="string">' '</span>).collect();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> args_addr: <span class="built_in">Vec</span>&lt;*<span class="keyword">const</span> <span class="built_in">u8</span>&gt; = args</span><br><span class="line">	.iter()</span><br><span class="line">	.map(|&amp;arg| &#123;</span><br><span class="line">		<span class="keyword">let</span> s = arg.to_string();</span><br><span class="line">		s.push(<span class="string">'\0'</span>);</span><br><span class="line">		s.as_ptr()</span><br><span class="line">	&#125;)</span><br><span class="line">	.collect();</span><br><span class="line">args_addr.push(<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>)</span><br></pre></td></tr></table></figure>

<p>Now task will accept a series of args rather than solely one string. So make <code>sys_exec</code> to:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>, <span class="keyword">mut</span> args: *<span class="keyword">const</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> args_vec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">	<span class="comment">// args would be a ptr of array contains ptr of string.</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arg_str_ptr = *translated_ref(token, args);</span><br><span class="line">        <span class="keyword">if</span> arg_str_ptr == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        args_vec.push(translated_str(token, arg_str_ptr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>));</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; args = args.add(<span class="number">1</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(app_inode) = open_file(path.as_str(), OpenFlags::RDONLY) &#123;</span><br><span class="line">        <span class="keyword">let</span> all_data = app_inode.read_all();</span><br><span class="line">        <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">        <span class="keyword">let</span> argc = args_vec.len();</span><br><span class="line">        task.exec(all_data.as_slice(), args_vec);</span><br><span class="line">        <span class="comment">// return argc because cx.x[10] will be covered with it later</span></span><br><span class="line">        argc <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we really gonna use user stack to store these args!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">	<span class="comment">// notice exec will allocate a new memory set!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>], args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// first allocate memory for ptr of strings.</span></span><br><span class="line">        user_sp -= (args.len() + <span class="number">1</span>) * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;();</span><br><span class="line">        <span class="keyword">let</span> argv_base = user_sp;</span><br><span class="line">		<span class="comment">// allocate new memory in user stack addr as a vector of strings </span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> argv: <span class="built_in">Vec</span>&lt;_&gt; = (<span class="number">0</span>..=args.len())</span><br><span class="line">            .map(|arg| &#123;</span><br><span class="line">                translated_refmut(</span><br><span class="line">                    memory_set.token(),</span><br><span class="line">                    (argv_base + arg * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">usize</span></span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect();</span><br><span class="line">        *argv[args.len()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..args.len() &#123;</span><br><span class="line">			<span class="comment">// allocate for strings themselves.</span></span><br><span class="line">            user_sp -= args[i].len() + <span class="number">1</span>;</span><br><span class="line">            *argv[i] = user_sp;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> p = user_sp;</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> args[i].as_bytes() &#123;</span><br><span class="line">                *translated_refmut(memory_set.token(), p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>) = *c;</span><br><span class="line">                p += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *translated_refmut(memory_set.token(), p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// make the user_sp aligned to 8B for k210 platform</span></span><br><span class="line">        user_sp -= user_sp % core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **** hold current PCB lock</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.acquire_inner_lock();</span><br><span class="line">        <span class="comment">// substitute memory_set</span></span><br><span class="line">        inner.memory_set = memory_set;</span><br><span class="line">        <span class="comment">// update trap_cx ppn</span></span><br><span class="line">        inner.trap_cx_ppn = trap_cx_ppn;</span><br><span class="line">        <span class="comment">// initialize trap_cx</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> trap_cx = TrapContext::app_init_context(</span><br><span class="line">            entry_point,</span><br><span class="line">            user_sp,</span><br><span class="line">            KERNEL_SPACE.lock().token(),</span><br><span class="line">            <span class="keyword">self</span>.kernel_stack.get_top(),</span><br><span class="line">            trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">		<span class="comment">// a[0] be args len</span></span><br><span class="line">        trap_cx.x[<span class="number">10</span>] = args.len();</span><br><span class="line">		<span class="comment">// a[1] be args base addr</span></span><br><span class="line">        trap_cx.x[<span class="number">11</span>] = argv_base;</span><br><span class="line">        *inner.get_trap_cx() = trap_cx;</span><br><span class="line">        <span class="comment">// **** release current PCB lock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we provide receive operation in <code>_start</code>, in which <code>main</code> could use it at first time S-level reading data and passing to U-level:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="meta-string">".text.entry"</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>(argc: <span class="built_in">usize</span>, argv: <span class="built_in">usize</span>) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP.lock()</span><br><span class="line">            .init(HEAP_SPACE.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>, USER_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..argc &#123;</span><br><span class="line">        <span class="keyword">let</span> str_start = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            ((argv + i * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">usize</span>).read_volatile()</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> len = (<span class="number">0usize</span>..).find(|i| <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            ((str_start + *i) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>).read_volatile() == <span class="number">0</span></span><br><span class="line">        &#125;).unwrap();</span><br><span class="line">        v.push(</span><br><span class="line">            core::<span class="built_in">str</span>::from_utf8(<span class="keyword">unsafe</span> &#123;</span><br><span class="line">                core::slice::from_raw_parts(str_start <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>, len)</span><br><span class="line">            &#125;).unwrap()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    exit(main(argc, v.as_slice()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h3><p>Redirection usually represent using <code>&gt;</code> and <code>&lt;</code> for output and input.</p>
<p>If we really want to redirect IO, we will combine <code>user_shell</code> and <code>sys_dup</code>.</p>
<p>First, <code>sys_dup</code> will duplicate a new file descriptor already opened in this process.</p>
<p>Then we parse user arguments, if there exist <code>&gt;</code> or <code>&lt;</code>, fork a new child process, open the file and close our corresponding <code>Stdin</code> and <code>Stdout</code> descriptor, using <code>dup</code> to hold the place of it by <code>file</code> itself! Then <code>exec</code> by original parsed arguments, and receive results in parent process.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/blog/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/70/">70</a><a class="extend next" rel="next" href="/blog/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
