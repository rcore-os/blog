<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/8/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">423</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">422</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/Learning-OS-2024-Spring-Phase-1-Final-Report-Blog-From-Zhangzw999/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/Learning-OS-2024-Spring-Phase-1-Final-Report-Blog-From-Zhangzw999/" class="post-title-link" itemprop="url">Learning OS 2024-Spring Phase 1: Final Report Blog - From Zhangzw999</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 22:42:36" itemprop="dateCreated datePublished" datetime="2024-04-29T22:42:36+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024春夏季开源操作系统训练营-第一阶段总结"><a href="#2024春夏季开源操作系统训练营-第一阶段总结" class="headerlink" title="2024春夏季开源操作系统训练营 - 第一阶段总结"></a>2024春夏季开源操作系统训练营 - 第一阶段总结</h1><h2 id="作者：Zhangzw999"><a href="#作者：Zhangzw999" class="headerlink" title="作者：Zhangzw999"></a>作者：Zhangzw999</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>笔者初二开始接触编程，当时还只会写一点 C 和 Python，后来上了初三，遇见疫情，在家无聊，出于兴趣开始捣鼓一些复杂点的项目，但始终没有接触到本质的东西。这次的训练营是个好机会，不仅能让我深入接触到一门编程语言的工作方式，还能让我借此增进对操作系统原理的了解。作为一名电子信息类专业的大一学生，我明白自己的时间和能力都极其有限，但我仍然愿意为了自己的兴趣，也为了将来工作多一份可能的机会，来参加开源操作系统训练营。我相信这次经历会成为我的一段难忘的回忆。</p>
<hr>
<h3 id="第一阶段：110-道-Rust-题目的摸爬滚打"><a href="#第一阶段：110-道-Rust-题目的摸爬滚打" class="headerlink" title="第一阶段：110 道 Rust 题目的摸爬滚打"></a>第一阶段：110 道 Rust 题目的摸爬滚打</h3><hr>
<h4 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h4><ul>
<li><p>变量篇简简单单就过去了，区别就是 Rust 中的可变变量要<strong>显式</strong>声明。</p>
</li>
<li><p>常量必须<strong>明确指定类型</strong>： <code>const a: i32 = 0</code> 。</p>
</li>
<li><p>可以用大括号限定变量的作用域，作用域之外的变量会被回收。</p>
</li>
<li><p>输出时可以直接在大括号内指定变量名，如 <code>println!(&quot;{&lt;name&gt;}&quot;);</code> 。</p>
</li>
<li><p>可以借助元组一次赋多个值：let (s1, s2) = (“Hello”, “World”);</p>
</li>
<li><p>定义有重复元素的数组：[3; 5] == [3, 3, 3, 3, 3]</p>
</li>
</ul>
<hr>
<h4 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 Functions"></a>函数 Functions</h4><ul>
<li><p>函数签名：</p>
<pre><code>[pub] fn function_name(para: type, ...) -&gt; return_type 
[where
    T: ...] // 这里是对泛型实现的 Trait 要求
{ ... }</code></pre></li>
<li><p><code>fn</code> 的返回值一般是在函数末尾不加分号的语句，以及 <code>return ...;</code> 语句。</p>
<ul>
<li>注：fn 不需要像 C 一样要先有独立的函数声明，直接定义即可</li>
</ul>
</li>
</ul>
<hr>
<h4 id="条件控制流-Control-Flow"><a href="#条件控制流-Control-Flow" class="headerlink" title="条件控制流 Control Flow"></a>条件控制流 Control Flow</h4><hr>
<h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5><ul>
<li><p>基本语法：</p>
<pre><code>if [condition 1] {

} else if [condition 2] {

} else {

}</code></pre></li>
<li><p>当 if <strong>有返回值</strong>时（在Rust中，各个分支的最后一条语句没有分号时，将该语句的执行结果作为返回值），允许<strong>将整个 if 语句作为右值</strong>。<br>该功能对应 C 中条件运算符 <code>A ? &lt;condition&gt; : &lt;...&gt;</code> 的增强版。</p>
</li>
</ul>
<hr>
<h5 id="loop-无条件循环"><a href="#loop-无条件循环" class="headerlink" title="loop 无条件循环"></a>loop 无条件循环</h5><pre><code>loop { ... } // 无限循环</code></pre><hr>
<h5 id="标签-Labels"><a href="#标签-Labels" class="headerlink" title="标签 Labels"></a>标签 Labels</h5><ul>
<li><code>&#39;&lt;name&gt;:</code> 指定标签，用于跳转，可用于跳出循环，方法：<code>break &#39;&lt;name&gt;;</code> 或者 <code>continue &#39;&lt;&gt;;</code><br><strong>注意前面的单引号！</strong></li>
</ul>
<hr>
<h5 id="while-条件循环"><a href="#while-条件循环" class="headerlink" title="while 条件循环"></a>while 条件循环</h5><pre><code>// 单条件循环，先判定后进入
while &lt;Condition&gt; { ... } </code></pre><hr>
<h5 id="for-遍历循环"><a href="#for-遍历循环" class="headerlink" title="for 遍历循环"></a>for 遍历循环</h5><pre><code>// 遍历循环
for n in (1..4).rev() { ... } 
// rev():反转数字序列
// 区间表达式：([Start]..[=][End])
// 表达式产生值，语句（带分号的）不产生值</code></pre><hr>
<h5 id="match-语句"><a href="#match-语句" class="headerlink" title="match 语句"></a>match 语句</h5><p>（见 枚举类型 Enum）</p>
<hr>
<h5 id="if-let-简洁控制流"><a href="#if-let-简洁控制流" class="headerlink" title="if let 简洁控制流"></a>if let 简洁控制流</h5><p>只匹配一个模式的值</p>
<pre><code>if let Coin::Fen = coin { … } 
// 等号右侧的值进入语句块
// 可以加入else处理其他情况</code></pre><hr>
<h5 id="while-let"><a href="#while-let" class="headerlink" title="while let"></a>while let</h5><p>类似于if let，只匹配一种情况，并以此作为循环变量进入循环</p>
<hr>
<h4 id="内置类型-Primitive-Types"><a href="#内置类型-Primitive-Types" class="headerlink" title="内置类型 Primitive Types"></a>内置类型 Primitive Types</h4><hr>
<h5 id="整型-Integer"><a href="#整型-Integer" class="headerlink" title="整型 Integer"></a>整型 Integer</h5><ul>
<li>前缀：i有符号，u无符号，8-128以及isize和usize（取决于所用计算机的架构）。<br><strong>为方便阅读，定义时可以在任意位置加入任意数量的_作为阅读分隔符。</strong><br>比如 <code>0b_1000_1000_0010_0101_u16</code></li>
</ul>
<hr>
<h6 id="整型溢出-Integer-Overflow"><a href="#整型溢出-Integer-Overflow" class="headerlink" title="整型溢出 Integer Overflow"></a>整型溢出 Integer Overflow</h6><ul>
<li><p><code>--release</code>模式下编译时，不会检查整数溢出。<br>对于此，Rust有完整的应对方法：</p>
<ol>
<li><code>wrapping_...()</code>：回绕，溢出时返回正确结果对最大值取模</li>
<li><code>checked_...()</code>：检查，溢出时返回None</li>
<li><code>overflowing_...()</code>：溢出，溢出时返回：(正确结果对最大值取模，指示是否溢出的布尔值)</li>
<li><code>saturating_...()</code>：饱和，返回最接近的范围内值，即最大或最小值</li>
</ol>
<ul>
<li><code>...</code> 可以是：add, sub, mul. div, rem(Mod), neg, abs, pow, shl(&lt;&lt; 左移位), shr(&gt;&gt; 右移位)</li>
</ul>
</li>
<li><p>更多资料：<a href="https://doc.rust-lang.org/stable/book/appendix-02-operators.html" target="_blank" rel="noopener">Rust 官方文档：运算符</a></p>
</li>
</ul>
<hr>
<h5 id="浮点型-Float"><a href="#浮点型-Float" class="headerlink" title="浮点型 Float"></a>浮点型 Float</h5><p>f32 和 f64。</p>
<hr>
<h5 id="逻辑值-Bool"><a href="#逻辑值-Bool" class="headerlink" title="逻辑值 Bool"></a>逻辑值 Bool</h5><p>true 和 false。</p>
<hr>
<h5 id="单字符-char"><a href="#单字符-char" class="headerlink" title="单字符 char"></a>单字符 char</h5><ul>
<li><p>Rust 中存储的字符类型为 <strong>Unicode</strong>，范围是 <code>U+0000 - U+D7FF, U+E000 - U+10FFFF</code>。</p>
</li>
<li><p><strong>注意</strong>：Rust 会将中文字符视作 “Alphabetic”（字母），处理时需特别留意。</p>
</li>
<li><p><code>b&#39;A&#39;</code>：这种情况下是ASCII，仅u8。</p>
</li>
</ul>
<hr>
<h5 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h5><pre><code>let a = [1, 2, 4, 3, 5]; // 字面量</code></pre><hr>
<h5 id="数组切片-Slice"><a href="#数组切片-Slice" class="headerlink" title="数组切片 Slice"></a>数组切片 Slice</h5><pre><code>&amp;array[1..=3]
// 获得数组中索引 1 &lt;= index &lt;= 3 的元素的切片
// 可以理解为获取子集</code></pre><p><strong>注意</strong>：尽量不要将切片用于 &amp;str ，因为有的字符只占一个字节，但有的字符会占两个，如果两者在同一个&amp;str中共存的话，就不知道该返回什么。</p>
<hr>
<h5 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h5><pre><code>let tuple1 = (&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;);
let bar = tuple.1; // 元素访问
let (a, b, c) = tuple1; // 元组结构
// 此时 a,b,c 分别对应 &quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;
// 此时所有权已经转移</code></pre><hr>
<h4 id="向量-Vectors"><a href="#向量-Vectors" class="headerlink" title="向量 Vectors"></a>向量 Vectors</h4><pre><code>// let v: Vec&lt;i32&gt; = Vec::new();
let v = vec![1, 2, 4, 3, 5];
println!(&quot;向量 v: {:?} 的长度为 {}。&quot;, v, v.len()); // 输出数组长度 
// ?? 暂时还不知道为什么要用 {:?} 来输出向量 

println!(&quot;第一个元素：{}&quot;, v[1]); 
// 此处执行了隐式的类型转换：v -&gt; &amp;v
// 访问元素也可以用 v.get(1)

v.push(6) // 向 vec 中压入新元素，需要 &amp;mut 
// 原因：push时需要分配新内存以及将原来的部分复制到新的地方，
// 在执行该操作时需要避免其他对该对象的引用
// （因为可能指向已经被移动的原来部分导致“空指针“的出现）
// v.pop() 同理

for i in &amp;v { ... } // 隐式转换：&amp;v -&gt; iter</code></pre><hr>
<h5 id="vec-gt-iter-（迭代器）"><a href="#vec-gt-iter-（迭代器）" class="headerlink" title="vec -&gt; iter （迭代器）"></a>vec -&gt; iter （迭代器）</h5><pre><code>v.iter()     // 不能改变 v 中的元素</code></pre><p>或者</p>
<pre><code>v.iter_mut() // 可以改变 v 中的元素</code></pre><p>返回<code>Option&lt;T&gt;（即 Some(n) / None）</code></p>
<p>更多资料：<br><a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html" target="_blank" rel="noopener">Rust 官方文档：向量/列表</a></p>
<hr>
<h4 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 Map"></a>映射 Map</h4><pre><code>let mut iter = A.iter().map( |&lt;Variable&gt;| &lt;Expr&gt;/{ ... } )</code></pre><p><code>| ... |</code>: 闭包（closure）</p>
<p>映射只用于已对元素完成其他操作后的情形，根据上面的语句生成iter后，可用<code>iter.next()</code>访问下一个元素。</p>
<hr>
<h4 id="所有权-Ownership"><a href="#所有权-Ownership" class="headerlink" title="所有权 Ownership"></a>所有权 Ownership</h4><h2 id="这部分是-Rust-的精髓。"><a href="#这部分是-Rust-的精髓。" class="headerlink" title="这部分是 Rust 的精髓。"></a><strong>这部分是 Rust 的精髓。</strong></h2><p>Rust中，在同一时段内，所有值均有且仅有一个所有者（Owner），且值的生命周期与所有者相同。</p>
<ul>
<li><p><code>A.drop()</code>: 变量退出作用域</p>
</li>
<li><p>Rust 对不同类型的所有权处理：</p>
<ol>
<li><p>对于占用空间明确/可以压入栈的类型（比如内置的数字类型），在形如 let n2 = n1; 的语句中，会重新创建一个值相同的对象，和其他语言一样；<br>而对于其他类型，在上述语句中，会将原来值的所有权移动（move）给之后的值，原来的值将退出生命周期。<br>注：占用空间明确/可以压入栈的类型：Integer bool float char tuple（元组，条件：只包含已经实现Copy的类型）</p>
</li>
<li><p>对于传入函数的其他类型，如果没有返回值且之后也没有调用的话，则在函数调用完之后，这些类型的变量会退出生命周期；</p>
</li>
</ol>
</li>
<li><p>如果有返回值，则会将返回值的所有权交还给调用该函数的上一级。</p>
</li>
<li><p>要执行更高成本的deep copy，可使用clone()方法创建副本：<code>let s2 = s1.clone();</code> </p>
</li>
</ul>
<h5 id="做题经验"><a href="#做题经验" class="headerlink" title="做题经验"></a>做题经验</h5><ul>
<li><p>若想在传递值时不改变所有权，可使用<strong>共享不可变引用 <code>&amp;A</code></strong> ，或者<strong>独占可变引用 <code>&amp;mut A</code></strong>。要访问引用中的值，可使用 <code>*B</code>。<strong>两者的作用域不能重合！！！</strong></p>
</li>
<li><p>若一个函数的参数不为引用（没有 &amp; 和 &amp;mut 修饰），则在执行函数时，该参数的所有权会移交给函数，提供的参数在进入函数时失效（无法再通过原来的变量名访问）。</p>
</li>
<li><p>通过引用传入函数的其他类型，由于函数并没有传入对象的所有权，因而这些变    量在离开函数之后也不会退出生命周期。</p>
</li>
<li><p>Dangling Reference（虚调用？）：如果一个变量在域内定义，则不能将其引用返    回域外，但可以将变量本身返回域外</p>
</li>
<li><p><code>&amp;</code> 和 <code>ref</code> 的区别：</p>
<ol>
<li><code>&amp;T</code>：类型：T的引用，可用于变量声明、函数参数和模式匹配中传递引用类型</li>
<li><code>ref T</code>：主要用于模式匹配，将值绑定在该引用上  </li>
</ol>
<p>  <strong>（获取到的类型仍然是T）</strong></p>
</li>
<li><p>函数参数可以使用 mut 修饰。</p>
</li>
<li><p>Rust 中的方法会根据自身需要，要求不同类型的引用，此时除了<strong><em>相信编译器的力量</em></strong>，还要多多查阅官方文档，以避免不可控的事件。</p>
</li>
</ul>
<hr>
<h4 id="结构体类型-Struct"><a href="#结构体类型-Struct" class="headerlink" title="结构体类型 Struct"></a>结构体类型 Struct</h4><p>以下展示了定义结构体的几种方法：</p>
<pre><code>struct ColorClassicStruct {
    red: i32,
    green: i32,
    blue: i32,
}
// 允许提供默认值

struct ColorTupleStruct(i32, i32, i32);
// 该结构元素的访问和元组一样，定义的时候需要在前面加上结构名
// e.g.: let green = ColorTupleStruct(0, 255, 0);

struct UnitLikeStruct;
// 没有任何字段的类单元结构体
// 单元结构体： ()</code></pre><ul>
<li><p>如果需要某个类型来实现某种<strong>不需要数据</strong>的行为时就可以用<strong>类单元结构体</strong>，<strong>类似于其它语言中没有数据成员的类</strong>。</p>
</li>
<li><p>输出时可用 <code>{:?}</code> 获得结构体类型的名称。</p>
</li>
<li><p>可以用 <code>let A2 = A { a: false, ..A1}</code> 定义除了a之外，其他元素和A1一样的对象。</p>
</li>
<li><p><strong>最好尽量保证结构体拥有其数据，也就是说尽量不要使用引用</strong>。<br>  比如说尽量用 <code>String</code> 而不是 <code>&amp;str</code></p>
</li>
<li><p>定义针对结构变量的方法和关联函数：<code>impl B { fn mB1(&amp;self) -&gt; u32 { ... } }，</code></p>
</li>
<li><p>方法的第一个参数必须是 <code>self: &amp;[mut] self</code> （可以简写为<code>&amp;self</code>）</p>
</li>
<li><p>关联函数不需要遵循上面的条件，用 <code>B::B2()</code> 调用，<br>例：<code>String::from()</code>，一般用于初始化对象（创建新的实例）</p>
</li>
</ul>
<h4 id="枚举类型-Enum"><a href="#枚举类型-Enum" class="headerlink" title="枚举类型 Enum"></a>枚举类型 Enum</h4><pre><code>enum An_Enum
{ 
    Int_2(i32, i32), 
    Float(f64), 
    Text(String), 
    Other,  
}

let A = An_Enum::Int_2(0, 0);</code></pre><ul>
<li><p>Rust 中枚举类型只作为标识符，不具有对应的“数字索引”。</p>
</li>
<li><p>枚举类型中的各个成员的类型可以不一样。</p>
</li>
<li><p>枚举Option在标准库中的定义：<code>enum Option&lt;T&gt; { None, Some(T), }</code><br>可用于消除空值运算的风险</p>
</li>
</ul>
<h5 id="match-语句：匹配枚举类型"><a href="#match-语句：匹配枚举类型" class="headerlink" title="match 语句：匹配枚举类型"></a>match 语句：匹配枚举类型</h5><pre><code>enum Year { 2005, 2006, 2007, }
enum Coin { 
    Fen, 
    Jiao, 
    Yuan(Year), 
} 
// 可以用(A)或者{ a:i32, b:i32 }绑定其他类型，之后match可以用

fn value_in_coins(coin: Coin) -&gt; u8 {
    match coin { // 此处的coin可以是任意类型，不一定是if那样的表达式
        Coin::Fen =&gt; 1,
        Coin::Jiao =&gt; 10,
        Coin::Yuan(year) =&gt; {
            println!(“这个一块发行于{:?}年”, year);
            100
        } // 可以是语句块

        // _ =&gt; (), 对默认情况 _（上面没有处理的情况）操作，
        // match 中必须处理所有可能出现的情况
    }
}
fn main() {
    value_in_coins( Coin::Yuan(2005) )
}</code></pre><ul>
<li><p>在匹配到的枚举元素后面，如果需要传递元组，需要拆成一个个元素才能传递</p>
</li>
<li><p>如果想忽略其中一些元素，可使用 _ ，忽略几个就打几个</p>
</li>
<li><p>如果想忽略之后的所有元素，可使用 ..</p>
</li>
<li><p>match 可用于处理 <code>Option&lt;T&gt;</code></p>
</li>
<li><p>匹配模式（=&gt; 左边的值）：<br>字面值、命名变量、多个值（用 | 分割）、区间表达式</p>
</li>
</ul>
<hr>
<h4 id="字符串类型-amp-Str-and-String"><a href="#字符串类型-amp-Str-and-String" class="headerlink" title="字符串类型 &amp;Str and String"></a>字符串类型 &amp;Str and String</h4><p>笔者目前遇到的 Rust 字符串有 2 种：<code>&amp;str</code> 和 <code>String</code>。字面量为 <code>&amp;str</code> 。</p>
<h5 id="amp-str"><a href="#amp-str" class="headerlink" title="&amp;str"></a>&amp;str</h5><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><pre><code>// &amp;str -&gt; String
let A = String::from(&quot;foo&quot;);</code></pre><p><code>&amp;s[RangeExpr]</code> : 字符串切片</p>
<p>访问 <code>String</code> 时需要用 <code>&amp;</code> 。</p>
<ul>
<li>以下提供一些字符串的常用方法（其他可查阅官方文档）：<ol>
<li><code>A + &quot; ... &quot;</code>: 字符串拼接，注意后面的是 <code>&amp;str</code> 。</li>
<li><code>A.replace(B, C)</code>: 将 A 中所有的子串 B 换成 C 。</li>
<li><code>&quot;...&quot;.to.owned()</code>: 将 <code>&amp;str</code> 转换为 <code>String</code>， 且获取其所有权。</li>
<li><code>A.to_uppercase() / A.to_lowercase()</code> : 字面意思。</li>
<li><code>A.as_bytes()</code>: 可将字符串转换为为 <code>vec</code>。</li>
<li><code>A.as_chars()</code>: 可将字符串转换为迭代器。</li>
<li><code>A.clear()</code>: 清空字符串</li>
<li><code>A.trim()</code>: 删除字符串两端所有的空白字符</li>
<li><code>A.trim_matches(&lt;pattern&gt;)</code>: 匹配字符串中所有的 pat 并删除<br>（ pat 不一定是字符串，比如<code>char::is_numeric</code>会删掉所有的数字）<br><code>&amp;str</code>会自动转换为<code>String</code><br>派生：<code>str.trim_left/right_matches(pat)</code></li>
<li><code>str.splitn(n, “&lt;sign&gt;”)</code>: 根据特定的sign将字符串分割为n份<br>如果要从后面开始分割就用 <code>str.rsplitn(...)</code><br>如果不需要知道具体多少份，只需要全部分割，就用 <code>split_terminator(&quot;&lt;sign&quot;?)</code></li>
</ol>
</li>
</ul>
<hr>
<h4 id="包-Crates"><a href="#包-Crates" class="headerlink" title="包 Crates"></a>包 Crates</h4><pre><code>use std::time::{SystemTime, UNIX_EPOCH};
// 以上是一个应用标准库模块的示例

mod &lt;mod_name&gt; {
    [pub] use &lt;some_explicit_module&gt; as &lt;alias&gt;; 
    // 在 mod 内使用外部模块

    fn ... { ... }        // 私有成员
    pub fn ... { ... }    // 公有成员
}</code></pre><h5 id="做题经验-1"><a href="#做题经验-1" class="headerlink" title="做题经验"></a>做题经验</h5><ol>
<li><p>cargo new得到的包中，./src/main.rs是与包同名的二进制crate的crate根，<br>而./src/lib.rs是与包同名的库crate的crate根，两者可共存<br>每个./src/bin下的文件都会被编译成一个独立的二进制crate</p>
</li>
<li><p>对一个模块（mod），编译时会从<code>crate</code>根开始逐级往下编译，<br>在根文件中可通过<code>mod &lt;name&gt;;</code>声明模块。<br>寻找该模块：  </p>
<ol>
<li>内联：用语句块{ … }代替分号  </li>
<li>在./src/<name>.rs  </name></li>
<li>在./src/<name>/mod.rs （老风格）  </name></li>
</ol>
<ul>
<li>在上述ii, iii的文件中仍可以用<code>mod &lt;name2&gt;;</code>声明子模块 </li>
</ul>
<p>模块一般需要定义在上一级的代码文件中，<br>如果想将当前目录下的主文件<code>&lt;name&gt;.rs</code>拆分成多个文件，也可以使用mod声明，<br>然后将声明的对象放在同级的文件夹中，<br>拆分后文件的子模块和上面操作一样，新建同名文件夹并将子模块放进去即可<br>访问：<code>&lt;crate&gt;::&lt;name1&gt;::&lt;name2&gt;</code></p>
<p>默认私有，公用：<code>pub mod &lt;pubname&gt;;</code><br>访问模块的快捷方式：<code>use &lt;crate&gt;::&lt;name1&gt;::&lt;name2&gt;;</code> ，<br>之后就可以只用<code>&lt;name2&gt;</code>访问</p>
<p>用途：对代码进行分组，使整体结构清晰</p>
</li>
<li><p>根据模块树的路径访问模块：用 <code>::</code><br>绝对路径：从<code>crate</code>开始； 相对路径：从当前位置开始</p>
</li>
<li><p>父模块的项不能使用子模块中的私有项，但反过来可以</p>
</li>
<li><p>公有项里面的私有项仍然是私有项<br>由此可以管理模块中的公有和私有方法，以及结构的公有成员和私有成员<br>但公有枚举的所有成员均为公有</p>
</li>
<li><p><code>use super::&lt;...&gt;;</code> 从父模块的路径开始</p>
</li>
<li><p><code>use</code>不允许导入同名的快捷方式，但可以通过父模块区分，<br>或者用<code>as</code>（像Python一样）起别名</p>
</li>
<li><p><code>pub use</code>：不仅将一个名称导入了当前作用域，还允许别人把它导入他们自己的作用域。<br>用途：导出公有的API</p>
</li>
<li><p>使用外部包：在包中的<code>Cargo.toml</code>文件中加入<code>&lt;packagename&gt; = &quot;&lt;version&gt;&quot;</code></p>
</li>
<li><p><code>use std::{cmp::Ordering, io};</code> ：可以用嵌套路径缩短use行</p>
</li>
<li><p><code>use std::collections::*;</code> ：*称为glob(al?)运算符，引入该模块下的所有公有成员<br>务必小心，可能会有7中同名的情况<br>常用于测试模块test中，有时也用于prelude模式</p>
</li>
<li><p><code>build.rs</code>：构建脚本<br>关于构建脚本的一些使用场景如下：</p>
<ul>
<li>构建 C 依赖库</li>
<li>在操作系统中寻找指定的 C 依赖库</li>
<li>根据某个说明描述文件生成一个 Rust 模块</li>
<li>执行一些平台相关的配置</li>
</ul>
<p><strong>构建脚本的输入可以是环境变量和构建脚本所在的当前目录</strong><br><strong>构建脚本的输出不应修改该目录之外的任何文件</strong><br>更多资料：<br><a href="https://course.rs/cargo/reference/build-script/intro.html" target="_blank" rel="noopener">构建脚本 build.rs - Rust语言圣经(Rust Course)</a></p>
<p>此脚本通过 stdout （标准输出）提供输出。<br>打印的所有行都写入到target/debug/build/<pkg>/output。<br>另外，以 cargo: 为前缀的行将由 cargo 直接解析，<br>因此可用于定义包编译的参数。  </pkg></p>
</li>
</ol>
<hr>
<h4 id="哈希表-HashMap"><a href="#哈希表-HashMap" class="headerlink" title="哈希表 HashMap"></a>哈希表 HashMap</h4><ul>
<li><p>使用前提：(因为比较少用，所以没有被 <code>prelude</code> 导入)</p>
<p>  use std::collections::HashMap;</p>
</li>
<li><p>哈希表对应 Python 中的字典，用于储存键-值对。</p>
<pre><code>let hm1 = HashMap::&lt;String, i32&gt;::new();

hm1.insert( &lt;key&gt;, &lt;value&gt; );
// 会转移所有权，可以用 &amp;

hm1.entry( &lt;key&gt; ).or_insert( &lt;value&gt; )
// 如果 hm1 中没有键 k ，就插入( &lt;key&gt;, &lt;value&gt; )

hm1.get( &lt;key&gt; )
// 读取元素

// 打印时顺序是任意的</code></pre></li>
</ul>
<hr>
<h4 id="异常处理-Panics"><a href="#异常处理-Panics" class="headerlink" title="异常处理 Panics"></a>异常处理 Panics</h4><ol>
<li><p>显式调用：<code>panic!(“&lt;err_message&gt;”);</code></p>
</li>
<li><p>默认展开（回溯栈并清理所有数据），可在<code>Cargo.toml</code>文件中设置为终止，可以让最终二进制文件更小，用法：在该文件中加入:</p>
<p>  [profile.release]<br>  panic = ‘abort’</p>
</li>
<li><p><code>enum Result&lt;T, E&gt; { Ok(T), Err(E), }</code> 用match处理</p>
</li>
<li><p>错误处理：依靠<code>Result</code>类型，<br>例如如果需要获得正确的结果(T)，就用<code>match</code>匹配即可（用闭包更短更快）</p>
</li>
<li><p><code>panic</code>处理简写：</p>
<ol>
<li><code>&lt;ResultObject&gt;.unwrap()</code> 返回Ok内的T，否则抛出panic<br>（尽量别用，因为这对人工检查代码没有Err的要求比较高）</li>
<li><code>&lt;ResultObject&gt;.expect(&quot;&lt;err_msg&gt;&quot;)</code> 同上，抛出时附带信息（更常用）</li>
<li><code>&lt;ResultObject&gt;?</code> 同<code>.unwrap()</code>，能使代码更短（只能用在返回Result类型的函数中）</li>
</ol>
</li>
<li><p>如果能准确预测错误的出现（可以恢复运行的错误），最好返回<code>Result&lt;T, E&gt;</code>而不是经常使用panic</p>
</li>
<li><p>输入字符串，处理为数字：<code>str.parse::&lt;i32&gt;()</code></p>
</li>
<li><p>▲ 在没有返回值（比如main）或者返回值为()的函数中不能使用 ? 运算符，<br>如果想用可以给函数加上返回值类型（返回Result类型；main也可以）<br>可以用<code>unwrap()</code>代替？<strong>（不建议使用）</strong><br>另：返回的Result可以是<code>Result&lt;(), ErrorType&gt;</code>，<br>  也可以是 <code>Result&lt;(), Box&lt;dyn ErrorType&gt;&gt;</code><br>  （可以捕捉所有类型的错误，但不建议在库代码中使用）  </p>
</li>
</ol>
<hr>
<h4 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型 Generics"></a>泛型 Generics</h4><ol>
<li>用在函数上：<code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {}</code></li>
<li>可用于函数、结构体、枚举、方法等</li>
<li>泛型定义中同一个字母只代表一种类型</li>
<li>Option 和 Result 就是利用泛型实现的</li>
<li>使用泛型的接口：<code>impl&lt;T&gt; Name&lt;T&gt; { }</code></li>
<li>泛型代码编译时会先进行单态化</li>
<li>可以针对特定类型实现特殊方法，如<code>impl Point&lt;f32&gt; {}</code></li>
<li>针对值的泛型：如<code>arr: [T; N]</code> 或者 <code>arr: [i32; 3]</code></li>
</ol>
<hr>
<h4 id="接口-Traits"><a href="#接口-Traits" class="headerlink" title="接口 Traits"></a>接口 Traits</h4><ol>
<li><p>声明：<code>trait &lt;trait_name&gt; { }</code><br>实现：<code>impl &lt;trait_name&gt; (for &lt;datatype&gt;) { }</code></p>
</li>
<li><p>trait 可以作为参数，以 <code>item: &amp;impl datatype</code> 的形式传入，以<code>item.method()</code>的形式调用方法（与 <code>&lt;T: datatype&gt;(item: &amp;T)</code> 等价）</p>
</li>
<li><p>可以用 + 连接需要同时实现的多个接口，<br>如<code>(item: &amp;(impl Summary + Display)</code><br>如果太长，可以用where写成：</p>
<p>  fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32<br>  where</p>
<pre><code>T: Display + Clone,
    U: Clone + Debug,</code></pre><p>  { … }</p>
<p><code>impl&lt;T: trait_name&gt; name&lt;T&gt;</code>：函数名处的<code>&lt;...&gt;</code>不需要再写实现的模块</p>
</li>
<li><p>返回值也可以用 <code>impl trait</code> 指定返回实现了trait的类型，但由于泛型会进行单态化，所以函数中所有的返回值类型必须一致</p>
</li>
<li><p>trait 中可以为方法提供默认行为，不是非要在 impl 中定义</p>
</li>
</ol>
<hr>
<h4 id="生命周期-Lifetimes"><a href="#生命周期-Lifetimes" class="headerlink" title="生命周期 Lifetimes"></a>生命周期 Lifetimes</h4><ol>
<li>显式声明如：<code>&amp;i32</code>改为<code>&amp;&#39;a i32</code></li>
<li>函数名后加标签：<code>method&lt;&#39;a&gt;</code></li>
<li>不允许创建悬垂引用（空指针），通过改变生命周期的方法也不行</li>
<li><code>&#39;static</code>：变量生命周期贯穿整个程序<br>大部分情况中，推荐 <code>&#39;static</code> 生命周期的错误信息都是尝试创建一个悬垂引用或者可用的生命周期不匹配的结果。<br>在这种情况下的解决方案是修复这些问题而非指定一个 <code>&#39;static</code> 的生命周期。</li>
<li>可以用 static 代替 let 声明静态变量，此时需要<strong>显式</strong>指定变量类型</li>
<li>生命周期约束：<br><code>&lt;’a, ‘b:’a, T&gt;</code>: 声明 ‘b 至少要和 ‘a 活得一样久<br><code>&lt;’a, T&gt;</code>：表示 T 至少比 ‘a 活得久</li>
<li>引用的生命周期从借用处开始一直到<strong>最后一次使用的地方</strong></li>
</ol>
<hr>
<h4 id="迭代器和闭包-Iterators-and-Closure"><a href="#迭代器和闭包-Iterators-and-Closure" class="headerlink" title="迭代器和闭包 Iterators and Closure"></a>迭代器和闭包 Iterators and Closure</h4><ol>
<li><p>声明：如<code>A.iter()</code></p>
</li>
<li><p>迭代器接口：</p>
<p>pub trait Iterator {<br>  type Item;<br>  fn next(&amp;mut self) -&gt; Option<a href="Self::Item">Self::Item</a>;<br>  // 此处省略了方法的默认实现<br>}</p>
<p><code>iter.next()</code> 返回 <code>Some(下一项)</code>，结束时返回 <code>None</code></p>
</li>
<li><p>迭代器声明后必须被使用</p>
</li>
<li><p>闭包：可以保存进变量或者作为参数传递给其他函数的匿名函数</p>
</li>
<li><p>闭包定义：<code>|x, y, z| { }</code> （只有一行时大括号可省略）<br>竖线内为参数<br>可以在一个地方创建闭包，之后在不同的上下文中进行闭包运算</p>
<p>  let capitalize_words: Vec<String> = words.iter().map(|x| capitalize_first(x)).collect();<br>  // map方法接受一个闭包作为参数</String></p>
<p>  let expensive_closure = |num| {</p>
<pre><code>println!(&quot;calculating slowly...&quot;);
thread::sleep(Duration::from_secs(2));
num</code></pre><p>  };<br>  // 后面的用法应该类似python的lambda函数</p>
</li>
<li><p><code>&lt;...&gt;.collect()</code> 可以直接将前面的表达式收集为需要返回的目标类型，<strong>目标类型需要明确指定</strong>。</p>
</li>
<li><p>一些方法：</p>
<p><code>Iter.count()</code>：返回迭代器项数</p>
<p><code>Iter.sum()</code>：返回迭代器的和</p>
<p><code>Iter.product()</code>：返回迭代器的积</p>
<p><code>Iter.filter( |x| expr_x )</code>：根据表达式真假过滤元素</p>
<p><code>List_Iter_A.enumerate()</code>: 可生成元组(Index, &amp;Element) </p>
<p>更多资料：</p>
<ol>
<li><a href="https://blog.csdn.net/feiyanaffection/article/details/125574862" target="_blank" rel="noopener">【Rust 笔记】13-迭代器（上）_rust笔记 迭代器 13 中-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/feiyanaffection/article/details/125574968" target="_blank" rel="noopener">【Rust 笔记】13-迭代器（下）_rust product-CSDN博客</a></li>
</ol>
</li>
<li><p>Hashmap转Vec：Vec::from_iter( hashmap.iter() )<br>返回[(K1,V1), (K2,V2), …]<br>可以换成hashmap.keys() / .values() 这两个方法直接返回迭代器  </p>
</li>
</ol>
<hr>
<h4 id="智能指针-Smart-Pointers"><a href="#智能指针-Smart-Pointers" class="headerlink" title="智能指针 Smart Pointers"></a>智能指针 Smart Pointers</h4><ol>
<li><p><code>Box&lt;T&gt;</code>：将数据存放在堆中，在栈中压入一个指向堆中数据的指针<br>用途：<br>1）编译时未知大小的类型，又想要在需要确切大小的上下文中使用这个类型值的时候<br>2）有大量数据并希望在确保数据不被复制的情况下转移所有权时</p>
</li>
<li><p>递归（Recrusive）：<br>定义：</p>
<p>  enum List {</p>
<pre><code>Cons(i32, List),
Nil, // Nil代表循环终止</code></pre><p>  }</p>
<p>使用：<code>let list = Cons(1, Cons(2, Cons(3, Nil)))</code></p>
<p><strong>在Rust中实现递归最大的问题是不知道运行的时候需要占用多少内存</strong>，<br>因此可以利用Box<T>改成这样：</T></p>
<p>enum List {<br>  Cons(i32, Box<List>),<br>  Nil, // Nil：代表循环终止<br>}</List></p>
<p>使用：<code>let list = Box::new(Cons(1, Box::new(Cons(2, Box::new(Cons(3, Nil))))));</code></p>
</li>
<li><p>解引用（dereference）：<code>*</code><br>实现 deref trait 即可，该特性允许智能指针采用与引用相同的处理方式进行处理<br>隐式Deref强制转换：有时可以省略&amp;或*  </p>
</li>
<li><p>Drop trait：(<code>std::mem::drop</code>)<br>需要实现方法drop，获取可变引用，最后释放资源<br>用法：<code>A.drop()</code>  </p>
</li>
<li><p>引用计数（reference counting）：<code>Rc&lt;T&gt;</code><br>用于需要用到多所有权的情况中<br>声明：<code>let Rc_A = Rc::new();</code><br>获取多所有权：<code>let Rc_1 = Rc::clone( &amp;Rc_A );</code>（可能需要显式指定类型）<br>释放多所有权：<code>drop(Rc_1);</code><br>获取和释放的顺序<strong>可以不一样</strong>  </p>
</li>
<li><p>Cow：Clone on write，<code>use std::borrow::cow;</code><br>仅当需要可变的 B 类型对象或者获取所有权时，才会将该对象复制并传递<br>当然也可以将比如没有 &amp; 的 slice 等类型按正常方式传递所有权<br>以下是标准库中的原型：</p>
<p>  pub enum Cow&lt;’a, B&gt;<br>  where</p>
<pre><code>B: &apos;a + ToOwned + ?Sized,</code></pre><p>  {</p>
<pre><code>Borrowed(&amp;&apos;a B),
Owned(&lt;B as ToOwned&gt;::Owned),</code></pre><p>  }</p>
</li>
</ol>
<hr>
<h4 id="线程-Threads-并发-Concurrent-Programming"><a href="#线程-Threads-并发-Concurrent-Programming" class="headerlink" title="线程 Threads / 并发 Concurrent Programming"></a>线程 Threads / 并发 Concurrent Programming</h4><ol>
<li><p>并发（Concurrent Programming）：<br>程序的不同部分相互独立地执行<br>并行（Parallel Programming）：<br>程序的不同部分相互独立且同时执行<br>对操作系统来说，<br>  进程是资源分配的基本单位<br>  线程是任务执行的基本单位<br>目的：将一批任务分给多个线程同时处理以提高效率  </p>
</li>
<li><p>创建新线程：</p>
<p>  use std::thread;<br>  &lt;let handle =&gt; thread::spawn( <move> || { 线程具体内容 })</move></p>
<p>两条竖线是没有参数的闭包<br>可选的<code>move</code>用于转移该线程中用到的变量所有权    </p>
</li>
<li><p><code>handle.join()</code> 等待所有线程结束，返回Result<T><br><code>thread::sleep(Duration::from_millis(1))</code>: 休眠<br>（需要用到 <code>std::time::Duration</code>）</T></p>
</li>
<li><p>在线程之间传递数据：</p>
<p>  let (Transmitter, Receiver) = std::sync::mpsc::channel();<br>  // mpsc：Multiple producers and single conducter<br>  Transmitter.send(val) 通过Transmitter将val发送给Receiver</p>
<p><code>Receiver.recv()</code>: 通过Receiver接受Transmitter发送过来的数据<br>上述两个方法会转移所有权，且返回<code>Result&lt;T&gt;</code><br>一个发送信道只能传递给一个线程，不过可以用<code>clone</code></p>
</li>
<li><p>互斥器（Mutual Exclusion）：<br><code>Mutex&lt;T&gt;</code>：任意时刻只允许一个线程访问某些数据<br>难点：</p>
<ol>
<li>在使用数据之前使用<code>mutex_val.lock()</code>先将数据锁定在当前线程</li>
<li>在处理完数据后解锁让其他的线程获取lock<br>e.g.:<br>对于一个<code>A = Arc(Mutex(Struct1( …… )))</code>对象，<br>调用Struct1内元素的方法是：<code>A.lock().unwrap().element1</code><br>对于有<code>Mutex&lt;T&gt;</code>的对象都需要先获取lock()  </li>
</ol>
</li>
<li><p>原子引用计数<code>Arc&lt;T&gt;</code>：<br>在<code>std::sync::Arc</code>中，用法和<code>Rc&lt;T&gt;</code>完全一样，但是能保证线程安全</p>
</li>
</ol>
<hr>
<h4 id="宏-Macros"><a href="#宏-Macros" class="headerlink" title="宏 Macros"></a>宏 Macros</h4><ol>
<li>优势：<br>  可以接受不同数量的参数；<br>  可以在编译前展开且为一个给定类型实现trait<br>缺点：<br>  更难阅读、理解和维护<br>  调用前必须定义  </li>
<li>声明：<code>macro_rules! &lt;macro_name&gt; {  }</code>     </li>
<li>要使用在mod中的宏，可以在mod开头加入<code>#[macro_use]</code></li>
<li>宏匹配的分支用<code>;</code>分隔即可，最后一个不需要</li>
</ol>
<h4 id="类型转换-Conversions"><a href="#类型转换-Conversions" class="headerlink" title="类型转换 Conversions"></a>类型转换 Conversions</h4><ol>
<li><code>as</code>：强制类型转换<br>（Rust <strong>不允许数值进行隐式的类型转换</strong>，也就是说1+1.0不合法）</li>
<li><code>from() / into()</code>：用于类型转换，实现了from就能自动实现into<br><code>try_from() / try_into()</code>：简单安全的类型转换，适用于比较容易错的类型转换<br>库：<code>std::convert::{TryFrom, TryInto};</code><br>上述方法可以实现泛型  </li>
<li><code>as_ref() / as_mut()</code> ：<br>对一个类型T，若实现了<code>AsRef&lt;U&gt;</code>，则可通过<code>as_ref()</code>将T转化为U的引用<br><code>as_mut()</code>为其可变版本</li>
</ol>
<h4 id="测试-Tests"><a href="#测试-Tests" class="headerlink" title="测试 Tests"></a>测试 Tests</h4><ol>
<li><code>#[test]</code>：可以加在mod或者fn上面，则这个代码块只会在cargo test中运行，在所有测试标签中要放在最上面<br>更常用：<code>#[cfg(test)]</code>：同上，但在cargo build中不编译</li>
<li><code>assert!()</code>：用于断言某些条件为真，第二个参数是可选的错误信息<br><code>assert_eq/ne!(A, B)</code>：字面意思</li>
<li>一般测试模块都会加入<code>use super::*;</code>来避免写出繁复的块外调用</li>
<li><code>#[Should_panic]</code>：<br>当下面的代码块抛出panic时测试通过<br><strong>不能</strong>在返回Result类型的代码块中使用</li>
<li>并行：<code>cargo test -- --test-threads=&lt;num&gt;</code></li>
<li>打印运行时输出的值：<code>cargo test -- --show-output</code></li>
<li><code>cargo test &lt;method_name&gt;</code>：指定运行哪些测试方法，<br>此处的参数是指：包含参数这个字符串的所有方法（不仅仅是这一个）</li>
<li><code>#[ignore]</code>：忽略某些测试<br><code>cargo test -- --ignored</code>：只运行被忽略的测试<br><code>cargo test -- --include-ignored</code>：运行所有测试  </li>
<li>集成测试：<br>在包的根目录下（和src同级的地方）创建 tests 文件夹，<br>新建 <code>integration_test.rs</code> 文件存放集成测试<br>需要加入 <code>use &lt;包名&gt;;</code><br>如果需要在tests中创建不需要被执行的模块，须在模块目录下新建mod.rs，将模块内容放进去  </li>
</ol>
<hr>
<h4 id="非安全代码块-Unsafe-Block"><a href="#非安全代码块-Unsafe-Block" class="headerlink" title="非安全代码块 Unsafe Block"></a>非安全代码块 Unsafe Block</h4><ol>
<li>信息来自ChatGPT：<br>在Rust中，<code>*mut</code>是一个指针类型，表示可变的裸指针（raw pointer）。裸指针是一种直接存储内存地址而不提供安全性保证的指针类型。<code>*mut T</code>中的T是指针指向的类型。<code>*mut</code>指针可以用于访问和修改内存中的数据，但是使用它们需要特别小心，因为它们不受Rust的所有权和借用规则的保护，可能导致内存安全问题。<br>使用<code>*mut</code>指针需要谨慎，因为它们可以绕过Rust的借用检查和内存安全性检查。在编写涉及裸指针的代码时，需要确保自己明确了解代码中的所有权和生命周期，并尽量减少对裸指针的使用，以减少潜在的错误和安全隐患。</li>
<li>使用：<code>unsafe { ... }</code><br>所有涉及到不安全行为的代码全部都要放在unsafe内</li>
<li>裸指针（Naked pointer）：<br>？？？ 和C中的指针比较类似，可以通过unsafe中的裸指针修改值</li>
<li><code>Box::into_raw(&lt;data&gt;)</code>：可以用于将<code>Box&lt;T&gt;</code>类型的data转换为 <code>*T</code>,<br><code>Box::from_raw(&lt;*mut_data&gt;)</code>：可以将<code>*T</code>转换为<code>Box&lt;T&gt;</code></li>
</ol>
<h6 id="关于题99"><a href="#关于题99" class="headerlink" title="关于题99"></a>关于题99</h6><p><a href="https://rustwiki.org/zh-CN/reference/items/external-blocks.html" target="_blank" rel="noopener">外部块 External Block</a></p>
<p><a href="https://course.rs/advance/unsafe/superpowers.html" target="_blank" rel="noopener">Unsafe 的五种兵器</a></p>
<p><a href="https://rustwiki.org/zh-CN/rust-by-example/std_misc/ffi.html" target="_blank" rel="noopener">外部语言函数接口 Extern</a></p>
<hr>
<h4 id="算法-Algorithms：第一阶段的拦路虎"><a href="#算法-Algorithms：第一阶段的拦路虎" class="headerlink" title="算法 Algorithms：第一阶段的拦路虎"></a>算法 Algorithms：第一阶段的拦路虎</h4><h5 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h5><ul>
<li>LIFO（最后入栈的元素最先出栈）</li>
<li>更快，因为数据在物理地址上更近，且组织形式简单</li>
</ul>
<h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h5><ul>
<li><p>分配内存并返回指向该内存的指针</p>
</li>
<li><p>调用函数时，函数参数（以及指向这些值的指针）会被压入栈以提高运行速度。</p>
</li>
<li><p>可以用栈实现，分为小顶堆和大顶堆</p>
<p>  pub struct Heap<T><br>  where</T></p>
<pre><code>T: Default,</code></pre><p>  {</p>
<pre><code>count: usize,
items: Vec&lt;T&gt;,
comparator: fn(&amp;T, &amp;T) -&gt; bool,</code></pre><p>  }</p>
<p>  impl<T> Heap<T><br>  where</T></T></p>
<pre><code>T: Default,</code></pre><p>  {</p>
<pre><code>pub fn new(comparator: fn(&amp;T, &amp;T) -&gt; bool) -&gt; Self {
    Self {
        count: 0,
        items: vec![T::default()],
        // 留下0号位，不使用
        comparator,
    }
}

pub fn len(&amp;self) -&gt; usize {
    self.count
}

pub fn is_empty(&amp;self) -&gt; bool {
    self.len() == 0
}

pub fn add(&amp;mut self, value: T) {
    //TODO
    self.count += 1;
    self.items.push(value);
    let new_idx = self.count;
    self.heapify_from_bottom_to_top(new_idx);
}

fn heapify_from_bottom_to_top(&amp;mut self, mut idx: usize) {
    // 目的：针对某一个元素自下而上堆化
    // 因为加入的新元素可能破坏堆结构
    // idx 为新元素的索引
    // 假设现在需要生成小顶堆，则比较器接口 comparator 应为 a &lt; b -&gt; true

    while idx &gt; 1 {
        if (self.comparator)(&amp;self.items[ idx ], &amp;self.items[ idx/2 ]) {
            // 这里的 i &gt; 1 是因为初始化堆时，已经预留了0号位不使用，所以此时堆中只有一个元素
            // 如果新元素比它现在的父节点大，就交换两者
            self.items.swap(idx, idx/2);
            idx /= 2;
            // 此时新元素的索引已经更新为 i/2 ，再次比较，直到上方元素小于或等于下方元素则终止
            // 注：堆中允许存在重复的元素
        } else {
            break;
            // !!! 这一条break非常重要！！！
            // 用于判定元素是否已经到达符合条件的位置
            // 如果没有break，会导致idx一直没有改变，从而陷入死循环
        }
    }
}

fn heapify_from_top_to_bottom(&amp;mut self, mut idx: usize) {
    // 目的：针对某一个元素自上而下堆化
    // 其他同上
    while self.children_present(idx) {
        // 如果当前节点有子节点
        let schild = self.smallest_child_idx(idx);
        // schild 是当前节点下索引应当最小的那个元素的索引
        if (self.comparator)( &amp;self.items[ schild ], &amp;self.items[ idx ] ) {
            // 如果该子节点的值比新元素小，则需要将子节点的值上移
            self.items.swap( schild, idx );
            idx = schild;
            // 此时新元素的索引已经更新为schild，重复该操作直到该元素到达正确的位置，
            // 或者该元素已经没有子节点
        } else {
            break;
            // !!! 这一条break非常重要！！！
            // 用于判定元素是否已经到达符合条件的位置
            // 如果没有break，会导致idx一直没有改变，从而陷入死循环
        }
    }
}

fn parent_idx(&amp;self, idx: usize) -&gt; usize {
    idx / 2
}

fn children_present(&amp;self, idx: usize) -&gt; bool {
    // 该方法用于判定当前节点有无子节点
    self.left_child_idx(idx) &lt;= self.count
}

fn left_child_idx(&amp;self, idx: usize) -&gt; usize {
    idx * 2
}

fn right_child_idx(&amp;self, idx: usize) -&gt; usize {
    self.left_child_idx(idx) + 1
}

fn smallest_child_idx(&amp;self, idx: usize) -&gt; usize {
    //TODO
    // 目的：返回当前节点下索引应当最小的那个元素的索引（？？？）
    let lchild = self.left_child_idx(idx);
    let rchild = self.right_child_idx(idx);
    if rchild &gt; self.count || (self.comparator)( &amp;self.items[ lchild ], &amp;self.items[ rchild ] ) {
        // 根据堆的结构：最底层的节点靠左填充，其他层节点全部被填满，
        // 如果右边没有元素（表现为用于储存数据的栈 items 长度不够），则直接返回左节点索引
        // 对小顶堆来说，每个节点左侧的节点值必定比右侧的大，此时返回左节点索引
        lchild
    } else {
        rchild
    }
}</code></pre><p>  }</p>
<p>  impl<T> Heap<T><br>  where</T></T></p>
<pre><code>T: Default + Ord,</code></pre><p>  {</p>
<pre><code>/// Create a new MinHeap
pub fn new_min() -&gt; Self {
    Self::new(|a, b| a &lt; b)
}

/// Create a new MaxHeap
pub fn new_max() -&gt; Self {
    Self::new(|a, b| a &gt; b)
}</code></pre><p>  }</p>
<p>  impl<T> Iterator for Heap<T><br>  where</T></T></p>
<pre><code>T: Default,</code></pre><p>  {</p>
<pre><code>type Item = T;

fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
    //TODO
    if self.count == 0 {
        return None;
    }  
    // 如果堆中存在元素，就将其与堆顶元素交换后移出该元素
    let next_elem = self.items.swap_remove(1);
    self.count -= 1;
    self.heapify_from_top_to_bottom(1);
    Some(next_elem)
}</code></pre><p>  }</p>
</li>
</ul>
<h5 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h5><pre><code>use std::collections::VecDeque;</code></pre><ul>
<li><p>FIFO（最先入队的元素最先出队）</p>
</li>
<li><p>VecDeque 的 push_back, pop_front, pop_back（可在双端操作）</p>
</li>
<li><p>环形队列：在队列中访问索引时，对最大容量取模</p>
</li>
<li><p>栈和队列可以互相实现</p>
<pre><code>pub struct myStack&lt;T&gt;
{
    //TODO
    q1:Queue&lt;T&gt;,
    q2:Queue&lt;T&gt;
}
impl&lt;T&gt; myStack&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self {
            //TODO
            q1:Queue::&lt;T&gt;::new(),
            q2:Queue::&lt;T&gt;::new()
            // q2的后端用于入栈
            // q1的前端用于出栈
            // 两者形成 U 形结构
        }
    }
    pub fn push(&amp;mut self, elem: T) {
        self.q1.enqueue(elem);
        // 接下来需要将elem移动到栈顶
        while let Ok(val) = self.q2.dequeue() {
            self.q1.enqueue(val);
            // 经过该操作后，q2被清空。所有元素全部进入q1，elem在队头（q1）
        }
        // 交换以确保q1为空，为下一次入栈做准备
        std::mem::swap(&amp;mut self.q1, &amp;mut self.q2);
    }
    pub fn pop(&amp;mut self) -&gt; Result&lt;T, &amp;str&gt; {
        //TODO
        match self.q2.dequeue() {
            Ok(val) =&gt; Ok(val),
            Err(_) =&gt; Err(&quot;Stack is empty&quot;),
        }

    }
    pub fn is_empty(&amp;self) -&gt; bool {
        //TODO
        self.q1.elements.is_empty() &amp;&amp; self.q2.elements.is_empty()
    }
}</code></pre></li>
</ul>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><ul>
<li>自定义排序：Ord Trait</li>
</ul>
<h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h6><ul>
<li><p>将2/多个有序子数组进行排序<br>  先划分块（尽量等分），直到各个数组长度为1或2（长度尽量相等）</p>
</li>
<li><p>具体过程：<br>假设一开始是a0和b0比，比如说如果b0比较小，那么就把b0放进新数组，然后移动到b1（下标+=1），此时比较的是a0和b1，<br>以此类推，如果一个数组已经空了，就把另一个剩下的元素全部放进新数组，至此归并排序完成。</p>
</li>
</ul>
<h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><ul>
<li><p>选定基准数字，将小于其的放在左边，大于其的放在右边</p>
</li>
<li><p>Sort_unstable：value相同时不保证key原来的位置</p>
</li>
<li><p>目前最快的排序算法：Timsort（稳定），pdqsort（不稳定）<br>注：稳定是指是否必定保留排序前的相对顺序</p>
</li>
</ul>
<h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><ul>
<li>usize/isize：64为8 Bytes / 32为4 Bytes</li>
<li>Sized Trait：静态大小，可以在编译时确切知道数据有多大</li>
</ul>
<h5 id="链表：线性关系"><a href="#链表：线性关系" class="headerlink" title="链表：线性关系"></a>链表：线性关系</h5><ol>
<li><p>节点（Node）：<br>包含值和指向下一个节点的引用，在内存中的储存是分散的<br>插入节点时必须先连接再断开，否则很可能造成内存泄漏</p>
<p>struct Node<T> {<br>  val: T,<br>  next: Option&lt;NonNull&lt;Node<T>&gt;&gt;,<br>}</T></T></p>
</li>
<li><p>解引用裸指针在Rust中视为unsafe</p>
</li>
<li><p>建议不要用Rust写链表，可以直接用标准库的<code>std::collections::LinkedList</code>（是双向链表）</p>
</li>
</ol>
<hr>
<h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><pre><code>impl&lt;T&gt; BinarySearchTree&lt;T&gt;
where
    T: Ord,
{

    fn new() -&gt; Self {
        BinarySearchTree { root: None }
    }

    // Insert a value into the BST
    fn insert(&amp;mut self, value: T) {
        match &amp;mut self.root {
            None =&gt; {
                self.root = Some(Box::new(TreeNode::new(value)));
            },
            Some(root) =&gt; {
                // 如果root中已经有值，那就直接在root中insert，
                // 节点的insert已经实现了自动查找空的left和right
                root.insert(value);
            }
        }
    }

    // Search for a value in the BST
    fn search(&amp;self, value: T) -&gt; bool {
        //TODO
        match &amp;self.root {
            None =&gt; {
                false
            },
            Some(root) =&gt; {
                //同上，节点处已经实现了search
                root.search(value)
            }
        }
    }
}

impl&lt;T&gt; TreeNode&lt;T&gt;
where
    T: Ord,
{
    // Insert a node into the tree
    fn insert(&amp;mut self, value: T) {
        // 向二叉搜索树中插入元素
        match value.cmp(&amp;self.value) {
            // 其实就是比较大小，只是Ordering可以让不需要操作的情况正常存在
            // 比根节点小的放在左侧，大的放右侧，接下去的每一层都这样实现
            Ordering::Less =&gt; {
                match &amp;mut self.left {
                    // 左侧没有节点时创建储存value的新节点
                    // 否则在下一级递归调用insert，直到没有节点为止
                    Some(left) =&gt; left.insert(value),
                    None =&gt; {
                        self.left = Some(Box::new(TreeNode::new(value)));
                    },
                }
            },
            Ordering::Greater =&gt; {
                match &amp;mut self.right {
                    Some(right) =&gt; right.insert(value),
                    None =&gt; {
                        self.right = Some(Box::new(TreeNode::new(value)));
                    },
                }
            },
            Ordering::Equal =&gt; {
                // 二叉树中不需要重复的元素
            }
        }
    }

    fn search(&amp;self, value: T) -&gt; bool {
        // 搜索树中的指定元素
        match value.cmp(&amp;self.value) {
            Ordering::Less =&gt; match &amp;self.left {
                // 如果要找的值比当前节点小，说明符合条件的值在子树的左侧
                Some(ref left) =&gt; left.search(value),
                None =&gt; false,
            }
            Ordering::Greater =&gt; match &amp;self.right {
                Some(ref right) =&gt; right.search(value),
                None =&gt; false,
            }
            Ordering::Equal =&gt; true
        }
    }
}</code></pre><hr>
<h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><ul>
<li>图可分为有向图/无向图，连通图/非连通图（有孤立节点）</li>
</ul>
<p>BFS与DFS中的self类型（Graph）采用如下定义：</p>
<pre><code>struct Graph {
    adj: Vec&lt;Vec&lt;usize&gt;&gt;, 
}

impl Graph {
    fn new(n: usize) -&gt; Self {
        Graph {
            adj: vec![vec![]; n],
        }
    }

    fn add_edge(&amp;mut self, src: usize, dest: usize) {
        self.adj[src].push(dest);
        self.adj[dest].push(src); 
    }
}</code></pre><hr>
<h6 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h6><pre><code>fn bfs_with_return(&amp;self, start: usize) -&gt; Vec&lt;usize&gt; {

    // BFS 广度优先搜索
    // 要求：先访问初始节点所有没有访问过的邻节点，
    // 再按上述顺序依次访问下一级邻节点，
    // 直到所有节点被访问过

    // 初始化
    // visited 用于标记图中的元素是否已经被访问过
    // visit_order 相当于栈，按访问顺序（广度优先）返回元素
    // queue 为双端队列，是BFS实现的关键
    let mut visit_order = vec![];
    let mut visited = vec![false; self.adj.len()];
    let mut queue = VecDeque::new();

    // 初始化开始的节点 start，并作为访问的第一个元素，
    // 同时令其进入队列
    visited[start] = true;
    queue.push_back(start);
    visit_order.push(start);

    // 接下来在 queue 前端获取一个节点作为当前操作的节点
    while let Some(current_node) = queue.pop_front() {
        // 在本题的结构 Graph 中，
        // 节点通过边连接的其他节点以邻接数组方式存储，
        // （由于邻接矩阵唯一，因此广度优先遍历序列也唯一）
        for &amp;neighbor_node in &amp;self.adj[current_node] {
            // 然后遍历当前节点连接的所有节点
            // 看这些节点有没有被访问过
            if !visited[neighbor_node] {
                // 如果没有访问过，那就访问并修改访问标记
                visit_order.push(neighbor_node);
                queue.push_back(neighbor_node);
                visited[neighbor_node] = true;
            }
        }
        // 直到所有节点全部被访问，则pop_front将返回None，从而退出循环
    }

    visit_order
}</code></pre><hr>
<h6 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h6><pre><code>fn dfs_util(&amp;self, v: usize, visited: &amp;mut HashSet&lt;usize&gt;, visit_order: &amp;mut Vec&lt;usize&gt;) {
    // DFS 深度优先算法
    // 要求：从初始节点开始向远处访问，直到没有后继节点，
    // 然后回溯到最近的且连接未访问节点的节点
    // 重复上述过程

    // 本题限制只能用HashSet，已经访问的元素可以放进HashSet中
    // 以下因为应用递归，所以每一次调用该方法都会使得输入的 v 
    // 通过开头的两条语句设置为已经被访问，因此只需要往下套即可
    visit_order.push(v);
    visited.insert(v);

    for &amp;neighbor_node in &amp;self.adj[v] {
        if !visited.contains(&amp;neighbor_node) {
            self.dfs_util(neighbor_node, visited, visit_order)
        }
    }

    // 以下为 DFS 提供了一种非递归的实现
    #[cfg(feature = &quot;non-recursive&quot;)]
    {
        let mut stack = vec![];
        // 此时v即为上题的start
        stack.push(v);
        visit_order.push(v);
        visited.insert(v);
        while let Some(current_node) = stack.pop() {
            for &amp;neighbor_node in &amp;self.adj[current_node] {
                if !visited.contains(&amp;neighbor_node) {
                    stack.push(neighbor_node);
                    visit_order.push(neighbor_node);
                    visited.insert(neighbor_node);
                }
            }
        }
    }
}

// Perform a depth-first search on the graph, return the order of visited nodes
fn dfs(&amp;self, start: usize) -&gt; Vec&lt;usize&gt; {
    let mut visited = HashSet::new();
    let mut visit_order = Vec::new(); 
    self.dfs_util(start, &amp;mut visited, &amp;mut visit_order);
    visit_order
}</code></pre><hr>
<h4 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h4><p>第一阶段虽然说迟了一两天完成，不过好在对Rust的理解更加深刻了。希望能顺利完成第二阶段。不过，算法那部分还是比较薄弱，在第二阶段应该会有更多的实际应用来巩固，期待第二阶段！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-Jiawens/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-Jiawens/" class="post-title-link" itemprop="url">2024春季开源操作系统训练营第一阶段总结-Jiawens</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 22:01:13" itemprop="dateCreated datePublished" datetime="2024-04-29T22:01:13+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>去年秋季已经参加过一次训练营，完成了第一阶段和第二阶段的一半，因此这次训练营的第一阶段完成得很快，只用了两三天左右，感知到的最显著的变化是后面算法题的加入：</p>
<ul>
<li>单向链表的合并：涉及 <code>NonNull</code></li>
<li>双向链表的反序</li>
<li>排序算法的实现</li>
<li>二叉查找树的插入、搜索</li>
<li>图的广度及深度优先搜索算法实现</li>
<li>使用栈来检测括号是否配对</li>
<li>使用队列实现栈</li>
<li>实现二叉堆的插入、遍历</li>
<li>实现图</li>
</ul>
<p>在尝试解决这些问题的过程中，我查阅了许多资料，了解到了很多未曾听说过的概念，希望在第二阶段里也能跟上进度，一路披荆斩棘。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5Blog-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-%E5%88%98%E6%A1%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5Blog-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-%E5%88%98%E6%A1%90/" class="post-title-link" itemprop="url">2024春夏季开源操作系统训练营Blog-第一阶段-刘桐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 19:15:01" itemprop="dateCreated datePublished" datetime="2024-04-29T19:15:01+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024春夏季开源操作系统训练营第一阶段总结报告"><a href="#2024春夏季开源操作系统训练营第一阶段总结报告" class="headerlink" title="2024春夏季开源操作系统训练营第一阶段总结报告"></a>2024春夏季开源操作系统训练营第一阶段总结报告</h1><p>我对于操作系统有一定兴趣，在被同学推荐了这个OS训练营后，便按步骤开始了训练，现在我将第一阶段任务完成，汇总为这篇第一阶段总结报告。</p>
<p>虽然以前用过其他编程语言，但由于之前从未接触过rust语言，在完成前100道题时几乎每一道题都被编译器疯狂拷打，实属让我回想起刚接触编程时的痛苦回忆了，但在历经100题的磨练后，我才能发现rust如此设计都是有一定理由的（虽然不是全部的特性都能理解到），后10道算法题在有rust基础后其实实现是比较简单的，虽然还会被编译器拷打。</p>
<p>总而言之，第一阶段是基础，便于我们后续阶段的展开，希望后续我能继续保持这份热情，完成后续阶段。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-wooeason/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-wooeason/" class="post-title-link" itemprop="url">2024开源操作系统训练营第一阶段总结-wooeason</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 18:14:41" itemprop="dateCreated datePublished" datetime="2024-04-29T18:14:41+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>南京大学  吴奕胜</code></pre><h2 id="初见-Rust"><a href="#初见-Rust" class="headerlink" title="初见 Rust"></a>初见 Rust</h2><p>训练营第一阶段的学习过程中，我初步掌握了一门新的编程语言 <code>rust</code>。这是我第一次接触到一门比较”新鲜”的编程语言，相较于课堂上学习的 <code>C/C++</code>，这无疑是一门更加现代也更加复杂的编程语言，拥有不少闻所未闻的新概念，新特性，当然，这也导致 <code>rust</code> 的学习并没有那么轻松。</p>
<p>余观夫 <code>rust</code> 之难，在”所有权”之义。入门阶段所以为惑者，所有权占十之八九。</p>
<h2 id="我如何理解所有权？"><a href="#我如何理解所有权？" class="headerlink" title="我如何理解所有权？"></a>我如何理解所有权？</h2><p><code>C/C++</code> 中，一个变量名被映射到唯一一个内存中有实际含义的内容，反之不成立，我们可以使用指针很轻松地做到这一点。<code>rust</code> 所做的，正是保证这个”反之”的成立，将一块内容唯一对应于一个所有者，当所有者生命周期结束时，内存也被回收，这就保证了内存安全。</p>
<p>这样做的好处很明显，我们可以断言在满足所有权规则的前提下，内存的使用总是安全的；但是坏处也很明显，由于所有权机制的存在，不少在 <code>C/C++</code> 中可以很简单地实现的数据结构或者函数，在 <code>rust</code> 可能需要费一番功夫。</p>
<p>把我们所学的 <code>rust</code> 的新特性做个分类，大致也就是两类：</p>
<ul>
<li>为了实现特定功能而实现的特性</li>
<li>为了补充所有权机制的灵活性而存在的特性</li>
</ul>
<p>这一点很好地体现在智能指针、unsafe rust 之类的概念里，虽然这可能造成很多麻烦，但长期来看终究是利大于弊，<code>rust</code> 严格得看起来有些偏执的编译器在教会我们，一个优秀的程序员应该在编程的过程中注意什么，不是吗？</p>
<h2 id="令人耳目一新的枚举类型"><a href="#令人耳目一新的枚举类型" class="headerlink" title="令人耳目一新的枚举类型"></a>令人耳目一新的枚举类型</h2><p>初学 <code>rust</code>，其中的枚举类型让我赞叹不已。我之前只学习了 <code>C/C++</code> 语言，并且实际上只是学习了 <code>C</code> 和部分的 <code>C++</code>，<code>C</code> 中的枚举类型让程序员可以赋予某些值以现实的语义，但是并不好用。</p>
<p>在某个课程中，我们被要求实现一个游戏，游戏要求实现一个可以在地图中上下左右移动的人物，人物还需要可以执行诸如放炸弹之类的功能，部分动作可能有附带的属性。对于每一个动作，我们当然可以实现一个类，用以表示指令，但是这样做显然是不够简洁的，而用 <code>rust</code> 中的枚举功能，则可以优雅地实现。</p>
<p>再比如编译原理课程中，我们要实现类型检查，那么很自然的就是要实现一个结构体，用以表示各种类型。在这个结构体中，一个枚举类型用以表示当前类型，一个 <code>union</code> 中保存了该种类型附加的信息。即使使用到了 <code>union</code> 这样的关键字减少冗余的部分，也并不优雅，如果换成 <code>rust</code>，则可以用一个枚举类型实现类型系统，相当简洁明了，且优雅。</p>
<p>说到底，枚举类型好用还是其成员可以附带一些信息，这是一般的枚举做不到的，并且即使用结构体或类等实现了类似的功能，也远不如 <code>rust</code> 中枚举的实现优雅。</p>
<h2 id="模式匹配——优雅版本的-switch"><a href="#模式匹配——优雅版本的-switch" class="headerlink" title="模式匹配——优雅版本的 switch"></a>模式匹配——优雅版本的 switch</h2><p>说模式匹配是优雅版本的 <code>switch</code> 其实也有失偏颇，毕竟模式匹配的功能要比后者多多了，但更多的时候（至少在入门学习阶段），主要的用法还是这两种：</p>
<ul>
<li>用于解构元组、枚举等等</li>
<li>用于匹配特定的分支</li>
</ul>
<p>先来说说 <code>switch</code> 让我感觉最不舒服的地方，就是每个分支后面需要加上一个 <code>break</code>，在编译原理课程实验中，对语法树进行语义分析的过程中，时常需要根据产生式的类型实现不同的功能，由于某些稀奇古怪的原因，在写代码的时候会漏掉 <code>break</code>，这会导致比漏掉 <code>break</code> 的原因还稀奇古怪的结果。</p>
<p>相比之下，<code>rust</code> 中的模式匹配就避免了这个问题，同时也让逻辑一致的情况可以使用 <code>|</code> 合并到同一个分支，相较于 <code>switch</code> 中省略 <code>break</code> 的写法，可以消除很多潜在的问题。</p>
<h2 id="Option-lt-T-gt-和-Result-lt-T-U-gt"><a href="#Option-lt-T-gt-和-Result-lt-T-U-gt" class="headerlink" title="Option&lt;T&gt; 和 Result&lt;T, U&gt;"></a><code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, U&gt;</code></h2><p>在以往的编程经验中，我常常碰到需要表达”没有”的语义的情况，这时候可能会使用一个极大值或者 $0$ 等约定的值来表达。比如在我们在表示一个无权图中不存在的边时，可以使用 $0$ 来表示，但如果是一个有权图呢？根据我们要解决的问题不同，用 $0$ 或者极大值的情况都有，这就造成了一些潜在的麻烦。<code>Option&lt;T&gt;</code> 就很好地解决了这个问题。我知道，其实 <code>C++</code> 中已经有类似的功能了，但是就使用方便程度来讲，模式匹配加上 <code>Option&lt;T&gt;</code> 可以称得上是一个大杀器了。</p>
<p>而错误处理也很自然地解决了需要调用者自行处理问题的情况。以往的编程经验中，遇到需要传递错误信息的情况往往是通过某些约定的值，这些值被假设不在函数返回值的域中，通过这些值来告诉调用者出现了什么问题。<code>Result&lt;T, U&gt;</code> 显然是更好的实现方法。</p>
<p>说到底，我们想要表达的”空”的语义和”幺元”的语义并不总是一致的，又或者在函数返回的域中并没有不会用到的值，这就导致了”空”的语义不好表达，这个情况下，带值的枚举真香。</p>
<h2 id="我的收获"><a href="#我的收获" class="headerlink" title="我的收获"></a>我的收获</h2><p>上面提到的内容，大体上就是所有 <code>rust</code> 给我带来最印象深刻的地方了，当然，<code>rust</code> 还有不少精心设计的语言特性，不过由于我的编程经验不够，并不能直接说出这些特性好在哪，也并没有被这些特性震撼到，不过，我心里也埋下了这样一颗种子，如果在将来的学习工作中遇到了什么问题，再回过头来看如今所学，或许就能有更深刻的理解了。</p>
<p>这是我第一次学习一门”课外语言”，这样的体验是很有价值的，不管是对我学习使用这门语言本身来说，还是对我更深入理解以前学习过的语言来说。前面所写的几节内容都是我在学习比较 <code>rust</code> 过程中的切身体会，比学习优秀的设计更重要的是，我知道了一个没那么优秀的设计不好在哪里。</p>
<p>无论怎样，第一阶段的学习落下帷幕，接下来需要进入第二阶段攻克更加困难的主题，这是十分激动人心的。祈祷中……</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/2024s-rustlings-kyrinzzz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/2024s-rustlings-kyrinzzz/" class="post-title-link" itemprop="url">2024s-rustlings-kyrinzzz</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 17:39:16" itemprop="dateCreated datePublished" datetime="2024-04-29T17:39:16+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>have done the orginal rustlings test before, try again and also get something to learn</p>
<p>not only the tech an trick experience , but also the design philosophy behind the language.</p>
</blockquote>
<h1 id="RoadBlock"><a href="#RoadBlock" class="headerlink" title="RoadBlock"></a>RoadBlock</h1><h2 id="0-variales"><a href="#0-variales" class="headerlink" title="0 variales"></a>0 variales</h2><h3 id="varaibles5-rs"><a href="#varaibles5-rs" class="headerlink" title="varaibles5.rs"></a>varaibles5.rs</h3><ul>
<li><code>shadowing</code>: use <code>let</code></li>
</ul>
<h2 id="1-primitive-types"><a href="#1-primitive-types" class="headerlink" title="1 primitive_types"></a>1 primitive_types</h2><h3 id="primitive-types3-rs"><a href="#primitive-types3-rs" class="headerlink" title="primitive_types3.rs"></a>primitive_types3.rs</h3><ul>
<li>shorthand to create an arry: <code>[elment; times]</code></li>
</ul>
<h3 id="primitive-types4-rs"><a href="#primitive-types4-rs" class="headerlink" title="primitive_types4.rs"></a>primitive_types4.rs</h3><ul>
<li>Ownership, borrow, ref: &amp;</li>
<li>slice: [ .. ]</li>
</ul>
<h2 id="2-vector"><a href="#2-vector" class="headerlink" title="2 vector"></a>2 vector</h2><h3 id="vecs1-rs"><a href="#vecs1-rs" class="headerlink" title="vecs1.rs"></a>vecs1.rs</h3><ul>
<li>Vec::new()</li>
<li>macro: vec![elements… ]</li>
</ul>
<h3 id="vecs2-rs"><a href="#vecs2-rs" class="headerlink" title="vecs2.rs"></a>vecs2.rs</h3><ul>
<li>two ways<ul>
<li>direct: use <code>*</code></li>
<li>map:</li>
</ul>
</li>
<li>used to do in the <code>*</code> way, now prefer the <code>map</code> way</li>
</ul>
<h2 id="3-move-semantics"><a href="#3-move-semantics" class="headerlink" title="3 move_semantics"></a>3 move_semantics</h2><h3 id="move-semantics1-rs"><a href="#move-semantics1-rs" class="headerlink" title="move_semantics1.rs"></a>move_semantics1.rs</h3><ul>
<li>ownership, borrow: the new va. takes the ownership from the old, the old can not be accessible</li>
<li>mutable</li>
</ul>
<h3 id="move-semantics2-rs"><a href="#move-semantics2-rs" class="headerlink" title="move_semantics2.rs"></a>move_semantics2.rs</h3><ul>
<li>clone()</li>
<li>mutally borrow a reference to its argument: the next exec</li>
</ul>
<h3 id="move-semantics6-rs"><a href="#move-semantics6-rs" class="headerlink" title="move_semantics6.rs"></a>move_semantics6.rs</h3><ul>
<li>ownership</li>
</ul>
<h2 id="4-struct"><a href="#4-struct" class="headerlink" title="4 struct"></a>4 struct</h2><h3 id="structs3-rs"><a href="#structs3-rs" class="headerlink" title="structs3.rs"></a>structs3.rs</h3><ul>
<li><code>self</code></li>
</ul>
<h2 id="5-enums"><a href="#5-enums" class="headerlink" title="5 enums"></a>5 enums</h2><h3 id="enums3-rs"><a href="#enums3-rs" class="headerlink" title="enums3.rs"></a>enums3.rs</h3><ul>
<li><p><code>match</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> expr1 &#123;</span><br><span class="line">    type1 =&gt; &#123; expr2 &#125;,</span><br><span class="line">    type2(var) =&gt; &#123; expr3 &#125;,</span><br><span class="line">    _ =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>match allows us to compare a value to a series of patterns and execute the code based on the matching pattern</p>
<ul>
<li>A pattern can consist of literal quantities, variables, wildcards, and many other things</li>
<li>bind partial values of matching patterns</li>
</ul>
</li>
<li><p>the return value of one branch is the return value of the whole match expection</p>
</li>
</ul>
<h2 id="6-strings"><a href="#6-strings" class="headerlink" title="6 strings"></a>6 strings</h2><h3 id="string1-rs"><a href="#string1-rs" class="headerlink" title="string1.rs"></a>string1.rs</h3><ul>
<li>lifetime</li>
<li>to_string()</li>
<li>From</li>
</ul>
<h3 id="strings3-rs"><a href="#strings3-rs" class="headerlink" title="strings3.rs"></a>strings3.rs</h3><ul>
<li>RTFD(RTFM): Read the fxxxx document(mannul)</li>
<li>STFW</li>
</ul>
<h3 id="string4-rs"><a href="#string4-rs" class="headerlink" title="string4.rs"></a>string4.rs</h3><ul>
<li>std</li>
</ul>
<h2 id="7-modules"><a href="#7-modules" class="headerlink" title="7 modules"></a>7 modules</h2><h3 id="modules1-rs"><a href="#modules1-rs" class="headerlink" title="modules1.rs"></a>modules1.rs</h3><ul>
<li>private default</li>
<li><code>pub</code></li>
</ul>
<h3 id="modules2-rs"><a href="#modules2-rs" class="headerlink" title="modules2.rs"></a>modules2.rs</h3><ul>
<li><code>use xx as xxx</code></li>
</ul>
<h3 id="modules3-rs"><a href="#modules3-rs" class="headerlink" title="modules3.rs"></a>modules3.rs</h3><ul>
<li><code>use xx :: {yy, zz}</code></li>
</ul>
<h2 id="8-HashMap"><a href="#8-HashMap" class="headerlink" title="8 HashMap"></a>8 HashMap</h2><h3 id="hashmap1-rs"><a href="#hashmap1-rs" class="headerlink" title="hashmap1.rs"></a>hashmap1.rs</h3><ul>
<li>&lt;key, value&gt;</li>
<li>Hash::new()</li>
<li>insert()</li>
</ul>
<h3 id="hashmap2-rs"><a href="#hashmap2-rs" class="headerlink" title="hashmap2.rs"></a>hashmap2.rs</h3><ul>
<li><code>entry()</code> and <code>or_insert()</code></li>
</ul>
<h3 id="hashmap3-rs"><a href="#hashmap3-rs" class="headerlink" title="hashmap3.rs"></a>hashmap3.rs</h3><ul>
<li>well, read the answer I wrote last time</li>
<li>have ideas, but stuck on &amp;mut T</li>
</ul>
<h2 id="quiz2-rs"><a href="#quiz2-rs" class="headerlink" title="quiz2.rs"></a>quiz2.rs</h2><ul>
<li>stuck on modules and strings for a while</li>
</ul>
<h2 id="9-Options"><a href="#9-Options" class="headerlink" title="9 Options"></a>9 Options</h2><h3 id="options1-rs"><a href="#options1-rs" class="headerlink" title="options1.rs"></a>options1.rs</h3><ul>
<li>Option<T>, Some(), None</T></li>
<li>unwrap() or match</li>
<li>read the answer of match way</li>
</ul>
<h3 id="options2-rs"><a href="#options2-rs" class="headerlink" title="options2.rs"></a>options2.rs</h3><ul>
<li><code>if let</code> statement and <code>while let</code> statement</li>
<li>read the answer: think in the reverse way, .unwrap() – Some()</li>
</ul>
<h3 id="options3-rs"><a href="#options3-rs" class="headerlink" title="options3.rs"></a>options3.rs</h3><ul>
<li><blockquote>
<p>Bind by reference during pattern matching.<br>ref annotates pattern bindings to make them borrow rather than move.<br>It is not a part of the pattern as far as matching is concerned: it does not affect whether a value is matched,<br>only how it is matched.</p>
</blockquote>
</li>
</ul>
<h2 id="10-error-handling"><a href="#10-error-handling" class="headerlink" title="10 error_handling"></a>10 error_handling</h2><h3 id="error1-rs"><a href="#error1-rs" class="headerlink" title="error1.rs"></a>error1.rs</h3><ul>
<li>Result&lt;T, E&gt;<ul>
<li>Ok(T)</li>
<li>Err(E)</li>
</ul>
</li>
</ul>
<h3 id="error2-rs"><a href="#error2-rs" class="headerlink" title="error2.rs"></a>error2.rs</h3><ul>
<li><p>? – match</p>
</li>
<li><blockquote>
<p>If the value of Result is OK, the expression will return the value in OK and the program will continue.<br>If the value is Err, Err is used as the return value for the entire function,<br>as if the return keyword were used, so that the error value is propagated to the caller.</p>
</blockquote>
</li>
</ul>
<h3 id="error3-rs"><a href="#error3-rs" class="headerlink" title="error3.rs"></a>error3.rs</h3><ul>
<li>the ? is valid only in function that -&gt; Result&lt;T, E&gt;</li>
<li>in main function, use <code>()</code> to present nothing needed</li>
</ul>
<h3 id="error4-rs"><a href="#error4-rs" class="headerlink" title="error4.rs"></a>error4.rs</h3><ul>
<li>kind of read the answer</li>
</ul>
<h3 id="error5-rs"><a href="#error5-rs" class="headerlink" title="error5.rs"></a>error5.rs</h3><ul>
<li>trait</li>
<li>Box&lt;T&gt;: A pointer type that uniquely owns a heap allocation of type T.</li>
<li>dyn</li>
</ul>
<h3 id="error6-rs"><a href="#error6-rs" class="headerlink" title="error6.rs"></a>error6.rs</h3><ul>
<li>stuck, read the answer; .map_err()</li>
</ul>
<h2 id="11-generics"><a href="#11-generics" class="headerlink" title="11 generics"></a>11 generics</h2><h3 id="generics2-rs"><a href="#generics2-rs" class="headerlink" title="generics2.rs"></a>generics2.rs</h3><ul>
<li><code>&lt;T&gt;</code><ul>
<li>functions: fn func_name<T>(arg: T) -&gt; T</T></li>
<li>structs: struct StructName<T></T></li>
<li>traits: trait TraitName<T></T></li>
<li>impl<T> StructName<T> { … }</T></T></li>
</ul>
</li>
</ul>
<h2 id="12-traits"><a href="#12-traits" class="headerlink" title="12 traits"></a>12 traits</h2><h3 id="traits1-rs"><a href="#traits1-rs" class="headerlink" title="traits1.rs"></a>traits1.rs</h3><ul>
<li>trait: A trait defines a set of behaviors that can be shared, and once the train is implemented,</li>
<li>you can use that set of behaviors.<ul>
<li>similar to interface</li>
</ul>
</li>
<li>trait trait_name { … }<ul>
<li>impl trait_name for StructName { … }</li>
</ul>
</li>
</ul>
<h3 id="traits4-rs"><a href="#traits4-rs" class="headerlink" title="traits4.rs"></a>traits4.rs</h3><ul>
<li>traits as parameters</li>
</ul>
<h3 id="traits5-rs"><a href="#traits5-rs" class="headerlink" title="traits5.rs"></a>traits5.rs</h3><ul>
<li>multiple traits: impl Trait1 + Trait2 + Trait3 for StructName { … }</li>
</ul>
<h2 id="quiz3-rs"><a href="#quiz3-rs" class="headerlink" title="quiz3.rs"></a>quiz3.rs</h2><ul>
<li>stuck, but according to the compiler info, fix it</li>
</ul>
<h2 id="13-lifetimes"><a href="#13-lifetimes" class="headerlink" title="13 lifetimes"></a>13 lifetimes</h2><h3 id="lifetimes1-rs"><a href="#lifetimes1-rs" class="headerlink" title="lifetimes1.rs"></a>lifetimes1.rs</h3><ul>
<li>lifetime: When returning a reference from a function,the lifetime parameter for the return type needs</li>
<li>to match the lifetime parameter for one of the parameters<ul>
<li>follow the compiler</li>
<li>‘a: fn funcName&lt;’a&gt;(x : ‘a i32) -&gt; &amp;’a str</li>
</ul>
</li>
</ul>
<h3 id="lifetimes2-rs"><a href="#lifetimes2-rs" class="headerlink" title="lifetimes2.rs"></a>lifetimes2.rs</h3><ul>
<li>same mark, same lifetime</li>
<li>paths:<ul>
<li>make y live longer</li>
<li>make println! inner</li>
</ul>
</li>
</ul>
<h3 id="lifetimes3-rs"><a href="#lifetimes3-rs" class="headerlink" title="lifetimes3.rs"></a>lifetimes3.rs</h3><ul>
<li>lifetime in struct: struct StructName&lt;&#39;a&gt; { field: &#39;a type1 }</li>
</ul>
<h2 id="14-tests"><a href="#14-tests" class="headerlink" title="14 tests"></a>14 tests</h2><h3 id="tests1-rs"><a href="#tests1-rs" class="headerlink" title="tests1.rs"></a>tests1.rs</h3><ul>
<li>assert!(condition, “{}”, message)</li>
</ul>
<h3 id="tests4-rs"><a href="#tests4-rs" class="headerlink" title="tests4.rs"></a>tests4.rs</h3><ul>
<li>attribute <code>should_panic</code></li>
</ul>
<h2 id="15-iterators"><a href="#15-iterators" class="headerlink" title="15 iterators"></a>15 iterators</h2><h3 id="iterators1-rs"><a href="#iterators1-rs" class="headerlink" title="iterators1.rs"></a>iterators1.rs</h3><ul>
<li>iter(), next ()</li>
</ul>
<h3 id="iterators3-rs"><a href="#iterators3-rs" class="headerlink" title="iterators3.rs"></a>iterators3.rs</h3><ul>
<li><code>.map()</code>, <code>collect()</code></li>
</ul>
<h3 id="iterator4-rs"><a href="#iterator4-rs" class="headerlink" title="iterator4.rs"></a>iterator4.rs</h3><ul>
<li><p><code>into_iter()</code> and <code>fold()</code>: e.g. iterator.fold(initial_value, |acc, x | { acc + x })</p>
</li>
<li><blockquote>
<p>The fold() method is similar to the iterator’s forEach() method, but it returns a value.</p>
</blockquote>
</li>
<li><blockquote>
<p>Folds every element into an accumulator by applying an operation, returning the final result.</p>
</blockquote>
<blockquote>
<p>fold() takes two arguments: an initial value, and a closure with two arguments: an ‘accumulator’, and an element.<br>The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<blockquote>
<p>The initial value is the value the accumulator will have on the first call.</p>
</blockquote>
<blockquote>
<p>After applying this closure to every element of the iterator, fold() returns the accumulator.</p>
</blockquote>
<blockquote>
<p>This operation is sometimes called ‘reduce’ or ‘inject’.</p>
</blockquote>
</li>
</ul>
<blockquote>
</blockquote>
<h3 id="iterators5-rs"><a href="#iterators5-rs" class="headerlink" title="iterators5.rs"></a>iterators5.rs</h3><ul>
<li>more familiar with the <code>iter()</code>, <code>map()</code> and <code>fold()</code></li>
</ul>
<h2 id="16-smart-pointers"><a href="#16-smart-pointers" class="headerlink" title="16 smart_pointers"></a>16 smart_pointers</h2><h3 id="box1-rs"><a href="#box1-rs" class="headerlink" title="box1.rs"></a>box1.rs</h3><ul>
<li>compile time</li>
<li><code>Box</code>: a smart pointer used to store data on the heap, which also allows us to wrap a recursive type.</li>
</ul>
<h3 id="rc1-rs"><a href="#rc1-rs" class="headerlink" title="rc1.rs"></a>rc1.rs</h3><ul>
<li><code>Rc&lt;T&gt;</code>: used for multiple owners</li>
<li><code>clone()</code>, <code>Rc::clone()</code>  and <code>drop()</code></li>
</ul>
<h3 id="arc1-rs"><a href="#arc1-rs" class="headerlink" title="arc1.rs"></a>arc1.rs</h3><ul>
<li>Arc<T>: used for multiple owners, but it is thread-safe</T></li>
<li><code>clone()</code></li>
</ul>
<h3 id="cow1-rs"><a href="#cow1-rs" class="headerlink" title="cow1.rs"></a>cow1.rs</h3><ul>
<li>Cow(Copy-On-Write type): It can enclose and provide immutable access to borrowed data,<br><br>and clone the data lazily when mutation or ownership is required.<br><br>The type is designed to work with general borrowed data via the Borrow trait.</li>
<li><code>Cow::Owned()</code> and <code>Cow::Borrowed()</code></li>
<li>well, this is a little confusing, got stuck; solved by simulating the code above TODOs and the answer wrote before</li>
</ul>
<h2 id="17-threads"><a href="#17-threads" class="headerlink" title="17 threads"></a>17 threads</h2><h3 id="threads1-rs"><a href="#threads1-rs" class="headerlink" title="threads1.rs"></a>threads1.rs</h3><ul>
<li><code>thread::spawn()</code>: create a new thread and run the closure in it; -&gt; JoinHandle<T></T></li>
<li><code>move</code>: move the value into the closure</li>
<li><code>join()</code>: wait for the thread to finish, return the result</li>
</ul>
<h3 id="threads2-rs"><a href="#threads2-rs" class="headerlink" title="threads2.rs"></a>threads2.rs</h3><ul>
<li><code>Mutex&lt;T&gt;</code>: A mutex is a mutual exclusion primitive that can be used to protect shared data<br><ul>
<li><code>lock()</code> : -&gt; LockResult&lt;MutexGuard&lt;’_, T&gt;&gt;</li>
</ul>
</li>
<li><code>Arc&lt;T&gt;</code>:</li>
</ul>
<h3 id="threads3-rs"><a href="#threads3-rs" class="headerlink" title="threads3.rs"></a>threads3.rs</h3><ul>
<li><code>std::sync::mpsc</code>: multi-producer, single-consumer channel, sending end and receiving end</li>
<li><code>clone()</code></li>
<li>well, I did get stuck on this one last time, this time go smoothly.</li>
</ul>
<h2 id="18-macros"><a href="#18-macros" class="headerlink" title="18 macros"></a>18 macros</h2><p>The term <code>macro</code> refers to a family of features in Rust:</p>
<ul>
<li>declarative macros with <code>macro_rules!</code> and</li>
<li>three kinds of <code>procedural</code> macros:<ul>
<li>Custom <code>#\[derive\]</code> macros that specify code added with the <code>derive</code> attribute used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>
</li>
</ul>
<h3 id="macros2-rs"><a href="#macros2-rs" class="headerlink" title="macros2.rs"></a>macros2.rs</h3><ul>
<li>the order of definition and use matters</li>
</ul>
<h3 id="macros3-rs"><a href="#macros3-rs" class="headerlink" title="macros3.rs"></a>macros3.rs</h3><ul>
<li><code>[macro_use]</code></li>
</ul>
<h3 id="macros4-rs"><a href="#macros4-rs" class="headerlink" title="macros4.rs"></a>macros4.rs</h3><ul>
<li>use <code>;</code> to separate the macro arms</li>
</ul>
<h2 id="19-clippy"><a href="#19-clippy" class="headerlink" title="19 clippy"></a>19 clippy</h2><h3 id="clippy1-rs"><a href="#clippy1-rs" class="headerlink" title="clippy1.rs"></a>clippy1.rs</h3><ul>
<li><code>constant s</code></li>
</ul>
<h3 id="clippy2-rs"><a href="#clippy2-rs" class="headerlink" title="clippy2.rs"></a>clippy2.rs</h3><ul>
<li><code>let Some(x) = option</code></li>
<li>there was a bug, solved</li>
</ul>
<h3 id="clippy3-rs"><a href="#clippy3-rs" class="headerlink" title="clippy3.rs"></a>clippy3.rs</h3><ul>
<li><code>std::mem::swap</code>, <code>vec.clear()</code></li>
</ul>
<h2 id="20-conversions"><a href="#20-conversions" class="headerlink" title="20 conversions"></a>20 conversions</h2><h3 id="using-as-rs"><a href="#using-as-rs" class="headerlink" title="using_as.rs"></a>using_as.rs</h3><ul>
<li><code>as</code> operator: type casting and renaming imports</li>
</ul>
<h3 id="from-into-rs"><a href="#from-into-rs" class="headerlink" title="from_into.rs"></a>from_into.rs</h3><ul>
<li>The From trait is used for value-to-value conversions. If From is implemented correctly for a type,<br><br>the Into trait should work conversely.</li>
<li>copilot this time; I dit get stuck on this last time for a while, solved eventually</li>
<li><code>impl From\&lt;T\&gt; for U</code></li>
</ul>
<h3 id="from-str-rs"><a href="#from-str-rs" class="headerlink" title="from_str.rs"></a>from_str.rs</h3><ul>
<li>copilot this time; did get stuck on this last time for a while, solved eventually</li>
<li><code>iterators</code>: <code>next()</code>, <code>last()</code></li>
<li><code>parse::\&lt;T\&gt;()</code></li>
</ul>
<h3 id="try-from-into-rs"><a href="#try-from-into-rs" class="headerlink" title="try_from_into.rs"></a>try_from_into.rs</h3><ul>
<li><code>TryFrom</code> and <code>TryInto</code> traits are provided by the standard library to support this conversion.<ul>
<li><code>impl TryFrom\&lt;From\&gt; for To</code> and  <code>-&gt; Result\&lt;T, E\&gt;</code></li>
</ul>
</li>
<li><code>tuple</code> and <code>array</code> will be checked at compile time, <code>struct</code> will be checked at runtime,</li>
<li><code>slice</code> implementation needs to check the slice length,</li>
</ul>
<h3 id="as-ref-rs"><a href="#as-ref-rs" class="headerlink" title="as_ref.rs"></a>as_ref.rs</h3><ul>
<li><code>trait bound</code>: <code>AsRef\&lt;T\&gt;</code> and <code>AsMut\&lt;T\&gt;</code></li>
</ul>
<h2 id="21-tests-II"><a href="#21-tests-II" class="headerlink" title="21 tests-II"></a>21 tests-II</h2><h3 id="tests5-rs"><a href="#tests5-rs" class="headerlink" title="tests5.rs"></a>tests5.rs</h3><ul>
<li><code>unsafe</code>: <code>item declaration</code> and <code>code block</code></li>
<li>The <code>unsafe</code> keyword has two uses:<ul>
<li>to declare the existence of contracts the compiler can’t check (unsafe fn and unsafe trait),</li>
<li>and to declare that a programmer has checked that these contracts have been upheld (unsafe {} and unsafe impl, <br><br>but also unsafe fn – see below).</li>
</ul>
</li>
<li>confusing</li>
</ul>
<h3 id="tests6-rs"><a href="#tests6-rs" class="headerlink" title="tests6.rs"></a>tests6.rs</h3><ul>
<li><code>Box</code>: <code>Box::into_raw()</code> and <code>Box::from_raw()</code></li>
</ul>
<h3 id="tests7-rs-build-rs-tests8-rs"><a href="#tests7-rs-build-rs-tests8-rs" class="headerlink" title="tests7.rs || build.rs || tests8.rs"></a>tests7.rs || build.rs || tests8.rs</h3><ul>
<li><code>build.rs</code><ul>
<li>Building a bundled C library.</li>
<li>Finding a C library on the host system.</li>
<li>Generating a Rust module from a specification.</li>
<li>Performing any platform-specific configuration needed for the crate.</li>
</ul>
</li>
</ul>
<h3 id="test9-rs"><a href="#test9-rs" class="headerlink" title="test9.rs"></a>test9.rs</h3><ul>
<li>ABI</li>
<li>extern <ul>
<li>“C” for C-like ABI, “stdcall” for Windows ABI, “C++” for C++ ABI, <br><br>“Rust” for Rust ABI, “system” for system ABI”</li>
<li>#[linkname = “..”]</li>
<li>export symbol to the linking environment, e.g. <code>extern &quot;C&quot; fn funcName()</code></li>
</ul>
</li>
<li>mangle symbol name: `#[no_mangle]</li>
<li>confused, copilot; the attributes should be applied properly</li>
</ul>
<h2 id="22-algorithm"><a href="#22-algorithm" class="headerlink" title="22 algorithm"></a>22 algorithm</h2><h3 id="algorithm1-rs-–-merge-linked-list"><a href="#algorithm1-rs-–-merge-linked-list" class="headerlink" title="algorithm1.rs – merge linked list"></a>algorithm1.rs – merge linked list</h3><ul>
<li>got stuck for a long time, not the fault of not understanding linked list, but those features</li>
<li><code>impl&lt;T: PartialOrd + Clone&gt;</code>: a trait bound that specifies requirements for the type T.</li>
</ul>
<h3 id="algorithm2-rs-–-reverse-double-linked-list"><a href="#algorithm2-rs-–-reverse-double-linked-list" class="headerlink" title="algorithm2.rs – reverse double linked list"></a>algorithm2.rs – reverse double linked list</h3><ul>
<li>a little confused, but solved</li>
</ul>
<h3 id="algorithm3-rs-–-sort-bubble-sort"><a href="#algorithm3-rs-–-sort-bubble-sort" class="headerlink" title="algorithm3.rs – sort, bubble sort"></a>algorithm3.rs – sort, bubble sort</h3><ul>
<li>copilot for <code>the trait Ord</code></li>
</ul>
<h3 id="algorithm4-rs-–-bst-the-binary-search-tree"><a href="#algorithm4-rs-–-bst-the-binary-search-tree" class="headerlink" title="algorithm4.rs – bst, the binary search tree"></a>algorithm4.rs – bst, the binary search tree</h3><ul>
<li>glad it’s not avl tree</li>
<li>recursion</li>
</ul>
<h3 id="algorithm5-rs-–-bfs-adjacency-matrix"><a href="#algorithm5-rs-–-bfs-adjacency-matrix" class="headerlink" title="algorithm5.rs – bfs, adjacency matrix"></a>algorithm5.rs – bfs, adjacency matrix</h3><ul>
<li><code>VecDeque</code>, <code>bfs</code>, <code>visited</code>,  <code>Adjacency matrix</code></li>
<li>familiar with this one, with <code>VecDeque</code>, solved quickly</li>
</ul>
<h3 id="algorithm6-rs-–-dfs-adjacency-matrix"><a href="#algorithm6-rs-–-dfs-adjacency-matrix" class="headerlink" title="algorithm6.rs – dfs, adjacency matrix"></a>algorithm6.rs – dfs, adjacency matrix</h3><ul>
<li>smooth</li>
</ul>
<h3 id="algorithm7-rs-–-stack-vec"><a href="#algorithm7-rs-–-stack-vec" class="headerlink" title="algorithm7.rs – stack, vec"></a>algorithm7.rs – stack, vec</h3><ul>
<li>copilot when the match arm</li>
</ul>
<h3 id="algorithm8-rs-–-impl-stack-with-queues"><a href="#algorithm8-rs-–-impl-stack-with-queues" class="headerlink" title="algorithm8.rs – impl stack with queues"></a>algorithm8.rs – impl stack with queues</h3><ul>
<li>with one queue<ul>
<li>push: just push </li>
<li>pop: pop the pre and push them again, loop queue.size - 1 times</li>
</ul>
</li>
<li>with two queues – this way this time<ul>
<li>make sure that the new element is in the front of the queue, and one queue is empty</li>
<li>use one empty queue q1 to store the new, move the rest of elements from the other queue q2 to the cur queue q1, </li>
<li>then use the other queue q2 to store the next new element, move the rest of elements from the cur queue q1 to the other queue q2,</li>
</ul>
</li>
</ul>
<h3 id="algorithm9-rs-–-binary-heap"><a href="#algorithm9-rs-–-binary-heap" class="headerlink" title="algorithm9.rs – binary heap"></a>algorithm9.rs – binary heap</h3><ul>
<li>although aware of that heap keeps the smallest or the biggest element at the top, often used in the k-th min or max problem</li>
<li>not so familiar with this one, stfw, gpt, copilot</li>
<li>use vec to implement heap: the parent’s index <code>(i - 1) / 2</code>, the left child’s index <code>2 * i + 1</code>, the right child’s index <code>2 * i + 2</code>, start from 0</li>
<li><code>add</code>: after <code>push</code>, use <code>heapify_up</code></li>
<li><code>heapify_up</code>: continuous swap until the parent is smaller(or greater, depending on the heap type) than the child</li>
<li><code>smallest_child_idx</code>: the smallest child idx</li>
<li><code>next</code>: iterate to get the smallest element</li>
</ul>
<h3 id="algorithm10-rs-–-graph-adjacency-table-undirected-graph"><a href="#algorithm10-rs-–-graph-adjacency-table-undirected-graph" class="headerlink" title="algorithm10.rs – graph: adjacency table, undirected graph"></a>algorithm10.rs – graph: adjacency table, undirected graph</h3><ul>
<li>copilot a little for programming quickly, like finding elem in hashmap, trying to insert new elem into hashmap</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/rCore-%E4%B8%89%E5%91%A8rust%E6%8A%98%E7%A3%A8%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/rCore-%E4%B8%89%E5%91%A8rust%E6%8A%98%E7%A3%A8%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">rCore 三周rust折磨记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 16:33:24" itemprop="dateCreated datePublished" datetime="2024-04-29T16:33:24+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rCore-三周rust折磨记录"><a href="#rCore-三周rust折磨记录" class="headerlink" title="rCore 三周rust折磨记录"></a>rCore 三周rust折磨记录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人是大三的菜鸡一枚, 因为突然一时兴起,想好好学习下操作系统,又同时看到了这个课程,于是跟着课程一起开始学习了rust.</p>
<h2 id="rustlins-通关记录"><a href="#rustlins-通关记录" class="headerlink" title="rustlins 通关记录"></a>rustlins 通关记录</h2><p>说起来也比较惭愧, 学了三周的rust,我对一些东西感觉还是模模糊糊,没有掌握清楚,这可能跟我没有按时听课有关系,忙着找实习笔试和面试(悲).<br>前30道题比较入门, 我是跟着进度来的, 到前70道题也都还好. 结果70-110 真的把我绕晕了, 又是去官网看英文资料, 又是去查别人的博客,还有问群里的大佬.<br>我们3群给我的感觉还是很温馨的,很多愚蠢的问题,大佬们都细心的解答.</p>
<p>说到rust, 感触最深的就是它的安全性, 可变引用只能有一个,这条规则把我恶心了好久 呜呜呜. 还有所有权的转移问题. 要时时刻刻注意用clone或者borrow_mut来避免所有权转移.<br>其实刚开始学习的时候, 我觉得也没什么吗, 不就是cpp里的unique_point吗, 我也学过, 但实际写起来就是容易忘记. 还有各种生命周期的问题, 以及范型要注意trait的限制, 真是太安全了. 无奈的转向了 unsafe 大法().</p>
<p>总的来说, 我还是很喜欢rust的, 但还是有很多东西需要学习, 希望能在后续的学习中, 能有所进步. 期待第二阶段的学习!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-LinfangWu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-LinfangWu/" class="post-title-link" itemprop="url">2024春夏季开源操作系统训练营第一阶段总结报告-LinfangWu</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 16:02:16" itemprop="dateCreated datePublished" datetime="2024-04-29T16:02:16+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先非常感谢陈渝老师和向勇老师提供开源操作系统训练营这个平台，在去年机缘巧合下知道了这个训练营，但当时只是报名了，作业都没领取。这次是第一次正式参加，算是一次挑战吧，push自己走出舒适区。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装rustlings之前要安装gcc编译器，用包管理器也安装不了，试过用aptitude解决依赖问题，最后是更新了系统软件包就装好了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://rustwiki.org/zh-CN/book/title-page.html" target="_blank" rel="noopener">Rust 程序设计语言</a></p>
<p><a href="https://rustwiki.org/zh-CN/rust-by-example/" target="_blank" rel="noopener">通过例子学 Rust</a></p>
<p><a href="https://course.rs/about-book.html" target="_blank" rel="noopener">Rust语言圣经(Rust Course)</a></p>
<p><a href="https://www.progit.cn/" target="_blank" rel="noopener">Pro Git 中文版 (第二版)</a></p>
<h2 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h2><p>Rust作为一种系统级编程语言，具有内存安全性、并发性和高性能的特点。在学习过程中，通过 Rustlings 这个练习题库，对 Rust 语言有了更深入的了解和掌握。</p>
<p>Rustlings 提供了一系列简单到复杂的练习题目，涵盖了 Rust 语言的各个方面，从基础的语法到高级的模式匹配、并发等。同时，Rustlings 的反馈机制非常及时和友好。这种及时的反馈可以快速纠正错误。前面100道题主要是熟悉语法，做一些小的改动就可以过了。后面10道题是算法，因为之前学习对算法掌握的不够扎实，花了几天时间去重新学习了一下。</p>
<p>虽然做完了rustlings的题目，但是感觉这只是入门，如果没有gpt估计要做好久。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/rustlings-unravel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/rustlings-unravel/" class="post-title-link" itemprop="url">rustlings-unravel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 11:31:35" itemprop="dateCreated datePublished" datetime="2024-04-29T11:31:35+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="艰难的开头"><a href="#艰难的开头" class="headerlink" title="艰难的开头"></a>艰难的开头</h2><p>第一次参加训练营对rust也是零基础，刚开始还有点担心，而且开放第一天立马就有好几个大佬交了直接满分通过，真给我吓到了。</p>
<p>不过潜下心来认真做还是很快进入了高强度学习的状态。</p>
<p>每道题目给的提示和对应的rust文档都很有帮助，前面题目难度不算很大，主要是有一些rust的规则或者说特性有点难以理解，生命周期和特性确实是好一番折腾，到现在也不敢说弄明白了。那部分题边做边看着报错改稀里糊涂的就做过去了。</p>
<p>我做完rustlings也算比较早的，不过blog拖了这么久，一个是考试，一个是有些简单的规则感觉没必要特意写在笔记里，而复杂的例如生命周期和特性这部分还真没完全搞懂。还是得慢慢学慢慢练，rust基础还是差得远。</p>
<p>最后这几天还连续发高烧人差点烧傻了。</p>
<h3 id="二阶段能做完一半就算胜利！"><a href="#二阶段能做完一半就算胜利！" class="headerlink" title="二阶段能做完一半就算胜利！"></a>二阶段能做完一半就算胜利！</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/29/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%99%88%E6%80%9D%E9%B9%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/29/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%99%88%E6%80%9D%E9%B9%8F/" class="post-title-link" itemprop="url">2024春夏季开源操作系统训练营第一阶段总结报告-陈思鹏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-29 00:51:03" itemprop="dateCreated datePublished" datetime="2024-04-29T00:51:03+00:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>Rust 的生命周期（lifetime）是一种编译时检查机制，它用来确保引用的有效性，防止悬垂指针和数据竞争等安全问题。生命周期在 Rust 中的作用非常关键，主要体现在以下几个方面：</p>
<p>生命周期注解：Rust 使用生命周期注解来标记引用的有效期。最常见的生命周期注解是 ‘a，这是一种显式标注，用来表明相关的引用必须至少与 ‘a 生存期一样长。<br>函数与方法中的生命周期：当函数或方法返回引用或使用引用作为参数时，必须显式指定生命周期。Rust 编译器（通过借用检查器）使用这些注解来确保数据的有效性。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，’a 指明 x 和 y 的引用以及返回值的引用必须拥有相同的生命周期。<br>结构体中的生命周期：当结构体中含有引用时，也需要使用生命周期注解来确保引用不会在结构体实例存在时失效。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Important</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体表明 part 的生命周期 ‘a 必须至少与结构体 Important 的实例一样长。<br>生命周期省略规则（Lifetime Elision Rules）：Rust 有一套自动推导生命周期的规则，这可以在许多简单情况下省略显式的生命周期注解。例如，单个输入生命周期可以被自动推导，函数返回的引用通常被认为与某个输入引用具有相同的生命周期。<br>生命周期与泛型的结合：在泛型类型或函数中使用生命周期参数，可以使得类型或函数更加灵活与安全。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span></span>&lt;<span class="symbol">'a</span>, T&gt; &#123;</span><br><span class="line">    value: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 T 是泛型类型，而 ‘a 是生命周期参数，表示 value 的引用至少与 Wrapper 实例持续相同的时间。<br>总的来说，Rust 的生命周期特性是为了在编译时进行严格的内存安全检查，通过这种方式帮助开发者写出更安全的代码，避免运行时错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很久之前就学会rust并用于工作，所以这次训练营的rust部分对我来说是比较简单的。<br>期待这次训练营的实操，Rust 会给我一个怎样的编程体验。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-Sober7135/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-Sober7135/" class="post-title-link" itemprop="url">2024开源操作系统训练营第一阶段总结-Sober7135</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-28 23:59:01" itemprop="dateCreated datePublished" datetime="2024-04-28T23:59:01+00:00">2024-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-08 10:05:17" itemprop="dateModified" datetime="2024-11-08T10:05:17+00:00">2024-11-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前写过一遍<code>rustlings</code>, 所以这次前 100 题刷得比较快. 虽然说之前写过, 但是这次基本没有之前的 repo, 从头自己写了一遍, 还是学到了很多很多, 对<code>Rust</code>的各种特性也更加熟悉了.</p>
<p>个人觉得后面助教加的<code>algorithm</code>还是很有意思的. 大部分的<code>Rust</code>教程只有语法还有特性, 很少有关于如何写算法的. 特别是关于<code>unsafe</code>的使用, 大家好像都对于<code>unsafe</code>如临大敌, 都不敢用. 事实上, 要写出性能好的底层代码, 感觉<code>unsafe</code>还是必不可少的. 后面的图论也挺有趣的, 让同学们在写算法的同时, 熟悉了<code>Rust</code>的各种容器的使用. 就是希望提示能够再清楚明确一些吧.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/blog/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/43/">43</a><a class="extend next" rel="next" href="/blog/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
