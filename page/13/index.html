<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/13/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/13/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">756</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">670</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/13/2025%E6%98%A5%E5%A4%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-heirish/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/13/2025%E6%98%A5%E5%A4%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-heirish/" class="post-title-link" itemprop="url">2025春夏操作系统训练营第一阶段总结-heirish</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-13 23:43:47" itemprop="dateCreated datePublished" datetime="2025-04-13T23:43:47+00:00">2025-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Rust:主要通过训练营的课程以及Rust by Example系列进行学习。有一些编程基础，相对较容易通过。</li>
<li>RISC-V基础：主要通过B站视频进行学习, 了解了一些基本的概念。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/13/%E4%BA%8C%E9%98%B6%E6%AE%B5rCore%E6%80%BB%E7%BB%93-%E6%8A%98%E9%B8%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/13/%E4%BA%8C%E9%98%B6%E6%AE%B5rCore%E6%80%BB%E7%BB%93-%E6%8A%98%E9%B8%A6/" class="post-title-link" itemprop="url">二阶段rCore总结-折鸦</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-13 02:00:30" itemprop="dateCreated datePublished" datetime="2025-04-13T02:00:30+00:00">2025-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二阶段-rCore-实验总结-折鸦"><a href="#二阶段-rCore-实验总结-折鸦" class="headerlink" title="二阶段 rCore 实验总结 - 折鸦"></a>二阶段 rCore 实验总结 - 折鸦</h1><h2 id="实验环境配置"><a href="#实验环境配置" class="headerlink" title="实验环境配置"></a>实验环境配置</h2><p>用 Rust 开发操作系统内核源代码, 通过 <code>rustc</code> 交叉编译到 <code>riscv64gc-unknown-none-elf</code> (一般情况下是 <code>x86_64-unknown-linux-gnu</code>), 通过 <code>rust-objcopy</code> 提取出 bin, 然后放到 <code>qemu-system-riscv64</code> 模拟器进行模拟, 大概是这么个工具链.</p>
<p>QEMU 最好装 <code>7.0.0</code> 版本的, 从源码编译安装的话需要注意一下依赖, 部分发行版的依赖可以在 <a href="https://risc-v-getting-started-guide.readthedocs.io/en/latest/linux-qemu.html#prerequisites" target="_blank" rel="noopener">Running 64- and 32-bit RISC-V Linux on QEMU — RISC-V - Getting Started Guide</a> 找到</p>
<p>Arch Linux 仓库里是 QEMU 9, 需要修改一下 <code>RustSBI</code> 的版本. 注意如果你想直接 <code>downgrade</code> 到 <code>7.0.0</code> 的话可能会需要连带降级一些非常核心的软件包, 非常不建议尝试. 有需要也可以自行寻找依赖包然后从源代码编译, 但是有一些接口变动可能会导致编译失败, 所以最佳方案还是替换 <code>RustSBI</code> 版本, 这里不再赘述.</p>
<h2 id="构建一个能跑但仅仅能跑的操作系统"><a href="#构建一个能跑但仅仅能跑的操作系统" class="headerlink" title="构建一个能跑但仅仅能跑的操作系统"></a>构建一个能跑但仅仅能跑的操作系统</h2><p>根据 OSTEP 的说法, 操作系统的主要三个任务部分在于: <strong>虚拟化</strong>, <strong>并发</strong>, <strong>可持久化</strong></p>
<ul>
<li>虚拟化主要表现在:<ul>
<li>对内存的抽象: 每个进程有自己的虚拟地址空间, 造成每个进程独占一个主存的假象(学过 CSAPP 可以回忆一下第九章, 博客还在补)</li>
<li>对 CPU 的虚拟化: 主要表现在操作系统内核对各个任务的调度, 使得每个任务产生独占 CPU 的假象(这就是一种并发)</li>
<li>对外设设备的虚拟化等等</li>
</ul>
</li>
<li>并发主要表现在:<ul>
<li>进程概念的抽象和实现, 进程间通信</li>
<li>多线程的实现</li>
</ul>
</li>
<li>可持久化主要涉及文件系统</li>
</ul>
<p>而形式上, 操作系统是一个二进制文件或二进制文件镜像, 被 bootloader 加载进内存的特定位置, 驻留在内存中的特定代码, 这些代码负责一些加载应用程序(简单来说就是把可执行文件加载到内存), 管理资源(设备/文件)并提供访问的任务, 这些任务以系统调用(syscall)的形式暴露给应用程序, 只是系统调用函数比较敏感特殊, 下面会仔细介绍.</p>
<p>那么我们的任务就比较明确了: </p>
<ul>
<li>先设计一个基本的能把应用程序加载到内存的功能 (当然因为现在内核没有任何调度能力也没有让应用程序启动其他应用程序的必要(这依赖进程的实现), 所以我们暂时不需要设计 <code>execve</code> 系统调用)</li>
<li>实现标准输出能力 (实际上标准输出就是调用系统调用 <code>write</code>, 目标为 <code>1</code> (标准输入))</li>
<li>实现退出程序的能力 (<code>exit</code> 系统调用)</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/04/13/%E4%BA%8C%E9%98%B6%E6%AE%B5rCore%E6%80%BB%E7%BB%93-%E6%8A%98%E9%B8%A6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/10/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-1430329301Lsj/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/10/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-1430329301Lsj/" class="post-title-link" itemprop="url"><2025春夏季开源操作系统训练营第一阶段总结报告-1430329301Lsj></a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-10 23:00:24" itemprop="dateCreated datePublished" datetime="2025-04-10T23:00:24+00:00">2025-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Rust速查表：<a href="https://cheats.rs/" target="_blank" rel="noopener">Rust Language Cheat Sheet</a></p>
<h1 id="Rust是什么"><a href="#Rust是什么" class="headerlink" title="Rust是什么"></a>Rust是什么</h1><ul>
<li><p>Rust可看作一个在语法层面（编译时）具有严格检查和限制的<strong>C语言上位</strong>。</p>
</li>
<li><p>扩展了<strong>面向对象</strong>的便捷方法绑定。</p>
</li>
<li><p>编译和运行方式类似于C/C++，可以<code>rustc xxx.rs</code>编译，<code>./xxx</code>运行。</p>
</li>
<li><p>有约定的项目目录格式，可使用<code>Cargo</code>配置<code>toml</code>进行包管理、编译、运行、测试等等。</p>
</li>
<li><p>包资源网站为<code>CratesIO</code>，见<code>src↑</code>。</p>
</li>
<li><p>不支持运算符重载，支持多态。其中语句为：<code>表达式+;</code>，语句的值是<code>()</code>。</p>
<blockquote>
<p><strong>运算符重载</strong>是指为自定义的类或结构体重新定义或赋予运算符(如+、-、*、/等)新的功能。它允许程序员对已有运算符赋予多重含义，使同一运算符作用于不同类型的数据时执行不同的操作。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>扩展运算符功能</strong>：让运算符不仅能作用于基本数据类型，也能作用于自定义类型</li>
<li><strong>语法简洁</strong>：使自定义类型的操作像基本类型一样自然</li>
<li><strong>保持直观性</strong>：重载后的运算符功能应与原意相符，避免滥用</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="Rust安装"><a href="#Rust安装" class="headerlink" title="Rust安装"></a>Rust安装</h1><p>可使用编译器：VSCode + <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer" target="_blank" rel="noopener">rust-analyzer</a>，VIM，<a href="https://www.jetbrains.com/rust/" target="_blank" rel="noopener">RustRover</a></p>
<p><img src="https://linhaiyi-1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%8A/image-20250403110554181.png" alt="image-20250403110554181"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#39;&#x3D;https&#39; --tlsv1.2 -sSf https:&#x2F;&#x2F;sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>

<p>我最终选择使用rustRover来编译——jetBrain全家桶之一，与Pycham同源使用会比较顺手，且可以直接连接WSL：</p>
<img src="https://linhaiyi-1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%8A/image-20250403110943092.png" alt="image-20250403110943092" style="zoom: 33%;" />

<h1 id="Rust基础"><a href="#Rust基础" class="headerlink" title="Rust基础"></a>Rust基础</h1><p>rust的编译与运行是分开的，是一种<strong>预编译静态类型</strong>语言。rust的源文件为<code>xx.rs</code>，最基础的编译为使用<code>rustc xx.rs</code>对代码进行编译。</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h3><p>Cargo是Rust的构建系统和包管理器：</p>
<ul>
<li>构建代码</li>
<li>下载依赖库（代码所需的库叫做依赖）</li>
</ul>
<p>1.使用Cargo构建项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new the_project</span><br><span class="line">$ cd the_project</span><br></pre></td></tr></table></figure>

<p>在Linux终端输入上面的代码创建rust项目后，会生成如下的文件与目录：</p>
<p><img src="https://linhaiyi-1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%BA%8A/image-20250410180737109.png" alt="image-20250410180737109"></p>
<p>变量</p>
<p>首先必须说明，Rust 是强类型语言，但具有自动判断变量类型的能力。这很容易让人与弱类型语言产生混淆。</p>
<p>默认情况下，Rust 中的变量是不可变的，除非使用 mut 关键字声明为可变变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 123;       &#x2F;&#x2F; 不可变变量</span><br><span class="line">let mut b &#x3D; 10;  &#x2F;&#x2F; 可变变量</span><br></pre></td></tr></table></figure>

<p>如果要声明变量，需要使用 <strong>let</strong> 关键字。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 123;</span><br></pre></td></tr></table></figure>

<p>变量和常量还是有区别的。在 Rust 中，以下程序是合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 123;   &#x2F;&#x2F; 可以编译，但可能有警告，因为该变量没有被使用</span><br><span class="line">let a &#x3D; 456;</span><br></pre></td></tr></table></figure>

<p>但是如果 a 是常量就不合法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a: i32 &#x3D; 123;</span><br><span class="line">let a &#x3D; 456;</span><br></pre></td></tr></table></figure>

<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p><strong>if 表达式</strong></p>
<p>实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let number &#x3D; 7;</span><br><span class="line">if number &lt; 5 &#123;</span><br><span class="line">  println!(&quot;小于 5&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  println!(&quot;大于等于 5&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>loop 循环:</strong> loop 是 Rust 中的无限循环，可以使用 break 退出循环。</p>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mut counter &#x3D; 0;</span><br><span class="line">loop &#123;</span><br><span class="line">  counter +&#x3D; 1;</span><br><span class="line">  if counter &#x3D;&#x3D; 10 &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>while 循环</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mut number &#x3D; 3;</span><br><span class="line">while number !&#x3D; 0 &#123;</span><br><span class="line">  println!(&quot;&#123;&#125;!&quot;, number);</span><br><span class="line">  number -&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for 循环</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for number in 1..4 &#123;</span><br><span class="line">  println!(&quot;&#123;&#125;!&quot;, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体-Structs"><a href="#结构体-Structs" class="headerlink" title="结构体 (Structs)"></a>结构体 (Structs)</h3><p>结构体用于创建自定义类型，字段可以包含多种数据类型。</p>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">  username: String,</span><br><span class="line">  email: String,</span><br><span class="line">  sign_in_count: u64,</span><br><span class="line">  active: bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user1 &#x3D; User &#123;</span><br><span class="line">  username: String::from(&quot;someusername&quot;),</span><br><span class="line">  email: String::from(&quot;someone@example.com&quot;),</span><br><span class="line">  sign_in_count: 1,</span><br><span class="line">  active: true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="枚举-Enums"><a href="#枚举-Enums" class="headerlink" title="枚举 (Enums)"></a>枚举 (Enums)</h3><p>枚举允许定义可能的几种数据类型中的一种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum IpAddrKind &#123;</span><br><span class="line">  V4,</span><br><span class="line">  V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let four &#x3D; IpAddrKind::V4;</span><br><span class="line">let six &#x3D; IpAddrKind::V6;</span><br></pre></td></tr></table></figure>



<h3 id="模式匹配-match"><a href="#模式匹配-match" class="headerlink" title="模式匹配 (match)"></a>模式匹配 (match)</h3><p>match 是 Rust 中强大的控制流工具，类似于 switch 语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Coin &#123;</span><br><span class="line">  Penny,</span><br><span class="line">  Nickel,</span><br><span class="line">  Dime,</span><br><span class="line">  Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">  match coin &#123;</span><br><span class="line">    Coin::Penny &#x3D;&gt; 1,</span><br><span class="line">    Coin::Nickel &#x3D;&gt; 5,</span><br><span class="line">    Coin::Dime &#x3D;&gt; 10,</span><br><span class="line">    Coin::Quarter &#x3D;&gt; 25,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Rust 有两种主要的错误处理方式：<strong>Result&lt;T, E&gt;</strong> 和 <strong>Option<T></strong>。</p>
<p><strong>Result:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">  Ok(T),</span><br><span class="line">  Err(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn divide(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; &#123;</span><br><span class="line">  if b &#x3D;&#x3D; 0 &#123;</span><br><span class="line">    Err(String::from(&quot;Division by zero&quot;))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Ok(a &#x2F; b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Option:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn get_element(index: usize, vec: &amp;Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">  if index &lt; vec.len() &#123;</span><br><span class="line">    Some(vec[index])</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    None</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="所有权与借用的生命周期"><a href="#所有权与借用的生命周期" class="headerlink" title="所有权与借用的生命周期"></a>所有权与借用的生命周期</h3><p>Rust 使用生命周期来确保引用的有效性。生命周期标注用 <strong>‘a</strong> 等来表示，但常见的情况下，编译器会自动推导。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;</span><br><span class="line">  if x.len() &gt; y.len() &#123;</span><br><span class="line">    x</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重影（Shadowing）"><a href="#重影（Shadowing）" class="headerlink" title="重影（Shadowing）"></a>重影（Shadowing）</h3><p>重影的概念与其他面向对象语言里的”重写”（Override）或”重载”（Overload）是不一样的。重影就是刚才讲述的所谓”重新绑定”，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念。</p>
<p>重影就是指变量的名称可以被重新使用的机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let x &#x3D; 5;</span><br><span class="line">  let x &#x3D; x + 1;</span><br><span class="line">  let x &#x3D; x * 2;</span><br><span class="line">  println!(&quot;The value of x is: &#123;&#125;&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数型（Integer）"><a href="#整数型（Integer）" class="headerlink" title="整数型（Integer）"></a>整数型（Integer）</h3><p>整数型简称整型，按照比特位长度和有无符号分为以下种类：</p>
<table>
<thead>
<tr>
<th align="left">位长度</th>
<th align="left">有符号</th>
<th align="left">无符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">8-bit</td>
<td align="left">i8</td>
<td align="left">u8</td>
</tr>
<tr>
<td align="left">16-bit</td>
<td align="left">i16</td>
<td align="left">u16</td>
</tr>
<tr>
<td align="left">32-bit</td>
<td align="left">i32</td>
<td align="left">u32</td>
</tr>
<tr>
<td align="left">64-bit</td>
<td align="left">i64</td>
<td align="left">u64</td>
</tr>
<tr>
<td align="left">128-bit</td>
<td align="left">i128</td>
<td align="left">u128</td>
</tr>
<tr>
<td align="left">arch</td>
<td align="left">isize</td>
<td align="left">usize</td>
</tr>
</tbody></table>
<p>isize 和 usize 两种整数类型是用来衡量数据大小的，它们的位长度取决于所运行的目标平台，如果是 32 位架构的处理器将使用 32 位位长度整型。</p>
<h3 id="浮点数型（Floating-Point）"><a href="#浮点数型（Floating-Point）" class="headerlink" title="浮点数型（Floating-Point）"></a>浮点数型（Floating-Point）</h3><p>Rust 与其它语言一样支持 32 位浮点数（f32）和 64 位浮点数（f64）。默认情况下，64.0 将表示 64 位浮点数，因为现代计算机处理器对两种浮点数计算的速度几乎相同，但 64 位浮点数精度更高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let x &#x3D; 2.0; *&#x2F;&#x2F; f64*</span><br><span class="line">  let y: f32 &#x3D; 3.0; *&#x2F;&#x2F; f32*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>布尔型用 bool 表示，值只能为 true 或 false。</p>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符型用 char 表示。</p>
<p>Rust的 char 类型大小为 4 个字节，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这是第一种注释方式</span><br><span class="line"></span><br><span class="line">&#x2F;* 这是第二种注释方式 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 多行注释</span><br><span class="line"> * 多行注释</span><br><span class="line"> * 多行注释</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> </span>&lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>Rust 中定义函数如果需要具备参数必须声明参数名称和类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  another_function(5, 6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn another_function(x: i32, y: i32) &#123;</span><br><span class="line">  println!(&quot;x 的值为 : &#123;&#125;&quot;, x);</span><br><span class="line">  println!(&quot;y 的值为 : &#123;&#125;&quot;, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>在函数体中，随时都可以以 return 关键字结束函数运行并返回一个类型合适的值。这也是最接近大多数开发者经验的做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn add(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 Rust 不支持自动返回值类型判断！如果没有明确声明函数返回值的类型，函数将被认为是”纯过程”，不允许产生返回值，return 后面不能有返回值表达式。这样做的目的是为了让公开的函数能够形成可见的公报。</p>
<h1 id="Rust特色"><a href="#Rust特色" class="headerlink" title="Rust特色"></a>Rust特色</h1><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>Rust 中的所有权是独特的内存管理机制，核心概念包括所有权 (ownership)、借用 (borrowing) 和引用 (reference)。</p>
<p><strong>所有权规则:</strong></p>
<ul>
<li>Rust 中的每个值都有一个所有者。</li>
<li>每个值在任意时刻只能有一个所有者。</li>
<li>当所有者超出作用域时，值会被删除。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s1 &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line">let s2 &#x3D; s1; &#x2F;&#x2F; s1 的所有权被转移给了 s2</span><br><span class="line">&#x2F;&#x2F; println!(&quot;&#123;&#125;&quot;, s1); &#x2F;&#x2F; 此处编译会报错，因为 s1 已不再拥有该值</span><br></pre></td></tr></table></figure>

<p><strong>借用和引用:</strong> 借用允许引用数据而不获取所有权，通过 <strong>&amp;</strong> 符号实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line">    let len &#x3D; calculate_length(&amp;s);  &#x2F;&#x2F; 借用</span><br><span class="line">    println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn calculate_length(s: &amp;String) -&gt; usize &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="组织管理"><a href="#组织管理" class="headerlink" title="组织管理"></a>组织管理</h2><p>Rust 中有三个重要的组织概念：箱、包、模块。</p>
<h3 id="箱（Crate）"><a href="#箱（Crate）" class="headerlink" title="箱（Crate）"></a>箱（Crate）</h3><p>“箱”是二进制程序文件或者库文件，存在于”包”中。</p>
<p>“箱”是树状结构的，它的树根是编译器开始运行时编译的源文件所编译的程序。</p>
<p>注意：”二进制程序文件”不一定是”二进制可执行文件”，只能确定是是包含目标机器语言的文件，文件格式随编译环境的不同而不同。</p>
<h3 id="包（Package）"><a href="#包（Package）" class="headerlink" title="包（Package）"></a>包（Package）</h3><p>当我们使用 Cargo 执行 new 命令创建 Rust 工程时，工程目录下会建立一个 Cargo.toml 文件。工程的实质就是一个包，包必须由一个 Cargo.toml 文件来管理，该文件描述了包的基本信息以及依赖项。</p>
<p>一个包最多包含一个库”箱”，可以包含任意数量的二进制”箱”，但是至少包含一个”箱”（不管是库还是二进制”箱”）。</p>
<p>当使用 cargo new 命令创建完包之后，src 目录下会生成一个 main.rs 源文件，Cargo 默认这个文件为二进制箱的根，编译之后的二进制箱将与包名相同。</p>
<h3 id="模块（Module）"><a href="#模块（Module）" class="headerlink" title="模块（Module）"></a>模块（Module）</h3><p>对于一个软件工程来说，我们往往按照所使用的编程语言的组织规范来进行组织，组织模块的主要结构往往是树。Java 组织功能模块的主要单位是类，而 JavaScript 组织模块的主要方式是 function。</p>
<p>这些先进的语言的组织单位可以层层包含，就像文件系统的目录结构一样。Rust 中的组织单位是模块（Module）。</p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>Rust 宏（Macros）是一种在编译时生成代码的强大工具，它允许你在编写代码时创建自定义语法扩展。</p>
<p>宏（Macro）是一种在代码中进行元编程（Metaprogramming）的技术，它允许在编译时生成代码，宏可以帮助简化代码，提高代码的可读性和可维护性，同时允许开发者在编译时执行一些代码生成的操作。</p>
<p>宏在 Rust 中有两种类型：声明式宏（Declarative Macros）和过程宏（Procedural Macros）。</p>
<p>本文主要介绍声明式宏。</p>
<h3 id="宏的定义"><a href="#宏的定义" class="headerlink" title="宏的定义"></a>宏的定义</h3><p>在 Rust 中，使用 <strong>macro_rules!</strong> 关键字来定义声明式宏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">macro_rules! my_macro &#123;</span><br><span class="line">    &#x2F;&#x2F; 模式匹配和展开</span><br><span class="line">    ($arg:expr) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 生成的代码</span><br><span class="line">        &#x2F;&#x2F; 使用 $arg 来代替匹配到的表达式</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明式宏使用 <strong>macro_rules!</strong> 关键字进行定义，它们被称为 <strong>“macro_rules”</strong> 宏。这种宏的定义是基于模式匹配的，可以匹配代码的结构并根据匹配的模式生成相应的代码。这样的宏在不引入新的语法结构的情况下，可以用来简化一些通用的代码模式。</p>
<p>注意：</p>
<ul>
<li><strong>模式匹配：</strong>宏通过模式匹配来匹配传递给宏的代码片段，模式是宏规则的左侧部分，用于捕获不同的代码结构。</li>
<li><strong>规则：</strong>宏规则是一组由 <strong>$</strong> 引导的模式和相应的展开代码，规则由分号分隔。</li>
<li><strong>宏的展开：</strong>当宏被调用时，匹配的模式将被替换为相应的展开代码，展开代码是宏规则的右侧部分。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;&#x2F; 宏的定义*</span><br><span class="line">macro_rules! vec &#123;</span><br><span class="line">  *&#x2F;&#x2F; 基本情况，空的情况*</span><br><span class="line">  () &#x3D;&gt; &#123;</span><br><span class="line">    Vec::new()</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  *&#x2F;&#x2F; 递归情况，带有元素的情况*</span><br><span class="line">  ($($element:expr),+ $(,)?) &#x3D;&gt; &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      let mut temp_vec &#x3D; Vec::new();</span><br><span class="line">      $(</span><br><span class="line">        temp_vec.push($element);</span><br><span class="line">      )+</span><br><span class="line">      temp_vec</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">  *&#x2F;&#x2F; 调用宏*</span><br><span class="line">  let my_vec &#x3D; vec![1, 2, 3];</span><br><span class="line">  println!(&quot;&#123;:?&#125;&quot;, my_vec); *&#x2F;&#x2F; 输出: [1, 2, 3]*</span><br><span class="line"></span><br><span class="line">  let empty_vec &#x3D; vec![];</span><br><span class="line">  println!(&quot;&#123;:?&#125;&quot;, empty_vec); *&#x2F;&#x2F; 输出: []*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<strong>vec!</strong> 宏使用了模式匹配，以及 <strong>$($element:expr),+ $(,)?)</strong> 这样的语法来捕获传递给宏的元素，并用它们创建一个 Vec。</p>
<p>注意，$<strong>(,)?)</strong> 用于处理末尾的逗号，使得在不同的使用情境下都能正常工作。</p>
<h3 id="过程宏（Procedural-Macros）"><a href="#过程宏（Procedural-Macros）" class="headerlink" title="过程宏（Procedural Macros）"></a>过程宏（Procedural Macros）</h3><p>过程宏是一种更为灵活和强大的宏，允许在编译时通过自定义代码生成过程来操作抽象语法树（AST）。过程宏在功能上更接近于函数，但是它们在编写和使用上更加复杂。</p>
<p>过程宏的类型：</p>
<ul>
<li><strong>派生宏（Derive Macros）</strong>：用于自动实现trait（比如<code>Copy</code>、<code>Debug</code>）的宏。</li>
<li><strong>属性宏（Attribute Macros）</strong>：用于在声明上附加额外的元数据，如<code>#[derive(Debug)]</code>。</li>
</ul>
<p>过程宏的实现通常需要使用 proc_macro 库提供的功能，例如 TokenStream 和 TokenTree，以便更直接地操纵源代码。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针（Smart pointers）是一种在 Rust 中常见的数据结构，它们提供了额外的功能和安全性保证，以帮助管理内存和数据。</p>
<p>在 Rust 中，智能指针是一种封装了对动态分配内存的所有权和生命周期管理的数据类型。</p>
<p>智能指针通常封装了一个原始指针，并提供了一些额外的功能，比如引用计数、所有权转移、生命周期管理等。</p>
<p>在 Rust 中，标准库提供了几种常见的智能指针类型，例如 Box、Rc、Arc 和 RefCell。</p>
<p><strong>智能指针的使用场景:</strong></p>
<ul>
<li>当需要在堆上分配内存时，使用 <code>Box&lt;T&gt;</code>。</li>
<li>当需要多处共享所有权时，使用 <code>Rc&lt;T&gt;</code> 或 <code>Arc&lt;T&gt;</code>。</li>
<li>当需要内部可变性时，使用 <code>RefCell&lt;T&gt;</code>。</li>
<li>当需要线程安全的共享所有权时，使用 <code>Arc&lt;T&gt;</code>。</li>
<li>当需要互斥访问数据时，使用 <code>Mutex&lt;T&gt;</code>。</li>
<li>当需要读取-写入访问数据时，使用 <code>RwLock&lt;T&gt;</code>。</li>
<li>当需要解决循环引用问题时，使用 <code>Weak&lt;T&gt;</code>。</li>
</ul>
<h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h2><p>Rust 有一套独特的处理异常情况的机制，它并不像其它语言中的 try 机制那样简单。</p>
<p>首先，程序中一般会出现两种错误：可恢复错误和不可恢复错误。</p>
<p>可恢复错误的典型案例是文件访问错误，如果访问一个文件失败，有可能是因为它正在被占用，是正常的，我们可以通过等待来解决。</p>
<p>但还有一种错误是由编程中无法解决的逻辑错误导致的，例如访问数组末尾以外的位置。</p>
<p>大多数编程语言不区分这两种错误，并用 Exception （异常）类来表示错误。在 Rust 中没有 Exception。</p>
<p>对于可恢复错误用 Result&lt;T, E&gt; 类来处理，对于不可恢复错误使用 panic! 宏来处理。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/04/10/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-1430329301Lsj/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/06/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-hxingjie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/06/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-hxingjie/" class="post-title-link" itemprop="url">2025春夏季开源操作系统训练营第二阶段总结报告-hxingjie</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-06 19:18:43" itemprop="dateCreated datePublished" datetime="2025-04-06T19:18:43+00:00">2025-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/summary-report/" itemprop="url" rel="index"><span itemprop="name">summary report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>通过阅读实验指导书，我跟着操作系统的发展历程，学习了批处理系统、多道程序与分时多任务、虚拟地址空间、进程管理、文件系统、进程通信和并发等核心概念，并对rCore的实现有了更深入的认识。以下是我对这两周学习过程的总结。</p>
<h2 id="二、学习内容"><a href="#二、学习内容" class="headerlink" title="二、学习内容"></a>二、学习内容</h2><ol>
<li><p>搭建执行环境：</p>
<p>学习了平台与目标三元组，理解了应用程序执行环境。</p>
</li>
<li><p>批处理系统：</p>
<p>学习了批处理系统的基本原理，包括作业调度、作业执行过程。</p>
</li>
<li><p>多道程序与分时多任务：</p>
<p>掌握了多道程序设计的基本概念，以及如何实现分时多任务调度。</p>
</li>
<li><p>虚拟地址空间：</p>
<p>理解了虚拟内存的概念，包括页表、地址映射。</p>
</li>
<li><p>进程管理：</p>
<p>学习了进程的管理、调度，更加深入的理解了fork+exec。</p>
</li>
<li><p>文件系统：</p>
<p>掌握了文件系统的基本结构，包括目录、文件。</p>
</li>
<li><p>进程通信：</p>
<p>学习了父子进程之间的通信机制——管道。</p>
</li>
<li><p>并发：</p>
<p>学习了线程管理机制的设计与实现，理解了同步互斥的实现，包括锁、信号量、条件变量。</p>
</li>
</ol>
<h2 id="三、学习心得"><a href="#三、学习心得" class="headerlink" title="三、学习心得"></a>三、学习心得</h2><p>第二次学习rCore，加之前段时间学习xv6的经历，对rCore有了更深入的认识，包括trap的过程、地址空间的切换等，和群里同学的讨论也加深了我对代码的理解。</p>
<p>通过学习rCore，我对操作系统的原理有了更深入的理解，虽然考研的时候较为系统的学习了操作系统的知识，但是基本上还是停留在理论知识方面。这次rCore学习之旅，我获取PCB对进程进行操作、实现课本上学习过的系统调用、深入汇编代码理解什么是 ‘陷入’ ，让我对操作系统的设计理念、计算机的体系结构有了具象化的认识。</p>
<p>在学习过程中，我也遇到了许多挑战，解决了旧问题又出现了新问题，对操作系统有了更深入的认识反而产生了更多的问题，但是我相信计算机没有魔法，多查资料多看源码一定能把疑惑解开。</p>
<p>两周的rCore学习之旅让我受益匪浅。通过学习rCore，我对操作系统的设计和实现有了更深刻的认识，同时也提升了我的编程技能。我相信，这些知识和经验将对我未来的学习和职业发展产生积极影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/03/25/%E6%A2%A6%E9%86%92%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/03/25/%E6%A2%A6%E9%86%92%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">梦醒的学习记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-03-25 21:02:12" itemprop="dateCreated datePublished" datetime="2025-03-25T21:02:12+00:00">2025-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天重写了一遍rustlings，虽然在其他训练营已经写过了，但是这次依然有收获。比如我了解到了<br>match时的ref有什么作用，以及他和&amp;的区别</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/03/25/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-hxingjie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/03/25/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-hxingjie/" class="post-title-link" itemprop="url">2025春夏季开源操作系统训练营第一阶段总结报告-hxingjie</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-03-25 19:17:06" itemprop="dateCreated datePublished" datetime="2025-03-25T19:17:06+00:00">2025-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/summary-report/" itemprop="url" rel="index"><span itemprop="name">summary report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>通读了一遍《Rust程序设计语言》书籍并完成了训练营的Rustlings练习。经过两周的学习，我对Rust有了初步的认识和掌握。以下是我对这两周学习过程的总结。</p>
<h2 id="二、学习内容"><a href="#二、学习内容" class="headerlink" title="二、学习内容"></a>二、学习内容</h2><ol>
<li>Rust基础知识</li>
</ol>
<ul>
<li>Rust编程语言的基本语法，包括变量、数据类型、运算符、控制流等。</li>
<li>Rust的所有权系统，包括所有权、借用、生命周期等概念。</li>
</ul>
<ol start="2">
<li>Rustlings练习</li>
</ol>
<ul>
<li>通过完成一系列练习，巩固对Rust基础知识的理解和应用。</li>
<li>练习涵盖了Rust的所有权、借用、生命周期、错误处理、宏、模式匹配等方面的内容。</li>
</ul>
<h2 id="三、学习心得"><a href="#三、学习心得" class="headerlink" title="三、学习心得"></a>三、学习心得</h2><p>这一阶段印象最深的还是最后的算法部份，尤其是前两道关于链表的题目，其实之前一直是使用c++做算法题，对链表也较为熟悉了，但是由于对rust的特性不熟悉以及对链表没有深刻理解，让我有一种有力使不出的感觉，后面通过阅读题目的框架，以及对书本知识的巩固，终于是对rust中的链表有了初步的认识，写完链表的题目后，后续的题目也很快完成了。rust语言的特性让我对编程和计算机有了更深的理解，尽管现在还是写得磕磕绊绊，但是相信通过不断学习和时间，将来我也能够编写出优秀的rust代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/12/22/2024%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E4%B8%89%E5%9B%9B%E9%98%B6%E6%AE%B5-%E5%8D%93%E5%A0%82%E8%B6%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/12/22/2024%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E4%B8%89%E5%9B%9B%E9%98%B6%E6%AE%B5-%E5%8D%93%E5%A0%82%E8%B6%8A/" class="post-title-link" itemprop="url">2024 秋冬季开源操作系统训练营第一二三四阶段总结-卓堂越</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-22 21:07:52" itemprop="dateCreated datePublished" datetime="2024-12-22T21:07:52+00:00">2024-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一阶段实验总结"><a href="#第一阶段实验总结" class="headerlink" title="第一阶段实验总结"></a>第一阶段实验总结</h2><p>在本次实验中，我深入探讨了Rust编程语言中的多个高级概念，并通过实际操作加深了对这些特性的理解。实验的重点涉及了Rust的内存管理、类型系统、并发编程等方面，帮助我更好地掌握了Rust的独特设计思想。</p>
<p>首先，我学习了<strong>Option类型</strong>，通过实践我了解了如何使用<code>Some</code>和<code>None</code>来表示可能不存在的值。这个特性不仅帮助我更好地处理空值，还为后续的错误处理打下了基础。接下来，我研究了Rust中的<strong>结构体</strong>和<strong>枚举</strong>，这两者是Rust数据建模的核心工具。通过定义常规结构体、元组结构体和单元结构体，我体会到了Rust在数据表示上的灵活性。尤其是在枚举的使用中，我学会了如何通过模式匹配来处理不同类型的值，这让代码更加简洁且易于维护。</p>
<p>在处理<strong>字符串</strong>时，我深入了解了Rust中<code>String</code>与<code>str</code>类型的差异，以及它们在内存管理中的不同表现。我通过字符串切片、拼接等操作，进一步掌握了Rust如何高效地处理内存。对于Rust的<strong>模块系统</strong>，我学习了如何通过<code>pub</code>关键字控制模块的可见性，并使用<code>use</code>语句引入外部模块，逐步掌握了Rust的模块化管理和命名空间管理技巧。</p>
<p>通过操作<strong>HashMap</strong>，我加深了对哈希表这种数据结构的理解。尤其是在函数间传递哈希表时，我学习了如何处理生命周期问题，确保数据在访问时的安全性。在<strong>错误处理</strong>方面，我通过<code>Option</code>和<code>Result</code>类型的应用，掌握了Rust中优雅的错误处理机制，学习了如何通过模式匹配有效地捕捉和处理错误。</p>
<p>在学习<strong>泛型</strong>和<strong>性状</strong>时，我认识到泛型使得Rust的代码更加灵活和可复用，而性状则赋予了类型更多的行为定义能力。通过实现和使用性状，我体会到了Rust的面向对象编程思想与函数式编程思想的结合。<strong>生命周期</strong>的学习使我更清晰地理解了Rust的内存管理机制，特别是在避免悬空引用和内存泄漏方面，通过生命周期注解，我能够精确控制数据的有效期，确保内存的安全使用。</p>
<p>通过对<strong>迭代器</strong>和<strong>智能指针</strong>（如<code>Rc</code>、<code>Arc</code>、<code>Box</code>）的学习，我掌握了Rust如何高效地处理集合数据和内存管理，尤其是智能指针帮助我理解了如何管理共享内存和避免内存泄漏的问题。最后，<strong>宏</strong>的学习让我认识到宏在Rust中的重要性，它不仅简化了代码，还提高了代码的复用性和灵活性。<strong>多线程编程</strong>部分则让我进一步理解了Rust的线程模型，学会了如何在保证数据安全的前提下，进行并发操作。</p>
<p>总结来说，通过本次实验，我不仅强化了对Rust基础概念的理解，还深入学习了Rust在内存管理、类型系统以及并发编程方面的独特设计。通过实验中的实际操作，我能够更熟练地使用Rust编写健壮、高效的代码，进一步提升了我的编程能力。</p>
<h2 id="第二阶段实验总结"><a href="#第二阶段实验总结" class="headerlink" title="第二阶段实验总结"></a>第二阶段实验总结</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在操作系统的开发过程中，系统调用是操作系统与用户程序之间的接口，负责提供底层的服务与功能。在本次操作系统实验中，我们实现了几个核心系统调用，包括任务信息查询、内存映射、进程创建等功能。通过实现这些系统调用，我们可以深入理解操作系统的基本原理，如进程管理、内存管理和调度机制。此外，我们还探讨了如何利用不同的调度算法优化任务调度，尤其是通过实现 Stride 调度算法来确保系统中各个进程能够公平地获得 CPU 时间。本文将详细介绍这些系统调用的设计与实现思路。</p>
<h3 id="任务信息查询：sys-task-info"><a href="#任务信息查询：sys-task-info" class="headerlink" title="任务信息查询：sys_task_info"></a>任务信息查询：<code>sys_task_info</code></h3><p><code>sys_task_info</code> 系统调用的主要目的是提供关于当前正在运行的任务的详细信息。每当操作系统需要调试或监控任务时，可以通过调用这个系统调用来获取相关的任务状态、系统调用次数和任务运行时间等信息。操作系统维护每个进程的相关数据，包括进程的状态、系统调用的计数和执行时间等，而这些信息对于开发人员调试系统、分析性能至关重要。</p>
<p>为了实现 <code>sys_task_info</code>，我们首先需要获取当前进程的相关信息。这通常通过存储在进程控制块（PCB）中的数据实现，PCB 记录了每个进程的状态、CPU 寄存器的值、已执行时间以及系统调用计数等信息。当用户或系统调用 <code>sys_task_info</code> 时，操作系统会返回当前任务的这些信息，包括任务的运行状态（如就绪、运行、等待等），系统调用的数量，以及进程自启动以来已经占用的 CPU 时间。通过这些信息，开发人员可以判断进程的执行状态，分析是否存在性能瓶颈或资源争用等问题。</p>
<h3 id="内存映射与取消映射：sys-mmap-和-sys-munmap"><a href="#内存映射与取消映射：sys-mmap-和-sys-munmap" class="headerlink" title="内存映射与取消映射：sys_mmap 和 sys_munmap"></a>内存映射与取消映射：<code>sys_mmap</code> 和 <code>sys_munmap</code></h3><p>在现代操作系统中，虚拟内存是每个进程独立的内存空间，而物理内存则是实际存在的硬件资源。为了有效地利用物理内存，操作系统采用虚拟内存与物理内存之间的映射机制。<code>sys_mmap</code> 系统调用的功能是将虚拟地址空间映射到物理内存上。通过 <code>mmap</code>，操作系统可以将某个文件的内容映射到进程的虚拟内存中，从而让程序可以像访问内存一样直接访问文件数据，而不需要每次都通过传统的 I/O 操作。</p>
<p>在实现 <code>sys_mmap</code> 时，操作系统首先检查请求的虚拟地址是否有效，并验证内存区域是否已经被映射。如果没有冲突，操作系统将通过页表将虚拟地址映射到物理地址。这需要操作系统处理页表的更新，并确保映射区域的权限设置正确。例如，映射的内存区域可能是可读、可写或可执行，操作系统需要为每个映射区域设置合适的访问权限，以避免非法访问或数据损坏。</p>
<p>与 <code>sys_mmap</code> 相对的 <code>sys_munmap</code> 系统调用则负责取消已经映射的虚拟内存区域。当进程不再需要某段内存时，可以调用 <code>munmap</code> 来解除映射。操作系统需要确保取消映射时，虚拟地址没有其他进程在使用，同时也需要回收该内存区域所占用的物理资源。为了实现这一点，操作系统会更新页表，释放相关的物理内存，并将其标记为可重用。通过这种方式，操作系统能够有效管理内存资源，避免内存泄漏和浪费。</p>
<h3 id="进程创建：sys-spawn"><a href="#进程创建：sys-spawn" class="headerlink" title="进程创建：sys_spawn"></a>进程创建：<code>sys_spawn</code></h3><p>进程创建是操作系统中非常重要的一部分功能。通过 <code>sys_spawn</code> 系统调用，操作系统可以根据用户给定的程序路径创建一个新的进程，并将该进程添加到调度队列中。进程创建的过程涉及多个步骤，包括路径验证、程序加载、内存分配和任务调度等。</p>
<p>在实现 <code>sys_spawn</code> 时，操作系统首先需要验证用户提供的程序路径是否有效。这意味着操作系统必须能够访问到指定的文件，并确认该文件是一个有效的可执行文件。接着，操作系统会为新进程分配一个进程控制块（PCB），用于保存该进程的状态、寄存器信息、内存映射、文件描述符等关键数据。然后，操作系统将程序的内容加载到新进程的虚拟内存中，并为其分配栈、堆等内存区域。</p>
<p>一旦新进程的资源分配完成，操作系统会将其添加到调度队列中，等待 CPU 的调度。此时，进程已经具备了执行的基本条件，可以在操作系统的控制下执行。在实际的操作系统中，进程的创建还会涉及到权限管理、父子进程关系的维护以及资源继承等问题，这些都是确保系统稳定和安全运行的关键部分。</p>
<h3 id="Stride-调度算法"><a href="#Stride-调度算法" class="headerlink" title="Stride 调度算法"></a>Stride 调度算法</h3><p>进程调度是操作系统中的一个核心任务，关系到系统性能和资源利用率。Stride 调度算法是一种基于权重的调度策略，旨在通过分配不同的权重来实现不同进程之间的公平调度。在 Stride 调度中，每个进程被分配一个 <code>stride</code> 值，该值与进程的优先级相关，优先级较高的进程将获得较小的 <code>stride</code> 值，而优先级较低的进程将获得较大的 <code>stride</code> 值。每个进程在执行时消耗一定的 <code>stride</code>，当它的 <code>stride</code> 值达到一定阈值时，该进程就会被调度执行。</p>
<p>Stride 调度算法的优点在于，它能够在多任务环境下有效地保证进程之间的公平性。每个进程的调度机会与其 <code>stride</code> 值成反比，这意味着优先级较高的任务会被调度得更频繁，而优先级较低的任务则会较少获得 CPU 时间。每当一个进程被调度执行后，操作系统会更新该进程的 <code>stride</code> 值，使得其调度机会逐渐减少，从而避免了高优先级进程过度占用 CPU 资源的问题。</p>
<p>通过实现 Stride 调度算法，操作系统能够根据每个进程的优先级动态地调整其调度频率。高优先级的任务能够更快速地完成，而低优先级的任务则能够平衡获得一定的执行时间，避免了优先级反转和过度竞争 CPU 的情况。这种方法提高了系统资源的使用效率，同时也保持了调度的公平性。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本次操作系统实验通过实现多个核心功能，深入探讨了系统调用的原理与实现方法。通过任务信息查询、内存映射与取消映射、进程创建等功能的实现，我们不仅加深了对操作系统基本原理的理解，也锻炼了我们如何设计和实现高效的内核功能。同时，Stride 调度算法的实现则帮助我们理解了操作系统如何管理进程的调度和资源分配，以保证公平性和系统性能。</p>
<p>这些操作系统的核心机制为我们未来开发更复杂、更高效的操作系统打下了坚实的基础。在实际的操作系统开发过程中，继续优化调度算法、内存管理、进程调度等底层功能，是提高操作系统性能、稳定性和可扩展性的关键。通过这次实验，我们不仅掌握了这些技术的实现方法，还为我们在更大规模的操作系统设计中奠定了理论基础。</p>
<hr>
<h3 id="2024-秋冬季开源操作系统训练营第三阶段总结-卓堂越"><a href="#2024-秋冬季开源操作系统训练营第三阶段总结-卓堂越" class="headerlink" title="2024 秋冬季开源操作系统训练营第三阶段总结 - 卓堂越"></a>2024 秋冬季开源操作系统训练营第三阶段总结 - 卓堂越</h3><p>通过第三阶段的学习，我深入理解了组件化操作系统内核的设计理念。这种思想强调以模块化方式构建内核，能够根据实际需求增量式地扩展功能，从而在不同场景下灵活构建各种模式的内核。具体而言，这种方法能够带来以下显著优势：</p>
<ol>
<li><strong>提高开发效率</strong>：模块化设计减少了重复工作，使开发者可以快速实现复杂功能。</li>
<li><strong>降低维护难度</strong>：各模块间解耦降低了修改与调试的成本。</li>
<li><strong>促进功能复用与协作</strong>：组件化方法支持功能模块的复用与团队协作开发。</li>
</ol>
<h4 id="学习成果回顾"><a href="#学习成果回顾" class="headerlink" title="学习成果回顾"></a>学习成果回顾</h4><p><strong>第一周</strong><br>学习了 <strong>Unikernel</strong> 的增量开发方法。从一个简单的内核开始，逐步扩展了文件系统等模块。同时，完成了基础设施建设，包括实现 <code>HashMap</code> 和简单的内存分配算法，并掌握了终端控制的技巧。</p>
<p><strong>第二周</strong><br>通过组件化设计，将 Unikernel 扩展为 <strong>Monolithic Kernel</strong>。深入学习了 RISC-V 架构，以及 Arceos 中的线程控制设计。除此之外，我还完成了缺页异常处理，并实现了基本的 Unix 工具功能。</p>
<p><strong>第三周</strong><br>了解了虚拟化的基本原理，并基于模块化方法为 Arceos 添加了虚拟化支持。具体包括虚拟设备接口和多虚拟机支持，同时优化了系统性能与架构设计。</p>
<h4 id="收获与展望"><a href="#收获与展望" class="headerlink" title="收获与展望"></a>收获与展望</h4><p>本阶段的学习让我切身感受到组件化设计在操作系统开发中的强大优势。通过将复杂问题拆解为模块，开发变得更加高效，系统也更易于维护。未来，我希望能将这一思想应用于更多实际项目中，持续提升内核开发能力，打造高效且可靠的系统。</p>
<hr>
<hr>
<h2 id="从小白到操作系统开发者：我的训练营历程与成长"><a href="#从小白到操作系统开发者：我的训练营历程与成长" class="headerlink" title="从小白到操作系统开发者：我的训练营历程与成长"></a>从小白到操作系统开发者：我的训练营历程与成长</h2><p>参加训练营已经快一年了，回顾这段时间的学习与实践，感觉收获满满，成长也非常明显。虽然过程中经历了不少挑战，但我从中学到了很多，也更加明白了自己未来的目标和方向。</p>
<h3 id="从初识RTOS和操作系统"><a href="#从初识RTOS和操作系统" class="headerlink" title="从初识RTOS和操作系统"></a>从初识RTOS和操作系统</h3><p>在训练营的第一阶段，我还是一个对RTOS（实时操作系统）了解甚少的“小白”。当时，我的理解仅限于知道 <strong>FreeRTOS</strong> 是什么，而对于操作系统的具体结构和工作原理几乎没有任何概念。然而，通过这段时间的学习，我开始接触并逐步理解操作系统的基本组成部分，像是内核、调度、进程管理等。这个阶段的学习让我明白了操作系统不仅仅是运行应用程序的基础，更是硬件和软件之间的重要桥梁。</p>
<h4 id="网络问题与任务挑战"><a href="#网络问题与任务挑战" class="headerlink" title="网络问题与任务挑战"></a>网络问题与任务挑战</h4><p>不过，学习的过程并不是一帆风顺的。由于网络不稳定，很多简单的任务总是上传不了，这让我有时感到非常沮丧。更有一次，我因为任务时间限制和一些技术难题，没能在结课期间按时完成所有的任务。这些问题让我认识到，技术的实现不仅仅依赖于个人的能力，还需要更好的时间管理和稳定的技术环境支持。</p>
<h3 id="深入探索异步编程与Python适配"><a href="#深入探索异步编程与Python适配" class="headerlink" title="深入探索异步编程与Python适配"></a>深入探索异步编程与Python适配</h3><p>进入训练营的第二阶段后，任务的难度逐步增加。我选择了一个相对较简单的方向，与其他小伙伴们一起研究 <strong>异步编程</strong>。虽然这与我之前的经验较为接近，但在实际实现过程中，我还是遇到了不少挑战，尤其是在理解异步编程模型时。</p>
<p>然而，通过逐步的实现，我不仅加深了对异步编程的理解，还接触了Python适配的相关知识。实际上，这个阶段让我学到了很多之前没有涉及的技术，这些新知识极大地丰富了我的技术栈，也让我对未来的技术方向更加清晰。</p>
<h3 id="Python与OpenCV的结合"><a href="#Python与OpenCV的结合" class="headerlink" title="Python与OpenCV的结合"></a>Python与OpenCV的结合</h3><p>尽管我没有完全按预期完成所有任务，但这个阶段让我深入思考了自己的学习方法。我曾经盲目追求高难度的任务，而忽略了任务的实际意义和自己的能力匹配。因此，在这个阶段，我主动选择了一个相对简单的任务——<strong>OpenCV</strong> 的相关实践。尽管我最终未能在 <strong>Starry</strong> 上完成OpenCV的测例，但这个过程让我更加明白了如何进行项目规划和任务分配。</p>
<p>在这阶段，我还负责了Python与OpenCV的结合，进行了一些与图像处理相关的实验和项目。通过这些实践，我深入了解了Python的图像处理能力，尤其是OpenCV库在计算机视觉中的应用。例如，如何使用OpenCV进行图像读取、处理和展示，这些操作帮助我了解了计算机如何通过视觉来感知和分析信息。</p>
<h4 id="实现Python3-11的syscall系统调用"><a href="#实现Python3-11的syscall系统调用" class="headerlink" title="实现Python3.11的syscall系统调用"></a>实现Python3.11的syscall系统调用</h4><p>作为实习任务的一部分，我参与了分析和实现支持 <strong>Python3.11</strong> 程序的 <strong>syscall</strong> 系统调用，尤其是在 <strong>ArceOS/Starry</strong> 系统中，逐步完善Python程序所依赖的系统调用。具体来说，这个过程涉及了用户态程序的交叉编译、依赖库的交叉编译、以及系统模拟器 <strong>Qemu</strong> 中的实验。</p>
<ol>
<li><p><strong>交叉编译Python程序</strong>：首先，我需要交叉编译 <strong>Python3.11</strong>，以支持 <strong>aarch64</strong> 架构。这包括了编译所需的依赖库（如 <strong>libffi</strong>、<strong>zlib</strong>、<strong>libuuid</strong> 和 <strong>xz</strong> 等），并且每个依赖库都必须交叉编译，以保证在目标架构上能够正常运行。</p>
</li>
<li><p><strong>Qemu模拟环境</strong>：为了测试在交叉编译后的Python程序，我在 <strong>Qemu</strong> 模拟环境中运行了一个 <strong>aarch64</strong> 架构的 <strong>Alpine Linux</strong>，并在其中加载了交叉编译生成的Python库。通过这种方式，我能够测试并调试系统调用，确保它们能够在模拟器中正常执行。</p>
</li>
<li><p><strong>系统调用分析</strong>：我使用 <strong>strace</strong> 工具来统计Python程序所使用的所有系统调用，并分析它们在不同架构下的表现。通过这个过程，我深入了解了 <strong>syscall</strong> 的工作机制，并能够在实际操作系统中正确实现这些调用。</p>
</li>
</ol>
<p>通过这个任务，我不仅加深了对操作系统内核和系统调用机制的理解，还在实践中学会了如何处理复杂的交叉编译任务。</p>
<h3 id="未来的目标–操作系统与编译器"><a href="#未来的目标–操作系统与编译器" class="headerlink" title="未来的目标–操作系统与编译器"></a>未来的目标–操作系统与编译器</h3><p>回顾这一年的学习，我不仅了解了操作系统的基本原理，还在逐步实现的过程中积累了不少经验。尤其是从一个仅仅知道FreeRTOS的小白，到如今能够理解操作系统结构的程度，我感到自己有了明显的进步。</p>
<p>最令我兴奋的是，未来我希望能够在自己写的操作系统上运行自己开发的编译器。这是我一直以来的梦想，虽然这需要我不断努力和学习，但我相信，通过这段时间的积累，我已经打下了坚实的基础。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>参加训练营的这一年里，我收获了很多，不仅有热心的助教和同学的帮助，还有机会接触到多种新技术和工具。虽然遇到了一些困难，但这些都成为了我成长的动力。我相信，未来我会继续沿着这个方向前行，实现自己在操作系统和编译器领域的梦想。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/12/22/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%88%B4%E5%BF%97%E5%BC%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/12/22/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%88%B4%E5%BF%97%E5%BC%BA/" class="post-title-link" itemprop="url">2024秋冬季训练营第四阶段总结-戴志强</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-22 21:07:52" itemprop="dateCreated datePublished" datetime="2024-12-22T21:07:52+00:00">2024-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024-秋冬季开源操作系统训练营"><a href="#2024-秋冬季开源操作系统训练营" class="headerlink" title="2024 秋冬季开源操作系统训练营"></a>2024 秋冬季开源操作系统训练营</h1><h2 id="导学阶段"><a href="#导学阶段" class="headerlink" title="导学阶段"></a>导学阶段</h2><p>这个阶段主要是介绍 linux 和 github的基本操作。</p>
<h2 id="基础阶段-Rust-编程"><a href="#基础阶段-Rust-编程" class="headerlink" title="基础阶段-Rust 编程"></a>基础阶段-Rust 编程</h2><p>在这个阶段，学员将深入学习 Rust 编程语言的基础知识和高级特性。主要内容包括 Rust 的语法结构、内存管理机制、并发编程和错误处理等。</p>
<aside>
📖

<p><strong>学习经历：</strong> 完成110题并上传，关于所有权的特性还不是特别熟练，特别是在数据结构比较复杂的情况下比如一个Rc指针 包含一个Vec<String>，在这种多层所有权的情况下容易出错，还需多多练加强。</p>
</aside>

<p>笔记：</p>
<h1 id="Rust编程-基础知识"><a href="#Rust编程-基础知识" class="headerlink" title="Rust编程 基础知识"></a>Rust编程 基础知识</h1><h1 id="梳理后"><a href="#梳理后" class="headerlink" title="梳理后"></a>梳理后</h1><p>变量与可变性:</p>
<p>使用 let 声明变量</p>
<p><code>let x = 5;</code></p>
<p>默认不可变（一旦赋值，不可修改）</p>
<p>意义：防止意外的数据修改和并发问题</p>
<p>如何可变？使用 mut 关键字</p>
<p><code>let mut x = 5;</code></p>
<p>常量声明</p>
<p>使用 const 而不是 let</p>
<p>声明值只能为 <strong>常量表达式</strong></p>
<p>（即，不可以是只能在程序运行时才能计算出的值）</p>
<p><code>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;</code></p>
<p>基本数据类型-原生类型（primitives）</p>
<p>标量类型</p>
<p>有符号整数 (signed integers) : i8, i16, i32, i64, i128 和 isize （指针宽度）</p>
<p>无符号整数 (unsigned integers) : u8</p>
<p>浮点数 (floating point): f32, f64</p>
<p>char (字符) : 单个 Unicode 字符，如 ‘a’</p>
<p>bool (布尔型) : 只能是 true 或 false</p>
<p>单元类型 (unit type) : ()。</p>
<p>复合类型</p>
<p>数组 (array) : 如 [1, 2, 3]</p>
<p>元组 (tuple) : 如 (1, true)</p>
<p>元组 (tuple)</p>
<p>把一个或多个其他类型的值组合进一个复合类型</p>
<p>长度固定（声明后长度不变）</p>
<p><code>let tup: (i32, f64, u8) = (500, 6.4, 1);</code></p>
<p>如何获取单个值？</p>
<ol>
<li><p>使用点号 (.) 加值的索引</p>
</li>
<li><p>使用模式匹配 (pattern matching) 来解构 (destruction) 元组值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The value of y is: &#123;y&#125;"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>数组 (array)</p>
<p>在栈上分配，单个内存块</p>
<p>声明</p>
<ol>
<li><p>直接声明</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定元素类型和元素数量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定初始值和元素个数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用</p>
<p>使用索引来访问</p>
<p>函数</p>
<p>声明</p>
<p>使用 fn 关键字来声明</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    another_function();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Another function."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if 表达式</p>
<p>loop 循环</p>
<p>循环标签</p>
<p>改变 break 或 continue 的作用对象</p>
<p>while 循环</p>
<p>for 循环</p>
<p>所有权概念</p>
<p>变量作用域与变量隐藏</p>
<p>函数参数的所有权</p>
<p>函数返回值</p>
<p>引用与借用</p>
<p>可变引用</p>
<p>String</p>
<p>String slice</p>
<p>结构体</p>
<p>元组结构体</p>
<p>Vector</p>
<p>定义</p>
<p>可变长数组，只能存储相同类型的值</p>
<p>使用</p>
<p>Vec::new() 可以新建空 vector</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line"><span class="comment">//这个 Vec&lt;i32&gt; 可以不加</span></span><br></pre></td></tr></table></figure>

<p>vec! 宏，会根据我们提供的值来创建一个新的 vector</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>使用 push 可以向 vector 中增加元素</p>
<p>hashmap</p>
<p>定义</p>
<p>HashMap&lt;K, V&gt; 类型储存了一个键类型为 K 对应一个值类型为 V 的映射</p>
<p>其通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中</p>
<p>使用</p>
<p>可以使用 new 来创建</p>
<p>使用 insert 增加元素</p>
<p>使用 get 方法来从 hashmap 中获取值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>第二节</p>
<p>枚举 enum</p>
<p>枚举 Option</p>
<p>定义</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<p>用 unwrap() 获取内部值</p>
<p>作用域 scope</p>
<p>就是作用范围吧</p>
<p>同一个作用域不能有两个相同名称的项 → C++ 中的变量名冲突</p>
<p>（可以使用一下工具来解决名称冲突？？？）</p>
<p>模块系统 the module system</p>
<p>模块系统可以将 crate 中的代码分组和封装，提高可读性和重用性</p>
<p>包 Packages</p>
<p>Cargo 的一个功能，允许构建、测试和分享 crate</p>
<p>包是提供一系列功能的一个或者多个 crate , 包含一个 Cargo.toml 文件</p>
<p>Crates</p>
<p>一个模块的树形结构，它形成了库或二进制项目</p>
<p>crate 是 Rust 在编译时最小的代码单位，有两种形式：二进制项和库</p>
<p>crate root 是一个源文件，是 crate 的根模块</p>
<p>crate 的约定</p>
<p>src/main.rs 是一个与包同名的二进制 crate 的 crate 根</p>
<p>src/lib.rs 是一个与包同名的库 crate 的 crate 根</p>
<p>src/bin 目录下的每个文件都会被编译成一个独立的二进制 crate</p>
<p>模块 Modules 和 use</p>
<p>允许你控制作用域和路径的私有性</p>
<p>use 关键字</p>
<p>可以在一个作用域内创建一个项的快捷方式，减少长路径的重复</p>
<p>类似于 Java 的导包？</p>
<p>as 关键字</p>
<p>配合 use 使用，就是给快捷方式重命名</p>
<p>一些调用项的方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如 xxx 模块的 yyy 子模块下定义了一个 zzz</span></span><br><span class="line">crate::xxx::yyy::zzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::xxx::yyy::zzz;<span class="comment">//之后就可以直接使用 zzz 了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::xxx::yyy::zzz <span class="keyword">as</span> z;</span><br></pre></td></tr></table></figure>

<p>私有和公有</p>
<p>默认所有内容私有</p>
<p>pub 关键字</p>
<p>可以将模块或模块内的项标记为公开的</p>
<p>模块树</p>
<p>crate 根文件 (src/lib.rs 或 src/main.rs) 是 crate 模块结构的根，也是名为 crate 的隐式模块的根</p>
<p>在 crate 根文件中，可以声明新的模块</p>
<p>使用 mod 关键字和花括号或分号</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> a_module &#123;</span><br><span class="line">    <span class="comment">//something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何寻找</p>
<p>内联（以大括号结尾时）</p>
<p>在文件 src/xxx.rs</p>
<p>在文件 src/xxx/mod.rs</p>
<p>在其它文件中，可以定义子模块</p>
<p>使用 mod 关键字和花括号或分号，并在以父模块命名的目录中寻找子模块代码</p>
<p>模块树可以用来展示 crate 中的模块层次结构，以及模块之间的父子和兄弟关系</p>
<p>路径 path</p>
<p>一个命名项（结构体、函数或模块等）的方式</p>
<p>绝对路径 absolute path</p>
<p>以 crate 根 (root) 开头的全路径</p>
<p>对于外部 crate 的代码，是以 crate 名开头的绝对路径</p>
<p>对于当前 crate 的代码，则以字面值 crate 开头</p>
<p>相对路径 relative path</p>
<p>从当前模块开始，以 self, super 或当前模块的标识符开头</p>
<p>绝对路径和相对路径都后跟一个或多个由双冒号分割的标识符</p>
<h2 id="专业阶段-OS设计实现"><a href="#专业阶段-OS设计实现" class="headerlink" title="专业阶段- OS设计实现"></a><strong>专业阶段- OS设计实现</strong></h2><aside>
📖
**学习经历：**本阶段的学习过程非常有启发性。作为我初次接触操作系统的经历，它帮我对操作系统的成功地祛魅，让我认识到其本质不过是一个为了实现提供用户态程序访问系统资源的接口以及对整个系统资源管理的 复杂程序。同时，详细的v3指导书也给我补充许多基础知识，让我对操作系统学习更有信心。

</aside>

<aside>
🤔

<p><strong>联想</strong> ：操作系统的运行是被隐藏起来的，给用户态程序提供了资源调用接口。而人的意识也是直接嵌入在生物机体上，通过生物神经系统间接地获取对身体地掌控权力。从人类个体到整个社会也是如此，个人嵌入在社会运行的某一环节中，并且他通过这种方式来实现和获得自身，同时又通过整个社会的隐藏环节来获取权力。</p>
</aside>

<h3 id="第三章：多道程序与分时多任务系统"><a href="#第三章：多道程序与分时多任务系统" class="headerlink" title="第三章：多道程序与分时多任务系统"></a>第三章：多道程序与分时多任务系统</h3><p><strong>ch3 要求我们完成的任务具体要求如下：</strong></p>
<ul>
<li>实现系统调用 <code>sys_task_info</code>，系统调用号为 410</li>
<li>该系统调用需要返回当前任务的以下信息：<ul>
<li>任务状态（必定为 Running）</li>
<li>任务使用的系统调用及其调用次数</li>
<li>系统调用时刻距离任务第一次被调度时刻的时长（单位ms）</li>
</ul>
</li>
<li>使用 <code>TaskInfo</code> 结构体来存储这些信息</li>
<li>系统调用成功时返回 0，失败时返回 -1</li>
<li>注意：调用 <code>sys_task_info</code> 本身也会被计入系统调用次数</li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>sys_task_info</strong> 需要三个信息，我们一个一个来，</p>
<p><strong>任务状态</strong>：第一个是任务状态，这个实现起来比较简单，甚至因为在这个系统里，查询的是当前任务的状态，因此 TaskStatus 一定是 Running。</p>
<p><strong>系统调用时刻距离任务第一次被调度时刻的时长</strong>：我们需要的这个时长等于 当前时刻减去第一次被调度的时刻，当前时刻很好获取，利用get_time_ms()函数就可以直接获取，而另外一个 则需要为任务控制块添加新的字段 ，用于记录第一次被调度的时长，这样我们就可以通过任务管理器直接地获取某任务初次调用时刻了。</p>
<p><strong>任务使用的系统调用及其调用次数</strong>:我的方法和提示里给出地方法相同 因为系统调用号一定小于 500，所以直接使用一个长为 <code>MAX_SYSCALL_NUM=500</code> 的数组做桶计数。同样也直接在 任务控制块中添加 数组，实现把各个任务的系统调用次数数组与该任务绑定。在此之后，我们直接到系统调用前<code>syscall/mod.rs:syscall</code> 增加相应任务的相应系统调用类型的调用次数即可。</p>
<p>最后我们直接创建一个TaskInfo类型保存如上三种数据，并利用<strong>sys_task_info</strong>中的*mut类型参数，把Taskinfo的内容传回用户态即可完成该功能。</p>
<p>总的来说作为第一个任务，用来熟悉内核编程，还算比较简单。</p>
<p><a href="%E9%97%AE%E7%AD%94%E9%A2%98-lab1%2013908b3cc7f1805dae96cff7f5eb924d.md">问答题-lab1</a></p>
<h3 id="第四章：地址空间"><a href="#第四章：地址空间" class="headerlink" title="第四章：地址空间"></a>第四章：地址空间</h3><p><strong>ch4要求我们完成的具体内容如下：</strong></p>
<blockquote>
<p>重写 sys_get_time 和 sys_task_info<br>引入虚存机制后，原来内核的 sys_get_time 和 sys_task_info 函数实现就无效了。请你重写这个函数，恢复其正常功能。<br> mmap 和 munmap 匿名映射 <a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener">mmap</a> 在 Linux 中主要用于在内存中映射文件， 本次实验简化它的功能，仅用于申请内存。<br>请实现 mmap 和 munmap 系统调用，mmap 定义如下： <code>fn** sys_mmap(start: usize, len: usize, port: usize) -&gt; isize</code> - syscall ID：222 - 申请长度为 len 字节的物理内存（不要求实际物理内存位置，可以随便找一块），将其映射到 start 开始的虚存，内存页属性为 port<br> <strong>参数：</strong><br> start 需要映射的虚存起始地址，要求按页对齐<br>len 映射字节长度，可以为 0<br>port：第 0 位表示是否可读，第 1 位表示是否可写，第 2 位表示是否可执行。其他位无效且必须为 0<br> 返回值：执行成功则返回 0，错误返回 1<br><strong>说明：</strong>  为了简单，目标虚存区间要求按页对齐，len 可直接按页向上取整，不考虑分配失败时的页回收。<br> <strong>可能的错误：</strong>  start 没有按页大小对齐 - port &amp; !0x7 != 0 (port 其余位必须为0) - port &amp; 0x7 = 0 (这样的内存无意义) - [start, start + len) 中存在已经被映射的页 - 物理内存不足</p>
</blockquote>
<p><strong>思路：</strong></p>
<p><strong>我们先说sys_get_time和sys task_info 这两个函数的重写：</strong></p>
<p>首先我们来说说为什么这两个函数会失效，在ch3中我们的系统调用 利用*mut类型指针来将数据直接地写入用户态中的地址，但是在ch4中，我们将用户态和内核态都分别做了不同的地址映射，这导致我们没办法像ch3那样直接利用_ts来写入数据，因为ch4中传入的是用户态中的虚拟地址，必须借助页表机制，将虚拟地址转换为物理地址，来修改。获取 time 和 TaskInfo的步骤和之前ch3中提到的方式类似。</p>
<p>需要注意的是，我们写入的数据结构可能存在如下所示的跨页的问题，</p>
<p><code>/// YOUR JOB: get time with second and microsecond
/// HINT: You might reimplement it with virtual memory management.
/// HINT: What if [TimeVal] is splitted by two pages ?</code></p>
<p>所以我们不能把数据一次性全部写入，这里我选择的办法是将数据转换为字节数组 并依次写入。</p>
<p><strong>mmap和unmmap:</strong></p>
<p><strong>首先来说mmap：</strong></p>
<p>mmap需要实现的是将一段虚拟地址进行页面映射，想要实现这个功能，我们需要在进程的地址空间中加入添加新的页面映射，而该系统正好提供了为地址空间提供了insert_framed_area方法，用于插入新的逻辑段，这样的话情况就会变得很简单。</p>
<p>首先我们根据可能的错误对函数给出的参数进行对应的判断，并且通过port得到MapPermission。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _start % PAGE_SIZE != <span class="number">0</span> || _port &amp; !<span class="number">0x7</span> != <span class="number">0</span> || _port &amp; <span class="number">0x7</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> portpomis = Portpomiss::from_bits_truncate(_port <span class="keyword">as</span> <span class="built_in">u8</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> flag:MapPermission=MapPermission::empty();</span><br><span class="line">flag|=MapPermission::U;</span><br><span class="line"><span class="keyword">if</span> portpomis.contains(Portpomiss::R)&#123;</span><br><span class="line">     flag|=MapPermission::R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> portpomis.contains(Portpomiss::W)&#123;</span><br><span class="line">     flag|=MapPermission::W;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> portpomis.contains(Portpomiss::X)&#123;</span><br><span class="line">    flag|=MapPermission::X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后我们检查虚拟页面是否已经被映射过</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> vpn <span class="keyword">in</span> vpn_range &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(pte) = inner.tasks[cur].memory_set.translate(vpn) &#123;</span><br><span class="line">        <span class="keyword">if</span> pte.is_valid() &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们直接添加页面映射</p>
<p><code>inner.tasks[id].memory_set.insert_framed_area(_start, _end, port);</code></p>
<p><a href="%E9%97%AE%E7%AD%94%E9%A2%98-lab2%2013a08b3cc7f1809ba8bcf3af8545930f.md">问答题-lab2</a></p>
<h3 id="第五章：进程及进程管理"><a href="#第五章：进程及进程管理" class="headerlink" title="第五章：进程及进程管理"></a>第五章：进程及进程管理</h3><p>ch5要求我们具体完成的内容如下:</p>
<blockquote>
<p><strong>spawn 系统调用定义</strong>( <a href="https://man7.org/linux/man-pages/man3/posix_spawn.3.html" target="_blank" rel="noopener">标准spawn看这里</a> )：</p>
<p><strong>`fn</strong> sys_spawn(path: <strong>*const</strong> u8) -&gt; isize`</p>
<ul>
<li>syscall ID: 400</li>
<li>功能：新建子进程，使其执行目标程序。</li>
<li>说明：成功返回子进程id，否则返回 -1。</li>
<li><strong>可能的错误：</strong><ul>
<li>无效的文件名。</li>
<li>进程池满/内存不足等资源错误。</li>
</ul>
</li>
</ul>
<p>TIPS：虽然测例很简单，但提醒读者 spawn <strong>不必</strong> 像 fork 一样复制父进程的地址空间。</p>
<p><strong>stride 调度算法</strong></p>
<p>算法描述如下:</p>
<p>(1) 为每个进程设置一个当前 stride，表示该进程当前已经运行的“长度”。另外设置其对应的 pass 值（只与进程的优先权有关系），表示对应进程在调度后，stride 需要进行的累加值。</p>
<ol>
<li>每次需要调度时，从当前 runnable 态的进程中选择 stride 最小的进程调度。对于获得调度的进程 P，将对应的 stride 加上其对应的步长 pass。</li>
<li>一个时间片后，回到上一步骤，重新调度当前 stride 最小的进程。</li>
</ol>
<p>可以证明，如果令 P.pass = BigStride / P.priority 其中 P.priority 表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。证明过程我们在这里略去，有兴趣的同学可以在网上查找相关资料。</p>
<p>其他实验细节：</p>
<ul>
<li>stride 调度要求进程优先级 ≥2，所以设定进程优先级 ≤1 会导致错误。</li>
<li>进程初始 stride 设置为 0 即可。</li>
<li>进程初始优先级设置为 16。</li>
</ul>
<p>为了实现该调度算法，内核还要增加 set_prio 系统调用</p>
</blockquote>
<p><strong>思路：</strong></p>
<p><strong>我们先说spawn系统调用:</strong></p>
<p>就如同TIPS一样，我们不需要复制父进程的地址空间，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_spawn</span></span>(_path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    trace!(</span><br><span class="line">        <span class="string">"kernel:pid[&#123;&#125;] sys_spawn NOT IMPLEMENTED"</span>,</span><br><span class="line">        current_task().unwrap().pid.<span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> current_task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> token =current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, _path);</span><br><span class="line">    <span class="keyword">let</span> tcb=Arc::new(TaskControlBlock::new(get_app_data_by_name(path.as_str()).unwrap()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner=tcb.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> pin=current_task.inner_exclusive_access();</span><br><span class="line">    inner.parent=<span class="literal">Some</span>(Arc::downgrade(&amp;current_task));</span><br><span class="line">    pin.children.push(tcb.clone());</span><br><span class="line">    <span class="built_in">drop</span>(inner);</span><br><span class="line">    <span class="keyword">let</span> pid = tcb.pid.<span class="number">0</span> <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line">    add_task(tcb);</span><br><span class="line">    pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们直接用 app_data来创建TaskControlBlock而跳过了复制父进程的地址空间，并将他连接到父进程的子进程上，这样才能在sys_waitpid中被遍历到。然后把他加入任务管理器。就可以通过测试。</p>
<p><strong>stride 调度算法：</strong></p>
<p>时间原因暂未实现..</p>
<p><a href="%E9%97%AE%E7%AD%94%E9%A2%98-lab3%2013a08b3cc7f180538397fa4a1ad9d508.md">问答题-lab3</a></p>
<h3 id="第六章：文件系统与I-O重定向"><a href="#第六章：文件系统与I-O重定向" class="headerlink" title="第六章：文件系统与I/O重定向"></a><strong>第六章：文件系统与I/O重定向</strong></h3><p>ch6要求我们具体完成的内容如下:</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接要求两个不同的目录项指向同一个文件，在我们的文件系统中也就是两个不同名称目录项指向同一个磁盘块。</p>
<p>本节要求实现三个系统调用 <code>sys_linkat、sys_unlinkat、sys_stat</code> 。</p>
<p><strong>linkat</strong>：</p>
<blockquote>
<p>syscall ID: 37功能：创建一个文件的一个硬链接， linkat标准接口 。Ｃ接口： int linkat(int olddirfd, char* oldpath, int newdirfd, char* newpath, unsigned int flags)Rust 接口： fn linkat(olddirfd: i32, oldpath: *const u8, newdirfd: i32, newpath: *const u8, flags: u32) -&gt; i32参数：olddirfd，newdirfd: 仅为了兼容性考虑，本次实验中始终为 AT_FDCWD (-100)，可以忽略。flags: 仅为了兼容性考虑，本次实验中始终为 0，可以忽略。oldpath：原有文件路径newpath: 新的链接文件路径。说明：为了方便，不考虑新文件路径已经存在的情况（属于未定义行为），除非链接同名文件。返回值：如果出现了错误则返回 -1，否则返回 0。可能的错误链接同名文件。</p>
</blockquote>
<p><strong>unlinkat</strong>:</p>
<blockquote>
<p>syscall ID: 35功能：取消一个文件路径到文件的链接, unlinkat标准接口 。Ｃ接口： int unlinkat(int dirfd, char* path, unsigned int flags)Rust 接口： fn unlinkat(dirfd: i32, path: *const u8, flags: u32) -&gt; i32参数：dirfd: 仅为了兼容性考虑，本次实验中始终为 AT_FDCWD (-100)，可以忽略。flags: 仅为了兼容性考虑，本次实验中始终为 0，可以忽略。path：文件路径。说明：注意考虑使用 unlink 彻底删除文件的情况，此时需要回收inode以及它对应的数据块。返回值：如果出现了错误则返回 -1，否则返回 0。可能的错误文件不存在。</p>
</blockquote>
<p><strong>fstat</strong>:</p>
<blockquote>
<p>syscall ID: 80功能：获取文件状态。Ｃ接口： int fstat(int fd, struct Stat* st)Rust 接口： fn fstat(fd: i32, st: *mut Stat) -&gt; i32参数：fd: 文件描述符st: 文件状态结构体#[repr(C)]<br>#[derive(Debug)]<br>pub struct Stat {<br>    /// 文件所在磁盘驱动器号，该实验中写死为 0 即可    pub dev: u64,<br>    /// inode 文件所在 inode 编号    pub ino: u64,<br>    /// 文件类型    pub mode: StatMode,<br>    /// 硬链接数量，初始为1    pub nlink: u32,<br>    /// 无需考虑，为了兼容性设计    pad: [u64; 7],<br>}</p>
</blockquote>
<p>/// StatMode 定义：bitflags! {<br>    pub struct StatMode: u32 {<br>        const NULL  = 0;<br>        /// directory        const DIR   = 0o040000;<br>        /// ordinary regular file        const FILE  = 0o100000;<br>    }<br>}</p>
<blockquote>
</blockquote>
<p><strong>我们先来实现fstat:</strong></p>
<p>fstat需要我们先得到三个位置信息分别是 </p>
<blockquote>
<p>/// inode 文件所在 inode 编号    pub ino: u64,<br>    /// 文件类型    pub mode: StatMode,<br>    /// 硬链接数量，初始为1    pub nlink: u32,</p>
</blockquote>
<p>inode 文件所在 inode 编号：</p>
<p>在rcore系统的内核中，似乎没有提供能直接从OSinode得到inode id的接口，所以有两种办法，一种是去修改Easy-fs，另有一种方法是在OSinode被创建的时候给他们分配id。在这里我使用的是后者。</p>
<p>在OSinode结构体中添加如下结构体</p>
<p><code>pub struct Ino{
link:u32,
ino:u64,
}</code></p>
<p>然后再每次打开文件之后对OSinode 使用一个bitmap来分配 id，在文件关闭时用bitmap来回收id；</p>
<p>bitmap在 easyfs中的<code>bitmap.rs</code>有相应实现。我们只需要利用bitmap的alloc和dealloc来实现id的分配和回收。</p>
<p>其中文件类型，可以通过使用 <code>read_disk_inode</code> 获取 <code>inode</code> 对应的 <code>DiskInode</code> 的只读引用，并从中读取相关信息即可。</p>
<p>最后是硬链接数量，该信息显然需要结合link 与 unlink来维护，我们在link时通过刚刚所分配的id，来进行映射即可</p>
<p><code>ITOS.get_mut(&amp;op).unwrap().link+=1;</code></p>
<p>ps:ITOS是一个BTreeMap 可以通过文件名来获取或者修改对应的 Ino结构体。</p>
<p><strong>我们再来实现link与unlink:</strong></p>
<p>首先我们刚刚已经为文件进行了id的分配，我们继续利用先前所分配的id，进行管理。</p>
<p>首先我储存了新的名字和磁盘块原名之间的映射，在文件open与close前，将输入的名字（如果已经被映射）替换为原名来实现两个不同名称目录项指向同一个磁盘块。</p>
<p>如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">unsafe</span> &#123;</span><br><span class="line">UMAP2.contains_key(&amp;path1)</span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">        path = <span class="keyword">unsafe</span> &#123; UMAP2 [&amp;path1].clone()&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    path =path1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlink的逻辑也与link类似，通过用BTreeMap的remove方法将映射删除。<br>但是要特别注意的是，当link为0时，我们需要回收inode id</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  c= <span class="keyword">unsafe</span> &#123; ITOS .get_mut(&amp;name).unwrap()&#125;;</span><br><span class="line"><span class="keyword">if</span> c.link&gt;<span class="number">0</span>&#123; </span><br><span class="line">        c.link-=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">let</span> fd=<span class="keyword">unsafe</span> &#123; UMAP1.get(&amp;name).unwrap() &#125;;</span><br><span class="line">         <span class="keyword">let</span> bind=current_task().unwrap();</span><br><span class="line">         <span class="keyword">let</span> inner=bind.inner_exclusive_access().fd_table[*fd].clone().unwrap();</span><br><span class="line">         inner.clear();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>向前兼容：</strong></p>
<p>唯一要注意的点就是在spawn 中，我们需要用ch6新建立的文件系统来获取应用数据，而不是像ch4一样用translated_str方法直接获取应用数据。</p>
<p><code>let Some(app_inode) = open_file(path.as_str(), OpenFlags::RDONLY)</code></p>
<p>向前兼容的其他方面都与先前类似。</p>
<p><a href="%E9%97%AE%E7%AD%94%E9%A2%98-lab4%2013a08b3cc7f1800b8911c11b8195ec54.md">问答题-lab4</a></p>
<h3 id="第八章：并发"><a href="#第八章：并发" class="headerlink" title="第八章：并发"></a>第八章：并发</h3><p>ch8要求我们具体完成的内容如下:</p>
<blockquote>
<p>死锁检测</p>
<p>目前的 mutex 和 semaphore 相关的系统调用不会分析资源的依赖情况，用户程序可能出现死锁。 我们希望在系统中加入死锁检测机制，当发现可能发生死锁时拒绝对应的资源获取请求。 一种检测死锁的算法如下：</p>
<p>定义如下三个数据结构：</p>
<ul>
<li>可利用资源向量 Available ：含有 m 个元素的一维数组，每个元素代表可利用的某一类资源的数目， 其初值是该类资源的全部可用数目，其值随该类资源的分配和回收而动态地改变。 Available[j] = k，表示第 j 类资源的可用数量为 k。</li>
<li>分配矩阵 Allocation：n * m 矩阵，表示每类资源已分配给每个线程的资源数。 Allocation[i,j] = g，则表示线程 i 当前己分得第 j 类资源的数量为 g。</li>
<li>需求矩阵 Need：n * m 的矩阵，表示每个线程还需要的各类资源数量。 Need[i,j] = d，则表示线程 i 还需要第 j 类资源的数量为 d 。</li>
</ul>
<p>算法运行过程如下：</p>
<ol>
<li>设置两个向量: 工作向量 Work，表示操作系统可提供给线程继续运行所需的各类资源数目，它含有 m 个元素。初始时，Work = Available ；结束向量 Finish，表示系统是否有足够的资源分配给线程， 使之运行完成。初始时 Finish[0..n-1] = false，表示所有线程都没结束；当有足够资源分配给线程时， 设置 Finish[i] = true。</li>
<li>从线程集合中找到一个能满足下述条件的线程</li>
</ol>
<p><code>1Finish[i] == false;
2Need[i,j] ≤ Work[j];</code></p>
<p>若找到，执行步骤 3，否则执行步骤 4。</p>
<ol>
<li>当线程 thr[i] 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行:</li>
</ol>
<p><code>1Work[j] = Work[j] + Allocation[i, j];
2Finish[i] = **true**;</code></p>
<p>跳转回步骤2</p>
<ol>
<li>如果 Finish[0..n-1] 都为 true，则表示系统处于安全状态；否则表示系统处于不安全状态，即出现死锁。</li>
</ol>
<p>出于兼容性和灵活性考虑，我们允许进程按需开启或关闭死锁检测功能。为此我们将实现一个新的系统调用： <code>sys_enable_deadlock_detect</code> 。</p>
<p><strong>enable_deadlock_detect</strong>：</p>
<ul>
<li>syscall ID: 469</li>
<li>功能：为当前进程启用或禁用死锁检测功能。</li>
<li>C 接口： <code>int enable_deadlock_detect(int is_enable)</code></li>
<li>Rust 接口： <code>fn enable_deadlock_detect(is_enable: i32) -&gt; i32</code></li>
<li><strong>参数：</strong><ul>
<li>is_enable: 为 1 表示启用死锁检测， 0 表示禁用死锁检测。</li>
</ul>
</li>
<li><strong>说明：</strong><ul>
<li>开启死锁检测功能后， <code>mutex_lock</code> 和 <code>semaphore_down</code> 如果检测到死锁， 应拒绝相应操作并返回 -0xDEAD (十六进制值)。</li>
<li>简便起见可对 mutex 和 semaphore 分别进行检测，无需考虑二者 (以及 <code>waittid</code> 等) 混合使用导致的死锁。</li>
</ul>
</li>
<li>返回值：如果出现了错误则返回 -1，否则返回 0。</li>
<li><strong>可能的错误</strong><ul>
<li>参数不合法</li>
<li>死锁检测开启失败</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>思路：</strong></p>
<p>要为锁机制实现死锁检测，关键在于如何维护相关状态，并在检测前构造出合适的资源分配结构。我们可以从mutex开始：每个线程最多只需要一把锁，因为线程只有在获取所需的锁资源后才能继续执行，若没有锁资源可用，线程将会被阻塞。因此，为每个线程分配一个 <code>mutex_need</code> 变量，用来记录当前线程所需的锁的 id。</p>
<p>除此之外，我们还需要维护一个 <code>mutex_allocation</code> 向量，记录线程当前已获得但未释放的锁资源的 id。当线程调用 <code>sys_mutex_lock(mutex_id)</code> 请求锁时，在实际获取锁前，我们将当前线程的 <code>mutex_need</code> 设置为 <code>mutex_id</code>。当线程成功获得锁时，将 <code>mutex_id</code> 加入 <code>mutex_allocation</code> 向量，并将 <code>mutex_need</code> 置为空。这里可以使用 <code>usize::MAX</code> 来表示空值，也可以使用 <code>Option</code> 类型，后者更为优雅。</p>
<p>当线程调用 <code>sys_mutex_unlock(mutex_id)</code> 释放锁时，在实际释放锁前，首先查找并移除 <code>mutex_allocation</code> 向量中对应的 <code>mutex_id</code> 元素。</p>
<p>通过这种方式，我们能够在死锁检测之前，根据维护的信息构建出 <code>Available</code>、<code>Allocation</code> 和 <code>Need</code> 数据结构，进而使用银行家算法判断当前系统是否处于不安全状态。信号量的实现方式大致相同，但由于信号量的数量不再是二值的，因此线程的资源分配向量需要记录每个信号量的数量。我们可以用 <code>&lt;sem_id, cnt&gt;</code> 这样的二元组来表示，或者也可以使用 <code>cnt</code> 个 <code>sem_id</code> 元素。在这里，我采用前者。</p>
<p>此外，信号量还可以为负数，负值的绝对值表示资源的提前“透支”数量。在银行家算法中，<code>Available[i][j]</code> 不应为负值，若出现负数，应视为 0 处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">deadlock_check</span></span>(available: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;, allocation: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;&gt;, need: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;&gt;) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="comment">// n: thread count  m: resources count</span></span><br><span class="line">        <span class="keyword">let</span> (n, m) = (allocation.len(), allocation[<span class="number">0</span>].len());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> work = available;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> finish = <span class="built_in">vec!</span>[<span class="literal">false</span>; n];</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> idx = <span class="built_in">usize</span>::MAX;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> finish[i] &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">                    <span class="keyword">if</span> need[i][j] &gt; work[j] &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> flag &#123;</span><br><span class="line">                    idx = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// has found a thread meet the requirement</span></span><br><span class="line">            <span class="keyword">if</span> idx != <span class="built_in">usize</span>::MAX &#123;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">                    work[j] += allocation[idx][j];</span><br><span class="line">                &#125;</span><br><span class="line">                finish[idx] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finish.iter().all(|&amp;x| x)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="%E9%97%AE%E7%AD%94%E9%A2%98-lab5%2013a08b3cc7f180caaa7df2266f4cf7cc.md">问答题-lab5</a></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/12/22/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%88%B4%E5%BF%97%E5%BC%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/12/22/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%88%B4%E5%BF%97%E5%BC%BA/" class="post-title-link" itemprop="url">2024秋冬季训练营第四阶段总结-戴志强</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-22 21:07:52" itemprop="dateCreated datePublished" datetime="2024-12-22T21:07:52+00:00">2024-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="在训练营中做了什么"><a href="#在训练营中做了什么" class="headerlink" title="在训练营中做了什么"></a>在训练营中做了什么</h1><h2 id="rust的异步机制学习"><a href="#rust的异步机制学习" class="headerlink" title="rust的异步机制学习"></a>rust的异步机制学习</h2><p>在 Rust 的异步编程中，<code>async</code> 和 <code>await</code> 是不可忽略的核心概念。</p>
<p>当一个函数被标记为 <code>async</code> 时，它会被转换为一个返回 <code>Future</code> 的函数。实际上，<code>async</code> 函数并不是立即执行的，而是生成了一个 <code>Future</code>，表示一个可能尚未完成的异步计算。类似地，<code>async</code> 代码块的行为与 <code>async</code> 函数本质相同，都可以生成一个 <code>Future</code>。</p>
<p>调用 <code>async</code> 函数后，你需要使用 <code>await</code> 来获取其结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_func().<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>

<h3 id="await的作用"><a href="#await的作用" class="headerlink" title="await的作用"></a><strong>await的作用</strong></h3><p><code>await</code> 的核心任务是对 <code>Future</code> 进行轮询（poll）。当调用 <code>await</code> 时，程序会检查 <code>Future</code> 是否已完成。如果尚未完成，当前任务会被暂停，并将控制权交还给执行器（executor）。此时，CPU 资源可以被其他任务使用。随后，执行器会在适当的时机再次轮询该 <code>Future</code>，直到其完成。</p>
<hr>
<h3 id="异步任务的顺序"><a href="#异步任务的顺序" class="headerlink" title="异步任务的顺序"></a><strong>异步任务的顺序</strong></h3><p>考虑以下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func1().<span class="keyword">await</span>;</span><br><span class="line">func2().<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>

<p>如果 <code>func1</code> 中存在一个耗时的操作（例如 2 秒的延迟），在 <code>await</code> 首次轮询时，由于任务未完成，执行器会暂停该任务并继续寻找其他可以执行的任务，例如 <code>func2</code>。这样就实现了异步调度。</p>
<p>然而，如果你在异步代码中混合了同步操作，比如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func1().<span class="keyword">await</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure>

<p>这种情况下，<code>func1</code> 的任务未完成时，程序会暂停整个任务链，而不会直接跳到同步代码。也就是说，<code>println!(&quot;1&quot;)</code> 的执行必须等到 <code>func1</code> 完成后才能继续。这表明异步任务的执行顺序可以调整，但同步代码的执行仍然是严格按顺序进行的。</p>
<hr>
<h3 id="async-await的底层原理"><a href="#async-await的底层原理" class="headerlink" title="async/await的底层原理"></a><strong>async/await的底层原理</strong></h3><p><code>async</code> 和 <code>await</code> 的实现涉及编译器的转换。在编译时，所有 <code>async</code> 函数会被转换为状态机。这种状态机的实现方式类似于无栈协程。每个 <code>Future</code> 都维护着一个状态，记录其当前的执行进度。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PollResult</span></span> &#123;</span><br><span class="line">    Ready,</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    StateA,</span><br><span class="line">    StateB,</span><br><span class="line">    StateC,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coroutine</span></span> &#123;</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Coroutine &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; PollResult &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">            State::StateA =&gt; &#123;</span><br><span class="line">                <span class="comment">/* Do something */</span></span><br><span class="line">                <span class="keyword">self</span>.state = State::StateB;</span><br><span class="line">                <span class="keyword">return</span> PollResult::Pending;</span><br><span class="line">            &#125;</span><br><span class="line">            State::StateB =&gt; &#123;</span><br><span class="line">                <span class="comment">/* Do something */</span></span><br><span class="line">                <span class="keyword">self</span>.state = State::StateC;</span><br><span class="line">                <span class="keyword">return</span> PollResult::Pending;</span><br><span class="line">            &#125;</span><br><span class="line">            State::StateC =&gt; &#123;</span><br><span class="line">                <span class="comment">/* Do something */</span></span><br><span class="line">                <span class="keyword">return</span> PollResult::Ready;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 poll 函数即为协程的具体运行函数，不难看出其是一个状态机模型，上层每次调用 poll 时都可能改变其状态，从而推进其运行；总的来说，无栈协程的调度是通过函数返回然后调用另一个函数实现的，而不是像有栈协程那样直接原地更改栈指针。</p>
<p>此外，编译器会为异步函数生成一个表，类似于 C++ 的虚函数表（vtable）。每当一个任务暂停时，执行器会通过这个表找到下一个可以执行的任务，并对其进行轮询。这种机制确保了异步任务之间的高效调度和协作。</p>
<p>通过这些特性，Rust 实现了高性能的异步编程，同时避免了传统回调方式的复杂性，保证了代码的可读性和可靠性。</p>
<h2 id="Phoenix-异步内核学习"><a href="#Phoenix-异步内核学习" class="headerlink" title="Phoenix 异步内核学习"></a>Phoenix 异步内核学习</h2><p>在这个内核中，异步任务的执行流是通过 Rust 的 <code>async</code> 和 <code>await</code> 特性来实现的。以下是执行流的一个简要过程。</p>
<h3 id="任务的核心调度"><a href="#任务的核心调度" class="headerlink" title="任务的核心调度"></a><strong>任务的核心调度</strong></h3><p>首先，从内核的主循环开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    executor::run_until_idle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>run_until_idle</code> 是任务调度的入口，其核心逻辑如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run_until_idle</span></span>() -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = TASK_QUEUE.fetch() &#123;</span><br><span class="line">            task.run();</span><br><span class="line">            n += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它从任务队列中提取任务并运行，直到队列为空。这里的任务可以是一个用户线程，也可以是其他异步任务。</p>
<hr>
<h3 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a><strong>线程的定义</strong></h3><p>内核将线程与进程分开设计。线程的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Thread</span></span> &#123;</span><br><span class="line">    tid: Arc&lt;TidHandle&gt;,</span><br><span class="line">    mailbox: Mailbox,</span><br><span class="line">    <span class="keyword">pub</span> sig_trampoline: SignalTrampoline,</span><br><span class="line">    <span class="keyword">pub</span> process: Arc&lt;Process&gt;,</span><br><span class="line">    <span class="keyword">pub</span> sig_queue: SpinNoIrqLock&lt;SigQueue&gt;,</span><br><span class="line">    <span class="keyword">pub</span> inner: UnsafeCell&lt;ThreadInner&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然内部资源管理方式与传统内核略有不同，但核心思想是一致的：通过 <code>Thread</code> 表示一个具体的任务实体。</p>
<p>在内核中，当加载一个 ELF 文件并创建线程时，会生成一个 <code>Thread</code> 实例。随后，这些线程会被包装为异步任务进行管理。</p>
<hr>
<h3 id="线程生命周期的实现"><a href="#线程生命周期的实现" class="headerlink" title="线程生命周期的实现"></a><strong>线程生命周期的实现</strong></h3><p>线程的执行过程通常包括以下几步：</p>
<ol>
<li>加载用户态寄存器（<code>ld regs</code>）。</li>
<li>返回用户态执行（<code>sret</code>）。</li>
<li>用户态发生中断时，陷入内核处理（<code>trap</code>）。</li>
<li>继续返回用户态，循环往复，直到线程终止。</li>
</ol>
<p>在一些传统内核中，这个循环过程可能直接用汇编实现（通常写在 <code>.S</code> 文件中）。但在该内核中，将线程生命周期抽象为 Rust 异步函数来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">threadloop</span></span>(thread: Arc&lt;Thread&gt;) &#123;</span><br><span class="line">    thread.set_waker(async_utils::take_waker().<span class="keyword">await</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        trap::user_trap::trap_return();</span><br><span class="line">        trap::user_trap::trap_handler().<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> thread.is_zombie() &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handle_exit(&amp;thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设计的关键在于使用 <code>async</code> 将线程的整个生命周期建模为一个 <code>Future</code>，使得线程的运行和中断处理都可以以异步方式进行，而无需依赖汇编实现。这种方式可以充分利用 Rust 异步编程的特性。</p>
<hr>
<h3 id="任务的-Future-封装"><a href="#任务的-Future-封装" class="headerlink" title="任务的 Future 封装"></a><strong>任务的 Future 封装</strong></h3><p>内核将每个线程包装为一个 <code>Future</code>，具体定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">UserTaskFuture</span></span>&lt;F: Future + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt; &#123;</span><br><span class="line">    task_ctx: <span class="built_in">Box</span>&lt;LocalContext&gt;,</span><br><span class="line">    task_future: F,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: Future + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt; Future <span class="keyword">for</span> UserTaskFuture&lt;F&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = F::Output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> this = <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.get_unchecked_mut() &#125;;</span><br><span class="line">        <span class="keyword">let</span> hart = processor::local_hart();</span><br><span class="line">        hart.push_task(&amp;<span class="keyword">mut</span> this.task_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> ret = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="keyword">mut</span> this.task_future).poll(cx) &#125;;</span><br><span class="line">        hart.pop_task(&amp;<span class="keyword">mut</span> this.task_ctx);</span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>task_ctx</code> 包含 CPU 上下文和线程指针，负责管理任务的运行状态。</p>
<p>在初始化时，线程会被封装成 <code>Future</code>，并推入调度队列：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn_thread</span></span>(thread: Arc&lt;Thread&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> future = UserTaskFuture::new(thread.clone(), threadloop(thread));</span><br><span class="line">    <span class="keyword">let</span> (runnable, task) = executor::spawn(future);</span><br><span class="line">    runnable.schedule();</span><br><span class="line">    task.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的 <code>threadloop</code> 被作为一个 <code>Future</code> 传递给 <code>UserTaskFuture::new</code>，从而将线程的整个生命周期管理交由异步调度器。</p>
<h2 id="异步的实现"><a href="#异步的实现" class="headerlink" title="异步的实现"></a>异步的实现</h2><p>我尝试对 rCore 内核进行异步化改造，利用 Rust 提供的 <code>async</code> 和 <code>await</code> 实现异步编程。参考了 <a href="https://github.com/AsyncModules/async-os/tree/main/modules/trampoline" target="_blank" rel="noopener">Phoenix</a> 的实现思路，将进出用户态等流程封装为一个协程。由于这是我第一次接触操作系统相关知识，在重构内核时，需要通过大量的调试来有机地理解和掌握内核的整体工作流程。然而，受限于期末周和其他大作业的时间压力，目前仅完成了将进出用户态等过程迁移到协程中的初步工作，仍有许多细节尚未完善。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/12/22/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%9B%B9%E8%BE%B0%E5%AE%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/12/22/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%9B%B9%E8%BE%B0%E5%AE%87/" class="post-title-link" itemprop="url">第四阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-22 15:16:26" itemprop="dateCreated datePublished" datetime="2024-12-22T15:16:26+00:00">2024-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-26 07:47:16" itemprop="dateModified" datetime="2025-12-26T07:47:16+00:00">2025-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四阶段总结报告"><a href="#第四阶段总结报告" class="headerlink" title="第四阶段总结报告"></a>第四阶段总结报告</h1><h3 id="一些碎语"><a href="#一些碎语" class="headerlink" title="一些碎语"></a>一些碎语</h3><p>我查看了三篇文档 ， 其中<a href="https://os.phil-opp.com/async-await/#pinning" target="_blank" rel="noopener">https://os.phil-opp.com/async-await/#pinning</a></p>
<p>新使用的crate：crossbeam ,conquer_once</p>
<p>为啥使用conquer_once的OnceCell而不是lazy_static!因为这个类型实现<br>了避免中断程序进行堆空间开辟（从而避免产生一个死锁）</p>
<p>future 中还有一个Stream的trait<br>tokio文档看了一下（trait回忆一下，它像个接口，implement后应用到具体的一个类型）</p>
<h2 id="Tokio-文档阅读"><a href="#Tokio-文档阅读" class="headerlink" title="Tokio 文档阅读"></a>Tokio 文档阅读</h2><h3 id="chat"><a href="#chat" class="headerlink" title="chat"></a>chat</h3><p>首先阅读的是一堆example，这里先看chat。<br>chat是一个聊天室，设立服务端然后异步读取其他客户端的消息，并且广播到是所有的客户端，<br>是一种中心式结构</p>
<h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><h3 id="与linux"><a href="#与linux" class="headerlink" title="与linux"></a>与linux</h3><p>linux有一个自己的原生异步IO接口，叫aio,他有一些问题：</p>
<ol>
<li>因为0_DIRECT，所以很多的IO用例不适用。普通的IO会退化为同步IO。</li>
<li>就算异步，IO也可能会阻塞，比如硬件部分，这使得软件必须获取加载这些部分的锡信息</li>
<li>API不够完美，每次提交需要64+8字节的内存，每次完成徐娅萍<br>他常用的方法是：io_submit() , io_setup()  , io_getevents().</li>
</ol>
<h3 id="io-uring-和-epoll。"><a href="#io-uring-和-epoll。" class="headerlink" title="io-uring 和 epoll。"></a>io-uring 和 epoll。</h3><p>epoll 只是通知机制，本质上事情还是通过用户代码直接 syscall 来做的，如 read。这样在高频<br>syscall 的场景下，频繁的用户态内核态切换会消耗较多资源。io-uring 可以做异步 syscall，<br>即便是不开 SQ_POLL 也可以大大减少 syscall 次数。</p>
<p>io-uring 的问题在于下面几点：</p>
<p><strong>兼容问题</strong>。平台兼容就不说了，linux only（epoll 在其他平台上有类似的存在，可以基于已<br>经十分完善的 mio 做无缝兼容）。linux 上也会对 kernel 版本有一定要求，且不同版本的实现性<br>能还有一定差距。大型公司一般还会有自己修改的内核版本，所以想持续跟进 backport 也是一件头疼<br>事。同时对于 Mac/Windows 用户，在开发体验上也会带来一定困难。</p>
<p><strong>Buffer 生命周期问题</strong>。io-uring 是全异步的，Op push 到 SQ 后就不能移动 buffer，一定<br>要保证其有效，直到 syscall 完成或 Cancel Op 执行完毕。无论是在 C/C++ 还是 Rust 中，都<br>会面临 buffer 生命周期管理问题。epoll 没有这个问题，因为 syscall 就是用户做的，陷入 sy<br>scall 期间本来就无法操作 buffer，所以可以保证其持续有效直到 syscall 返回。</p>
<h2 id="smol"><a href="#smol" class="headerlink" title="smol"></a>smol</h2><p>在几个库的基础上封装成最后几个接口</p>
<p>在 Linux 上，mio 使用 epoll 来实现高效的 I/O 多路复用。smol 使用 mio 来实现<br>这一点。具体来说，smol 会将 I/O 操作抽象为异步任务，然后将这些任务交给 mio 处理。<br>mio 通过 epoll 监听文件描述符，当某个文件描述符变得可读或可写时，它会通知 smol 来<br>执行相应的任务。</p>
<p>在 smol 的源码中，底层通过调用 mio 提供的异步 I/O API 来实现任务的异步调度。例如<br>，读取数据时，它会发出 epoll 查询，直到某个文件描述符准备好读取数据，才会从事件队列中获<br>取该事件并执行对应的异步任务。</p>
<h2 id="关于我的运行时"><a href="#关于我的运行时" class="headerlink" title="关于我的运行时"></a>关于我的运行时</h2><p>用proactor包装io_uring实现基本的异步读写，然后再包装proactor实现io和file，然后没有什么了，<br>一开始低估了整个运行时的大小</p>
<p>然后看了很多的文档：</p>
<p><a href="https://github.com/rust-lang/futures-rs/blob/master/futures-core/src/stream.rs" target="_blank" rel="noopener">https://github.com/rust-lang/futures-rs/blob/master/futures-core/src/stream.rs</a><br><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_12/monoio.html" target="_blank" rel="noopener">https://rustmagazine.github.io/rust_magazine_2021/chapter_12/monoio.html</a><br><a href="https://github.com/bytedance/monoio/blob/master/docs/zh/io-cancel.md" target="_blank" rel="noopener">https://github.com/bytedance/monoio/blob/master/docs/zh/io-cancel.md</a><br><a href="https://github.com/ihciah/mini-rust-runtime/blob/master/src/tcp.rs" target="_blank" rel="noopener">https://github.com/ihciah/mini-rust-runtime/blob/master/src/tcp.rs</a><br><a href="https://github.com/rust-lang/futures-rs/blob/master/futures-core/src/lib.rs" target="_blank" rel="noopener">https://github.com/rust-lang/futures-rs/blob/master/futures-core/src/lib.rs</a></p>
<p>这里我认为monoio算是一个正确的，完善的运行时，不过这个大小太夸张了，可以下期一开始就把它粘出来，让大家<br>直观感受一下成果的规模。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/blog/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/76/">76</a><a class="extend next" rel="next" href="/blog/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
