<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/21/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/21/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">587</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">537</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/24/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E5%88%98%E6%A2%93%E9%99%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/24/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E5%88%98%E6%A2%93%E9%99%86/" class="post-title-link" itemprop="url">2024开源操作系统训练营第一阶段总结-刘梓陆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-24 10:04:16" itemprop="dateCreated datePublished" datetime="2024-05-24T10:04:16+00:00">2024-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024-开源操作系统训练营第二阶段总结-刘梓陆"><a href="#2024-开源操作系统训练营第二阶段总结-刘梓陆" class="headerlink" title="2024 开源操作系统训练营第二阶段总结-刘梓陆"></a>2024 开源操作系统训练营第二阶段总结-刘梓陆</h1><ul>
<li><a href="#2024-开源操作系统训练营第二阶段总结-刘梓陆">2024 开源操作系统训练营第二阶段总结-刘梓陆</a><ul>
<li><a href="#写在前面">写在前面</a></li>
<li><a href="#欢迎交流-">欢迎交流;-）</a></li>
<li><a href="#os-大概是个什么东西捏我在完成了这个阶段的任务之后的理解">OS 大概是个什么东西捏？我在完成了这个阶段的任务之后的理解</a><ul>
<li><a href="#os-下面还有一个-sbi">os 下面还有一个 sbi？</a></li>
<li><a href="#毫无疑问就是一个应用程序">毫无疑问就是一个应用程序</a></li>
<li><a href="#通过寄存器和-pc-的指令流">通过寄存器和 pc 的指令流</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>真是一段很长的旅程啊，怎么说呢，这一阶段的任务我基本上都是“挣扎”着完成的，一开始感觉以我对 Rust 和 OS 的理解，应该此阶段的任务不会非常困难。后来发现还得是“纸上得来终觉浅，绝知此事要躬行”，有些东西在课上学习理论知识和实际使用代码进行实现完全是不一样的感觉，而且怎么说呢，Rust 的运用程度实际上对编写操作系统的帮助也不是特别大，就好像你要和<em>亚里士多德</em>探讨哲学问题，重点是这个哲学问题，而不是<em>古希腊语</em>，当然你得先对古希腊语有一个大致的了解，但是古希腊语本身对理解这个哲学问题是没有什么帮助的。</p>
<p>反正总之由于种种原因，我感觉我在这方面的经验根本就是 0，导致本阶段的任务超出截止时间一周差不多才完成。</p>
<p>但是怎么说呢，就好比是 DND 里面的等级系统一样，在等级为 1 的情况下，升到 2 级所需要的经验值是很少的，所以这个训练营给我的提升感觉也特别大（OS 子职等级），了解到了很多之前根本没有机会接触的知识领域，最重要的，更是加深了我对 os 的理解。</p>
<p>我在第一阶段的总结之中也提到了我非常崇拜 Linux，现在感觉我离他好像又进一步了，感到非常开心！</p>
<h2 id="欢迎交流-）"><a href="#欢迎交流-）" class="headerlink" title="欢迎交流;-）"></a>欢迎交流;-）</h2><p>在写这篇博客时，本人<strong>东北大学</strong>大三在读，前两年东学西学，Rust 就是之一，说实话，在本学期开始时，我实在找不到什么东西来做，准备先买一本《趣读 Linux 源码》来看，感谢我学弟<strong>翊嘉</strong>，是他给我推荐了这个操作系统训练营，这样直接上手操作系统的效果比看书要好太多了，真的十分感谢！</p>
<p>我对 Rust 的理解还是比较少，future、unsafe 的内容更是知之甚少，所以大佬求带！看到我这篇总结报告之中有什么不足也请指出！</p>
<ul>
<li>github ID: <a href="https://github.com/destinyFvcker" target="_blank" rel="noopener">destinyFvcker</a></li>
<li>邮箱：<a href="mailto:&#x64;&#101;&#115;&#x74;&#x69;&#x6e;&#121;&#x66;&#117;&#110;&#107;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#109;">&#x64;&#101;&#115;&#x74;&#x69;&#x6e;&#121;&#x66;&#117;&#110;&#107;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#109;</a></li>
<li>微信号：wxid_r3se52q2d4pg22</li>
</ul>
<h2 id="OS-大概是个什么东西捏？我在完成了这个阶段的任务之后的理解"><a href="#OS-大概是个什么东西捏？我在完成了这个阶段的任务之后的理解" class="headerlink" title="OS 大概是个什么东西捏？我在完成了这个阶段的任务之后的理解"></a>OS 大概是个什么东西捏？我在完成了这个阶段的任务之后的理解</h2><p>最近在看 Linus 的自传，他在里面讲了一段关于 OS 的话感觉说得特别好：</p>
<blockquote>
<p>计算机上的所有功能要起作用，都得以操作系统为基础。于是，创造一个操作系统就成了终极挑战。你创造操作系统的时候，相当于给所有在这部电脑上跑的程序创造了一个全新的生存环境—从根本上说，其实就是在制定这个世界的规则：什么事可以接受、可以做，什么事不可以接受、不可以做。其实所有的程序都是在制定规则，只不过操作系统制定的是最根本的规则。创造一个操作系统，就相当于自己创造的一方土地制定宪法，而在电脑上跑的程序则相当于各式各样的普通法律。</p>
</blockquote>
<p>这段话形象地表达了操作系统的功能、作用、以及它对上层应用程序强大的控制能力，但是实际上感觉在实现了一些东西之后，好像也不完全是这样。</p>
<h3 id="os-下面还有一个-sbi？"><a href="#os-下面还有一个-sbi？" class="headerlink" title="os 下面还有一个 sbi？"></a>os 下面还有一个 sbi？</h3><p>原来就是认为是下面这个层级关系：</p>
<ul>
<li>计算机硬件 -&gt; os -&gt; user application</li>
</ul>
<p>但是在使用 RISC-V 实际上应该是这样的！</p>
<ul>
<li>计算机硬件 -&gt; sbi -&gt; os -&gt; user application</li>
</ul>
<p>实际上操作系统也要向下请求 sbi 提供的功能！在本次训练营之中一个比较常用的功能——往屏幕上输出字符就是通过 sbi 完成的。实际上完全不止于此，SBI 还会在计算机启动的时候进行它所负责的环境初始化工作，并将计算机控制权移交给内核，操作系统的关闭也是由 SBI 控制的。</p>
<p>从 RISC-V 特权级架构的视角来看，我们编写的 OS 内核位于 Supervisor 特权级，而 RustSBI 位于 Machine 特权级，也是最高的特权级。</p>
<p>说实话，我对 SBI 的理解就到此为止了，在代码之中，很贴心地向我们提供了 SBI 服务调用的接口，我们直接使用就可以了。</p>
<hr>
<p><strong>这部分我感觉还不是很清楚的内容：</strong><br>SBI 的内容我感觉真的后续还有必要继续学习一下。</p>
<hr>
<h3 id="毫无疑问就是一个应用程序"><a href="#毫无疑问就是一个应用程序" class="headerlink" title="毫无疑问就是一个应用程序"></a>毫无疑问就是一个应用程序</h3><p>在本阶段的相关代码项目之中，除了一些关键的处理 Trap 和上下文切换的逻辑是使用汇编进行编写的之外，其他都是使用 Rust 编写的、和普通的用户应用程序并没有什么不同。</p>
<p>在实现了地址空间之后，基本上就完全停留在逻辑上的开发了，不再关心操作系统的实现细节，实际上我在实现了进程和文件系统的相关功能之后回头一看都感觉地址空间之中的一些实现细节都开始遗忘了。</p>
<hr>
<p><strong>这部分我感觉还不是很清楚的内容：</strong><br>Rust 编译器是如何将这个汇编代码和 Rust 代码链接在一起的？<br>而且在 Rust 之中是如何调用在汇编代码之中定义的过程的？</p>
<hr>
<h3 id="通过寄存器和-pc-的指令流"><a href="#通过寄存器和-pc-的指令流" class="headerlink" title="通过寄存器和 pc 的指令流"></a>通过寄存器和 pc 的指令流</h3><p>而且我发现真的一个应用程序实际上非常简单，就是一堆指令，pc 拿到之后一条条执行，然后会有一个跳转指令跳转到另外一条指令进行执行，然后指令的操作数都是从寄存器拿出来的，线程或者进程实际上就是一个包装了指令流的上下文，在里面进行了一些簿记工作，记录了当前指令进行到了哪里，然后一些相关寄存器的状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/22/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-c2h4moe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/22/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-c2h4moe/" class="post-title-link" itemprop="url">二阶段总结报告--c2h4moe</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 19:47:45" itemprop="dateCreated datePublished" datetime="2024-05-22T19:47:45+00:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>狂赶一周，二阶段也算是终于做完了，这里就说说实验中令我印象比较深的部分吧。</p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>操作系统为每个应用程序制造了一种假象，仿佛它们能够独占并随意的使用巨大的内存空间，但实际上，这是硬件分页机制和操作系统维护页表共同营造的幻觉，在加载ELF文件时，操作系统会把程序加载到物理地址中一段空闲的区间，但会让ELF文件中指定的加载地址对应的页表指向真正的物理地址。</p>
<p>我觉得这个实验需要注意很多细节，比如，页表切换是一条指令完成的，如何保证切换完之后依然能够按照我们所期望的执行流继续执行呢？我们开辟了一个“跳板页”，让所有地址空间的最高一页都指向一段相同的物理地址，这样就可以保证页表切换是“平滑的”。</p>
<p>还有，之前想了很久为什么用户态的上下文是存在用户的地址空间而非内核的，后来看实验指导书才明白页表切换和内核栈切换是两步操作，但只有一个sscratch寄存器，无法在不破坏通用寄存器的条件下切换到内核空间并在内核栈保存上下文。</p>
<p>这章还有很多技术上的优化技巧，比如，如果为每个应用都建立一个能够映射全部空间的页表，会占有过大的物理空间，所以，我们不再对每一个地址都映射，而是根据ELF文件的程序头一段段来映射，并且引入类似“字典树”的数据结构来建立多级页表，有效的节省了空间。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>实现互斥锁可以有三种方式，一种是在纯软件形式在用户态通过类Peterson算法</p>
<p>实现锁，还有是在硬件的支持下通过原子指令来实现，还可以通过操作系统支持（假设内核进程不被打断）。</p>
<p>这章给我印象比较深的部分是引入互斥锁时举了一个计数器的例子，根据例子运行的异常提供了3个分析思路：是不是编译优化造成的？是不是OS调度造成的？是不是CPU造成的？并且逐一分析，最终找到根本原因，我认为这给我了一个关于系统编程方法论的启发。并且在分析错误原因时通过状态机和合法状态来分析，也是一个很深刻的想法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了上面说的一些底层的特性（页表，地址空间切换等等），操作系统大部分也只不过是个普通的应用程序。在看框架代码时，我也学习到了一些编程的技巧和方法，比如，通过drop trait来实现RAII，通过这个rust机制有效的减少了内存分配相关的错误。</p>
<p>总体来说，不管是对OS的理解，还是对rust的掌握，我都进步了很多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/21/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94Air-Suck/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/21/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94Air-Suck/" class="post-title-link" itemprop="url"><2024开源操作系统训练营总结报告——Air-Suck></a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-21 19:59:36" itemprop="dateCreated datePublished" datetime="2024-05-21T19:59:36+00:00">2024-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024春夏季开源操作系统训练营总结报告"><a href="#2024春夏季开源操作系统训练营总结报告" class="headerlink" title="2024春夏季开源操作系统训练营总结报告"></a>2024春夏季开源操作系统训练营总结报告</h1><h2 id="第一阶段总结报告"><a href="#第一阶段总结报告" class="headerlink" title="第一阶段总结报告"></a>第一阶段总结报告</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名大二在读生，在听同学说有一门语言很炫酷的时候，就算是面对着巨大的课业压力，我还是选择来看看rust到底是什么样的一门语言。</p>
<h3 id="Rustlings总结"><a href="#Rustlings总结" class="headerlink" title="Rustlings总结"></a>Rustlings总结</h3><p>刚刚接触rust语言时，我并没有意识到rust的强大之处，认为它只是一门新的语言罢了。但是当我跟着文档一步步去接触rust中全新的概念时，我才发现这门语言与其他的编程语言有多大的区别。</p>
<p>从rust变量的所有权与借用规则，再到后面的智能指针和生命周期，每一个特性都是那么晦涩难懂。我甚至在刚刚接触这些特性时，认为这些特性就是在束缚我，<strong>让我没法自由自在的编程</strong>。我甚至真的想过直接给我的所有rust代码套上一个unsafe。</p>
<p>但是没有束缚的自由也确实不是真正的自由。随着学校课程，尤其是操作系统课程的推进，让我知道了rust的所有权、借用规则以及智能指针，都是为了从语言层面提高整个计算机系统的性能，包括但不限于防止内存泄漏、不让指针乱飞、实现共享区互斥访问等。让我不用像写C语言一样，总是要考虑堆上变量有没有free，指针到底是几级指针，到底指的是什么玩意。不得不承认，经过rustlings110道练习的磨炼，我意识到，rust在通过它的特性，<strong>让我更自由的编程</strong>。</p>
<p>从头开始学习一门语言是不容易的，尤其是学习像rust这样特性贼多的语言。我在这里要感谢一位之前一直被我忽视的一位朋友——编译器。在之前编程时，不论是写C还是写Java，又或者是写Go，我总是认为编译器只不过是在检查我的语句是不是合法罢了。但是在写rust时，我就深深感受到，没有rust编译器，单单靠我一团浆糊的脑子和厚厚的文档，我是学不会rust的，甚至说都难以写出符合rust语法的程序。每次的报错都让我能够更深地了解rust的语言特性，每次的help，都能让我精确无误的修改错误。编译器好像一直在对我说：“嘿，跟着哥，哥带你学rust。”</p>
<p>希望我能够在接下来的阶段乃至之后与rust同行的时间里，跟着rust编译器，不断加深对rust的理解。</p>
<p>嘿，把rust当做母语真的很酷好吗。</p>
<h2 id="第二阶段总结报告"><a href="#第二阶段总结报告" class="headerlink" title="第二阶段总结报告"></a>第二阶段总结报告</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>进入到第二阶段的同时，学校其实也开始进入了期末考试的阶段，每天我说的最多的一句话就是：汗流浃背了。但是好在，我还是走完了这一艰难但是有意义的阶段。</p>
<h3 id="1-2-应用程序基本执行环境与批处理系统"><a href="#1-2-应用程序基本执行环境与批处理系统" class="headerlink" title="1-2 应用程序基本执行环境与批处理系统"></a>1-2 应用程序基本执行环境与批处理系统</h3><p>虽然第一章和第二章并没有让我动手实践，但是看着文档一步步从搭建最小环境，再到实现自己的print，再到实现riscv特权级的切换。很难想象这是我在两章里面能学到的东西。</p>
<h3 id="3-多道程序与分时多任务"><a href="#3-多道程序与分时多任务" class="headerlink" title="3 多道程序与分时多任务"></a>3 多道程序与分时多任务</h3><p>从这里开始，我终于能上手碰碰操作系统了。</p>
<p>这个实验主要是要让我通过rust实现一个任务状态查询的系统调用。我最自然的想法是，任务状态一定是跟任务绑定的，所以我直接在TCB中新增了一个计算系统调用的成员变量。实现下来也是非常自然顺畅的。但是我知道这个方法应该不是最好的方法，毕竟要在TCB中创建一个挺大的数组，而TCB是属于操作系统内核的，并且操作系统中可能有许多的任务，这样就会导致操作系统内核比较臃肿。</p>
<h3 id="4-地址空间"><a href="#4-地址空间" class="headerlink" title="4 地址空间"></a>4 地址空间</h3><p>这一章就涉及到了我之前很少接触到的部分——虚拟地址空间。</p>
<p>从sv39多级页表机制到内核与应用的地址空间，这些内容都挺让我头大的。虽然在进入第四章时走了点弯路，编写代码的时候甚至没有涉及到逻辑段。当后来发现其实框架代码中有一些函数接口可以直接调用（如：shrink_to、append_to、insert_framed_area等），我就开始吐槽之前浪费了太多的时间。但是现在想想，这一段小插曲让我对虚拟地址空间有了更深的了解：从分配物理页帧，到建立虚拟地址和物理地址之间的映射，再到用户程序逻辑段的构建。艰难但有意义。</p>
<h3 id="5-进程及进程管理"><a href="#5-进程及进程管理" class="headerlink" title="5 进程及进程管理"></a>5 进程及进程管理</h3><p>本章主要实现操作系统中一个重要的系统调用——spawn。此外还涉及到了一种调度算法——stride调度算法</p>
<p>spawn与fork+exec的最大的区别就是，spawn并不需要像fork一样完全复制父进程的地址空间，并依此再创建一个TCB，然后再通过exec将TCB重写为需要执行的用户程序的TCB。它是直接根据新的用户程序创建一个TCB，省去了重写TCB的开销。所以如果要实现一个spawn系统调用，就只需要模仿fork来实现就好了。</p>
<p>而stride调度算法就是在TCB中增加两个成员stride和priority，在不考虑性能的情况下，只需要遍历就绪队列并执行 stride最小的任务即可。但是受于双端队列的限制，就只能从队列中取出一个TCB然后进行比较，如果stride比当前已经选出的TCBstride还大的话就重新将其放回就绪队列，这样可行，但是会导致更大的系统开销。</p>
<h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul>
<li>由于系统终止一个进程的时候是根据TCB的Arc指针强引用数量来判断的，所以很多地方就不能让编译器帮我drop变量，而是需要进行显式的变量drop。</li>
</ul>
<h3 id="6-文件系统与I-O重定向"><a href="#6-文件系统与I-O重定向" class="headerlink" title="6 文件系统与I/O重定向"></a>6 文件系统与I/O重定向</h3><p>在这一章的实验中我对操作系统中的另一个重要部分——文件系统有了基本的认识</p>
<p>从最底层的块设备、缓存，再到上层的文件系统以及操作系统相关的系统调用，学习下来我的感觉就是——多且杂，搞不明白为什么要分这么多层。但是现在回想一下这一切都是有意义的，这些分层让文件系统的不同层的代码高度解耦合，提高了文件系统的可移植性。</p>
<p>实验要求实现建立硬链接、释放硬链接以及查询文件状态系统调用。对于建立硬链接，我就按照文档上的提示按部就班为相同的磁盘索引块再创建了一个目录项。但是对于释放硬链接需要考虑的东西就多了：当一个文件在释放当前硬链接之后还存在硬链接的话，就只需要将磁盘上的某个目录项删除；当一个文件在释放当前硬链接之后没有硬链接了，那就需要将其在磁盘上所有的空间回收（虽然有同学说就算没有回收也能过测试用例）。而对于查询文件状态，我就是将需要查询的字段作为成员放在磁盘索引节点中，这样就能实现就算系统断电，文件的状态也不会丢失（由于是存储在磁盘块上而不是在内存中）</p>
<h4 id="一些注意点-1"><a href="#一些注意点-1" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul>
<li>删除目录项的时候按道理来说不能仅仅是将该目录项清零，而是应该将后面的目录项移动到前面来，并且如果移动后刚好空出了一个磁盘块，还需要去回收该磁盘块。但是在我的代码中仅仅实现到了将后面的目录项移动到前面，之后有时间可以尝试去改进一下。</li>
<li>在给磁盘索引节点增加成员的时候一定要减少直接索引的数量以保证一个磁盘块的大小是128字节。</li>
</ul>
<h3 id="7-8-进程间通信与并发"><a href="#7-8-进程间通信与并发" class="headerlink" title="7-8 进程间通信与并发"></a>7-8 进程间通信与并发</h3><p>这两章的实验主要实现了一个重要的算法——死锁检测算法</p>
<p>这个算法其实在学校的课程中学过，是一个非常类似于银行家算法的算法，但是银行家算法是为了避免死锁。</p>
<p>这个算法中我觉得最让我摸不着头脑的就是need矩阵到底应该如何初始化。Available矩阵可以根据剩余的信号量或者锁是否被占用来实现；Allocation可以根据查询当前哪些线程在占据资源来确定。而need呢？显然不能单从信号量和锁的阻塞队列来确定。</p>
<p>从结果来看，其实应该是我的理解错了，我将死锁检测算法和银行家算法混淆了。我之前一直以为死锁检测算法中的need是一个线程在<strong>全局角度</strong>上对资源的需求量。而实际上need矩阵只是系统在<strong>当前状态</strong>下各个线程对资源的需求量，在每次需要分配资源时都需要调用死锁检测算法。所以死锁检测算法中的need矩阵是由信号量或者锁的阻塞队列以及当前请求资源的线程决定的。接下来只需要按照算法描述进行编码问题就迎刃而解了。</p>
<p>虽然第三阶段的时间与学校期末考试的时间完美重合，但是从第二阶段的学习中我真正感受到了操作系统的魅力，冲就完了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-OSFantasy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-OSFantasy/" class="post-title-link" itemprop="url">2024开源操作系统训练营第二阶段总结-OSFantasy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 19:16:19" itemprop="dateCreated datePublished" datetime="2024-05-19T19:16:19+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二阶段-OS设计实现"><a href="#第二阶段-OS设计实现" class="headerlink" title="第二阶段 - OS设计实现"></a>第二阶段 - OS设计实现</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>由于我是二刷了，所以一阶段很快就搞完了，然后提前了一个月左右弄二阶段。最后赶在了五一假期前做完了二阶段的Lab。（PS：不得不说，群友都好强，Orz）</p>
<p>然后我五一假期过后，训练营学习基本上就有些摆了（除了上课就没干啥了）。一方面原因是学校课程忽然要考试了，二是不得不重视英语学习了，三是自制力下降了很多。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E8%9E%8D%E5%8C%96.png" alt="融化"></p>
<p>虽然是二刷训练营了，但是这次是第一次参与到二阶段的学习中（上次二阶段还没开始就没搞了）。不得不说二阶段真的学到了好多关于OS相关的知识，同时代码的实操非常有用。（PS：Tutorial-Book-V3的step-by-step真的很棒）</p>
<p>我本人是非计算机专业的，对于本次二阶段来说，基本上算是零基础了（没学过计组、操作系统概论、CSAPP、计算机体系结构等）。不过好在的是我对于单片机的开发还是比较熟悉的，在二阶段的学习中我也发现了OS开发和单片机开发的很多相似之处，比如：STM32有个东西叫HAL库，OS中有个东西叫HAL层(也就是SBI)，它两都是对硬件的一层抽象。</p>
<h2 id="1-环境与工具软件等"><a href="#1-环境与工具软件等" class="headerlink" title="1 环境与工具软件等"></a>1 环境与工具软件等</h2><h3 id="RustRover"><a href="#RustRover" class="headerlink" title="RustRover"></a>RustRover</h3><p>还是强推RustRover。毕竟rCore的代码量可不小，用vim在多个文件间切换太麻烦了。而且RR可以方便的查看函数的使用和trait的impl。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-19%20194056.png" alt="RR"></p>
<p>另外提一下，我在使用Ubuntu22上的RR2024.3时遇到了闪退问题。换回到RR2023后解决了。</p>
<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><p>这个主要是用来模拟一个risc-v64的机器在我们的x86_64的电脑上。</p>
<p>在安装的时候可能会遇到一个坑，就是在执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 安装编译所需的依赖包</span><br><span class="line">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \</span><br><span class="line">              gawk build-essential bison flex texinfo gperf libtool patchutils bc \</span><br><span class="line">              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev libslirp-dev \</span><br><span class="line">              git tmux python3 python3-pip ninja-build</span><br><span class="line"># 下载源码包</span><br><span class="line"># 如果下载速度过慢可以使用我们提供的百度网盘链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1dykndFzY73nqkPL2QXs32Q</span><br><span class="line"># 提取码：jimc</span><br><span class="line">wget https:&#x2F;&#x2F;download.qemu.org&#x2F;qemu-7.0.0.tar.xz</span><br><span class="line"># 解压</span><br><span class="line">tar xvJf qemu-7.0.0.tar.xz</span><br><span class="line"># 编译安装并配置 RISC-V 支持</span><br><span class="line">cd qemu-7.0.0</span><br><span class="line">.&#x2F;configure --target-list&#x3D;riscv64-softmmu,riscv64-linux-user  # 在第九章的实验中，可以有图形界面和网络。如果要支持图形界面，可添加 &quot; --enable-sdl&quot; 参数；如果要支持网络，可添加 &quot; --enable-slirp&quot; 参数</span><br><span class="line">make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>而后，可能会报错说缺少某个东西。这是因为第一步操作可能少了个需要的依赖。按照提示执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install &lt;缺少的某个依赖&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-OS知识"><a href="#2-OS知识" class="headerlink" title="2 OS知识"></a>2 OS知识</h2><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><p>站在应用程序的角度来看，我们可以发现常见的应用程序其实是运行在由硬件、操作系统内核、运行时库、图形界面支持库等所包起来的一个 执行环境 (Execution Environment) 中，如下图所示。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-19%20204200.png" alt="OS结构"></p>
<h3 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h3><p>在操作系统中，需要处理三类异常控制流：外设中断 (Device Interrupt) 、陷入 (Trap) 和异常 (Exception，也称Fault Interrupt)。</p>
<p>陷入 (Trap) 是程序在执行过程中由于要通过系统调用请求操作系统服务而有意引发的事件。产生陷入后，操作系统需要执行系统调用服务来响应系统调用请求，这会破坏陷入前应用程序的控制流上下文，所以操作系统要保存与恢复陷入前应用程序的控制流上下文。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-19%20232241.png" alt="异常控制流：陷入"></p>
<h3 id="RISC-V-特权级架构"><a href="#RISC-V-特权级架构" class="headerlink" title="RISC-V 特权级架构"></a>RISC-V 特权级架构</h3><p>RISC-V 架构中一共定义了 4 种特权级：</p>
<table>
<thead>
<tr>
<th>特权级</th>
<th>编码</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>00</td>
<td>用户/应用模式 (U)</td>
<td>用于运行普通的用户应用程序。在这个模式下，应用程序不能执行特权指令，也不能直接访问硬件资源。</td>
</tr>
<tr>
<td>1</td>
<td>01</td>
<td>监督模式 (S)</td>
<td>通常用于运行操作系统内核。在这个模式下，操作系统可以执行特权指令来管理进程、内存和其他系统资源，但是它不能直接访问所有的硬件资源。</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>虚拟监督模式 (H)</td>
<td>用于运行虚拟化管理程序（Hypervisor），它可以在物理硬件上管理多个虚拟机监视器（VMM）。Hypervisor模式可以执行一些特定的管理操作，但不是所有的机器级指令都是可用的。</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>机器模式 (M)</td>
<td>用于运行固件和操作系统内核。机器模式可以执行所有的指令，并且可以直接访问所有的硬件资源。通常，机器模式下的代码负责硬件管理和启动时的引导。</td>
</tr>
</tbody></table>
<p>其中，级别的数值越大，特权级越高，掌控硬件的能力越强。从表中可以看出， M 模式处在最高的特权级，而 U 模式处于最低的特权级。在CPU硬件层面，除了M模式必须存在外，其它模式可以不存在。</p>
<p>从特权级架构的角度，去分析支持应用程序运行的执行环境栈，如下图所示：</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/PrivilegeStack.png" alt="特权级"></p>
<p>其中，白色块表示一层执行环境，黑色块表示相邻两层执行环境之间的接口。这张图片给出了能够支持运行 Unix 这类复杂系统的软件栈。其中操作系统内核代码运行在 S 模式上；应用程序运行在 U 模式上。运行在 M 模式上的软件被称为 监督模式执行环境 (SEE, Supervisor Execution Environment)，如在操作系统运行前负责加载操作系统的 Bootloader – RustSBI。站在运行在 S 模式上的软件视角来看，它的下面也需要一层执行环境支撑，因此被命名为 SEE，它需要在相比 S 模式更高的特权级下运行，一般情况下 SEE 在 M 模式上运行。</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>在操作系统的管理下，应用程序不用理解持久存储设备的硬件细节，而只需对 文件 这种持久存储数据的抽象进行读写就可以了，由操作系统中的文件系统和存储设备驱动程序一起来完成繁琐的持久存储设备的管理与读写。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-20%20211446.png" alt="文件系统"></p>
<h3 id="移植FATFS"><a href="#移植FATFS" class="headerlink" title="移植FATFS"></a>移植FATFS</h3><p>之前移植FATFS文件系统到FeatOS（其实就是照着rCore写的，改了一点）中时，学习FATFS结构打的草稿。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/FATFS.jpg" alt="FATFS"></p>
<p>最后移植成功后，能够读取并运行FAT32文件系统镜像中的elf文件。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>这次总算是圆满完成第二阶段了，同时也取得了不错的成绩。文件系统和并发让我印象深刻，打算后面完成第三阶段后再回来详细的搞搞ch6后面的东西。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-20%20214215.png" alt="成绩"></p>
<p>感激社区提供了这样一个学习平台，它为我打开了一扇探索操作系统奥秘的大门。希望后续的学习我还能够坚持下去吧！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/Map-for-Rust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/Map-for-Rust/" class="post-title-link" itemprop="url">Summary of 2024s-rcore 1st stage  -- Map for Rust</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 15:58:49" itemprop="dateCreated datePublished" datetime="2024-05-19T15:58:49+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/catogory/" itemprop="url" rel="index"><span itemprop="name"><catogory></span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Rust 是一种高级程序设计语言</p>
<p>Rust 设计上的主要目标是保证内存安全，同时追求运行速度和内存利用率</p>
<p>个人认为，想要更好地理解和掌握 Rust，应该在探索 Rust 语法规则的同时思考 Rust 如何达成以上两个目标</p>
<h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p>高级程序设计语言的主要特征是高效的代码开发、管理和维护</p>
<p>在这一方面，Rust 提供了丰富的特性：</p>
<ul>
<li>泛型</li>
<li>强大的宏特性</li>
<li>Attribute</li>
<li>函数式</li>
<li>trait</li>
<li>强大的包管理器 Cargo</li>
<li>很好的学习资料和活跃的社区</li>
</ul>
<h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><p>为了实现零成本抽象，Rust 选择花更多的时间在编译阶段的静态分析上</p>
<p>Rust 一大核心功能——所有权系统，正是基于静态分析的 RAII 思想实践</p>
<p>RAII 思想的提出主要是针对动态数据类型（位于堆上的大部分数据）的释放问题，其基本思想是在变量获取存储资源时就为其绑定一个生命周期，资源将在生命周期结束后被自动释放</p>
<p>所有权系统保证了资源不会被二次释放</p>
<h1 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h1><p>这篇简短的博客作为2024春夏季开源操作系统训练营第一阶段的总结，我在其中简单概述了我对 Rust 语言的理解</p>
<p>因为我所学尚浅，且没有足够的实践经历，导致以上内容十分简略，甚至可能有不少错误</p>
<p>我并不希望这些内容就这样简短的结束并被掩埋和遗忘，所以我将在<a href="https://ldq3.github.io/" target="_blank" rel="noopener">我的个人博客</a>上持续更新我对 Rust 的理解</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/Rust-for-OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/Rust-for-OS/" class="post-title-link" itemprop="url">Summary of 2024s-rcore 2nd stage  -- Rust for OS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 15:58:49" itemprop="dateCreated datePublished" datetime="2024-05-19T15:58:49+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/catogory/" itemprop="url" rel="index"><span itemprop="name"><catogory></span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Rust 具有安全和高效的特性，这使得它有希望被用于构建更好的操作系统</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>在计算机的分层体系结构中，操作系统位于软件和硬件的分界处</p>
<p>操作系统的职责是帮助用户程序管理计算机硬件，这基于 CPU 提供 ISA 实现（在本次实验过程中，具体是 RISC-V）</p>
<p>操作系统的职责可以被进一步细分为几个方面——虚拟化、并发、持久性和驱动（和外部设备的通信）</p>
<p>在第二阶段，我们并没有太多的关于驱动的内容。虚拟化考虑如何在有限的硬件资源上为多个软件提供相互隔离的服务，并发考虑如何控制软件对共享资源的使用、持有性主要指文件系统</p>
<p>操作系统称得上是人类所设计的最复杂的一类程序，在这里你几乎能用上计算机中的所有知识</p>
<h1 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h1><p>这篇简短的博客作为2024春夏季开源操作系统训练营第二阶段的总结，我在其中简单概述了我对 Rust 用于构建操作系统的理解</p>
<p>因为我所学尚浅，且没有足够的实践经历，导致以上内容十分简略，甚至可能有不少错误</p>
<p>我并不希望这些内容就这样简短的结束并被掩埋和遗忘，所以我将在<a href="https://ldq3.github.io/" target="_blank" rel="noopener">我的个人博客</a>上持续更新我对使用 Rust 编写 OS 的理解</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E6%9D%8E%E5%B1%B9%E6%A5%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E6%9D%8E%E5%B1%B9%E6%A5%A0/" class="post-title-link" itemprop="url">2024S 开源操作系统训练营总结-李屹楠</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 00:29:45" itemprop="dateCreated datePublished" datetime="2024-05-19T00:29:45+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h1><p>因为想学习 rust,所以找找有没有用 rust 开发的项目，就找到了 rCore，然后刚好看到有个春季训练营，就参加了。刚刷完官方的 Rustlings，所以第一阶段完成的还挺快的。</p>
<h1 id="第二阶段总结"><a href="#第二阶段总结" class="headerlink" title="第二阶段总结"></a>第二阶段总结</h1><p>因为工作上也很忙，所以需要挤出时间来做，在 ddl 的最后一周才开始做，几乎一天一个 lab，也是有点忙坏了。</p>
<p>从课程上来看，因为在 21 年的时候有完成过 xv6-riscv ,所以 rCore 上手的时候主要难度还是在 rust 上面，经常用不明白 rust。又整体复习了一遍操作系统和 rust，希望后面能够继续去写 rust 代码，这感觉很有意思。</p>
<p>感谢清华大学, 感谢 rCore 社区</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/2024%E6%98%A5%E5%A4%8FrCore%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-ChoHee15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/2024%E6%98%A5%E5%A4%8FrCore%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-ChoHee15/" class="post-title-link" itemprop="url">2024春夏rCore训练营第二阶段总结-ChoHee15</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 00:02:18" itemprop="dateCreated datePublished" datetime="2024-05-19T00:02:18+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="2024春夏rCore训练营第二阶段总结"><a href="#2024春夏rCore训练营第二阶段总结" class="headerlink" title="2024春夏rCore训练营第二阶段总结"></a>2024春夏rCore训练营第二阶段总结</h2><p>参加过2023秋冬，所以ch3-ch5参考了之前的报告。</p>
<p><a href="https://github.com/rcore-os/blog/blob/master/source/_posts/2023%E7%A7%8B%E5%86%ACrCore%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-ChoHee15.md" target="_blank" rel="noopener">2023秋冬报告</a></p>
<p>这里讲讲我之前未接触过的lab。</p>
<h3 id="Lab4-ch6"><a href="#Lab4-ch6" class="headerlink" title="Lab4-ch6"></a>Lab4-ch6</h3><p>对文件系统的了解比较浅，之前也从未以代码的形式接触过文件系统，因此花了不少功夫理解easy-fs的设计。再和群友简短交流后，最终胜利完成了。</p>
<h3 id="Lab5-ch8"><a href="#Lab5-ch8" class="headerlink" title="Lab5-ch8"></a>Lab5-ch8</h3><p>手册给出的算法类似银行家算法，但不太一样。</p>
<p>我感觉没有理解到位，尤其是我自己打了打草稿后，发现不太能理解负值的semaphore要如何如何在这种方法下表示；同时我觉得用这种方法动态检测死锁，好像需要满足一些条件，比如线程p了一定会在后面v之类的。</p>
<p>然后在如何构建算法的矩阵上我也走了弯路，我首先很呆的在线程创建、mutex/sem创建的syscall里添加自定义struct的方法，来动态维护资源矩阵。这使得代码很乱，且static的struct导致运行多个程序时会出问题，需要特殊处理。这导致后面维护和debug很复杂。最后我选择推导重来，在进程这一层添加功能，并在pcb的mutex/sem_list获取各资源的数目，从task获取线程信息。这样功能几乎就集中在了少数地方，比之前轻松很多。</p>
<p>另外，文档中没有提示ch8需要实现时间的syscall，这导致即使死锁检测的逻辑出错，测试也必然出错。初见必然要debug一轮，感觉这个就有点坑了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想必于上一期此次要求500分全写完，要求提高了。不过这两个lab由于其内容我接触不多所以感觉还挺有意思的。</p>
<p>然后就是之前也提过的跨章代码合并，还有测试问题。我后来想了想，这好像也没什么办法；跨章合并是由rcore的风格导致的，上下两章代码可能是冲突的，不太好随着章节渐进更新，我见过的一些lab可以做到直接fetch + merge进入下一章；然后用测试框架每次都要恢复文件的问题，麻烦当然是有点麻烦的，但也许受制于某些因素只能这么设计的，如果这个能改了的话就很舒服了。</p>
<p>总的来说训练营还是很不错的，也有在更新维护；我想我们很多学生都应该多一些实际的代码经历，训练营就是这样一个机会。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/18/Rust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/18/Rust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Rust语言初步以及Rustlings错题整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-18 15:37:38" itemprop="dateCreated datePublished" datetime="2024-05-18T15:37:38+00:00">2024-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RUST语言学习和Rcore实验感想"><a href="#RUST语言学习和Rcore实验感想" class="headerlink" title="RUST语言学习和Rcore实验感想"></a>RUST语言学习和Rcore实验感想</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​    这篇博客可能长度有点长（<del>逃</del>），因为之前没get到要求，以为blog是从二阶段才开始要写hhhh，所以从来没写过就是了hhh~~</p>
<p>​    这篇blog的主要内容是将我在学习RUST期间所做的笔记做一个整理（主要是来自于RUST语言圣经的节选）以便于自己后续回顾，以及将RUSTLINGS习题集中一些值得标注的语法问题做了记录。</p>
<p>​    :cry:二阶段得好好写了hhhh</p>
<h2 id="RUST语言圣经笔记"><a href="#RUST语言圣经笔记" class="headerlink" title="RUST语言圣经笔记"></a>RUST语言圣经笔记</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li><p>数据类型</p>
<ul>
<li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数<ul>
<li>Nan表示未被定义的结果</li>
<li>debug模式检查整数溢出，release不会管</li>
<li>浮点数不支持判等(eq操作未实现)</li>
</ul>
</li>
<li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li>
<li>布尔类型： <code>true</code>和<code>false</code>，1个字节</li>
<li>字符类型: 表示单个 <strong>Unicode 字符</strong>，存储为 <strong>4 个字节</strong></li>
<li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li>
</ul>
<p>一般来说不用显式声明，RUST编译器有变量推导</p>
<p>比较逆天的话就不行了……</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> guess = <span class="string">"42"</span>.parse().expect(<span class="string">"Not a number!"</span>);<span class="comment">//推导不了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//确定类型的三种方式</span></span><br><span class="line"><span class="comment">// 编译器会进行自动推导，给予twenty i32的类型</span></span><br><span class="line"><span class="keyword">let</span> twenty = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 类型标注</span></span><br><span class="line"><span class="keyword">let</span> twenty_one: <span class="built_in">i32</span> = <span class="number">21</span>;</span><br><span class="line"><span class="comment">// 通过类型后缀的方式进行类型标注：22是i32类型</span></span><br><span class="line"><span class="keyword">let</span> twenty_two = <span class="number">22i32</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>序列</p>
<p>生成<strong>连续值</strong>，只允许用于数字和字符类型（编译器可在编译期确定类型和判空）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'a'</span>..=<span class="string">'z'</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数</p>


</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(i: <span class="built_in">i32</span>, j: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">   i + j</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特殊返回类型</p>
<ul>
<li><p>无返回值</p>
<ul>
<li>函数没有返回值，那么返回一个 <code>()</code></li>
<li>通过 <code>;</code> 结尾的语句返回一个 <code>()</code></li>
</ul>
</li>
<li><p>发散函数：永不返回</p>
<p>用<code>!</code>作为函数的返回类型</p>
</li>
</ul>
</li>
</ul>
<h3 id="所有权和借用"><a href="#所有权和借用" class="headerlink" title="所有权和借用"></a>所有权和借用</h3><ol>
<li><p>C和RUST的内存管理差别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;          <span class="comment">// 变量a的作用域开始</span></span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">char</span> *c = <span class="string">"xyz"</span>;   <span class="comment">// 变量c的作用域开始</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;                   <span class="comment">// 变量a和c的作用域结束</span></span><br><span class="line"><span class="comment">//a是常数，被放在栈里，函数返回时出栈，a被回收，&amp;a是悬空指针</span></span><br><span class="line"><span class="comment">//c是字符串常量，在常量区，整个程序结束之后才会回收常量区</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所有权规则</p>
<ul>
<li><p>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</p>
</li>
<li><p>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</p>
</li>
<li><p>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"><span class="comment">//浅拷贝，两个变量都依然有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"><span class="comment">//变量移动，默认是只copy指针，不会复制其实际内容</span></span><br><span class="line"><span class="comment">//s1失效，s2接管那片内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line"><span class="comment">//你真想赋值的时候复制其内容，用clone()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: &amp;<span class="built_in">str</span> = <span class="string">"hello, world"</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"><span class="comment">//浅拷贝，"hello, world"是字符串字面量</span></span><br></pre></td></tr></table></figure>

<p>Copy特征：一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。<strong>任何基本类型的组合可以 <code>Copy</code> ，不需要分配内存或某种形式资源的类型是可以 <code>Copy</code> 的</strong>。</p>
<ul>
<li>所有整数类型，比如 <code>u32</code></li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code></li>
<li>所有浮点数类型，比如 <code>f64</code></li>
<li>字符类型，<code>char</code></li>
<li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是</li>
<li>不可变引用 <code>&amp;T</code> ，例如<a href="https://course.rs/basic/ownership/ownership.html#转移所有权" target="_blank" rel="noopener">转移所有权</a>中的最后一个例子，<strong>但是注意: 可变引用 <code>&amp;mut T</code> 是不可以 Copy的</strong></li>
</ul>
</li>
<li><p>函数传值和返回——所有权的不断变化</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);<span class="comment">//传入的是引用而不是所有权</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;."</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()<span class="comment">//拿到的是引用，因此函数结束的时候不会释放所有权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line"><span class="comment">//引用默认不可变（就是你不能动你借用的东西的值）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);<span class="comment">//可变引用（可以修改借用的东西）</span></span><br><span class="line"></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line"><span class="comment">//在同一个作用域只可以存在一个可变引用（互斥锁懂我意思吧……）</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;<span class="comment">//r1的作用域还没寄，你怎么也搞个可变</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, r1, r2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line"><span class="comment">//可变和不可变引用不能同时存在</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;, and &#123;&#125;"</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure>

<p>引用的作用域 <code>s</code> 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; and &#123;&#125;"</span>, r1, r2);</span><br><span class="line">    <span class="comment">// 新编译器中，r1,r2作用域在这里结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, r3);</span><br><span class="line">&#125; <span class="comment">// 老编译器中，r1、r2、r3作用域在这里结束</span></span><br><span class="line">  <span class="comment">// 新编译器中，r3作用域在这里结束</span></span><br><span class="line"><span class="comment">//Non-Lexical Lifetimes(NLL)特性：用于寻找到某个引用在`&#125;`之前就不再被使用的位置</span></span><br></pre></td></tr></table></figure>

<p>悬垂引用在Rust是不会存在的，因为当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，<strong>要想释放数据，必须先停止其引用的使用</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s<span class="comment">//悬垂引用，会报错</span></span><br><span class="line">    <span class="comment">//解决办法是直接返回s，也就是交出其所有权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="字符串和切片"><a href="#字符串和切片" class="headerlink" title="字符串和切片"></a>字符串和切片</h4><ol>
<li><p><strong>Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</strong>。</p>
</li>
<li><p>为啥 <code>String</code> 可变，而字符串字面值 <code>str</code> 却不可以？</p>
<p>就字符串字面值来说，我们在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件中，这使得字符串字面值快速且高效，这主要得益于字符串字面值的不可变性。不幸的是，我们不能为了获得这种性能，而把每一个在编译时大小未知的文本都放进内存中（你也做不到！），因为有的字符串是在程序运行的过程中动态生成的。</p>
</li>
<li><p>String和&amp;str的转换</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从&amp;str生成String</span></span><br><span class="line"><span class="built_in">String</span>::from(<span class="string">"hello,world"</span>)</span><br><span class="line"><span class="string">"hello,world"</span>.to_string()</span><br><span class="line"></span><br><span class="line"><span class="comment">//String到&amp;str 取切片即可</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello,world!"</span>);</span><br><span class="line">    say_hello(&amp;s);</span><br><span class="line">    say_hello(&amp;s[..]);</span><br><span class="line">    say_hello(s.as_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">say_hello</span></span>(s: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串索引（Rust<strong>不支持</strong>）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">"中国人"</span>);</span><br><span class="line"><span class="keyword">let</span> h = s1[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> h = hello[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//不同字符的编码长度是不一样的，英文是1byte，中文是3byte，对特定单元的索引不一定有意义</span></span><br></pre></td></tr></table></figure>

<p>还有一个原因导致了 Rust 不允许去索引字符串：因为索引操作，我们总是期望它的性能表现是 O(1)，然而对于 <code>String</code> 类型来说，无法保证这一点，因为 Rust 可能需要从 0 开始去遍历字符串来定位合法的字符。</p>
<p>字符串的区间切片Rust是<strong>支持</strong>的，但是必须谨慎</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">"中国人"</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见字符串操作</p>
<ul>
<li><p>追加和插入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//追加</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"Hello "</span>);<span class="comment">//mut！</span></span><br><span class="line"></span><br><span class="line">    s.push_str(<span class="string">"rust"</span>);<span class="comment">//追加字符串</span></span><br><span class="line"></span><br><span class="line">    s.push(<span class="string">'!'</span>);<span class="comment">//追加单字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入 insert需要插入位置和内容 位置越界会报错</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"Hello rust!"</span>);<span class="comment">//mut！</span></span><br><span class="line">    s.insert(<span class="number">5</span>, <span class="string">','</span>);</span><br><span class="line">    s.insert_str(<span class="number">6</span>, <span class="string">" I like"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个新的字符串，而不是操作原来的字符串！！！</span></span><br><span class="line"><span class="comment">//replace  参数是：被替换内容，用来替换的内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string_replace = <span class="built_in">String</span>::from(<span class="string">"I like rust. Learning rust is my favorite!"</span>);</span><br><span class="line">    <span class="keyword">let</span> new_string_replace = string_replace.replace(<span class="string">"rust"</span>, <span class="string">"RUST"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//replacen  和前面差不多，不过是替换n个匹配到的</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string_replace = <span class="string">"I like rust. Learning rust is my favorite!"</span>;</span><br><span class="line">    <span class="keyword">let</span> new_string_replacen = string_replace.replacen(<span class="string">"rust"</span>, <span class="string">"RUST"</span>, <span class="number">1</span>);</span><br><span class="line">    dbg!(new_string_replacen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法是直接操作原来的字符串，不会返回新的字符串！！！</span></span><br><span class="line"><span class="comment">//replace_range  替换特定范围</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> string_replace_range = <span class="built_in">String</span>::from(<span class="string">"I like rust!"</span>);<span class="comment">//mut！！！</span></span><br><span class="line">    string_replace_range.replace_range(<span class="number">7</span>..<span class="number">8</span>, <span class="string">"R"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接操作原来的字符串  mut！！！</span></span><br><span class="line"><span class="comment">//pop  删除并返回最后一个字符 由于不确保存在，返回的是Option()类型 需要具体考察</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> string_pop = <span class="built_in">String</span>::from(<span class="string">"rust pop 中文!"</span>);</span><br><span class="line">    <span class="keyword">let</span> p1 = string_pop.pop();</span><br><span class="line">    <span class="keyword">let</span> p2 = string_pop.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove 删除指定位置的一个字符  注意给的索引要合法（表示字符的起始位置）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> string_remove = <span class="built_in">String</span>::from(<span class="string">"测试remove方法"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"string_remove 占 &#123;&#125; 个字节"</span>,</span><br><span class="line">        std::mem::size_of_val(string_remove.as_str())</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 删除第一个汉字</span></span><br><span class="line">    string_remove.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 下面代码会发生错误</span></span><br><span class="line">    <span class="comment">// string_remove.remove(1);</span></span><br><span class="line">    <span class="comment">// 直接删除第二个汉字</span></span><br><span class="line">    <span class="comment">// string_remove.remove(3);</span></span><br><span class="line">    dbg!(string_remove);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//truncate 从当前位置直接删除到结尾 注意给的索引</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> string_truncate = <span class="built_in">String</span>::from(<span class="string">"测试truncate"</span>);</span><br><span class="line">    string_truncate.truncate(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear 清空</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> string_clear = <span class="built_in">String</span>::from(<span class="string">"string clear"</span>);</span><br><span class="line">    string_clear.clear();</span><br><span class="line">    dbg!(string_clear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+或+=   +右边的必须是切片引用类型</span></span><br><span class="line"><span class="comment">//返回一个新的字符串，所以变量声明可以不需要 mut 关键字修饰</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string_append = <span class="built_in">String</span>::from(<span class="string">"hello "</span>);</span><br><span class="line">    <span class="keyword">let</span> string_rust = <span class="built_in">String</span>::from(<span class="string">"rust"</span>);</span><br><span class="line">    <span class="comment">// &amp;string_rust会自动解引用为&amp;str</span></span><br><span class="line">    <span class="keyword">let</span> result = string_append + &amp;string_rust;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> result = result + <span class="string">"!"</span>; <span class="comment">// `result + "!"` 中的 `result` 是不可变的</span></span><br><span class="line">    result += <span class="string">"!!!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"连接字符串 + -&gt; &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//format!() 格式化输出</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"rust"</span>);</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">"&#123;&#125; &#123;&#125;!"</span>, s1, s2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模式匹配解构元组</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用.访问元组</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> five_hundred = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> six_point_four = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> one = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ol>
<li><p>结构体语法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化  每个字段都要初始化</span></span><br><span class="line">    <span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过.来访问结构体内部字段</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;  <span class="comment">//要改的话还是要mut</span></span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="built_in">String</span>::from(<span class="string">"anotheremail@example.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当函数参数和结构体字段名称一样时，可以简写</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,<span class="comment">//缩略的初始化</span></span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">  <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">        ..user1  <span class="comment">//未显式声明的字段都会从user1中获取   不过..user1只可以写在末尾</span></span><br><span class="line">    &#125;;<span class="comment">//也就是说你要赋值的写在前面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新过程可能会有某些字段发生了所有权的转移，不会影响其他字段的访问</span></span><br><span class="line"><span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    active: user1.active,</span><br><span class="line">    username: user1.username,</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, user1.active);</span><br><span class="line"><span class="comment">// 下面这行会报错</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>元组结构体</p>
<p>为整个结构体提供名称，而字段不需要</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>单元结构体：没有任何字段和属性的结构体</p>
</li>
</ol>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ol>
<li><p>任何数据类型都可以放到枚举中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PokerCard</span></span> &#123;</span><br><span class="line">    Clubs(<span class="built_in">u8</span>),</span><br><span class="line">    Spades(<span class="built_in">u8</span>),</span><br><span class="line">    Diamonds(<span class="built_in">char</span>),<span class="comment">//定义枚举成员时关联数据</span></span><br><span class="line">    Hearts(<span class="built_in">char</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> c1 = PokerCard::Spades(<span class="number">5</span>);</span><br><span class="line">   <span class="keyword">let</span> c2 = PokerCard::Diamonds(<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举和结构体的对比</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举来定义这些消息</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m1 = Message::Quit;</span><br><span class="line">    <span class="keyword">let</span> m2 = Message::Move&#123;x:<span class="number">1</span>,y:<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> m3 = Message::ChangeColor(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用结构体来定义这些消息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuitMessage</span></span>; <span class="comment">// 单元结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MoveMessage</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WriteMessage</span></span>(<span class="built_in">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChangeColorMessage</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于每个结构体都有自己的类型，因此我们无法在需要同一类型的地方进行使用，例如某个函数它的功能是接受消息并进行发送，那么用枚举的方式，就可以接收不同的消息，但是用结构体，该函数无法接受 4 个不同的结构体作为参数。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取代NULL的方式——Option()枚举</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Option()枚举定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T), <span class="comment">//T可以是任何类型</span></span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">——————————————</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"><span class="comment">//当有个None值时，你需要告诉编译器T的类型，因为编译器无法通过None来推断本来应该是什么</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Option()枚举的好处</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = x + y;<span class="comment">//报错！Option(i8)和i8并不是同一种类型</span></span><br></pre></td></tr></table></figure>

<p>当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值，我们可以放心使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候才需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p>
<p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行 <code>T</code> 的运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：期望某值不为空但实际上为空的情况。</p>
</li>
<li><p>match表达式可以用于处理枚举</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;<span class="comment">//如果接收到Some(i)类型，将其中的变量绑定到i上，计算i+1，再将其用Some()包裹</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> six = plus_one(five);</span><br><span class="line"><span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol>
<li><p>创建</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RUST的数组是定长的，被存储在栈上</span></span><br><span class="line"><span class="comment">//变长的动态数组被存储在堆上</span></span><br><span class="line"><span class="comment">//数组的长度也是类型的一部分</span></span><br><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明多个重复值</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//非基础类型数组的创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样子写会报错，本质还是因为string不能浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="built_in">String</span>::from(<span class="string">"rust is good!"</span>); <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样子写可以，但是很难看</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="built_in">String</span>::from(<span class="string">"rust is good!"</span>),<span class="built_in">String</span>::from(<span class="string">"rust is good!"</span>),<span class="built_in">String</span>::from(<span class="string">"rust is good!"</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//遇到非基本类型数组 调用std::array::from_fn</span></span><br><span class="line"><span class="keyword">let</span> array: [<span class="built_in">String</span>; <span class="number">8</span>] = std::array::from_fn(|_i| <span class="built_in">String</span>::from(<span class="string">"rust is good!"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持索引访问，<strong>如果越界会崩溃</strong></p>
</li>
</ol>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想在循环中获取元素的索引，使用.iter()方法获得迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// `.iter()` 方法把 `a` 数组变成一个迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i, v) <span class="keyword">in</span> a.iter().enumerate() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"第&#123;&#125;个元素是&#123;&#125;"</span>, i + <span class="number">1</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>使用方法</th>
<th>等价使用方式</th>
<th>所有权</th>
</tr>
</thead>
<tbody><tr>
<td><code>for item in collection</code></td>
<td><code>for item in IntoIterator::into_iter(collection)</code></td>
<td>转移所有权</td>
</tr>
<tr>
<td><code>for item in &amp;collection</code></td>
<td><code>for item in collection.iter()</code></td>
<td>不可变借用</td>
</tr>
<tr>
<td><code>for item in &amp;mut collection</code></td>
<td><code>for item in collection.iter_mut()</code></td>
<td>可变借用</td>
</tr>
</tbody></table>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">let</span> collection = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..collection.len() &#123;</span><br><span class="line">  <span class="keyword">let</span> item = collection[i];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> collection &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//while循环</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, a[index]);</span><br><span class="line"></span><br><span class="line">        index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//用while循环来实现和第一种for循环是一样的</span></span><br></pre></td></tr></table></figure>

<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环集合中的元素，优劣如下：</p>
<ul>
<li><strong>性能</strong>：第一种使用方式中 <code>collection[index]</code> 的索引访问，会因为边界检查(Bounds Checking)导致运行时的性能损耗 —— Rust 会检查并确认 <code>index</code> 是否落在集合内，但是第二种直接迭代的方式就不会触发这种检查，因为编译器会在编译时就完成分析并证明这种访问是合法的</li>
<li><strong>安全</strong>：第一种方式里对 <code>collection</code> 的索引访问是非连续的，存在一定可能性在两次访问之间，<code>collection</code> 发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险( 由于所有权限制，在访问过程中，数据并不会发生变化)。</li>
</ul>
<p>loop：简单的无限循环，需要搭配break跳出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;<span class="comment">//break可以单独使用直接跳出，也可以带一个值返回（类似return）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The result is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><h4 id="match和if-let"><a href="#match和if-let" class="headerlink" title="match和if let"></a>match和if let</h4><ol>
<li><p>匹配</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt;  &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Lucky penny!"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//match匹配需要穷尽所有的可能，用_表示没有列出的其他可能性(如果没有穷尽可能性的话会报错)</span></span><br><span class="line"><span class="comment">//match的每一个分支都必须是一个表达式,且所有分支的表达式最终返回值的类型必须相同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模式绑定</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState), <span class="comment">// 25美分硬币</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;<span class="comment">//这里将枚举类别Coin中的UsState值绑定给state变量</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if let匹配</p>
<p>当我们只关注某个特定的值的匹配情况时，可以使用if let匹配代替match</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="literal">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> v &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if let匹配</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>matches!()宏</p>
<p>将表达式和模式进行匹配，返回True或者False</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyEnum</span></span> &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对v进行过滤，只保留类型为MyEnum::Foo的元素</span></span><br><span class="line">v.iter().filter(|x| matches!(x, MyEnum::Foo));</span><br><span class="line"></span><br><span class="line"><span class="comment">//更多例子</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">'f'</span>;</span><br><span class="line"><span class="built_in">assert!</span>(matches!(foo, <span class="string">'A'</span>..=<span class="string">'Z'</span> | <span class="string">'a'</span>..=<span class="string">'z'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">assert!</span>(matches!(bar, <span class="literal">Some</span>(x) <span class="keyword">if</span> x &gt; <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>match和if let匹配导致的变量遮蔽</p>
<p>​    尽量不要使用同名变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> age = <span class="literal">Some</span>(<span class="number">30</span>);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">"在匹配前，age是&#123;:?&#125;"</span>,age);</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(age) = age &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">"匹配出来的age是&#123;&#125;"</span>,age);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">"在匹配后，age是&#123;:?&#125;"</span>,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> age = <span class="literal">Some</span>(<span class="number">30</span>);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">"在匹配前，age是&#123;:?&#125;"</span>,age);</span><br><span class="line">   <span class="keyword">match</span> age &#123;</span><br><span class="line">       <span class="literal">Some</span>(age) =&gt;  <span class="built_in">println!</span>(<span class="string">"匹配出来的age是&#123;&#125;"</span>,age),</span><br><span class="line">       _ =&gt; ()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">"在匹配后，age是&#123;:?&#125;"</span>,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="一些模式适用场景"><a href="#一些模式适用场景" class="headerlink" title="一些模式适用场景"></a>一些模式适用场景</h4><ol>
<li><p>while let 只要匹配就会一直循环下去</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vec是动态数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> stack = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组尾部插入元素</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stack.pop从数组尾部弹出元素</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(top) = stack.pop() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>let和if let</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">Some</span>(x) = some_option_value;<span class="comment">//报错，有可能是None</span></span><br><span class="line"><span class="comment">//let，match，for都需要完全匹配(不可驳匹配)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(x) = some_option_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;<span class="comment">//通过，只要有值的情况，其余情况忽略(可驳模式匹配)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="全模式列表"><a href="#全模式列表" class="headerlink" title="全模式列表"></a>全模式列表</h4><ol>
<li><p>用序列语法<code>..=</code>匹配区间内的值（还是只能用于数字和字符）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one through five"</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">"something else"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模式忽略值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//忽略函数变量</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(_: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"This code only uses the y parameter: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>_</code>忽略值和用<code>_s</code>的区别</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="literal">Some</span>(<span class="built_in">String</span>::from(<span class="string">"Hello!"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(_s) = s &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"found a string"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, s);<span class="comment">//会报错，因为s的所有权已经转移给_s了</span></span><br><span class="line"></span><br><span class="line">——————————————————————————</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="literal">Some</span>(<span class="built_in">String</span>::from(<span class="string">"Hello!"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(_) = s &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"found a string"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, s);<span class="comment">//使用下划线本身是不会绑定值的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>..</code>忽略多个值需要保证没有歧义</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (.., second, ..) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Some numbers: &#123;&#125;"</span>, second)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//报错，编译器无法理解second具体指哪个</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配守卫——为匹配提供额外条件</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"Got 50"</span>),</span><br><span class="line">        <span class="literal">Some</span>(n) <span class="keyword">if</span> n == y =&gt; <span class="built_in">println!</span>(<span class="string">"Matched, n = &#123;&#125;"</span>, n),</span><br><span class="line">        <span class="comment">//通过匹配守卫，使得在匹配中也可以正常的使用外部变量，而不用担心变量遮蔽的问题</span></span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"Default case, x = &#123;:?&#125;"</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"at the end: x = &#123;:?&#125;, y = &#123;&#125;"</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">——————————————————</span><br><span class="line"><span class="comment">//匹配守卫的优先级：会作用于所有的匹配项</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> <span class="keyword">if</span> y =&gt; <span class="built_in">println!</span>(<span class="string">"yes"</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">"no"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@绑定——提供在限定范围条件下，在分支代码内部使用变量的能力</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="built_in">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Found an id in range: &#123;&#125;"</span>, id_variable)</span><br><span class="line">    &#125;,<span class="comment">//@变量绑定，限定范围且绑定变量</span></span><br><span class="line">    Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Found an id in another range"</span>)</span><br><span class="line">    &#125;,<span class="comment">//限定了范围，但是这样子只会匹配，而id这个量用不了</span></span><br><span class="line">    Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Found some other id: &#123;&#125;"</span>, id)</span><br><span class="line">    &#125;,<span class="comment">//可以匹配并绑定到id上，但是这样子限制不了范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line"><span class="comment">//绑定的同时对变量结构</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绑定新变量 `p`，同时对 `Point` 进行解构</span></span><br><span class="line">    <span class="keyword">let</span> p @ Point &#123;x: px, y: py &#125; = Point &#123;x: <span class="number">10</span>, y: <span class="number">23</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;, y: &#123;&#125;"</span>, px, py);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> point = Point &#123;x: <span class="number">10</span>, y: <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> p @ Point &#123;x: <span class="number">10</span>, y&#125; = point &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x is 10 and y is &#123;&#125; in &#123;:?&#125;"</span>, y, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x was not 10 :("</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="方法Method"><a href="#方法Method" class="headerlink" title="方法Method"></a>方法Method</h3><ol>
<li><p>定义和初始化</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">    radius: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Circle &#123;</span><br><span class="line">    <span class="comment">// new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字</span></span><br><span class="line">    <span class="comment">// 这种方法往往用于初始化当前结构体的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: <span class="built_in">f64</span>, y: <span class="built_in">f64</span>, radius: <span class="built_in">f64</span>) -&gt; Circle &#123;</span><br><span class="line">        Circle &#123;</span><br><span class="line">            x: x,</span><br><span class="line">            y: y,</span><br><span class="line">            radius: radius,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Circle的方法，&amp;self表示借用当前的Circle结构体</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">        std::<span class="built_in">f64</span>::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这种定义在 <code>impl</code> 中且没有 <code>self</code> 的函数被称之为<strong>关联函数</strong>： 因为它没有 <code>self</code>，不能用 <code>f.read()</code> 的形式调用，因此它是一个函数而不是方法，它又在 <code>impl</code> 中，与结构体紧密关联，因此称为关联函数。</p>
<p>​    因为是函数，所以不能用 <code>.</code> 的方式来调用，我们需要用 <code>::</code> 来调用，例如 <code>let sq = Rectangle::new(3, 3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。</p>
<img src="/blog/.io//2024/05/18/Rust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/method.png" class="D:\116\sigs\blog\source\_posts\Rust语言初步以及Rustlings错题整理">

<p>其他的语言往往将类型和方法一起定义，而Rust对这两者的定义是分开的。</p>
</li>
<li><p>self和被实例化类型的关系</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;<span class="comment">//方法名称可以和结构体的名称相同</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//self 表示 Rectangle 的所有权转移到该方法中，这种形式用的较少</span></span><br><span class="line">    <span class="comment">//&amp;self 表示该方法对 Rectangle 的不可变借用</span></span><br><span class="line">    <span class="comment">//&amp;mut self 表示可变借用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"The area of the rectangle is &#123;&#125; square pixels."</span>,</span><br><span class="line">        rect1.area()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法和字段同名的好处</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(width: <span class="built_in">u32</span>, height: <span class="built_in">u32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">width</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle::new(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, rect1.width());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    方法和字段同名有助于我们实现访问器，我们可以将<code>width</code>和<code>height</code>设置为私有属性，而通过<code>pub</code>关键字将<code>Rectangle</code>结构体对应的<code>new</code>方法和<code>width</code>方法设置为公有方法，这样子用户可以通过<code>rect1.width()</code>方法访问到宽度的数据，却无法直接使用<code>rect1.width</code>来访问。</p>
</li>
<li><p>Rust中用自动引用/解引用机制代替了C/C++的-&gt;运算符</p>
<p>​    在 C/C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 和 <code>(*object).something()</code> 是一样的。</p>
<p>​    Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p>
<p>​    他是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.distance(&amp;p2);</span><br><span class="line">(&amp;p1).distance(&amp;p2);</span><br></pre></td></tr></table></figure>

<p>​    第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p>
</li>
</ol>
<h3 id="泛型和特征"><a href="#泛型和特征" class="headerlink" title="泛型和特征"></a>泛型和特征</h3><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ol>
<li><p>代替值的泛型，而不是针对类型的泛型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码会报错，因为不同长度的数组在Rust中是不同的类型</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">display_array</span></span>(arr: [<span class="built_in">i32</span>; <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    display_array(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    display_array(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用切片的方式打印任意长度的数组，同时用泛型指代不同的类型</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">display_array</span></span>&lt;T: std::fmt::<span class="built_in">Debug</span>&gt;(arr: &amp;[T]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    display_array(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    display_array(&amp;arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片是一种引用，但是有的场景不允许我们使用引用，此时通过const泛型指代不同的长度</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">display_array</span></span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="built_in">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    display_array(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    display_array(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型的性能</p>
<p>编译器完成<strong>单态化</strong>的过程，增加了编译的繁琐程度，也让编译后的文件更大</p>
<p>会对每一个具体用到的类型都生成一份代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序编写</span></span><br><span class="line"><span class="keyword">let</span> integer = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> float = <span class="literal">Some</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option_i32</span></span> &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="built_in">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option_f64</span></span> &#123;</span><br><span class="line">    <span class="literal">Some</span>(<span class="built_in">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> integer = Option_i32::<span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> float = Option_f64::<span class="literal">Some</span>(<span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>​    一组可以被共享的行为，只要满足了特征，就可以做以下的行为。</p>
<ol>
<li><p>定义特征</p>
<p>​    只管定义，而往往不会提供具体的实现</p>
<p>​    谁满足这个特征，谁来实现具体的方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;<span class="comment">//以;结尾 只提供定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">//也可以给一个默认实现</span></span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"(Read more...)"</span>)</span><br><span class="line">    &#125;<span class="comment">//可以调用，也可以重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现。</strong>如此，特征可以提供很多有用的功能而只需要实现指定的一小部分内容。例如，我们可以定义 <code>Summary</code> 特征，使其具有一个需要实现的 <code>summarize_author</code> 方法，然后定义一个 <code>summarize</code> 方法，此方法的默认实现调用 <code>summarize_author</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;<span class="comment">//让实现Summary特征的类型具体实现吧</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"(Read more from &#123;&#125;...)"</span>, <span class="keyword">self</span>.summarize_author())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现特征</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Post</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="built_in">String</span>, <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>, <span class="comment">// 作者</span></span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>, <span class="comment">// 内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Post &#123;<span class="comment">//为Post实现Summary特征</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"文章&#123;&#125;, 作者是&#123;&#125;"</span>, <span class="keyword">self</span>.title, <span class="keyword">self</span>.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Weibo</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Weibo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;发表了微博&#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>孤儿规则——特征定义和实现的位置关系</p>
<p>​    关于特征实现与定义的位置，有一条非常重要的原则：<strong>如果你想要为类型</strong> <code>A</code> <strong>实现特征</strong> <code>T</code><strong>，那么</strong> <code>A</code> <strong>或者</strong> <code>T</code> <strong>至少有一个是在当前作用域中定义的！</strong> 例如我们可以为上面的 <code>Post</code> 类型实现标准库中的 <code>Display</code> 特征，这是因为 <code>Post</code> 类型定义在当前的作用域中。同时，我们也可以在当前包中为 <code>String</code> 类型实现 <code>Summary</code> 特征，因为 <code>Summary</code> 定义在当前作用域中。</p>
<p>​    但是你无法在当前作用域中，为 <code>String</code> 类型实现 <code>Display</code> 特征，因为它们俩都定义在标准库中，其定义所在的位置都不在当前作用域，跟你半毛钱关系都没有，看看就行了。</p>
</li>
<li><p>使用特征作为函数的参数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;<span class="keyword">impl</span> Summary) &#123;<span class="comment">//实现了特征Summary的item参数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());<span class="comment">//可以调用特征对应的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特征约束</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收两个实现了Summary特征的参数，但是不能保证这两个参数的类型相同</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: &amp;<span class="keyword">impl</span> Summary, item2: &amp;<span class="keyword">impl</span> Summary) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用泛型T指代</span></span><br><span class="line"><span class="comment">//T:Summary要求其实现了特征Summary</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多重约束</span></span><br><span class="line"><span class="comment">//这里T被要求同时实现两个特征才行</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Where约束，主要是用于简化函数的签名，将特征约束写在别处</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回值中的impl Trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    <span class="comment">//返回一个实现了Summary特征的类型，具体是什么类型不知道</span></span><br><span class="line">    Weibo &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"sunface"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(</span><br><span class="line">            <span class="string">"m1 max太厉害了，电脑再也不会卡"</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这种 <code>impl Trait</code> 形式的返回值，在一种场景下非常非常有用，那就是返回的真实类型非常复杂，你不知道该怎么声明时(毕竟 Rust 要求你必须标出所有的类型)，此时就可以用 <code>impl Trait</code> 的方式简单返回。</p>
</li>
<li><p>derive派生特征</p>
<p>​    在本书中，形如 <code>#[derive(Debug)]</code> 的代码已经出现了很多次，这种是一种特征派生语法，被 <code>derive</code> 标记的对象会自动实现对应的默认特征代码，继承相应的功能。</p>
<p>​    例如 <code>Debug</code> 特征，它有一套自动实现的默认代码，当你给一个结构体标记后，就可以使用 <code>println!(&quot;{:?}&quot;, s)</code> 的形式打印该结构体的对象。</p>
<p>​    再如 <code>Copy</code> 特征，它也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现 <code>Copy</code> 特征，进而可以调用 <code>copy</code> 方法，进行自我复制。</p>
<p>​    总之，<code>derive</code> 派生出来的是 Rust 默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重载该实现。</p>
</li>
</ol>
<h4 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h4><p>​    指向了所有实现了某特征的对象，二者之间存在映射关系，可以通过特征对象找到该对象具体的实现方法。</p>
<ol>
<li><p>可以通过 <code>&amp;</code> 引用或者 <code>Box&lt;T&gt;</code> 智能指针的方式来创建特征对象</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Draw</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"u8: &#123;&#125;"</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> <span class="built_in">f64</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"f64: &#123;&#125;"</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 T 实现了 Draw 特征， 则调用该函数时传入的 Box&lt;T&gt; 可以被隐式转换成函数参数签名中的 Box&lt;dyn Draw&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">draw1</span></span>(x: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;) &#123;</span><br><span class="line">    <span class="comment">// 由于实现了 Deref 特征，Box 智能指针会自动解引用为它所包裹的值，然后调用该值对应的类型上定义的 `draw` 方法</span></span><br><span class="line">    x.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">draw2</span></span>(x: &amp;<span class="keyword">dyn</span> Draw) &#123;</span><br><span class="line">    x.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1.1f64</span>;</span><br><span class="line">    <span class="comment">// do_something(&amp;x);</span></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">8u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x 和 y 的类型 T 都实现了 `Draw` 特征，因为 Box&lt;T&gt; 可以在函数调用时隐式地被转换为特征对象 Box&lt;dyn Draw&gt; </span></span><br><span class="line">    <span class="comment">// 基于 x 的值创建一个 Box&lt;f64&gt; 类型的智能指针，指针指向的数据被放置在了堆上</span></span><br><span class="line">    draw1(<span class="built_in">Box</span>::new(x));</span><br><span class="line">    <span class="comment">// 基于 y 的值创建一个 Box&lt;u8&gt; 类型的智能指针</span></span><br><span class="line">    draw1(<span class="built_in">Box</span>::new(y));</span><br><span class="line">    draw2(&amp;x);</span><br><span class="line">    draw2(&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>draw1</code> 函数的参数是 <code>Box&lt;dyn Draw&gt;</code> 形式的特征对象，该特征对象是通过 <code>Box::new(x)</code> 的方式创建的</li>
<li><code>draw2</code> 函数的参数是 <code>&amp;dyn Draw</code> 形式的特征对象，该特征对象是通过 <code>&amp;x</code> 的方式创建的</li>
<li><code>dyn</code> 关键字只用在特征对象的类型声明上，在创建时无需使用 <code>dyn</code></li>
</ul>
<p>可以通过特征对象来代表具体的泛型。</p>
</li>
<li><p>使用泛型的实现和特征对象的对比</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span>&lt;T: Draw&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Draw &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的 <code>Screen</code> 的列表中，存储了类型为 <code>T</code> 的元素，然后在 <code>Screen</code> 中使用特征约束让 <code>T</code> 实现了 <code>Draw</code> 特征，进而可以调用 <code>draw</code> 方法。</p>
<p>​    但是这种写法限制了 <code>Screen</code> 实例的 <code>Vec&lt;T&gt;</code> 中的每个元素必须是 <code>Button</code> 类型或者全是 <code>SelectBox</code> 类型。如果只需要同质（相同类型）集合，更倾向于采用泛型+特征约束这种写法，因其实现更清晰，且性能更好(特征对象，需要在运行时从 <code>vtable</code> 动态查找需要调用的方法)。</p>
</li>
<li><p>特征对象的限制</p>
<p><strong>不是所有特征都能拥有特征对象，只有对象安全的特征才行。</strong>当一个特征的所有方法都有如下属性时，它的对象才是安全的：</p>
<ul>
<li>方法的返回类型不能是 <code>Self</code></li>
<li>方法没有任何泛型参数</li>
</ul>
<p>对象安全对于特征对象是必须的，因为一旦有了特征对象，就不再需要知道实现该特征的具体类型是什么了。如果特征方法返回了具体的 <code>Self</code> 类型，但是特征对象忘记了其真正的类型，那这个 <code>Self</code> 就非常尴尬，因为没人知道它是谁了。但是对于泛型类型参数来说，当使用特征时其会放入具体的类型参数：此具体类型变成了实现该特征的类型的一部分。而当使用特征对象时其具体类型被抹去了，故而无从得知放入泛型参数类型到底是什么。</p>
<p>标准库中的 <code>Clone</code> 特征就不符合对象安全的要求：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Clone</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为它的其中一个方法，返回了 <code>Self</code> 类型，因此它是对象不安全的。</p>
</li>
<li><p>特征对象的动态分发</p>
<p>​    静态分发：编译器会为每一个泛型参数对应的具体类型生成一份代码</p>
<p>​    动态分发：直到运行时，才能确定需要调用什么方法。编译器无法知晓所有可能用于特征对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。</p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cv2-b771fe4cfc6ebd63d9aff42840eb8e67_1440w.jpg" alt="img"></p>
<p>​    </p>
<ul>
<li><strong>特征对象大小不固定</strong>：这是因为，对于特征 <code>Draw</code>，类型 <code>Button</code> 可以实现特征 <code>Draw</code>，类型 <code>SelectBox</code> 也可以实现特征 <code>Draw</code>，因此特征没有固定大小</li>
<li>几乎总是使用特征对象的引用方式，如<code>&amp;dyn Draw</code>和<code>Box&lt;dyn Draw&gt;</code><ul>
<li>虽然特征对象没有固定大小，但它的引用类型的大小是固定的，它由两个指针组成（<code>ptr</code> 和 <code>vptr</code>），因此占用两个指针大小</li>
<li>一个指针 <code>ptr</code> 指向实现了特征 <code>Draw</code> 的具体类型的实例，也就是当作特征 <code>Draw</code> 来用的类型的实例，比如类型 <code>Button</code> 的实例、类型 <code>SelectBox</code> 的实例</li>
<li>另一个指针 <code>vptr</code> 指向一个虚表 <code>vtable</code>，<code>vtable</code> 中保存了类型 <code>Button</code> 或类型 <code>SelectBox</code> 的实例对于可以调用的实现于特征 <code>Draw</code> 的方法。当调用方法时，直接从 <code>vtable</code> 中找到方法并调用。之所以要使用一个 <code>vtable</code> 来保存各实例的方法，是因为实现了特征 <code>Draw</code> 的类型有多种，这些类型拥有的方法各不相同，当将这些类型的实例都当作特征 <code>Draw</code> 来使用时(此时，它们全都看作是特征 <code>Draw</code> 类型的实例)，有必要区分这些实例各自有哪些方法可调用</li>
</ul>
</li>
</ul>
<p>简而言之，当类型 <code>Button</code> 实现了特征 <code>Draw</code> 时，类型 <code>Button</code> 的实例对象 <code>btn</code> 可以当作特征 <code>Draw</code> 的特征对象类型来使用，<code>btn</code> 中保存了作为特征对象的数据指针（指向类型 <code>Button</code> 的实例数据）和行为指针（指向 <code>vtable</code>）。</p>
<p>一定要注意，此时的 <code>btn</code> 是 <code>Draw</code> 的特征对象的实例，而不再是具体类型 <code>Button</code> 的实例，而且 <code>btn</code> 的 <code>vtable</code> 只包含了实现自特征 <code>Draw</code> 的那些方法（比如 <code>draw</code>），因此 <code>btn</code> 只能调用实现于特征 <code>Draw</code> 的 <code>draw</code> 方法，而不能调用类型 <code>Button</code> 本身实现的方法和类型 <code>Button</code> 实现于其他特征的方法。<strong>也就是说，<code>btn</code> 是哪个特征对象的实例，它的 <code>vtable</code> 中就包含了该特征的方法。</strong></p>
</li>
</ol>
<h4 id="特征进阶内容"><a href="#特征进阶内容" class="headerlink" title="特征进阶内容"></a>特征进阶内容</h4><ol>
<li><p>关联类型</p>
<p>在特征定义的语句块中，声明一个自定义类型，这样就可以在特征中使用这个类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="Rustlings习题整理"><a href="#Rustlings习题整理" class="headerlink" title="Rustlings习题整理"></a>Rustlings习题整理</h2><h3 id="map-的用法"><a href="#map-的用法" class="headerlink" title="map()的用法"></a>map()的用法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">vec_map</span></span>(v: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    v.iter().map(|element| &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Do the same thing as above - but instead of mutating the</span></span><br><span class="line">        <span class="comment">// Vec, you can just return the new number!</span></span><br><span class="line">        *element * <span class="number">2</span></span><br><span class="line">    &#125;).collect()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map方法由原来的迭代器生成一个新的迭代器，对旧迭代器的每一个方法都调用该闭包</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串和切片操作"><a href="#字符串和切片操作" class="headerlink" title="字符串和切片操作"></a>字符串和切片操作</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trim_me</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Remove whitespace from both ends of a string!</span></span><br><span class="line">    input.trim().to_string()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compose_me</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Add " world!" to the string! There's multiple ways to do this!</span></span><br><span class="line">    input.to_string() + <span class="string">" world!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">replace_me</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Replace "cars" in the string with "balloons"!</span></span><br><span class="line">    input.replace(<span class="string">"cars"</span>,<span class="string">"balloons"</span>).to_string()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">trim_a_string</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(trim_me(<span class="string">"Hello!     "</span>), <span class="string">"Hello!"</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(trim_me(<span class="string">"  What's up!"</span>), <span class="string">"What's up!"</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(trim_me(<span class="string">"   Hola!  "</span>), <span class="string">"Hola!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">compose_a_string</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(compose_me(<span class="string">"Hello"</span>), <span class="string">"Hello world!"</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(compose_me(<span class="string">"Goodbye"</span>), <span class="string">"Goodbye world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">replace_a_string</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(replace_me(<span class="string">"I think cars are cool"</span>), <span class="string">"I think balloons are cool"</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(replace_me(<span class="string">"I love to look at cars"</span>), <span class="string">"I love to look at balloons"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断字符串和字符串切片的类型"><a href="#判断字符串和字符串切片的类型" class="headerlink" title="判断字符串和字符串切片的类型"></a>判断字符串和字符串切片的类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string_slice</span></span>(arg: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string</span></span>(arg: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    string_slice(<span class="string">"blue"</span>);</span><br><span class="line">    string(<span class="string">"red"</span>.to_string());</span><br><span class="line">    string(<span class="built_in">String</span>::from(<span class="string">"hi"</span>));</span><br><span class="line">    string(<span class="string">"rust is fun!"</span>.to_owned()); </span><br><span class="line">    <span class="comment">//to_owned()方法用于从借用的数据中创建一个具有所有权的副本</span></span><br><span class="line">    <span class="comment">//和clone方法的区别是如果传入的参数是引用类型的，可以通过复制获得其所有权</span></span><br><span class="line">    string_slice(<span class="string">"nice weather"</span>.into()); </span><br><span class="line">    string(<span class="built_in">format!</span>(<span class="string">"Interpolation &#123;&#125;"</span>, <span class="string">"Station"</span>));</span><br><span class="line">    string_slice(&amp;<span class="built_in">String</span>::from(<span class="string">"abc"</span>)[<span class="number">0</span>..<span class="number">1</span>]);</span><br><span class="line">    string_slice(<span class="string">"  hello there "</span>.trim());</span><br><span class="line">    string(<span class="string">"Happy Monday!"</span>.to_string().replace(<span class="string">"Mon"</span>, <span class="string">"Tues"</span>));</span><br><span class="line">    string(<span class="string">"mY sHiFt KeY iS sTiCkY"</span>.to_lowercase()); </span><br><span class="line">    <span class="comment">//to_lowercase()返回此字符串切片的小写等效项，类型为string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>clone()</th>
<th>to_owned()</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>T -&gt; T</td>
<td>T -&gt; T</td>
</tr>
<tr>
<td>&amp;T</td>
<td>&amp;T -&gt; &amp;T</td>
<td>&amp;T -&gt; T</td>
</tr>
</tbody></table>
<h3 id="模块use"><a href="#模块use" class="headerlink" title="模块use"></a>模块use</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> delicious_snacks &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Fix these use statements</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> self::fruits::PEAR <span class="keyword">as</span> fruit;<span class="comment">//修改为pub才对外可见</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> self::veggies::CUCUMBER <span class="keyword">as</span> veggie;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> fruits &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">const</span> PEAR: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Pear"</span>;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">const</span> APPLE: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Apple"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> veggies &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">const</span> CUCUMBER: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Cucumber"</span>;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">const</span> CARROT: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Carrot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"favorite snacks: &#123;&#125; and &#123;&#125;"</span>,</span><br><span class="line">        delicious_snacks::fruit,</span><br><span class="line">        delicious_snacks::veggie</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="比赛统计"><a href="#比赛统计" class="headerlink" title="比赛统计"></a>比赛统计</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A structure to store the goal details of a team.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Team</span></span> &#123;</span><br><span class="line">    goals_scored: <span class="built_in">u8</span>,</span><br><span class="line">    goals_conceded: <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_scores_table</span></span>(results: <span class="built_in">String</span>) -&gt; HashMap&lt;<span class="built_in">String</span>, Team&gt; &#123;</span><br><span class="line">    <span class="comment">// The name of the team is the key and its associated struct is the value.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores: HashMap&lt;<span class="built_in">String</span>, Team&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> results.lines() &#123;</span><br><span class="line">        <span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt; = r.split(<span class="string">','</span>).collect();</span><br><span class="line">        <span class="keyword">let</span> team_1_name = v[<span class="number">0</span>].to_string();</span><br><span class="line">        <span class="keyword">let</span> team_1_score: <span class="built_in">u8</span> = v[<span class="number">2</span>].parse().unwrap();</span><br><span class="line">        <span class="keyword">let</span> team_2_name = v[<span class="number">1</span>].to_string();</span><br><span class="line">        <span class="keyword">let</span> team_2_score: <span class="built_in">u8</span> = v[<span class="number">3</span>].parse().unwrap();</span><br><span class="line">        <span class="comment">//注意Team是没有实现可加性的，只可以按照Team内部的元素来操作</span></span><br><span class="line">        <span class="keyword">let</span> team1 = scores.entry(team_1_name).or_insert(Team&#123;</span><br><span class="line">            goals_scored:<span class="number">0</span>,</span><br><span class="line">            goals_conceded:<span class="number">0</span></span><br><span class="line">        &#125;);</span><br><span class="line">        team1.goals_scored += team_1_score;</span><br><span class="line">        team1.goals_conceded += team_2_score;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> team2 = scores.entry(team_2_name).or_insert(Team&#123;</span><br><span class="line">            goals_scored:<span class="number">0</span>,</span><br><span class="line">            goals_conceded:<span class="number">0</span></span><br><span class="line">        &#125;);</span><br><span class="line">        team2.goals_scored += team_2_score;</span><br><span class="line">        team2.goals_conceded += team_1_score;</span><br><span class="line">    &#125;</span><br><span class="line">    scores</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_results</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> results = <span class="string">""</span>.to_string()</span><br><span class="line">            + <span class="string">"England,France,4,2\n"</span></span><br><span class="line">            + <span class="string">"France,Italy,3,1\n"</span></span><br><span class="line">            + <span class="string">"Poland,Spain,2,0\n"</span></span><br><span class="line">            + <span class="string">"Germany,England,2,1\n"</span>;</span><br><span class="line">        results</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">build_scores</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> scores = build_scores_table(get_results());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> keys: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">String</span>&gt; = scores.keys().collect();</span><br><span class="line">        keys.sort();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            keys,</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">"England"</span>, <span class="string">"France"</span>, <span class="string">"Germany"</span>, <span class="string">"Italy"</span>, <span class="string">"Poland"</span>, <span class="string">"Spain"</span>]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">validate_team_score_1</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> scores = build_scores_table(get_results());</span><br><span class="line">        <span class="keyword">let</span> team = scores.get(<span class="string">"England"</span>).unwrap();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(team.goals_scored, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(team.goals_conceded, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">validate_team_score_2</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> scores = build_scores_table(get_results());</span><br><span class="line">        <span class="keyword">let</span> team = scores.get(<span class="string">"Spain"</span>).unwrap();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(team.goals_scored, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(team.goals_conceded, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="quiz2"><a href="#quiz2" class="headerlink" title="quiz2"></a><strong>quiz2</strong></h3><p>首先要观察代码判断其类型，随后用match表达式匹配枚举类型，做出相应的处理</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Command</span></span> &#123;</span><br><span class="line">    Uppercase,</span><br><span class="line">    Trim,</span><br><span class="line">    Append(<span class="built_in">usize</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> my_module &#123;</span><br><span class="line">    <span class="keyword">use</span> super::Command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Complete the function signature!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">transformer</span></span>(input: <span class="built_in">Vec</span>&lt;(<span class="built_in">String</span>,Command)&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Complete the output declaration!</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> output: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">for</span> (string, command) <span class="keyword">in</span> input.iter() &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Complete the function body. You can do it!</span></span><br><span class="line">            <span class="keyword">let</span> applied_string:<span class="built_in">String</span> = <span class="keyword">match</span> command&#123;</span><br><span class="line">                Command::Uppercase =&gt; string.to_uppercase(),</span><br><span class="line">                Command::Trim =&gt; string.trim().to_string(),</span><br><span class="line">                Command::Append(n) =&gt; <span class="built_in">format!</span>(<span class="string">"&#123;&#125;&#123;&#125;"</span>,string,<span class="string">"bar"</span>.repeat(*n)),</span><br><span class="line">            &#125;;</span><br><span class="line">            output.push(applied_string);</span><br><span class="line">        &#125;</span><br><span class="line">        output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> What do we need to import to have `transformer` in scope?</span></span><br><span class="line">    <span class="keyword">use</span> crate::my_module::transformer;</span><br><span class="line">    <span class="keyword">use</span> super::Command;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> output = transformer(<span class="built_in">vec!</span>[</span><br><span class="line">            (<span class="string">"hello"</span>.into(), Command::Uppercase),</span><br><span class="line">            (<span class="string">" all roads lead to rome! "</span>.into(), Command::Trim),</span><br><span class="line">            (<span class="string">"foo"</span>.into(), Command::Append(<span class="number">1</span>)),</span><br><span class="line">            (<span class="string">"bar"</span>.into(), Command::Append(<span class="number">5</span>)),</span><br><span class="line">        ]);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(output[<span class="number">0</span>], <span class="string">"HELLO"</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(output[<span class="number">1</span>], <span class="string">"all roads lead to rome!"</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(output[<span class="number">2</span>], <span class="string">"foobar"</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(output[<span class="number">3</span>], <span class="string">"barbarbarbarbarbar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从Option中取出值"><a href="#从Option中取出值" class="headerlink" title="从Option中取出值"></a>从Option中取出值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果你确定Option中是有值的，可以使用unwrap()方法直接取出来</span></span><br><span class="line"><span class="keyword">let</span> my_option: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>); <span class="comment">// 一个Option&lt;i32&gt;类型的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value = my_option.unwrap();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The value is: &#123;&#125;"</span>, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要处理可能有None的情况，可以使用unwrap_or(初始值)</span></span><br><span class="line"><span class="comment">//为None的情况设置一个初始值</span></span><br><span class="line"><span class="keyword">let</span> my_option: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>); <span class="comment">// 一个Option&lt;i32&gt;类型的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value = my_option.unwrap_or(<span class="number">0</span>); <span class="comment">// 如果my_option是None，则使用默认值0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The value is: &#123;&#125;"</span>, value);</span><br></pre></td></tr></table></figure>

<h3 id="Option的类型问题"><a href="#Option的类型问题" class="headerlink" title="Option的类型问题"></a>Option的类型问题</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> optional_integers: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt;&gt; = <span class="built_in">vec!</span>[<span class="literal">None</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..(range + <span class="number">1</span>) &#123;</span><br><span class="line">    optional_integers.push(<span class="literal">Some</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> cursor = range;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop()函数会包着一层Some()在外面</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="literal">Some</span>(integer)) = optional_integers.pop() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(integer, cursor);</span><br><span class="line">    cursor -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="所有权的问题"><a href="#所有权的问题" class="headerlink" title="所有权的问题"></a>所有权的问题</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;Point&gt; = <span class="literal">Some</span>(Point &#123; x: <span class="number">100</span>, y: <span class="number">200</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> y &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> p) =&gt; <span class="built_in">println!</span>(<span class="string">"Co-ordinates are &#123;&#125;,&#123;&#125; "</span>, p.x, p.y),</span><br><span class="line">        <span class="comment">//加ref是为了防止所有权的转移</span></span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">"no match!"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    y; <span class="comment">// Fix without deleting this line.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="? 表达式"></a>? 表达式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> ParsePosNonzeroError &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from_creation</span></span>(err: CreationError) -&gt; ParsePosNonzeroError &#123;</span><br><span class="line">        ParsePosNonzeroError::Creation(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add another error conversion function here.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from_parseint</span></span>(err: ParseIntError) -&gt; ParsePosNonzeroError&#123;</span><br><span class="line">        ParsePosNonzeroError::ParseInt(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_pos_nonzero</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> change this to return an appropriate error instead of panicking</span></span><br><span class="line">    <span class="comment">// when `parse()` returns an error.</span></span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i64</span> = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;</span><br><span class="line">    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为动态数组Vector实现特征"><a href="#为动态数组Vector实现特征" class="headerlink" title="为动态数组Vector实现特征"></a>为动态数组Vector实现特征</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AppendBar</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">append_bar</span></span>(<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Implement trait `AppendBar` for a vector of strings.</span></span><br><span class="line"><span class="keyword">impl</span> AppendBar <span class="keyword">for</span> <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">append_bar</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">Self</span>&#123; <span class="comment">//声明可变mut</span></span><br><span class="line">        <span class="keyword">self</span>.push(<span class="string">"Bar"</span>.to_string());</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_vec_pop_eq_bar</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> foo = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"Foo"</span>)].append_bar();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(foo.pop().unwrap(), <span class="built_in">String</span>::from(<span class="string">"Bar"</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(foo.pop().unwrap(), <span class="built_in">String</span>::from(<span class="string">"Foo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特征约束代替类型"><a href="#特征约束代替类型" class="headerlink" title="特征约束代替类型"></a>特征约束代替类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Licensed</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">licensing_info</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="string">"some information"</span>.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeSoftware</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OtherSoftware</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Licensed <span class="keyword">for</span> SomeSoftware &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Licensed <span class="keyword">for</span> OtherSoftware &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// YOU MAY ONLY CHANGE THE NEXT LINE</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compare_license_types</span></span>(software:<span class="keyword">impl</span> Licensed, software_two:<span class="keyword">impl</span> Licensed) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    software.licensing_info() == software_two.licensing_info()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面有SomeSoftware和OtherSoftware两种类型</span></span><br><span class="line"><span class="comment">//用impl Licensed可以指代他们</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">compare_license_information</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> some_software = SomeSoftware &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> other_software = OtherSoftware &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(compare_license_types(some_software, other_software));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">compare_license_information_backwards</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> some_software = SomeSoftware &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> other_software = OtherSoftware &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(compare_license_types(other_software, some_software));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="should-panic"><a href="#should-panic" class="headerlink" title="#[should_panic]"></a>#[should_panic]</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">i32</span>,</span><br><span class="line">    height: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// Only change the test functions themselves</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(width: <span class="built_in">i32</span>, height: <span class="built_in">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Rectangle width and height cannot be negative!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Rectangle &#123;width, height&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">correct_width_and_height</span></span>() &#123;</span><br><span class="line">        <span class="comment">// This test should check if the rectangle is the size that we pass into its constructor</span></span><br><span class="line">        <span class="keyword">let</span> rect = Rectangle::new(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(rect.width, <span class="number">10</span>); <span class="comment">// check width</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(rect.height, <span class="number">20</span>); <span class="comment">// check height</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">negative_width</span></span>() &#123;</span><br><span class="line">        <span class="comment">// This test should check if program panics when we try to create rectangle with negative width</span></span><br><span class="line">        <span class="keyword">let</span> _rect = Rectangle::new(-<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">negative_height</span></span>() &#123;</span><br><span class="line">        <span class="comment">// This test should check if program panics when we try to create rectangle with negative height</span></span><br><span class="line">        <span class="keyword">let</span> _rect = Rectangle::new(<span class="number">10</span>, -<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">capitalize_first</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = input.chars();</span><br><span class="line">    <span class="keyword">match</span> c.next() &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">String</span>::new(),</span><br><span class="line">        <span class="literal">Some</span>(first) =&gt; first.to_uppercase().to_string() + c.as_str(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2.</span></span><br><span class="line"><span class="comment">// Apply the `capitalize_first` function to a slice of string slices.</span></span><br><span class="line"><span class="comment">// Return a vector of strings.</span></span><br><span class="line"><span class="comment">// ["hello", "world"] -&gt; ["Hello", "World"]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">capitalize_words_vector</span></span>(words: &amp;[&amp;<span class="built_in">str</span>]) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    words.iter().map(</span><br><span class="line">        |&amp;word| &#123;</span><br><span class="line">            capitalize_first(word)</span><br><span class="line">        &#125;</span><br><span class="line">    ).collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3.</span></span><br><span class="line"><span class="comment">// Apply the `capitalize_first` function again to a slice of string slices.</span></span><br><span class="line"><span class="comment">// Return a single string.</span></span><br><span class="line"><span class="comment">// ["hello", " ", "world"] -&gt; "Hello World"</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">capitalize_words_string</span></span>(words: &amp;[&amp;<span class="built_in">str</span>]) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    words.iter().map(</span><br><span class="line">        |&amp;word| &#123;</span><br><span class="line">            capitalize_first(word)</span><br><span class="line">        &#125;</span><br><span class="line">    ).collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">test_success</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(capitalize_first(<span class="string">"hello"</span>), <span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">test_empty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(capitalize_first(<span class="string">""</span>), <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">test_iterate_string_vec</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> words = <span class="built_in">vec!</span>[<span class="string">"hello"</span>, <span class="string">"world"</span>];</span><br><span class="line">        <span class="built_in">assert_eq!</span>(capitalize_words_vector(&amp;words), [<span class="string">"Hello"</span>, <span class="string">"World"</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">test_iterate_into_string</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> words = <span class="built_in">vec!</span>[<span class="string">"hello"</span>, <span class="string">" "</span>, <span class="string">"world"</span>];</span><br><span class="line">        <span class="built_in">assert_eq!</span>(capitalize_words_string(&amp;words), <span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏的定义要在使用之前</span></span><br><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Check out my macro!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    my_macro!();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用分号区分不同的模式</span></span><br><span class="line"><span class="meta">#[rustfmt::skip]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Check out my macro!"</span>);</span><br><span class="line">    &#125;; <span class="comment">//使用分号来区分不同的模式</span></span><br><span class="line">    ($val:expr) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Look at this other macro: &#123;&#125;"</span>, $val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    my_macro!();</span><br><span class="line">    my_macro!(<span class="number">7777</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rcore实验感想"><a href="#Rcore实验感想" class="headerlink" title="Rcore实验感想"></a>Rcore实验感想</h2><h3 id="写在前面-1"><a href="#写在前面-1" class="headerlink" title="写在前面"></a>写在前面</h3><p>由于实验要求不能够贴代码，因此本报告重点就是日记这种了……</p>
<p>会简单的讲一下过程</p>
<h3 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h3><p>看了一下自己写的东西……玛德我原本也贴了不少代码</p>
<p>行吧……那就放些记录性的东西</p>
<p>……</p>
<p>报错挺多的，反正就照着编译器一个一个来吧……</p>
<p>类型错误……</p>
<img src="/blog/.io//116\sigs\blog\source\_posts\Rust语言初步以及Rustlings错题整理.assets\image-20240428141340827.png" alt="image-20240428141340827" style="zoom:67%;">

<p>missing documentations for functions</p>
<p>不写注释也不行 <del>笑</del></p>
<img src="/blog/.io//116\sigs\blog\source\_posts\Rust语言初步以及Rustlings错题整理.assets\image-20240428142025031.png" alt="image-20240428142025031">





<h3 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h3><h4 id="重写sys-get-time和sys-task-info"><a href="#重写sys-get-time和sys-task-info" class="headerlink" title="重写sys_get_time和sys_task_info"></a>重写sys_get_time和sys_task_info</h4><p>先看看原本的sys_get_time是如何实现的？</p>
<p>对指针<code>*ts</code>所指向的内存空间赋值时间信息，在引入虚存之前应用空间和内核空间之间不存在隔离，二者都可以直接访问到<code>*ts</code>所在位置。在引入虚存之后，每个应用以及内核本身都有独立的地址空间，没办法访问了。</p>
<p>因此我们需要想办法，使得OS能够访问到应用所在的位置，需要完成二者地址的翻译。</p>
<p>……</p>
<p>和mmap那个题目一样，sys_get_time以及sys_task_info也是需要在当前任务下才行</p>
<p>为什么突然写回来了呢……（因为在线CI测了sys_get_time还有sys_task_info 发现自己写的根本就不对</p>
<p>我知道哪里不行了 我的实现没问题 搞得我还重写了一次</p>
<p>每次执行系统调用的时候忘记调用<code>add_syscall_num</code></p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p><code>insert_frame_area</code>函数是比较值得参考的一个函数</p>
<p>不仅仅是函数实现的功能类似，用法也很值得学习</p>
<p>……</p>
<p>随后就是漫长的调试……</p>
<p>这里注意到特殊的一行</p>
<p><code>[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.</code></p>
<p>先找到这行输出是哪里来的，发现在<code>Trap_handler</code>方法里面</p>
<p>然后再考虑，发现其实我的程序连<code>mmap0</code>都没正常跑完</p>
<p>但是正确分配了页面，要不然就不会有<code>start_va:0x10000000~end_va:0x10001000 map_perm:0x16</code>输出</p>
<p>这里的<code>0x16</code>完全没问题（之前看成10进制了）</p>
<p><code>0001 0110</code> 代表<code>U</code>,<code>W</code>,<code>R</code>被置位 而测试用例<code>mmap0</code>给的是<code>3</code> 也就是<code>011</code> 也是对应<code>W</code>,<code>R</code></p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240518222104567.png" alt="image-20240518222104567"></p>
<p>妈的 我知道怎么搞了 之所以会不断出现<code>The Page you wanted has been alloced to others</code>的报错信息是因为之前在<code>sys_mmap</code>方法中对MemorySet中<code>mmap()</code>的调用是这样子的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取内核实例 取得所有权完成分配(这样不对 你并没有找到实际你要分配的位置) 实际上你是给内核多次分配了 所以才这样子报错</span></span><br><span class="line"><span class="keyword">let</span> num = KERNEL_SPACE.exclusive_access().mmap(start, len, port);</span><br><span class="line"><span class="comment">//之所以这样子写主要还是因为参考了前面insert_frame_area的用法 没有具体考虑他使用的上下文</span></span><br></pre></td></tr></table></figure>

<p>事实上应该找到当前运行的任务，只有当前运行的任务是知道自己的地址空间信息的，具体在<code>TCB</code>里面有一项<code>memory_set</code> </p>
<p>这里也走了点弯路 一开始我的想法是在<code>TaskControlBlock</code>中实现一个<code>get_current_tasks_area</code>（类似于之前<code>get_tasks_start_time</code>一样拿到时间）拿到<code>memory_set</code>的所有权或者引用之后，在<code>sys_mmap()</code>里面再用得到的<code>memory_set</code>来调用（我个人感觉主要还是仿照了前面代码的思路，就非要拿到一个类似于<code>KERNEL_SPACE</code>的地址空间，事实上没必要）</p>
<p>……</p>
<p>实现了<code>mmap</code>之后<code>munmap</code>就比较简单了</p>
<p>这里写一个点 关于<code>munmap</code>的最后一个测试用例</p>
<p>下面给一个比较滑头的办法 检查一下是不是页对齐就行（start硬编码写死了 所以其实你怎么写都差不多</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YOUR JOB: Implement munmap.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_munmap</span></span>(start: <span class="built_in">usize</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    trace!(<span class="string">"kernel: sys_munmap NOT IMPLEMENTED YET!"</span>);</span><br><span class="line">    <span class="keyword">if</span> start % PAGE_SIZE != <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> num = munmap_current_task(start, len);</span><br><span class="line">    num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按理说应该是实现一个检测解除映射范围和现有的映射区域是否完全一致的方法</p>
<p>明天再想吧……先看看能不能过在线CI</p>
<p>懂了 在线CI看不到报错 我就说为什么lab4的测例全过了assert断言还是不行</p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240505014117148.png" alt="image-20240505014117148"></p>
<p>这里可以看到比较详细的信息</p>
<p>这里记录一下回退的点 本地执行CI之后需要删除一些未跟踪的文件</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clean -f  删除未跟踪的文件（不包括目录）</span><br><span class="line">git clean -fd 删除未跟踪的文件和目录</span><br></pre></td></tr></table></figure>



<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240505171002449.png" alt="image-20240505171002449"></p>
<p>解决了 太sb了</p>
<h3 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h3><h4 id="之前的测例实现过程"><a href="#之前的测例实现过程" class="headerlink" title="之前的测例实现过程"></a>之前的测例实现过程</h4><p>经典内容……</p>
<p>注意一个点 在Lab5里面把TaskManager拆分成了TaskManager和processor两个数据结构</p>
<p>不过他们对进程信息的获取还是通过TaskControlBlock</p>
<p>关于初始化信息补全</p>
<p>忘记记录了……之前的测例实现基本就是cv，注意放到正确的数据结构里面重新实现一次就行</p>
<p>遇到一个新问题</p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240506003949090.png" alt="image-20240506003949090"></p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240506004011708.png" alt="image-20240506004011708"></p>
<p>这个<code>Write</code>系统调用莫名其妙多出这么多次数</p>
<p>我决定在增加系统调用的方法中加一行调试，打印一下系统调用编号</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 添加系统调用</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_current_syscall_times</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,syscall_id:<span class="built_in">usize</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> current_inner = <span class="keyword">self</span>.current.as_mut().unwrap().inner_exclusive_access();</span><br><span class="line">    current_inner.syscall_times[syscall_id] += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; + 1\n"</span>,syscall_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240506010214962.png" alt="image-20240506010214962"></p>
<p>出现了奇怪的输出</p>
<p>每次键入一个字符 对应着<code>read</code> <code>waitpid</code> <code>yield</code> <code>write</code>系统调用都+1了</p>
<p>虽然输出流打断了我的输入流 但是功能应该还是正常的 只是我没有键入回车键 所以用户程序没有被正常执行起来</p>
<p>应该是前面的实现有问题（</p>
<p>在父进程通过<code>fork()</code>系统调用创建子进程的时候，子进程不应该继承父进程的系统调用次数和开始时间</p>
<p>系统调用次数应该直接初始化为0才对（重新算</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_time:get_time_us() / <span class="number">1000</span>,</span><br><span class="line">syscall_times:[<span class="number">0</span>;MAX_SYSCALL_NUM]</span><br></pre></td></tr></table></figure>

<p>ok 这里可以过了</p>
<p>现在又有新问题了 还是<code>ch3_taskinfo</code>的测例</p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240506011435160.png" alt="image-20240506011435160"></p>
<p>好像还是过不了 但是断言错误的次数确实是减少了……</p>
<p>好像是用<code>println!()</code>打印调试信息的问题，如果去掉的话<code>Write</code>系统调用的次数就不会增加</p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240506013300058.png" alt="image-20240506013300058"></p>
<p>还真是 回头看了一下<code>console.rs</code>里面对<code>println!()</code>的实现 很明显是基于<code>Write</code>的</p>
<p>不然平白无故你的OS怎么能打印东西的……把这事情给忘记了    <del>笑</del></p>
<p>先一次性把时间信息都打印下来吧 后面就不看了</p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240506013635316.png" alt="image-20240506013635316"></p>
<p>我切换分支到<code>ch4</code>重新跑一下这个用例 <code>t1=43</code> <code>t2=544</code> <code>t3=544</code> <code>info.time=501</code>是没有问题的 </p>
<p>睡了 明天再说</p>
<p>……睡觉的时候突然想到Lab5的<code>run_tasks()</code>方法应该是没有修改 所以没有把时间信息记录下来</p>
<p>没错 就是在此处补一个记录时间的功能就ok了</p>
<h4 id="Spawn系统调用实现"><a href="#Spawn系统调用实现" class="headerlink" title="Spawn系统调用实现"></a>Spawn系统调用实现</h4><p>一遍过 感觉还是比较简单的…… 主要就是<code>fork()</code> <code>new()</code> 还有<code>exec()</code>的仿写</p>
<p>注意对parent字段特殊处理</p>
<p><code>spawn</code>出来的进程的父进程应该为当前运行的进程</p>
<h4 id="Stride调度"><a href="#Stride调度" class="headerlink" title="Stride调度"></a>Stride调度</h4><p>首先是在TCB里面增加进程优先级的字段<code>priority</code>和步长调度的参考数据<code>stride</code></p>
<p>其实是对初始化信息的补全</p>
<p>一开始我是看到的<code>processor.rs</code>的<code>run_tasks()</code>模块，里面有一个<code>fetch_tasks()</code>的过程，取得目前应该运行的任务。但是<code>fetch_tasks()</code>是局限在<code>Task Manager</code>内部，缺少<code>Processor</code>结构，也就是当下的任务状态拿不到（就是有一种可能性是当下正在运行的进程<code>stride</code>还是最小）</p>
<p>然后继续看源码 </p>
<p>感觉这几个函数之间的关系有点懵</p>
<p>……</p>
<p>后面感觉还是得在<code>add</code>位置实现，也就是<code>fetch</code>还是从队头把进程取出来，但是在<code>add</code>增加进程的时候维护所有进程的<code>stride</code>顺序</p>
<h3 id="Lab6"><a href="#Lab6" class="headerlink" title="Lab6"></a>Lab6</h3><h4 id="之前的测例"><a href="#之前的测例" class="headerlink" title="之前的测例"></a>之前的测例</h4><p>首先就是要通过之前的测例 <code>sys_spawn</code>和之前会有一些区别</p>
<p>主要就是获得程序数据的方式有差异</p>
<h4 id="本实验测试点"><a href="#本实验测试点" class="headerlink" title="本实验测试点"></a>本实验测试点</h4><p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240510225304112.png" alt="image-20240510225304112"></p>
<p>差最后一个</p>
<p>？？？</p>
<p>byd什么勾八</p>
<p>怎么实验还不能复现的 本地跑差一个点 在线ci全过了是吧</p>
<p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240510225444383.png" alt="image-20240510225444383"></p>
<h3 id="Lab8"><a href="#Lab8" class="headerlink" title="Lab8"></a>Lab8</h3><p>如果启用死锁检测功能的话，主要的检测就是在上锁相关的操作检测是否合法</p>
<p>这里有个困惑的点，就是一开始没搞懂<code>资源</code>到底是什么</p>
<p>其实就是各类的<code>lock</code>……能够得到锁 就代表得到了某个特定的资源</p>
<p>初始化是一门玄学……</p>
<p>需要自己设置好两个常量<code>MAX_THREADS</code>和<code>MAX_RESOURES</code>的数量，代表当前可以获得的资源</p>
<p>……</p>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><p><img src="/blog/.io//D:%5C116%5Csigs%5Cblog%5Csource_posts%5CRust%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8ARustlings%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86.assets%5Cimage-20240516200029337.png" alt="image-20240516200029337"></p>
<p>就卡在这里了，也不知道怎么回事</p>
<p>gpt问了一下</p>
<p>……死锁了 我就说为什么寄了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/18/2024%E5%B9%B4%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%93%E5%A0%82%E8%B6%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/18/2024%E5%B9%B4%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E5%8D%93%E5%A0%82%E8%B6%8A/" class="post-title-link" itemprop="url">2024年开源操作系统训练营第一第二阶段学习总结-卓堂越</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-18 15:22:54" itemprop="dateCreated datePublished" datetime="2024-05-18T15:22:54+00:00">2024-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-27 04:08:33" itemprop="dateModified" datetime="2025-04-27T04:08:33+00:00">2025-04-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024年开源操作系统训练营第一阶段学习总结-卓堂越"><a href="#2024年开源操作系统训练营第一阶段学习总结-卓堂越" class="headerlink" title="2024年开源操作系统训练营第一阶段学习总结-卓堂越"></a>2024年开源操作系统训练营第一阶段学习总结-卓堂越</h1><p>首先，我要衷心感谢所有给予我帮助助教导师。每次我有困惑的时候他们的专业知识和耐心指导帮我解决一系列棘手的问题。通过这个平台可以很好的交到对这方面感兴趣的朋友，在群里跟朋友们讨论让我可以更好地理解和应用 Rust 语法。此外，也离不开Rust 社区分享的宝贵的学习资料。同时课堂上分享的The Rust Reference 不失为一本经典巨作给我前期的语法学习提供很有力的帮助。<br>在开始开发操作系统之前，先熟悉 Rust 语言的基础知识，包括语法、类型系统、所有权和生命周期等概念为首要目标。选择Rust是因为他的安全性和性能使其成为编写操作系统的理想选择。在正式做练习之前花了很多时间在环境配置上面，之前学过的harmony os 都是他们给的镜像直接导入，第一次在上面搭建问了很多导师问题，他们都耐心的回答我，让我在这方面更有兴趣。比如在当推送本地更改时，如果远程仓库已经有了更新，可能会出现合并冲突，需要手动解决这些冲突。通过这些学习能更好的完成后面几个阶段的学习。<br>和其他语言对比在生命周期这个方面Rust 强制使用生命周期来检查引用的有效性，以避免悬空引用和数据竞争。生命周期注解使得 Rust 的借用系统变得更加严格和安全。C++ 中也有生命周期的概念，但它通常通过使用智能指针、RAII（资源获取即初始化）等技术。相比rust在这方面更不容易出错。而且在所有权上面Rust 引入了所有权和借用的概念，这是与 C++ 最明显的区别之一。在 Rust 中，每个值都有一个所有者，并且在任何时候只能有一个可变借用或任意数量的不可变借用。这确保了在编译时不会出现数据竞争。在以前学过的 C++ 中，没有类似的所有权和借用系统，开发人员需要手动管理内存和资源，这可能导致内存泄漏、悬空指针和其他常见的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let result;</span><br><span class="line">    &#123;</span><br><span class="line">        let x &#x3D; 5;</span><br><span class="line">        result &#x3D; compute(&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn compute&lt;&#39;a&gt;(value: &amp;&#39;a i32) -&gt; &amp;&#39;a i32 &#123;</span><br><span class="line">    value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个 main 函数，它调用了一个 compute 函数来计算一个整数的引用，并将结果赋值给 result 变量。然后我们尝试在 main 函数中打印 result 的值。然而，compute 函数返回了一个指向局部变量 x 的引用，而 x 的生命周期只在包含它的代码块内有效。由于 x 在 compute 函数返回后就会被销毁，所以返回的引用将指向无效的内存，导致悬垂引用错误。后期我发现需要通过修改函数签名来指定一个更长的生命周期，或者避免返回对局部变量的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let result;</span><br><span class="line">    &#123;</span><br><span class="line">        let x &#x3D; 5;</span><br><span class="line">        result &#x3D; compute(x);</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn compute(value: i32) -&gt; i32 &#123;</span><br><span class="line">    value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码的修改这样就避免了使用引用并返回了整数值本身，从而避免了悬垂引用错误。</p>
<h1 id="第二部分学习总结"><a href="#第二部分学习总结" class="headerlink" title="第二部分学习总结"></a>第二部分学习总结</h1><p>实验是按照rCore-Tutorial-Book-v3来完成的<br>环境搭建我是用了VMware 安装虚拟机在文档提供的直接使用</p>
<h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>这个任务主要是为了获取任务信息，通过引入新的系统调用 sys_task_info，操作系统增强了对任务的监控和管理能力。现在，系统管理员可以根据任务 ID 查询到任务的详细信息，包括当前任务的状态、已经执行的系统调用及其调用次数，以及任务的总运行时长。这个功能使得系统能够更加细致地了解任务的运行情况，有助于优化系统资源的分配，提高系统的整体性能和稳定性。同时，对于开发人员来说，这也提供了一个更好的调试工具，可以更方便地跟踪和分析任务的行为，帮助定位和解决潜在的问题。</p>
<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p>sys_get_time 函数的重写，我们重新设计了获取系统时间的逻辑，使其能够适应新的系统架构。这样，我们成功恢复了获取系统时间的功能，确保系统在引入新特性的同时不影响原有功能的正常运行。sys_mmap 和 sys_munmap 系统调用的实现，则为系统增加了动态内存管理的功能。通过 sys_mmap 系统调用，我们可以在虚存中映射一段指定长度的物理内存，为进程提供所需的内存空间。而 sys_munmap 则提供了取消内存映射的功能，帮助释放不再需要的内存空间，有效管理系统资源。</p>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><p>实现了一个完全 DIY 的系统调用 sys_spawn，用以创建一个新进程。与传统的 fork 和 execve 组合不同，sys_spawn 系统调用直接创建一个新的子进程，并使其执行指定的目标程序。这种方式更加直接，省去了复制父进程地址空间的步骤，从而提高了效率。在实现 sys_spawn 系统调用的过程中，我们需要处理一些可能的错误情况，比如无效的文件名或者系统资源不足导致的错误。通过正确处理这些错误，我们可以保证系统的稳定性和可靠性。通过这次实践作业，我们深入理解了进程创建的原理和实现方式，加深了对操作系统内核的理解。同时，也提高了我们对系统调用的理解和实现能力。</p>
<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>在本次实践中，我们要用到三个系统调用：sys_linkat、sys_unlinkat 和 sys_stat，分别用于创建硬链接、取消链接以及查询文件状态。通过这些系统调用，我们可以实现文件系统中文件的硬链接操作，并获取文件的状态信息，从而提高文件管理的便利性和灵活性。</p>
<h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>本次实验旨在实现一个新的系统调用 <code>sys_eventfd2</code>，用于在 Linux 系统中创建 eventfd，其功能是创建一个带有计数器的文件描述符，用于进程间事件通知。通过参数解析和错误处理，我们成功实现了该系统调用，并能够根据传入的参数创建相应的 eventfd，从而为进程间通信提供了一种有效的机制。</p>
<p>这次实验为我们提供了一个很好的机会，加深了对操作系统的理解，并提高了我们的系统编程能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/20/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/blog/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/59/">59</a><a class="extend next" rel="next" href="/blog/page/22/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
