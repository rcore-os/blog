<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/7/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">730</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">633</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/2025s-os-camp-123-summary-noah/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/2025s-os-camp-123-summary-noah/" class="post-title-link" itemprop="url">2025年春夏开源操作系统训练营三阶段总结-noah</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 14:33:00" itemprop="dateCreated datePublished" datetime="2025-05-25T14:33:00+00:00">2025-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025-春季开源操作系统训练营前三阶段总结报告"><a href="#2025-春季开源操作系统训练营前三阶段总结报告" class="headerlink" title="2025 春季开源操作系统训练营前三阶段总结报告"></a>2025 春季开源操作系统训练营前三阶段总结报告</h1><h2 id="学习背景"><a href="#学习背景" class="headerlink" title="学习背景"></a>学习背景</h2><p>在进行网络编程的时候，如果要提高程序的并发性能会用到 io 多路复用和协程，很多框架和语言都会有自己的实现，在逐渐深入的过程中，就会提出一些问题：</p>
<ul>
<li>io 多路复用 select、epoll、io_uring 是如何做到可以提高并发性的</li>
<li>阻塞和非阻塞又是如何做到的</li>
<li>到底什么是同步什么是异步</li>
<li>协程底层是如何实现的</li>
</ul>
<p>这些问题虽然网上有很多资料，但如果自己不亲自去写一些 case 去验证，感觉是很难理解透彻的。而这些技术的实现都是直接或者间接的依赖操作系统才可以做到，也就是说要理解这些知识点，那就必须要学操作系统的知识。</p>
<p>正好我也在模仿着想实现一个协程框架(有栈的)，发现要用到汇编知识，发现写操作系统也需要汇编知识，于是顺手查了下比较好的操作系统课程：</p>
<ul>
<li>南京大学的操作系统</li>
<li>清华大学操作系统 - ucore &amp; rcore</li>
<li>MIT xv6 操作系统</li>
</ul>
<p>在视频网站上看到有人分享参加了开源操作系统训练营，于是便在今年 1 月份就定计划要专供下操作系统的知识，来参与下开源操作系统训练营了，也算是补上十多年前没学好的专业课吧(出来混，早晚都要还的)</p>
<p>另外，也想通过这次的学习，寻找一些志同道合的朋友，一起进步。</p>
<h2 id="学习仓库"><a href="#学习仓库" class="headerlink" title="学习仓库"></a>学习仓库</h2><p>跟着老师和同学们一起学习用的代码仓库，里面包含了每次作业的提交内容</p>
<ul>
<li><a href="https://github.com/LearningOS/2025s-rustling-CreatorMetaSky" target="_blank" rel="noopener">rustling</a></li>
<li><a href="https://github.com/LearningOS/2025s-rcore-CreatorMetaSky" target="_blank" rel="noopener">rcore</a></li>
<li><a href="https://github.com/LearningOS/2025s-arceos-CreatorMetaSky" target="_blank" rel="noopener">ucore</a></li>
<li><a href="https://github.com/osxspace/qhos" target="_blank" rel="noopener">qhos</a> - 记录了一些学习笔记 - 记录的有些凌乱</li>
</ul>
<h2 id="各阶段学习内容总结"><a href="#各阶段学习内容总结" class="headerlink" title="各阶段学习内容总结"></a>各阶段学习内容总结</h2><h3 id="第一阶段-rustling"><a href="#第一阶段-rustling" class="headerlink" title="第一阶段 rustling"></a>第一阶段 rustling</h3><p>rustling 很久之前曾经刷过一遍了，这次是温故知新，复习了以下知识点：</p>
<ul>
<li>rust 的基本语法</li>
<li>模式匹配</li>
<li>所有权转移</li>
<li>容器智能指针</li>
<li>包管理机制</li>
<li>使用 async await</li>
</ul>
<h3 id="第二阶段-rcore"><a href="#第二阶段-rcore" class="headerlink" title="第二阶段 rcore"></a>第二阶段 rcore</h3><p>在学习 rCore 的过程中，首先通读了一遍 <a href="https://learningos.cn/rCore-Tutorial-Guide-2025S" target="_blank" rel="noopener">rCore-Tutorial-Guide</a>， 发现其中大部分章节只是罗列了代码的改动，对于基础知识原理，并没有过多的介绍。<br>又开始阅读学习 <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3" target="_blank" rel="noopener">rCore-Book</a>，后续配合陈渝老师导学阶段的视频(2022年教学视频)，才逐渐走上了学习的正轨。学到了以下知识：</p>
<p><strong>构建操作系统的步骤</strong></p>
<ul>
<li>env setup - 模拟器搭建裸机运行环境</li>
<li>libos - 在内核上跑一个最简单的程序</li>
<li>batchos - 支持批量运行多个程序 - 引入特权级机制</li>
<li>taskos - 实现分时多任务执行</li>
<li>asos - 地址空间以及映射</li>
<li>pos - 进程 - 从 TCB 到 PCB 的进化</li>
<li>fos - 支持文件系统 - 从文件读取程序执行</li>
<li>ipcos - 进程间通信 - shell 的方式进行进程切换</li>
<li>tcos - 线程、协程 - 进程对应资源，线程对应调度</li>
</ul>
<p><strong>操作系统内核核心组件</strong></p>
<ul>
<li>地址空间</li>
<li>进程管理和切换</li>
<li>文件系统</li>
</ul>
<p><strong>学到的具体知识点</strong></p>
<ul>
<li>程序的内存布局结构、如何通过 linker.ld 去修改程序布局</li>
<li>页表机制以及虚拟地址到物理地址的映射方式</li>
<li>进程的协作式调度和抢占式调度以及不同的调度算法的历史演进</li>
<li>文件系统 inode 的结构组织方式，逐层递进的调用方式，为深入理解一切皆 io 打下基础</li>
<li>从进程发展的角度去理解 fork exec spawn</li>
<li>进程间通信 pipe 和 shell</li>
<li>从操作系统源码层面深入的理解进程、线程、绿色线程以及它们的异同</li>
<li>理解互斥、同步的概念，锁、信号量、条件变量</li>
</ul>
<p><strong>帮助理解的知识点</strong></p>
<ul>
<li>操作系统的启动流程</li>
<li>中断和崩溃信号量机制的实现</li>
<li>内存分配和管理机制</li>
<li>IO 多路复用技术</li>
<li>协程以及调度实现</li>
<li>各种锁的实现原理</li>
<li>RingBuffer</li>
<li>LRU</li>
</ul>
<p>通过上述知识的学习，终于明白了操作系统是为上层应用开发提供硬件抽象的一种系统软件实现这句话，也为我揭开了操作系统的神秘面纱</p>
<h3 id="第三阶段-arceos"><a href="#第三阶段-arceos" class="headerlink" title="第三阶段 arceos"></a>第三阶段 arceos</h3><p>arceos 这部分主要是把老师的上课视频给走了一遍，个人理解就是把 rCore 中的各部分代码用 rust 的包管理机制打散，最终做到通过拼装组件就可以形成操作系统的效果，类似应用开发中的模块化和组件化。</p>
<p><strong>学到的知识点</strong></p>
<ul>
<li>unikernel 调用流程，如何从应用层通过系统调用调用内核的实现</li>
<li>如何拼装新的模块到 unikernel 中</li>
<li>理解 unikernel 到 宏内核的转变过程 - 解决特权级切换(用户态到内核态的切换)、地址空间的问题是关键</li>
<li>能够运行标准 linux 二进制 - 这块还是挺感兴趣的</li>
<li>hypervisor 这块牵扯到在虚拟环境中运行 rCore 操作系统 - 个人理解相当于在操作系统中再次嵌套操作系统 - 学的有点吃力了</li>
</ul>
<h2 id="总结学习方法"><a href="#总结学习方法" class="headerlink" title="总结学习方法"></a>总结学习方法</h2><h3 id="渐进式的学习"><a href="#渐进式的学习" class="headerlink" title="渐进式的学习"></a>渐进式的学习</h3><ul>
<li>what - 某个技术是什么，有个初步的认识</li>
<li>when - 什么时候用，在什么情况下或者说上下文下使用这种技术</li>
<li>how - 如何用这种技术，如何写代码</li>
<li>why - 为什么要用，为什么要使用这种技术</li>
<li>build - 内部是如何实现的，自己写一个</li>
</ul>
<h3 id="如何高效学习"><a href="#如何高效学习" class="headerlink" title="如何高效学习"></a>如何高效学习</h3><p>就像面试自己一样，不断地向自己提问题是最好的学习方式，这样才能加深理解，才算是真正理解</p>
<h2 id="遗憾之处"><a href="#遗憾之处" class="headerlink" title="遗憾之处"></a>遗憾之处</h2><ol>
<li>时间上的原因，并没有把自己提问的问题以及理解，全部深入的汇总出来</li>
<li>我们目前是学的 Risc-V 架构的操作系统，但是目前 x86 架构依然是主流，之前 uCore 的操作系统实现就是基于 x86 的，后续还要学习下 uCore 的实现。</li>
<li>在参加这次训练营的过程中，只是走马观花的看和了解了一些基础知识和概念，虽然也做了课后作业，但是跟自己实际上手去实现还是差着十万八千里，对于一些用到的库，基本都是拿来主义，也没有深入的去探索其内部的实现原理，如：内存分配算法，进程调度算法、rust-sbi，希望自己以后还是能脚踏实地的从头跟着 rCore-Book 手搓一个真正自己的操作系统。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/2025%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%9B%B9%E8%BE%B0%E5%AE%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/2025%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%9B%B9%E8%BE%B0%E5%AE%87/" class="post-title-link" itemprop="url">前三阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 10:12:26" itemprop="dateCreated datePublished" datetime="2025-05-25T10:12:26+00:00">2025-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/os/" itemprop="url" rel="index"><span itemprop="name">os</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="各阶段总结"><a href="#各阶段总结" class="headerlink" title="各阶段总结"></a>各阶段总结</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>rust的基本筛查，没什么说的。rust的诸多库日后再学，目前就系统库使用比较多。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>这里是一个简单的小操作系统</p>
<p>好的，这是参照您提供的原文，并进行书面化、精炼化处理后的中文版本：</p>
<h3 id="Chapter-1-应用程序与基本执行环境"><a href="#Chapter-1-应用程序与基本执行环境" class="headerlink" title="Chapter 1: 应用程序与基本执行环境"></a>Chapter 1: 应用程序与基本执行环境</h3><p>本章旨在阐明操作系统作为系统软件与应用层软件在执行环境层面存在的本质差异，而非对操作系统自身的复杂理论进行深入剖析。<br>同时，通过具体的代码范例，演示了在操作系统此种独特的执行环境下构建可执行程序的途径。</p>
<p>用户态程序的运行普遍依赖于特定的语言运行时环境及其附带的标准库。所谓运行时，通常包含预先编译的代码片段，用以实现诸如数组边界检查等基础功能；<br>标准库则对底层系统调用进行了封装，例如，常见的打印函数其内部便是通过<code>write</code>系统调用将数据输出至显示设备。<br>操作系统亦承担了程序运行的准备与善后职责，涵盖虚拟内存空间的辟配、程序代码的加载以及退出时的资源清理等环节。<br>但是，操作系统是直接运行于硬件之上的，并无现成的系统调用或预置软件可供利用，一切功能从零开始编码实现。</p>
<h3 id="Chapter-2-批处理系统"><a href="#Chapter-2-批处理系统" class="headerlink" title="Chapter 2: 批处理系统"></a>Chapter 2: 批处理系统</h3><p>本章的核心议题集中于系统调用的具体实现过程，此过程涉及较多工程实践层面的细节。从上下文保存与恢复的视角来看，系统调用与常规的函数调用具有相似性：<br>两者均要求在调用发生前保存当前的执行上下文（主要指寄存器状态），并在调用返回时予以恢复，<br>这与编译原理中函数调用的序言（prologue）和尾声（epilogue）机制异曲同工。</p>
<p>其主要差异体现在以下两个方面：</p>
<ol>
<li>操作系统必须负责保存所有的通用寄存器（因为用户态的调用约定对此并无保障）以及一系列关键的控制状态寄存器（CSRs），例如<code>sstatus</code>（记录CPU当前的特权级别）、<code>sepc</code>（记录发生trap时的指令地址，即trap返回后应继续执行的地址）、<code>scause</code>/<code>stval</code>（分别记录trap发生的原因及相关的附加信息）。这些CSRs对于用户态程序而言通常是透明的。</li>
<li>出于安全性的考量，操作系统必须为内核态的执行维护一个独立的内核栈，而非在用户栈的基础上进行扩展。RISC-V架构为此提供了<code>sscratch</code>寄存器，可用于保存内核栈的地址。当陷入（trap）发生时，操作系统可以从<code>sscratch</code>寄存器中获取内核栈的起始地址，并切换至内核栈上开始后续处理。</li>
</ol>
<p>另外，在此阶段，所有的内存操作均基于物理地址进行，尚未实现内核态与用户态之间的内存隔离。<br>理论上，应用程序能够访问包括内核栈在内的所有物理内存区域，这具有极大的潜在风险。此内存隔离问题将在后续实现虚拟内存机制时得到解决。</p>
<h3 id="Chapter-3-多道程序与分时多任务"><a href="#Chapter-3-多道程序与分时多任务" class="headerlink" title="Chapter 3: 多道程序与分时多任务"></a>Chapter 3: 多道程序与分时多任务</h3><p>第三章引入了抢占式（preemptive）机制。这使得操作系统能够以分时复用的方式交替运行多个程序，从而显著提升了系统的交互体验。</p>
<p>实现分时系统的关键技术在于引入了时钟（timer）中断。定时器会周期性地产生中断信号，使操作系统得以重新获得CPU的控制权，<br>并依据预设的调度策略来决定是否需要切换到另一个应用程序执行。这种应用程序间的切换过程，与系统调用的处理流程相似，均涉及到中断当前应用的执行并在稍后某个时刻恢复其运行，<br>因此同样需要对应用程序的运行上下文进行细致的保存与恢复。</p>
<p>在本章中，应用程序被抽象为“任务”（Task）的实体，并通过“任务控制块”（Task Control Block, TCB）的数据结构来进行统一的调度与管理。<br>实验任务之一是实现<code>trace</code>系统调用。一个值得注意的实现细节是，若实验要求分别统计每个应用程序的系统调用次数，这通常需要借助特定的数据结构<br>（例如二维数组）来实现。在设计实现时，若将此统计结构直接置于<code>TaskControlBlock</code>内部，可能会因<code>TaskControlBlock</code>自身内存布局或大小的限制而引发内核崩溃。<br>因此，将此类统计结构设计在更高层级的<code>TaskManager</code>中，通常是更为稳妥和健壮的方案。</p>
<h3 id="Chapter-4-地址空间"><a href="#Chapter-4-地址空间" class="headerlink" title="Chapter 4: 地址空间"></a>Chapter 4: 地址空间</h3><p>本章的核心内容围绕虚拟内存的实现展开。通过引入虚拟内存机制，每个应用程序都能拥有各自独立的、私有的地址空间，从而无需关心其在物理内存中的实际存储位置。<br>虚拟内存的管理主要依赖于诸如<code>MemorySet</code>和<code>MapArea</code>（原文提及<code>MemoryMap</code>，但在教程实践中<code>MapArea</code>更为常用）等精心设计的数据结构，<br>其核心设计思想与Linux等成熟操作系统中的虚拟内存管理机制存在共通之处。</p>
<p>硬件层面，内存管理单元（MMU）承担了虚拟地址到物理地址的自动翻译工作。操作系统仅需将页表的根节点指针（例如在RISC-V架构中，<br>此指针存放于<code>satp</code>寄存器）加载到特定的控制寄存器中，即可启用地址翻译功能。</p>
<p>虚拟内存机制的引入，对内核的整体结构进行了一次较大规模的重构。其主要原因在于，先前在系统调用处理和程序切换过程中所保存的上下文内容，<br>由于地址空间的根本性变革，必须进行相应的调整以适应新的内存模型。此过程涉及到若干复杂的技术细节：<br>例如，在启用虚拟内存之后，当程序从用户态陷入（trap）到内核态时，内核需要借助应用态的页表（或预设的内核自身映射关系）来访问并保存用户程序的上下文信息。<br>此外，由于内核与应用程序的地址空间通常是不同的（或者说，它们各自拥有不同部分的内存映射），在从用户态陷入内核态之前，<br>往往需要借助一个位于固定虚拟地址的“跳板页”（trampoline page）来实现上下文的平滑、安全切换。这些具体的设计考量与实现细节，<br>可能是在先前纯理论学习阶段未曾深入探究的。</p>
<p>本章实验中的一个难点可能在于<code>sys_trace</code>函数的移植。当需要向目标地址写入数据时，<br>一个常见的理解误区涉及对物理页号（Physical Page Number, PPN）的认知：PPN本身并非一个带有零填充的完整物理地址，它仅仅是物理页帧的一个编号。<br>正确的物理地址应通过将PPN左移页大小对应的位数（PAGE_SIZE，通常为12位，即乘以$2^{12}$），再加上页内偏移（offset）来计算得到。</p>
<h3 id="Chapter-5-进程"><a href="#Chapter-5-进程" class="headerlink" title="Chapter 5: 进程"></a>Chapter 5: 进程</h3><p>本章正式引入了“进程”（Process）这一核心概念。进程可以被视为前四章所学知识（例如内存管理、任务调度等）的进一步抽象、封装与整合。<br>进程抽象使得操作系统能够支持更为丰富和高级的语义，例如实现更为灵活多样的进程调度策略，<br>以及通过<code>fork()</code>和<code>exec()</code>等经典的系统调用来创建新进程和加载执行新程序。本章还通过实现一个简易的Shell，使得该实验性操作系统在功能完备性上又迈进了一步。</p>
<p>本章内容主要在于如何有机地结合前述章节所介绍的技术手段来实现进程这一核心概念，并补充了进程管理相关的诸多细节，<br>例如初始进程（init process）的启动流程、进程正常或异常退出后的资源回收（reap）机制等。</p>
<p>本章的实验内容可能包括：</p>
<ul>
<li><code>spawn</code>系统调用：其实现可视为<code>fork</code>与<code>exec</code>系统调用的某种组合。但其区别在于，<code>spawn</code>通常用于创建一个全新的进程来执行一个指定的程序，</li>
<li>它会为新进程创建全新的地址空间（<code>MemorySet</code>）并加载目标程序，而不是像<code>fork</code>那样完全复制父进程的地址空间。</li>
<li>stride调度算法：其实现主要是在调度器（例如<code>TaskManager</code>）的数据结构中为每个进程维护其步长（stride）和优先级（priority）等属性，</li>
<li>并依据这些属性进行调度决策。在透彻理解相关数据结构之后，该算法的实现过程相对较为清晰。</li>
</ul>
<h3 id="Chapter-6-文件系统"><a href="#Chapter-6-文件系统" class="headerlink" title="Chapter 6: 文件系统"></a>Chapter 6: 文件系统</h3><p>本章介绍了文件系统的具体实现，这一机制使得程序和数据能够持久化地存储在块设备（如磁盘）之上，而不仅仅是暂时驻留在易失性的内存之中。<br>尽管文件系统的基本理论可能已在其他课程中有所涉猎，但通过本章的实际动手实现，学习者可以深入了解到诸多实践层面的细节，<br>例如操作系统是如何与磁盘驱动程序进行交互的。由于磁盘驱动程序通常已经提供了一层硬件抽象（例如通过<code>BlockDevice</code> trait定义接口），<br>文件系统的实现便主要集中在遵循这些预定义的接口规范，并构建文件系统自身的逻辑结构（例如inode、dentry、superblock等核心概念的实现）。</p>
<p>在实验中实现硬链接（hard link）功能时，正确的处理方式是在目录条目（directory entry）中将新的文件名链接到目标文件的inode之上，<br>而不是为每一个硬链接都创建一个全新的inode副本。</p>
<p>实验过程中可能的问题：在向<code>DiskInode</code>等核心数据结构中添加过多字段时，有时可能会偶发性地触发与虚拟内存相关的<code>LoadPageError</code>或类似的错误，<br>且这种错误行为可能表现出一定的随机性或平台依赖性。其深层原因可能与数据结构在内存中的对齐方式、大小变化触及了某些边界条件，<br>或是与底层内存管理模块之间存在一些微妙的交互问题有关，这类问题通常具有较高的调试难度。</p>
<p>此外，由于引入了标准输入（stdin）和标准输出（stdout）的概念（它们通常作为文件描述符0和1存在），在通过<code>spawn</code>或类似机制创建新进程时，<br>必须确保正确初始化其文件描述符表，特别是<code>stdin</code>和<code>stdout</code>的指向，<br>否则可能导致新创建的进程无法正常进行输入输出操作（例如，测试程序可能无法打印任何内容到控制台）。</p>
<h3 id="Chapter-7-进程间通信"><a href="#Chapter-7-进程间通信" class="headerlink" title="Chapter 7: 进程间通信"></a>Chapter 7: 进程间通信</h3><p>本章内容有助于加深对Shell命令执行机制的理解，特别是关于管道（pipe）和重定向（redirection）的处理方式。例如，对于形如<code>a | b</code>的管道命令，<br>以及包含输入/输出重定向的复杂命令（如<code>cmd xx &gt; yy &lt;&lt; zz</code>），<br>其解析和执行流程并非简单的串行化处理，而是由Shell进行统一的调度与编排，从而在不同程序（进程）之间建立起正确的数据流。</p>
<p>本章的核心技术在于，通过为不同类型的IPC（Inter-Process Communication，进程间通信）资源（例如管道Pipe）实现一个统一的<code>File</code><br>trait（可理解为接口或特性），使得进程可以使用与文件操作相一致的文件描述符来管理这些IPC资源。举例来说，标准输出可以被视为一个实现了<code>File</code><br>trait的对象，对其执行<code>write</code>操作最终会将数据导向屏幕显示或传递给管道的下一级。</p>
<p>I/O重定向（例如使用<code>&gt;</code>和<code>&lt;</code>符号）也遵循相似的原理：操作系统层面通过修改目标进程文件描述符表中的相应条目，<br>使其指向特定的文件或其他I/O端点，从而实现数据流向的改变。</p>
<p>对于其他形式的进程间通信机制，例如基于环形缓冲区（ring buffer）实现的管道，同样可以为其封装<code>read</code>和<code>write</code>等文件操作接口。<br>当进程调用这些接口时，数据被读入或写入共享的环形缓冲区，以此方式实现了进程间的数据交换。</p>
<h3 id="Chapter-8-并发"><a href="#Chapter-8-并发" class="headerlink" title="Chapter 8: 并发"></a>Chapter 8: 并发</h3><p>本章探讨了操作系统与并发编程中的若干经典并发控制机制，例如锁（包括互斥锁Mutex、自旋锁SpinLock）、信号量（Semaphore）以及条件变量（Condition Variable）。</p>
<p>本章关于线程（Thread）管理的具体实现尤为值得关注。在此阶段，rCore的调度模型进一步向类Linux系统演进：线程成为基本的调度单位，<br>而进程（Process）则更多地扮演资源容器的角色，负责管理诸如文件描述符表（<code>fd_table</code>）、地址空间（<code>MemorySet</code>）等由同一进程内所有线程共享的资源。</p>
<p>为了支持多线程，进程需要为每一个在其内部运行的线程维护独立的运行上下文（Trap Context）和内核栈（Kernel Stack）。<br>由于同一进程内的所有线程共享相同的地址空间，它们的线程栈（用户态栈）通常被统一分配和管理在进程用户地址空间内的特定区域<br>（或者由内核统一管理，但对用户而言是透明的）。线程切换的机制，在保存和恢复上下文方面，与早期章节中描述的任务切换机制基本一致。<br>若发生跨进程的线程切换（即从一个进程中的线程切换到另一个不同进程中的线程），<code>switch</code>函数除了需要切换线程的上下文外，<br>还必须负责切换地址空间（即更换当前生效的页表），以确保线程能够在新的目标进程的地址空间中正确运行。</p>
<p>本章的实验任务之一是实现银行家算法（Banker’s Algorithm），这是一个经典的用于避免死锁的算法。</p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>arcore 阶段，这是另一个更严谨也更复杂一点的系统</p>
<h3 id="组件化基础-Unikernel内核"><a href="#组件化基础-Unikernel内核" class="headerlink" title="组件化基础 - Unikernel内核"></a>组件化基础 - Unikernel内核</h3><h4 id="课堂"><a href="#课堂" class="headerlink" title="课堂"></a>课堂</h4><p>组件化内核设计，即通过选择和组合可复用的软件模块来构建内核。这种方法使得构建各种类型的内核（从简单的 Unikernel<br>到更复杂的宏内核或 Hypervisor）具有灵活性，可以通过增量添加或扩展组件来实现。系统的启动过程也正体现了这一理念：<br>首先由特定于体系结构的硬件抽象层 (axhal) 进行早期设置（如 MMU 和栈初始化），然后转换到通用运行时环境 (axruntime)，<br>后者会初始化日志、内存分配器和调度器等更多系统，并最终运行主应用程序。通过features可以实现定制化，允许开发者编译仅包含特定应用所需组件的内核。</p>
<p>之后我们讲了内存管理。</p>
<p>内存管理 是一个关键方面，包含两个核心领域：</p>
<p><strong>分页 (paging)</strong> 是分阶段实现的。这类似于现代操作系统（如 Linux 或 Windows）中的虚拟内存机制。<br>一个强制的初始阶段建立基本的内存映射（例如，内核代码和数据的直接映射）；<br>一个可选的第二阶段则重建更完整、更细粒度的虚拟到物理地址映射 ，这对于管理更大的地址空间（如整个物理内存上限）和设备 MMIO（内存映射 I/O，例如 UART、VirtIO 插槽的物理地址 0x1000_0000 等被映射到虚拟地址 0xffff_ffc0_1000_0000 ）至关重要。</p>
<p>通过 axalloc 组件引入了 动态内存分配，它提供了一个 GLOBAL_ALLOCATOR 。这与 C 语言中的 malloc/free 或 C++ 中的 new/delete 作用类似。该分配器支持字节和页分配，并采用了多种算法（如文稿中提到的 TLSF、Buddy、Slab 算法 ），从而能够支持像 Rust 的 Vec（动态数组）或 HashMap（哈希表）这类需要动态调整大小的数据结构 。</p>
<p><strong>任务管理与调度</strong>对于实现并发至关重要。系统定义了任务状态（如图中所示的运行、就绪、阻塞、退出 ），并使用 TaskContext（保存了如 ra 返回地址、sp 栈指针以及 s0-s11等被调用者保存寄存器 ）在上下文切换期间保存和恢复任务状态。探讨了多种调度算法：</p>
<p>协作式 FIFO调度：任务会一直运行，直到完成或主动调用 yield_now  放弃 CPU。这与早期单任务操作系统或者一些需要应用明确出让控制权的系统（如早期的 Windows）相似。<br>但是，如果一个任务陷入死循环或长时间不调用 yield_now，其他任务将得不到执行机会，造成系统“假死”。</p>
<p>抢占式轮询 (Round Robin, RR) 调度：为任务分配时间片（如 MAX_TIME_Slice ），当定时器中断发生，发现当前任务时间片耗尽时，调度器可以抢占该任务，并将其移至就绪队列的末尾 。这常见于简单的实时操作系统或分时系统。<br>注意时间片设置过短会导致频繁的上下文切换，增加系统开销；设置过长则会降低系统的响应速度。<br>完全公平调度器 (Completely Fair Scheduler, CFS)：这种抢占式算法使用一个名为 vruntime (虚拟运行时间) 的概念来确定任务优先级 。vruntime 最小的任务将下一个运行，而 vruntime 的值受任务实际运行时间和其 ‘nice’ 值（优先级）的影响 。Linux 当前的默认调度器就是 CFS 的一种实现。</p>
<p>最后是设备交互与文件系统：</p>
<p>设备管理框架 (AllDevices)  为访问不同类型的设备（如块设备、网络设备和显示设备 ）提供统一途径，类似于 Windows 中的设备管理器或 Unix 系统中的 /dev 目录。例如，当需要访问某个 VirtIO 块设备时，上层会通过 AllDevices 查找对应的驱动实例。<br>注意，设备驱动在 probe 阶段（如 probe_bus_devices  或针对 QEMU VirtIO MMIO 的地址范围探测 ）如果未能正确识别硬件或初始化失败，设备将无法使用。我在做题时因为漏了一个参数卡了半天（真半天）</p>
<p>VirtIO 模型被用作设备驱动程序的示例，突出了 vring（一种共享内存环形缓冲区）在客户机和主机之间高效通信以及中断处理方面的应用 。这是一种在虚拟化环境中（如 QEMU ）常用的半虚拟化设备接口。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>大部分题都在这一阶段，print_color更改下宏的定义就可以。hashmap我参考了hashbrown</p>
<p><strong>hashbrown</strong></p>
<p>hashbrown 之所以高效，主要归功于其精妙的SwissTable算法实现，该算法源自 Google。其核心优势在于缓存友好 (cache-friendliness) 和SIMD (Single Instruction, Multiple Data) 指令集的有效利用。</p>
<p>下面是一些核心要点：</p>
<p>开放寻址 (Open Addressing)：与链式哈希表（separate chaining）不同，hashbrown 使用开放寻址策略，将所有条目直接存储在主哈希表数组中。这减少了指针间接寻址带来的开销，并提高了缓存局部性。当发生哈希冲突时，它会探测（probe）数组中的其他位置，直到找到一个空槽。</p>
<p>二次探测：简单易懂，就是遇到冲突后再次探测</p>
<p>元数据与主数据分离存储: hashbrown 将每个槽的元数据（例如哈希值的高位和控制字节）与实际的键值对分开存储。元数据通常更小，可以更紧凑地排列。</p>
<p>SIMD 优化查找: hashbrown 利用 SIMD 指令并行地检查多个元数据槽。它将哈希值的一部分（通常是高7位）存储在控制字节中。在查找、插入或删除操作时，可以加载一组控制字节（例如16个字节），并使用单个 SIMD 指令与目标哈希值的高位进行比较。这极大地加速了匹配过程，尤其是在哈希表密集的情况下。</p>
<p>特殊控制字节 (Special Control Bytes)：控制字节不仅存储部分哈希值，还用于标记槽的状态，例如：</p>
<p>EMPTY: 槽为空。<br>DELETED (或称 TOMBSTONE): 槽之前被占用但现在已删除。这对于开放寻址的正确探测至关重要。<br>FULL: 槽已占用，并存储了部分哈希值。<br>低开销的元数据: 每个条目仅需要1字节的元数据开销（控制字节），这比许多其他哈希表实现要低得多，从而提高了内存效率。</p>
<p>默认使用快速的非加密哈希算法: hashbrown （以及现在 Rust 标准库中的 HashMap）通常默认使用像 FxHash 或类似的快速非加密哈希算法。这类哈希算法对于整数等简单键类型非常快，但可能不适用于需要抵抗哈希洪水攻击 (HashDoS) 的场景。</p>
<p><strong>bump内存算法</strong><br>这里我们的bump_allocator是一个双端分配器，一边是零散的小字节分配，一边是整页分配。只要注意好内存检查（插入内存有没有侵入已分配的这端的，以及<br>如果分配的特别多会不会影响到另一端的），然后两个标记指明当前内存分配位置即可。</p>
<h3 id="Monolithic-Kernel宏内核"><a href="#Monolithic-Kernel宏内核" class="headerlink" title="Monolithic Kernel宏内核"></a>Monolithic Kernel宏内核</h3><h4 id="课堂-1"><a href="#课堂-1" class="headerlink" title="课堂"></a>课堂</h4><p><strong>异构内核扩展</strong></p>
<p>核心目标是在保证可扩展性和高性能的前提下，让不同内核架构（如Unikernel、宏内核、Hypervisor）能够复用核心组件（称为”Backbone”）和系统服务 。</p>
<p>任务（Task）单元的扩展 是关键，因为任务是内核资源的集合体 。Unikernel的任务可能仅包含基本的上下文信息，而宏内核任务需要页表信息和文件描述符，Hypervisor任务则需要VCPU状态等 。<br>为了优雅地处理这些差异，而不直接修改核心Task结构（这会降低可读性和异构扩展性 ），或者避免像旧版Starry那样通过TaskID索引外部结构（这会带来性能开销 ），ArceOS引入了 extension域机制 。<br>这类似于在C语言结构体中预留一个void*指针，具体类型由使用者定义。具体做法是在Task结构中增加一个extension指针，外部模块可以预先定义好特定于某种内核模式的扩展对象（例如，宏内核的进程控制块），<br>然后在创建任务时在堆上分配内存给这个扩展对象，并将extension指针指向它 。这样，访问扩展域的开销接近于普通结构体成员访存，同时保证了不同内核模式按需扩展的灵活性 。<br>例如，宏内核的扩展可以包含指向其独立地址空间（页表）的引用和文件描述符表。未来的工作甚至设想了扩展的泛型化，使得不同类型的任务（Unikernel任务、宏内核进程、自定义任务）<br>可以携带不同的扩展，并在同一套调度、文件系统、网络框架下运行，例如在众核处理器上，某些核心运行Unikernel任务进行高性能计算，另一些核心运行宏内核任务负责管理和交互 。</p>
<p>系统服务的复用 也是一个重要议题，特别是如何让Unikernel已经提供的服务（如文件描述符表 Fd_table、虚拟内存管理、API处理器）方便地被其他架构（如宏内核）复用 。<br>挑战在于资源的隔离与共享：Unikernel中资源通常是全局唯一的，而宏内核中资源则归属于进程，并通过clone等机制控制共享 。<br>一个具体的复用目标是arceos_posix_api，它原本为Unikernel提供POSIX接口适配，但在宏内核场景下，可以直接复用其复杂的语义检查逻辑作为SYSCALL层的一部分，而无需为宏内核重新实现一套，从而减少冗余和开发精力 。<br>为了实现这种复用，引入了Resource（定义资源，使用Arc指针管理以支持共享）和NameSpace（保存所有Resource的集合）的概念 。对于Unikernel，NameSpace是全局唯一的；对于宏内核，每个任务（进程）拥有一份NameSpace，可以动态分配 。<br>Global namespace的布局可以在编译期通过link_section将所有全局Resource集中在特定段（如axns_resource段）来确定 。<br>当宏内核需要独有的NameSpace时，可以在堆上分配空间并将全局NameSpace拷贝过去；需要共享时，则利用Arc指针指向全局或父进程的Resource，<br>这样修改对共享的线程间可见，同时避免了不必要的拷贝开销 。这种设计使得新功能（如新的系统调用或资源类型）更容易接入，并与组件化思想联动。</p>
<p>总结来说，面对未来多样化的应用场景（如智能家居中需要高性能Unikernel的边缘节点和需要安全性的微内核或宏内核的控制中枢 ），组件化为异构内核的快速构建提供了有力支持，<br>它通过Unikernel基座和精心设计的扩展机制（如Task extension和Namespace），在最大化组件复用和灵活性的同时，兼顾了不同内核模式的特性需求 。<br><strong>宏内核演进</strong></p>
<p>核心在于引入用户特权级、独立的用户地址空间以及系统调用机制，最终目标是能够直接运行原始的Linux应用程序（二进制）。</p>
<p>从未经修改的Linux应用（通常使用glibc或musl-libc编译）的角度看，它期望运行在一个与内核隔离的用户地址空间，并通过标准的系统调用（syscall）接口与内核交互 。<br>为了实现这种兼容性，组件化宏内核需要在几个层面进行适配：</p>
<p>用户地址空间的创建与管理：与Unikernel共享单一地址空间不同，宏内核为每个用户应用（进程）创建独立的页表和地址空间（AddrSpace对象）。<br>通常，页表的高端部分映射内核空间（所有进程共享），低端部分则映射独立的用户应用空间 。这意味着加载应用时，<br>内核会将ELF文件的代码段和数据段加载到用户地址空间的预定虚拟地址 。</p>
<p>ELF格式应用的加载：大多数应用编译为ELF格式。内核需要解析ELF头获取入口点（Entry point）以及各个段（Segment）的信息，<br>特别是类型为LOAD的段（代码段和数据段）。需要注意，ELF文件中段的偏移（Offset）和文件大小（FileSiz）可能与加载到内存后的虚拟地址（VirtAddr）<br>和内存大小（MemSiz）不同，尤其是BSS段（未初始化数据段），它在ELF文件中不占空间，但加载时需要在内存中预留并清零 。</p>
<p>用户栈的初始化：Linux应用（尤其是使用标准C库的应用）的main函数执行前，C库的启动代码会检查用户栈上的参数，如argc（参数个数）、<br>argv（参数指针数组）和envp（环境变量指针数组），甚至auxv（辅助向量）。因此，内核在切换到用户态执行应用首条指令前，<br>必须在用户栈上按照约定的布局准备好这些信息，并正确设置用户栈指针（SP寄存器）。<br>特权级切换与系统调用处理：应用通过特定的指令（如RISC-V的ecall ）陷入内核态发起系统调用。内核需要在异常处理流程中识别出系统调用，<br>并根据调用号分发到相应的处理函数 。例如，示例m_3_0中涉及的set_tid_address (96), ioctl (29), writev (66), exit_group (94)等都是具体的系统调用 。<br>对于从内核态首次启动用户任务，由于多数架构没有直接的“切换到用户态”指令，一种常见的做法是在内核态伪造一个来自用户态的异常上下文现场（包括用户态的PC、SP、状态寄存器等），<br>然后通过异常返回指令（如RISC-V的sret）“返回”到用户态开始执行应用 。</p>
<p>任务属性扩展：为了在复用Unikernel调度机制的同时支持宏内核的进程概念，TaskInner结构通过ext成员进行了扩展 。<br>这个ext可以是一个空结构体（对于Unikernel），也可以是一个包含进程特有信息（如指向其用户地址空间AddrSpace的引用、进程ID等）的结构体（对于宏内核）。<br>这使得调度器只关注通用的任务属性，而将资源管理等模式相关的特性封装在扩展中 。</p>
<p>为了支持更高级的内存管理特性，如 缺页加载（Lazy Loading）和内存映射（mmap），内核需要处理页错误（Page Fault）异常 。<br>当应用访问一个尚未建立有效物理映射的虚拟地址时（例如，通过init_user_stack(&amp;mut uspace, false)设置用户栈为Lazy映射 ），会触发页错误。<br>内核的页错误处理函数（如handle_page_fault）会介入，它通常会查找该虚拟地址所属的MemoryArea（内存区域）。每个MemoryArea关联一个Backend，<br>负责具体的映射操作 。Backend可以有两种主要类型 ：</p>
<p>Linear Backend：用于已存在的、连续的物理内存区域的直接映射，例如设备MMIO或共享内存。</p>
<p>Alloc Backend：用于按需分配物理页帧并建立映射。在缺页异常发生时，Alloc后端会申请物理页帧，然后在页表中补齐映射 。<br>sys_mmap系统调用的实现也与此类似：如果populate参数为true，则立即分配并映射；如果为false，则仅建立空映射，<br>等待后续访问时通过缺页异常来实际分配物理页面 。</p>
<p>此外，为了更好地兼容Linux生态，还需要支持像ProcFS、SysFS这样的 伪文件系统，它们提供内核和进程信息的接口（如/proc）或暴露设备信息（如/sys）。<br>在ArceOS中，这些可以通过axfs_ramfs的实例或专门的axfs_devfs组件来实现 。</p>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><strong>page_fault</strong></p>
<p>缺页相应，这里其实系统里已经有不少实现了，我们只需要获取当前用户空间，然后调用find_free_area和map_alloc就可以了</p>
<p><strong>ramfs_rename</strong></p>
<p>这里首先要修正依赖，让测试依赖本地的axramfs（笑），这里依赖本地的库之后，在dir.rs中添加rename的函数，这里底层是用了BTreeMap来保存<br>已经申请过的文件，然后值对应着在内存中的物理节点。更改BTreeMap就可以了，字符串处理仿照其他实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/24/rcore-study-report-by-mio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/24/rcore-study-report-by-mio/" class="post-title-link" itemprop="url">rcore-study-report-by-mio</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-24 23:48:45" itemprop="dateCreated datePublished" datetime="2025-05-24T23:48:45+00:00">2025-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="rustling-阶段总结"><a href="#rustling-阶段总结" class="headerlink" title="rustling 阶段总结"></a>rustling 阶段总结</h2><p>先来一份 C++ 转 Rust 急救指南（</p>
<h3 id="Mutable-Borrow-amp-take-ownership"><a href="#Mutable-Borrow-amp-take-ownership" class="headerlink" title="/ Mutable Borrow &amp; take ownership"></a>/ Mutable Borrow &amp; take ownership</h3><p>rust 中函数传递参数有三种方式，不可变借用，可变借用以及获取所有权。这三种方式贯穿了 rust 的设计思想。<br>它们的定义对应了 <code>&amp;T, &amp;mut T, T</code> 三种类型。与 C++ 不同，rust 中值传递的默认行为是 <code>move</code> 而非 <code>copy</code>，对于 <code>copy</code> 需要实现 <code>Copy</code> 的 trait。 且类型一旦实现 <code>Copy</code> trait 之后，默认行为就变为 <code>copy</code>。</p>
<h3 id="Borrow-amp"><a href="#Borrow-amp" class="headerlink" title="Borrow &amp;"></a>Borrow &amp;</h3><p>rust 中的 <code>&amp;T</code> 应等同于 C++ 中的指针，只是 rust 对于 <code>&amp;T</code> 实现了隐式 <code>Deref</code>，在大部分情况下避免了显式 <code>* / &amp;</code>。<br>迭代器有三种类型：<code>iter(), iter_mut(), into_iter()</code>，分别对应了 <code>&amp;T, &amp;mut T, T</code> 三种类型。</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>rust 中迭代器的成员函数被分为两类，<strong>Non-Consuming Adaptors</strong> 返回对应的迭代器，是惰性的，<strong>Consuming Adaptors</strong> 返回结果，会消耗迭代器的所有权，在使用后无法再次使用该迭代器。</p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p><code>[]</code> 应返回 <code>&amp;T</code> 或 <code>&amp;mut T</code>，不应获取所有权，这是为了避免通过 index 访问而隐式获得所有权的情况。</p>
<h3 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a>Deref</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Deref</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span>: ?<span class="built_in">Sized</span>;  <span class="comment">// 关联类型，表示解引用后的目标类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Self::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 rust 中关于 Deref 的定义，通过在 impl 的时候指定相关的类型，就可以无需像泛型定义那样显式指定类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Deref <span class="keyword">for</span> <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = <span class="built_in">str</span>; <span class="comment">// 指定解引用目标为 `str`</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="built_in">str</span>::from_utf8_unchecked(&amp;<span class="keyword">self</span>.as_bytes()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此我们也知道了，对于一个 <code>Deref</code> 实现来说，它所返回的类型是 single 的，并不会出现解引用可以返回不同类型的情况。对 <code>&amp;String</code> 解引用可以得到 <code>&amp;str</code>，是因为 <code>Target = str</code>。<br>正因如此，编译器可以通过 <code>T, U</code> 类型推断这两个类型是否可以通过 <code>Deref</code> 转换。</p>
<h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h3><p><code>Drop::drop()</code> 会在变量离开作用域后由编译器隐式调用，不应显式调用该函数。<br><code>Drop</code> trait 被实现用于回收资源，若需要显式调用，可使用 <code>std::mem::drop(x)</code> 通过消耗 <code>x</code> 的所有权来提前触发析构。</p>
<h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h3><p>在编译时允许同时存在多个可变引用，但运行时仍会检查是否存在多个可变引用，通过 <code>borrow(), borrow_mut()</code> 中的引用计数来实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RefCell</span></span>&lt;T&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">    borrow_count: <span class="built_in">usize</span>,</span><br><span class="line">    is_mut_borrowed: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; RefCell&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">borrow</span></span>(&amp;<span class="keyword">self</span>) -&gt; Ref&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_mut_borrowed &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Already mutably borrowed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.borrow_count += <span class="number">1</span>;</span><br><span class="line">        Ref &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">borrow_mut</span></span>(&amp;<span class="keyword">self</span>) -&gt; RefMut&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.borrow_count &gt; <span class="number">0</span> || <span class="keyword">self</span>.is_mut_borrowed &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Already borrowed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.is_mut_borrowed = <span class="literal">true</span>;</span><br><span class="line">        RefMut &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RefCell&lt;T&gt;</code> 会返回 <code>Ref&lt;T&gt;</code> 或者 <code>RefMut&lt;T&gt;</code>。<code>Ref&lt;T&gt;</code> 的所有权检查发生在运行时，且可以通过 <code>map</code> 来拆分借用，更加灵活。<br>可以通过 <code>RefCell</code> 来实现内部可变性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cache</span></span> &#123;</span><br><span class="line">    data: RefCell&lt;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cache &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_data</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="comment">// 检查缓存</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cache = <span class="keyword">self</span>.data.borrow_mut();</span><br><span class="line">        <span class="keyword">if</span> cache.is_none() &#123;</span><br><span class="line">            *cache = <span class="literal">Some</span>(<span class="string">"Expensive result"</span>.to_string());</span><br><span class="line">        &#125;</span><br><span class="line">        cache.as_ref().unwrap().clone()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> cache = Cache &#123; data: RefCell::new(<span class="literal">None</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Data: &#123;&#125;"</span>, cache.get_data()); <span class="comment">// 计算并缓存</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Cached: &#123;&#125;"</span>, cache.get_data()); <span class="comment">// 直接读取缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>borrow_mut()</code> 时，由于变量的生命周期与临时值不同，应谨慎与变量进行绑定。</p>
<h3 id="Lifetime"><a href="#Lifetime" class="headerlink" title="Lifetime"></a>Lifetime</h3><p>rust 的临时值会在表达式结束后析构，因此允许存在这样的情况。在 <code>clone2.borrow_mut()</code> 语句执行的时候，<code>clone1.borrow_mut()</code> 已经被析构，所以 <code>borrow_mut()</code> 不会因为引用计数 <code>&gt; 1</code> 而崩溃。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shared_data = Rc::new(RefCell::new(<span class="number">42</span>)); <span class="comment">// 克隆 Rc（共享所有权） </span></span><br><span class="line"><span class="keyword">let</span> clone1 = Rc::clone(&amp;shared_data); </span><br><span class="line"><span class="keyword">let</span> clone2 = Rc::clone(&amp;shared_data);</span><br><span class="line">*clone1.borrow_mut() += <span class="number">10</span>; <span class="comment">// 步骤1：获取可变借用，修改后立即释放</span></span><br><span class="line">*clone2.borrow_mut() *= <span class="number">2</span>;  <span class="comment">// 步骤2：前一个可变借用已释放，安全获取新借用</span></span><br></pre></td></tr></table></figure>
<p>作为对比，如果改成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shared_data = Rc::new(RefCell::new(<span class="number">42</span>)); <span class="comment">// 克隆 Rc（共享所有权） </span></span><br><span class="line"><span class="keyword">let</span> clone1 = Rc::clone(&amp;shared_data); </span><br><span class="line"><span class="keyword">let</span> clone2 = Rc::clone(&amp;shared_data);</span><br><span class="line"><span class="keyword">let</span> longer_lifetime = clone1.borrow_mut();</span><br><span class="line">*longer_lifetime += <span class="number">10</span>; </span><br><span class="line">*clone2.borrow_mut() *= <span class="number">2</span>;  <span class="comment">// 前一个可变借用未释放，程序崩溃</span></span><br></pre></td></tr></table></figure>
<p>就无法正常运行，因为 <code>longer_lifetime</code> 作为 <code>RefCell</code> 和 <code>NLL</code> 的交互，其行为表现为它的生命周期持续到该作用域结束。</p>
<h3 id="Non-Lexical-Lifetime"><a href="#Non-Lexical-Lifetime" class="headerlink" title="Non-Lexical Lifetime"></a>Non-Lexical Lifetime</h3><p>Non-Lexical Lifetimes (NLL) 是 Rust 编译器的一项核心特性，通过更精细的生命周期分析，允许变量在其<strong>最后一次使用后</strong>立即释放（而非必须等到词法作用域结束），但与某些类型的交互具有其他的表现。</p>
<h3 id="Copy-amp-Clone"><a href="#Copy-amp-Clone" class="headerlink" title="Copy &amp; Clone"></a>Copy &amp; Clone</h3><p><code>Copy</code> trait 是面向编译器实现的，<code>Clone</code> trait 是面向程序员实现的。一旦实现 <code>Copy</code> trait 默认行为将变为 <code>copy</code> 而非 <code>move</code>。在语义上，如果实现了 <code>Copy</code>，实现的 <code>Clone</code> 应当与之相容，可以通过调用 <code>[#derived(Copy, Clone)]</code> 获取默认实现。<br>并没有对于 <code>Clone</code> trait 实现的硬性约束。</p>
<p>这些是我觉得印象比较深刻的点，除此之外感觉似乎不太难。rust 唯一能折磨我的数据结构只有 <code>Box&lt;T&gt;</code>，但归根到底还是没有完全学会语言底层逻辑，没有完全学会用 rust 的方式写代码。</p>
<h2 id="rcore-阶段总结"><a href="#rcore-阶段总结" class="headerlink" title="rcore 阶段总结"></a>rcore 阶段总结</h2><p>进入到这个阶段之后意识到，之前学的 xv6 还是有些太玩具了，尽管 rcore-os 也是一个教学用途的操作系统，但它的深度似乎是远大于 xv6 的，你可以在这里面接触到链接器是如何编写的，如何用自己的一套交叉编译工具链来编译并且运行 kernel 以及裸机程序。</p>
<p>Chapter1 给我的印象很深刻，上来就告诉我们要写一个裸机程序，要抛弃 std 库，但彼时的我还是连 rustling 都没有写明白的完全的 rust 萌新，看到这些东西未免觉得有些难以下手，好在 rcore-os 提供的简明 Tutorial 十分清晰，静下心来读基本上没有不理解的地方。</p>
<p>整个 rcore 阶段最困扰我也是让我思考了最久的一个问题：</p>
<blockquote>
<p>为什么一个物理页不会同时被分配为页表和供内存使用？</p>
</blockquote>
<p>因为在创建页表的过程中会使用 <code>PageTable.map()</code>，该函数会调用 <code>PageTable().find_pte_create()</code>，在这一创建多层页表的过程中会使用 <code>frame_alloc()</code>。<br>而在分配内存的部分，<code>MemorySet</code> 的 <code>Framed</code> 映射会调用 <code>frame_alloc()</code> 分配新的物理页供其使用，这是除了创建页表之外我们唯一能使用到 <code>[ekernel, MEMORY_END)</code> 这段内存的部分。<br>而在 <code>MemorySet</code> 里，主要是 <code>KERNEL_SPACE</code> 会产生一个恒等映射 <code>[ekernel, MEMORY_END)</code>。这部分恒等映射被用于寻找页表。<br>即使开启虚拟内存映射后，我们在 <code>PhysPageNum.get_pte_array()</code> 处也可以直接将 <code>pa</code> 转为 <code>*mut PageTableEntry</code>，就是因为此处的恒等映射会直接将 <code>pa</code> 对应的虚拟地址映射为物理地址。</p>
<p>我觉得愿意去弄明白这些，不给自己留有太多的疑惑，这个阶段的收获基本是不小的。</p>
<p>rcore-os 阶段让我印象最深刻的 lab 还是 filesystem 相关的部分，要求我们试着给文件维护一个引用计数。这个引用计数维护起来并不困难，但对于这样持久化的数据来说，在什么抽象层来维护十分重要，如果在视图层维护，那么是无法维护的。具体来说 <code>OSInode</code> 和 <code>Inode</code> 便是对于 <code>DiskInode</code> 的视图，而看明白这一点，需要对整个代码的结构有比较好的了解。</p>
<h2 id="arceos-阶段总结"><a href="#arceos-阶段总结" class="headerlink" title="arceos 阶段总结"></a>arceos 阶段总结</h2><p>这个阶段是我过的比较急的一个阶段。但其实这个阶段的代码质量远高于 rcore-os 阶段，因为是接近工业级别的代码，解耦合等各种设计思想也能学到不少。</p>
<p>lab2 的实现 HashMap 是我耗时最长的一个 lab，因为对于 Box<T> 的特性不太熟悉，而且在不可变引用迭代器中，又很容易涉及到 second borrow 的问题。</p>
<p>感觉这个阶段的 lab 都是很贴近实际工程环境的 lab，但难度相较于 rcore-os 阶段来说其实下降了一些，因为通过 demo 并不要求效率，也不考虑 corner case。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/24/ACrazyShark-25rcore-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/24/ACrazyShark-25rcore-blog/" class="post-title-link" itemprop="url">ACrazyShark-25rcore-blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-24 23:00:15" itemprop="dateCreated datePublished" datetime="2025-05-24T23:00:15+00:00">2025-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是ACrazyShark（李卓恒）。今年2月，我和志同道合的同学们组队报名了全国大学生系统能力赛操作系统内核赛道，开启了操作系统开发的探索之旅。备赛过程中，我们有幸接触到由清华大学等高校打造的rcore训练营——这个以Rust语言重写Linux内核的实践项目，不仅帮助我们构建了从理论到落地的完整知识体系，更让我们在”通过开源学习开源”的理念中感受到系统级编程的魅力。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/05/24/ACrazyShark-25rcore-blog/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/24/2025s-os%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/24/2025s-os%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url"><2025s os训练营总结></a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-24 20:27:01" itemprop="dateCreated datePublished" datetime="2025-05-24T20:27:01+00:00">2025-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><p>rustlings的练习还是比较基础的，实在想不起来某个知识点还可以去rust圣经翻翻文档。不过貌似后面的dsa部分对于rcore的练习基本没啥用处。</p>
<h2 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h2><p>之前有过自己搓内核（没有文件系统），以及做xv6 for riscv的lab的经验，实际到ch6为止都十分顺畅，ch6的部分实现参考了2023秋训练营的代码，ch8则是在线程的粒度上实现银行家算法，码量相对较少。</p>
<h2 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h2><p>配置环境的时候遇到点小插曲，qemu.mk指定bios为default，结果没有正确加载固件，后面指定固件加载路径解决了这个问题。</p>
<p>第三阶段的题目普遍简单，可能是框架基本搭好了所以实际工作量也减少了。此外arceos因为是unikernel架构，各个组件功能耦合较低，对应练习需要修改的地方也一目了然。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/24/OsCamp2025-kangrali/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/24/OsCamp2025-kangrali/" class="post-title-link" itemprop="url">OsCamp2025-kangrali</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-24 18:55:46" itemprop="dateCreated datePublished" datetime="2025-05-24T18:55:46+00:00">2025-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>每日记录放在<a href="https://github.com/kangrali/oscamp-2025-blog" target="_blank" rel="noopener">https://github.com/kangrali/oscamp-2025-blog</a></p>
<h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>主要是语言学习，详细阅读了Rust Programming Language中文书，然后做练习。</p>
<p>因为有C++知识的积累没有遇到太大的问题</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>主要是阅读实验指导书，理解rCore整体的框架</p>
<p>个人任务需要理解的几个关键点：</p>
<ul>
<li>trap上下文的保存与恢复，对应了用户特权级和内核特权级的切换</li>
<li>任务上下文的保存与恢复，对应了任务(线程)的切换</li>
<li>地址空间，内核态和用户态使用不同的页表</li>
</ul>
<p>详细报告见二阶段仓库<a href="https://github.com/LearningOS/2025s-rcore-kangrali" target="_blank" rel="noopener">https://github.com/LearningOS/2025s-rcore-kangrali</a></p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>这一阶段主要通过看课程视频完成，关键在于理解整个项目的代码架构，代码是如何组织到各个层次的crates中的。</p>
<p>至于完成的练习都难度不大，了解各模块的调用关系后，做简单修改或调用api就可完成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/24/rCore-%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-Nzzz964/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/24/rCore-%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-Nzzz964/" class="post-title-link" itemprop="url">rCore-三阶段学习总结-Nzzz964</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-24 15:20:31" itemprop="dateCreated datePublished" datetime="2025-05-24T15:20:31+00:00">2025-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本人没有 408 基础，之前仅仅是有过 CRUD 的经验，但是对各种底层很感兴趣，最近考试结束正好有时间参加训练营。索性接受了大佬的邀约（毕竟以后也是要做的）。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/05/24/rCore-%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-Nzzz964/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/24/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%89%8D%E4%B8%89%E7%BB%93%E7%82%B9%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/24/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%89%8D%E4%B8%89%E7%BB%93%E7%82%B9%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" class="post-title-link" itemprop="url">2025春夏季开源操作系统训练营前三结点总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-24 14:13:28" itemprop="dateCreated datePublished" datetime="2025-05-24T14:13:28+00:00">2025-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>凭着已有的rust知识速通了，都是基础填空题没啥好说的。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>应用填空题，多看几遍就会了，没什么工作量，主要是看。详细报告见二阶段仓库。<br><a href="https://github.com/LearningOS/2025s-rcore-Vinci-hit" target="_blank" rel="noopener">https://github.com/LearningOS/2025s-rcore-Vinci-hit</a></p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>主要感觉还是重在看，只要多看几遍就知道怎么做了，而且有提示，还是填空题。</p>
<p>第一题要求实现HashMap，只需要实现一个HashMap即可，有些坑会自动出现。</p>
<p>第二题要求实现内存分配算法，但其实都已经实现好了只需要学会看懂后调用api即可。</p>
<p>之后的每一题几乎都是只要看懂了会调用api就可以了，代码量都很少。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/24/2025%E5%89%8D%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-TectoWang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/24/2025%E5%89%8D%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-TectoWang/" class="post-title-link" itemprop="url">2025前三阶段总结-TectoWang</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-24 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-24T00:00:00+00:00">2025-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<h2 id="第一阶段：Rustling-与-Rust-基础练习"><a href="#第一阶段：Rustling-与-Rust-基础练习" class="headerlink" title="第一阶段：Rustling 与 Rust 基础练习"></a>第一阶段：Rustling 与 Rust 基础练习</h2><p>这个阶段我主要进行了 Rustling 题目的练习和 Rust 编程语言的基础训练。因为我本身有一定编程基础，所以整体难度对我来说并不高，主要是为了熟悉 Rust 的语言风格和核心概念，比如所有权、借用、模式匹配等。为后面更深入的系统开发打下了语言基础。</p>
<hr>
<h2 id="第二阶段：操作系统内核功能实现"><a href="#第二阶段：操作系统内核功能实现" class="headerlink" title="第二阶段：操作系统内核功能实现"></a>第二阶段：操作系统内核功能实现</h2><p>到了第二阶段，框架已经搭建好，任务主要是完成其中某些具体功能模块的实现。虽然刚开始面对内核设计和系统调用这样的内容有些抽象，但随着理解的深入，实际的编码和调试也渐渐变得顺利起来。<br>具体详情见：<a href="https://github.com/LearningOS/2025s-rcore-Tecto-Wang" target="_blank" rel="noopener">https://github.com/LearningOS/2025s-rcore-Tecto-Wang</a></p>
<hr>
<h2 id="第三阶段：借助资料进行模块化理解"><a href="#第三阶段：借助资料进行模块化理解" class="headerlink" title="第三阶段：借助资料进行模块化理解"></a>第三阶段：借助资料进行模块化理解</h2><p>第三阶段的学习方式更为系统。我通过 PPT 和视频资料来逐步学习实现细节，并通过留空的方式聚焦于具体模块的实现。这样的方式可以集中注意力专注于每一个点，然后再逐渐拼凑出整个系统的全貌。相比第二阶段，这种学习方式更轻松、更具条理，也帮助我对整个系统架构的整体理解。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/23/rcore-%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/23/rcore-%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-kafka/" class="post-title-link" itemprop="url">rcore-三阶段总结-kafka</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-23 22:43:10" itemprop="dateCreated datePublished" datetime="2025-05-23T22:43:10+00:00">2025-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-08 01:58:30" itemprop="dateModified" datetime="2025-07-08T01:58:30+00:00">2025-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/rCore/" itemprop="url" rel="index"><span itemprop="name">rCore</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="个人碎碎念"><a href="#个人碎碎念" class="headerlink" title="个人碎碎念"></a>个人碎碎念</h1><p>了解到rCore训练营是一位大佬拉我一起参加的，之前没有参加过类似的训练营，没有学习过rust，对os的理解也只停留在408里面片面的os（实际做下来跟应试学习的完全是两个东西）。回想起来当时在做之前应该先去看一下除提供的文档之外的os知识，很多时候也缺少走读代码和理解代码的能力，拖团队后腿了。<br>通过这次训练营，意识到自己很菜，一开始还是蛮焦虑的（虽然现在也是），跟不上大家，后来焦虑多了也在心态上有一些变化，开始慢慢走读现有的代码，结合训练营提供的资料一步一步理解任务，再根据自己的理解完成任务，不懂的就在团队的小群上问群友，也是比较艰辛的把三个阶段给完成了。<br>也是感谢几位群友，在我拖后腿的时候都会比较耐心的等我慢慢做，本来队伍还打算拿优胜队长的奖励的hhh。</p>
<h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>由于是第一次接触rust，之前只接触过java，写起来非常割裂，并且在一些java可以的地方，rust是禁止的，就比如在类型检查上。rust的match以及一些闭包函数是蛮好用的（这里也要小小的吐槽一下rust实现链表太麻烦了。</p>
<h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><p>这个阶段主要是了解系统内核，学习rCore指导书并且完成五个实验，这个阶段有大半时间都处在焦虑状态，没有好好的理解指导书和代码内容，结果就是一些实验需要靠群友帮助才能完成。但还是学习到了os底层的运作方式，多任务系统，虚拟地址空间映射，进程的管理调度，文件系统，锁的实现。印象最深的就是在写sys_linkat的时候由于没有走读理解现有的代码，愣是卡了一周才完成。    </p>
<h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><p>这个阶段原以为是在阶段二的基础上继续添加完善os系统，结果并不是，有一些实验写下来感觉不如阶段二，不过正因为这个阶段没有那么难，算是比较顺利的在预期时间就做完了，这个阶段开始慢慢的看懂框架代码，随后根据提示完成任务，算是进步比较大的阶段，还需要持续学习，接下来打算试试参加阶段四，拿一个结营证书，同时要好好反思自己，努力学习提升代码能力和计算机基础。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/05/23/rcore-%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-kafka/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/blog/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/73/">73</a><a class="extend next" rel="next" href="/blog/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
