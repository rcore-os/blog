<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/44/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/44/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">687</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">593</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-algoshimo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-algoshimo/" class="post-title-link" itemprop="url">2024春夏季开源操作系统训练营第一阶段总结报告-algoshimo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 17:02:56" itemprop="dateCreated datePublished" datetime="2024-04-25T17:02:56+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="契机"><a href="#契机" class="headerlink" title="契机"></a>契机</h1><p>事情的起因是在威神群里看到的清华操作系统训练营。一个教你用rust写os的训练营!</p>
<p>受到了炸药哥、cjj等多位体系结构大佬的影响，且本身自己就有一个想把cs和ai结合起来的梦想。而且了解到开源操作系统研究组研究方向涉及高性能计算，于是果断报名。</p>
<p>其实我自己也不知道是否对操作系统感冒，对rust的兴趣也不及cpp。我只是喜欢了解计算机科学的底层，加之想找hpc的暑期实习但简历却石沉大海(悲)，且也想扎实自己os基础便来了这里。</p>
<h1 id="rust学习曲线真的好陡峭-痛苦面具"><a href="#rust学习曲线真的好陡峭-痛苦面具" class="headerlink" title="rust学习曲线真的好陡峭(痛苦面具)"></a>rust学习曲线真的好陡峭(痛苦面具)</h1><p>从rust零基础到完成rustlings大概用了两周时间。</p>
<p>看过rust圣经，rust程序设计语言，做过rust最佳实践的练习，在b站看过网课，还尝试做过两个项目: 用rust实现基本数据结构和用rust实现lua解释器。 真的想说一句:”我xxx!” (请读者自行想象)</p>
<p>其实依旧是有很多不明白的东西，比如链表的布局其实我是似懂非懂的，只是照搬了它的布局。但为何这样布局当时并没有太清楚。<br>这样的地方还有很多，就且留到以后慢慢体会。毕竟我是来学os的(嘿嘿)，我始终坚信一点:所有的疑问都会在不断学习的过程中找到答案!</p>
<h1 id="幻想成为英雄"><a href="#幻想成为英雄" class="headerlink" title="幻想成为英雄"></a>幻想成为英雄</h1><p>南京大学jyy在他的操作系统课上曾说过一句话:”这个世界需要英雄！”</p>
<p>我真的真的很喜欢这句话，在这个浮躁的时代，越来越多的人选择卷绩点，水科创，水竞赛，学前后端狠赚一笔()…</p>
<p>但这样不酷，真的不酷。<br>我要打下最扎实的计算机科学基础，我要实现真正顶层和底层的结合，我要做ai system!</p>
<p><strong>那么就从认真完成这次操作系统训练营开始吧，第二阶段见!</strong></p>
<p><strong>我们，一定未来可期!</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/2024rust-camp-stage1-summarize-HYL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/2024rust-camp-stage1-summarize-HYL/" class="post-title-link" itemprop="url">2024rust_camp_stage1_summarize_HYL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 17:01:06" itemprop="dateCreated datePublished" datetime="2024-04-25T17:01:06+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在第一阶段的学习中，主要对rust的所有权以及指针等方面进行了着重学习,下面对相关知识点进行简要总结</p>
<h1 id="所有权相关规则"><a href="#所有权相关规则" class="headerlink" title=" 所有权相关规则"></a> 所有权相关规则</h1><blockquote>
<p>一个值只能被一个变量所拥有，这个变量被称为所有者</p>
<p>一个值同一时刻只能有一个所有者，即不能有两个变量拥有相同的值</p>
<p>当所有者离开作用域，其拥有的值被丢弃，内存得到释放。</p>
</blockquote>
<p>当出现所有权冲突时，可以通过调用 data.clone() 把 data 复制一份出来给 data1，这样做可以创建 data 的深拷贝，避免出现所有权问题</p>
<p><em>Move 语义：当一个值被赋值给另一个变量时，它的所有权会转移，原始变量将不再有效，默认情况下，大部分自定义类型都是具有 Move 语义（优点：可以避免使用拷贝操作，提高性能）</em></p>
<p><em>Copy 语义：不希望值的所有权被转移，赋值或者传参时，值会自动按位拷贝（浅拷贝），两个变量都拥有独立的内存空间。 Copy 语义通常适用于简单的基本类型，如整数、浮点数、布尔值等</em></p>
<p><em>Borrow 语义：不希望值的所有权被转移，又无法使用 Copy 语义，可以“借用”数据，其允许在不转移所有权的情况下借用值的引用，包括不可变引用（&amp;T）和可变引用（&amp;mut T），允许同时存在多个不可变引用，但不允许同时存在可变引用和不可变引用（优点：使得代码更加安全，因为它在编译时进行所有权检查，防止了一些常见的错误，如悬垂指针和数据竞争）</em></p>
<h1 id="一个值给多个所有者"><a href="#一个值给多个所有者" class="headerlink" title="一个值给多个所有者"></a>一个值给多个所有者</h1><ul>
<li>Rc</li>
</ul>
<p>对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数，当引用计数为0时，内存释放</p>
<p><em>Arc<T> 与 Rc<T> 类似，但是使用原子操作来保证引用计数的线程安全性,支持线程共享数据。</T></T></em></p>
<p><em>（如果不用跨线程访问，可以用效率非常高的 Rc。如果要跨线程访问，那么必须用 Arc）</em></p>
<pre><code>use std::rc::Rc;</code></pre><ul>
<li>RefCell<br>允许在不可变引用的情况下修改数据，采用borrow_mut（可变）、borrow（不可变）</li>
</ul>
<p><em>Mutex 和 RwLock 都用在多线程环境下，当需要多线程时，可直接替换RefCell</em></p>
<pre><code>use std::cell::RefCell;</code></pre><h1 id="智能指针Box"><a href="#智能指针Box" class="headerlink" title="智能指针Box"></a>智能指针Box</h1><blockquote>
<p>Rust 中，凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针。</p>
</blockquote>
<p>允许将数据分配在堆上，当 Box<T> 离开作用域时，它指向的堆内存会被自动清理。常用于： 在编译时大小未知的数据；大型数据结构，以避免栈溢出；拥有数据，确保只有一个所有者。</T></p>
<p>Box&lt;dyn Trait&gt; 表示一个指向实现了指定 trait 的类型的堆上分配的指针。<br>Trait 可以是任何 trait，它定义了一组行为或方法，而具体的类型则实现了这些方法。<br>通过 Box 将其放置在堆上，可以在运行时动态确定对象的具体类型，并通过指针进行访问。<br>运行时动态派发（动态调用）是通过虚函数表来实现的，这意味着在运行时确定调用的具体方法。</p>
<pre><code>trait Animal {
    fn sound(&amp;self);
}

struct Dog;
impl Animal for Dog {
    fn sound(&amp;self) {
        println!(&quot;The dog barks!&quot;);
    }
}

struct Cat;
impl Animal for Cat {
    fn sound(&amp;self) {
        println!(&quot;The cat meows!&quot;);
    }
}

fn main() {
    let dog: Box&lt;dyn Animal&gt; = Box::new(Dog);
    let cat: Box&lt;dyn Animal&gt; = Box::new(Cat);

    make_sound(&amp;dog);
    make_sound(&amp;cat);
}

fn make_sound(animal: &amp;Box&lt;dyn Animal&gt;) {
    animal.sound();
}</code></pre><h1 id="unsafe代码块"><a href="#unsafe代码块" class="headerlink" title="unsafe代码块"></a>unsafe代码块</h1><blockquote>
<p>unsafe绕过了 Rust 的安全检查，错误使用可能导致内存不安全、数据竞态等问题。</p>
</blockquote>
<ul>
<li>解引用裸指针</li>
</ul>
<pre><code>let mut x = 10;
let ptr = &amp;mut x as *mut i32;
unsafe {
    *ptr += 1;
}</code></pre><ul>
<li>访问或修改静态变量：在 Rust 中，修改静态变量是不安全的操作。</li>
</ul>
<pre><code>static mut COUNT: i32 = 0;
unsafe {
    COUNT += 1;
}</code></pre><ul>
<li><p>实现不安全的 trait，如 Send 和 Sync</p>
</li>
<li><p>进行内存布局的低级操作：如结构体的字段重叠或内存对齐。</p>
</li>
</ul>
<h1 id="类型之间的相互转换"><a href="#类型之间的相互转换" class="headerlink" title="类型之间的相互转换"></a>类型之间的相互转换</h1><ul>
<li>as 运算符：as 运算符用于类型转换，可以用于将一个值从一种类型转换为另一种类型。例如，将一个 u32 转换为 u64。</li>
</ul>
<ul>
<li>into 和 from 方法：这些方法是 From 和 Into trait 的一部分，用于在不同类型之间进行转换。这些方法通常会涉及类型的所有权转移。</li>
</ul>
<ul>
<li>try_into 和 try_from 方法：这些方法是 TryFrom 和 TryInto trait 的一部分，用于尝试在不同类型之间进行转换。这些方法在转换失败时会返回一个错误（Err）</li>
</ul>
<ul>
<li>cast 方法：在特定场景下，尤其是与裸指针相关的操作中，cast 方法可以用于将一个指针转换为另一种类型的指针。</li>
</ul>
<pre><code>let ptr: *const i32 = &amp;10 as *const i32;
let ptr_void: *const std::ffi::c_void = ptr.cast();</code></pre><ul>
<li>transmute 方法：transmute 是一个不安全的操作，它可以在不同类型之间进行任意转换。这是一个高级的转换函数，使用时必须非常小心。</li>
</ul>
<pre><code>use std::mem::transmute;

let x: u32 = 42;
let y: f32 = unsafe { transmute(x) };</code></pre><p><em>as用于显式转换，所有权不变；into/from用于隐式转换，所有权转移；try_into/try_from和into/from不同的地方是，转换失败会返回Err</em></p>
<p>以上是一些本阶段学习的知识点总结，通过第一阶段的训练，整体对rust的语法与编写有了初步地认识，不过在代码调试，多线程、链表操作方面还有所欠缺，将在后续空闲时间不断学习。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/2024%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-wat3rmelon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/2024%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-wat3rmelon/" class="post-title-link" itemprop="url">2024春夏开源操作系统训练营阶段总结-wat3rmelon</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 16:48:00" itemprop="dateCreated datePublished" datetime="2024-04-25T16:48:00+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>两年前就有听说过rust了，但是只是简单的看了下the rust book，并没有实际使用rust进行编程。这次打算借着rcore进一步实践rust。</p>
<p>目前的感受是rust的设计给了很多的限制，同时rust似乎也和cpp一样算是多范式的语言？就比如迭代一个列表既可以写成下面的形式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ... <span class="keyword">in</span> something.iter() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写可以写成</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something.iter().sum();</span><br></pre></td></tr></table></figure>
<p>这样的形式。说实话，我不是很喜欢多范式的编程语言。因为选择太多了，对于我来说阅读别人的代码就会很麻烦。所以这里我更喜欢go的设计。</p>
<p>此外我用rust刷了一些leetcode上的简单的算法题，感觉挺头疼的。需要关注特别多的细节，而且leetcode特别喜欢给i32类型数据，而rust中访问容器用的下标都是usize类型的。导致代码写起来一点也不美观。有特别多的<code>xx as usize</code></p>
<p>此外，感觉rust的标准库看起来是提供了很多方法来代替本来可用指针操作的方法。比如vector的swap，一般情况下其它语言里可能是这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b = b,a</span><br></pre></td></tr></table></figure>

<p>rust对数据类型还特别敏感，只要有越界就会报错，必须得用饱和减法<code>saturating_sub</code>之类的方式来处理。</p>
<p>总之，我感觉rust的限制太多了，这让我对写好一个rust程序来说感觉心智负担很重。对于不依靠编辑器写完整程序没有信心。</p>
<p>希望接下来的rcore能改变我当前对rust的看法。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>第二阶段的难度算是渐进式的吧。第二阶段的lab里，我印象最深的部分分别是内存的地址空间，文件系统Inode组织，死锁检测。</p>
<p>因此，下面我就对这三部分进行一些总结好了。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>首先聊一下死锁检测吧，因为这个是最近做过的，所以印象比较深。这部分我之前一直只知道有一个银行家算法，所以一开始看到死锁检测这部分的算法跟银行家算法一样记录allocation和need的时候感觉优点懵。因为，在我原来的理解里，银行家算法应该是需要提前知道线程需要的资源的。</p>
<p>后来动手实现后，才发现死锁检测算法和银行家算法是有区别的，银行家算法其实是死锁避免算法。死锁检测算法感觉主要针对的就是信号量上的资源分配，然后在每一次申请的时候检查，是否分配这次资源后，能够有一个序列走得通，如果有，就算无死锁，否则算有死锁。整体上的时间复杂度应该是 $O(nm)$ 的其中 $n$ 是线程数量， $m$ 是资源数量。</p>
<p>平常写其它语言的时候并没有感觉到死锁检测的存在，可能就是因为这个时间复杂度随着资源数量和线程数量线性增长，所以不采用吧？</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>下面来聊一下文件系统，这部分实验的学习中，我感觉复杂的地方主要在于存在很多的抽象。文件系统本身存储diskInode，然后虚拟文件系统上抽象了Inode，OSInode，最后到操作系统中，它使用的是File trait抽象。</p>
<p>抽象层数很多，因此让我挺晕的。这部分代码上面，感觉比较关键的是Inode的组织。超级快-&gt;Inode位图-&gt;数据位图-&gt;Inode区域-&gt;数据块区域。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>这部分我觉得是非常有收获的一部分，让我感觉算是彻底理解了多级页表，段表的区别。在此之前一直不知道页表是怎样存储的，总是想着它是存到一个特殊的内存里。现在算是明白了页表不过是存储在普通的内存里的一个结构，然后CPU依靠token来区分当前的页表。</p>
<p>SV39页表中，偏移为4KB，所以使用了后12位，剩余的 $39-12=27$刚刚好分成3部分，每部分占了 $27/3=9$ 位，也就是512个页表项，每个页表项占8字节，刚刚好可以将一个页存储满。</p>
<p>然后是操作系统内核采用恒等映射，用户程序除了跳板页，其它的采用Framed映射。这样使得操作系统访问的虚拟地址就是物理地址，而用户程序访问的是虚拟地址。这种区分使得操作系统可以访问到用户的地址，用户程序无法访问操作系统的地址。实现了空间上的隔离。</p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>第三阶段我选择的是项目一：ArceOS单内核Unikernel。该实习项目主要分为两部分：熟悉ArceOS阶段与完成实习任务阶段。</p>
<h3 id="熟悉ArceOS阶段"><a href="#熟悉ArceOS阶段" class="headerlink" title="熟悉ArceOS阶段"></a>熟悉ArceOS阶段</h3><p>这一阶段主要是在ArceOS仓库下，完成一些简单的任务。分了两周来实现，第一周主要是尝试为ArceOS添加一些简单的功能。第二周则是练习从外部加载应用到arceos中，通过func call的方式使得外部应用可以打印字符。</p>
<h4 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h4><ul>
<li>练习1：支持彩色打印 println! 通过在输出的时候，在前后添加特殊符号，使得输出的颜色可以改变。</li>
<li>练习2：支持HashMap数据类型 这一步我参考rust的HashMap实现，调用了相同的库完成。</li>
<li>练习3：为内存分配器实现新的内存算法 这一步我主要是利用了现有的算法完成页分配与字节分配</li>
<li>练习4：解析dtb并打印 这一步我觉得主要难点是dtb的解析，因为不清楚dtb长什么样的，学习后，调用一个crate完成了该任务。</li>
<li>练习5：抢占式调度算法 这一步我记得我是参考了现有的抢占式调度算法，然后做了一个奇偶性的判断，每次出队前，如果这次出队是奇数，就放到队头，否则正常放到队尾。</li>
</ul>
<h4 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h4><p>本周主要是我的收获主要是对qemu的启动参数有了一些了解，然后就是了解了rust中手写asm的方法。</p>
<h3 id="实习任务阶段"><a href="#实习任务阶段" class="headerlink" title="实习任务阶段"></a>实习任务阶段</h3><h4 id="第一周-rt-helloworld与rt-memtest与系统调用新增"><a href="#第一周-rt-helloworld与rt-memtest与系统调用新增" class="headerlink" title="第一周 rt_helloworld与rt_memtest与系统调用新增"></a>第一周 rt_helloworld与rt_memtest与系统调用新增</h4><p>我主要是在熟悉lkmodel，完成了原来arceos下的rt_helloworld与rt_memtest两个unikernel的实现。这一部分根据要求，必须要有axstd。因此我一开始的实现是将arceos下的axstd库直接拷贝过来，并且把它需要用到的库也进行了靠北，然后修改一些代码，使得可以编译通过。这个的结果在dev_task1_brute_force分支下。不过后来从群里得知，要尽量从lkmodel已经有的库开始，所以就重新实现了这部分，主要的方式是基于axlog2这个库，做了一些包装和宏的重新导出。</p>
<p>本周的问题是</p>
<ul>
<li><p>在实现rt_memtest的时候，出现的全局分配器不存在的问题。<br>是为了解决这个问题，我发现是需要引用axalloc这个crate，同时还需要进行初始化。因此，出于实现方便，我在axstd文件夹下同时创建了一个axruntime crate，在其中编写了rust_main函数，在其中完成全局分配器的初始化。</p>
</li>
<li><p>同时在周的结尾，我遇到的问题是宏内核在我操作系统上无法成功运行btp下的测试，通过在微信群与老师交流，我得知主要的原因是glibc在不同操作系统下编译C文件的结果，使用到的系统调用是不同的。就比如init.c，在我的操作系统下编译出的结果需要使用到stat系统调用，而该系统调用在当前lkmodel中是未实现的，因此我尝试在lkmodel中添加该系统调用，主要实现在axsyscall crate中添加该系统调用的函数，然后再fileops中添加fstat函数，该函数的实现参考fstatat函数，这个函数的功能是在目录中获取文件信息。</p>
</li>
</ul>
<p>通过对系统调用新增实现，成功让我的宏内核可以在我的操作系统中运行btp下的init.c程序。我的感受就是了解了不同指令集，linux给他们分配的系统调用号码是不一样的。同时不同操作系统版本的下的glibc生成的文件，使用的系统调用也不一样。</p>
<h4 id="第二、三周-rt-loader"><a href="#第二、三周-rt-loader" class="headerlink" title="第二、三周 rt loader"></a>第二、三周 rt loader</h4><p>我在第二、三周完成了lkmodel下运行glibc静态编译的hello world的c应用。</p>
<p>这一部分我主要是参考思路3PPT的实现，首先就是对opensbi与sbi-rt的修改，这一步我是clone了opensbi代码然后按照ppt的方法进行修改。对于sbi-rt的修改则是fork其仓库，修改后提交到自己的仓库下。最后在cargo.toml中添加依赖即可。</p>
<p>剩下的就是修改qemu.mk脚本，向其中增加Pflash参数与bios参数。<br>如下所示,让其指向payload文件夹以此加载程序内容。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qemu_args-riscv64 := \</span><br><span class="line">  -machine virt \</span><br><span class="line">  -drive if=pflash,file=<span class="variable">$(CURDIR)</span>/payload/apps.bin,format=raw,unit=1 \</span><br><span class="line">  -bios ~/opensbi/build/platform/generic/firmware/fw_jump.bin  \</span><br><span class="line">  -kernel <span class="variable">$(OUT_BIN)</span></span><br><span class="line">  <span class="comment"># -bios default</span></span><br></pre></td></tr></table></figure>

<p>此处payload我是复制org_arceos下的payload，运行mk.sh脚本即可生成apps.bin。其中包含了两个hello world程序，不过由于我没有实现多线程，所以我只能跑一个hello world程序，跑完后发出的exit调用会导致我的程序直接退出。如果实现多线程的话就只会线程退出，然后回到rt_loader。</p>
<h5 id="地址空间管理问题"><a href="#地址空间管理问题" class="headerlink" title="地址空间管理问题"></a>地址空间管理问题</h5><p>使用rt_loader时，主要加载的是glibc静态编译的的elf程序，elf程序中存在两个数据段，一个是.text段，一个是.data段。程序想要运行就必须将这两个段搬运到对应的虚拟地址上去，否则程序无法运行。</p>
<p>因此为了完成虚拟地址映射，需要进行地址空间的管理。主要是创建SV39页表，目前lkmodel中的paging完成了这个页表的管理，因此我一开始是参照这个crate与org_arceos的实现，在其中创建一个静态变量来存储用户程序的页表。并编写了map_region。</p>
<p>但是这样做不太好，因为这样一次只能运行一个程序了，而且接下来我在运行程序的时候，它进行系统调用时，获取访问页表的手段是通过TCB中mm_struct来获取的。因此我对此进行了修改。</p>
<p>主要是在我的axstd下添加了map_region函数，它的功能是获取当前的task，然后获取一个可变引用，然后在task中我添加了一个map_region方法，这个map_region方法最终会对task的mm成员变量进行map_region操作。大致的调用关系如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// rt_loader中的程序调用map_region方法</span></span><br><span class="line">vm::map_region(va, pa, num_pages &lt;&lt; PAGE_SHIFT, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// axstd的vm模块下的map_region</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map_region</span></span>(va: <span class="built_in">usize</span>, pa: <span class="built_in">usize</span>, len: <span class="built_in">usize</span>, flags: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task = task::current();</span><br><span class="line">    <span class="comment">// 向当前任务的mm中进行map_region</span></span><br><span class="line">    task.as_task_mut().map_region(va, pa, len, flags)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// task的map_region方法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map_region</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,va: <span class="built_in">usize</span>, pa: <span class="built_in">usize</span>, len: <span class="built_in">usize</span>, flags: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.mm.as_mut().map(|mm| &#123;</span><br><span class="line">        <span class="keyword">let</span> locked_mm = mm.lock();</span><br><span class="line">        locked_mm.map_region(va, pa, len, flags);</span><br><span class="line">        <span class="keyword">use</span> mm::VmAreaStruct;</span><br><span class="line">        <span class="keyword">let</span> vma = VmAreaStruct::new(va, va + len, <span class="number">0</span>, <span class="literal">None</span>, <span class="number">0</span>);</span><br><span class="line">        mm.lock().vmas.insert(va, vma);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// mm的map_region方法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map_region</span></span>(&amp;<span class="keyword">self</span>, va: <span class="built_in">usize</span>, pa: <span class="built_in">usize</span>, len: <span class="built_in">usize</span>, _uflags: <span class="built_in">usize</span>) -&gt; PagingResult &#123;</span><br><span class="line">    <span class="keyword">let</span> flags =</span><br><span class="line">        MappingFlags::READ | MappingFlags::WRITE | MappingFlags::EXECUTE ; </span><br><span class="line">    <span class="keyword">self</span>.pgd</span><br><span class="line">        .lock()</span><br><span class="line">        .map_region(va.into(), pa.into(), len, flags, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处我实现的一个额外点在于调用map_region方法的时候，我同时会向mm struct中的vmas添加vma，也就是让程序知道这个地址空间被分段使用了。</p>
<h4 id="task-ctx问题"><a href="#task-ctx问题" class="headerlink" title="task_ctx问题"></a>task_ctx问题</h4><p>在我的实现中，因为使用task记录了页表，因此我在我的axruntime库上添加了对axtask的初始化。同时我还初始化了axtrap，用于系统调用。</p>
<p>最后存在的一个问题是，在lkmodel的系统调用处理过程中，它经常需要访问task_ctx，从中获取当前的task，然后进行相关的操作，比如mmap，mprotect，brk系统调用等。但是因为获取task_ctx失败，所以我一直卡在此处。</p>
<p>听了符同学的提醒，我最终使用静态变量的方式将记录task_ctx，如下所示</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">mut</span> CURRENT_TASKCTX_PTR:<span class="built_in">Option</span>&lt;* <span class="keyword">const</span> SchedInfo&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在所有初始化task_ctx的位置</span></span><br><span class="line"><span class="comment">// 将 axhal::cpu::set_current_task_ptr(ptr);</span></span><br><span class="line"><span class="comment">// 修改为 CURRENT_TASKCTX_PTR = Some(ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在所有获取task_ctx的位置</span></span><br><span class="line"><span class="comment">// 将 axhal::cpu::current_task_ptr();</span></span><br><span class="line"><span class="comment">// 修改为if let Some(ptr) = CURRENT_TASKCTX_PTR &#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="brk问题"><a href="#brk问题" class="headerlink" title="brk问题"></a>brk问题</h4><p>解决完了上述问题后，我还遇到的问题就是系统调用分配堆空间的问题。我一开始没有设置brk，因此它总是从默认的位置0开始向后分配堆空间，而这部分空间与程序运行的代码段产生了冲突。</p>
<p>即代码段在0x10000-0x7e0000之间，而brk申请了0x1000-0x220000之间的空间。这导致了空间上的冲突，因此我后来在运行linux app之前，首先设置了brk的地址，将它设置为了数据段之后的位置。通过这样设置，就不会产生冲突了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来说，我完成了lkmodel下运行glibc静态编译的hello world的c应用。这让我对elf结构，qemu.log的调试，地址空间与系统调用都有了更进一步的了解。</p>
<p>lkmodel的组件划分让我觉得非常地棘手，因为虽然是将组件进行了分类，但是感觉想要实现特定功能的话，我依然是需要理解每个组件之间的依赖关系，有时还需要理解每个组件的内部实现。这是我认为相比rcore-os来说，主要的难点。</p>
<p>仓库链接是<a href="https://github.com/waterm310n/lkmodel" target="_blank" rel="noopener">lkmodel</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-cc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-cc/" class="post-title-link" itemprop="url">2024春季开源操作系统训练营第一阶段总结-cc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 16:02:48" itemprop="dateCreated datePublished" datetime="2024-04-25T16:02:48+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rust的学习"><a href="#rust的学习" class="headerlink" title="rust的学习"></a>rust的学习</h1><p>因为之前学过一些c++，有一定的基础，对rust的学习真的帮助挺大的。rust里的所有权，智能指针，移动语义都能在c++里找到对应的东西，rust学起来还是挺轻松的。</p>
<p>相较于c++，rust使用起来真的太舒服了。使用match进行流程控制十分优雅，宏也比c++的宏更加强大，rust泛型编程的类型萃取使用起来也比c++方便，更不用说<code>cargo</code>包管理对c++简直就是降为打击。</p>
<p>代价是rust的<code>unsafe</code>用起来有点丑陋。</p>
<h1 id="rustlings实验"><a href="#rustlings实验" class="headerlink" title="rustlings实验"></a>rustlings实验</h1><p>前一百道题通过看 <a href="https://kaisery.github.io/trpl-zh-cn/" target="_blank" rel="noopener">Rust 程序设计</a> 、 <a href="https://doc.rust-lang.org/std/index.html" target="_blank" rel="noopener">rust官方api文档</a> 和问gpt都能够轻松的完成。</p>
<p>后十道数据结构题目就遇到麻烦了，主要是对 rust <code>unsafe</code> 操作的不熟悉，写起来真的折磨。在认真学习了解rust 指针操作后，有算法基础数据结构实现还是比较好实现的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>rust入门可以认真看完 《Rust 程序设计》，不理解的地方问gpt和百度。再写完rustlings, 最后在github上找个练手项目去理解代码尝试自己实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%9D%A8%E4%BD%B3%E8%B1%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%9D%A8%E4%BD%B3%E8%B1%AA/" class="post-title-link" itemprop="url">2024开源操作系统训练营第一阶段总结-杨佳豪</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 15:01:51" itemprop="dateCreated datePublished" datetime="2024-04-25T15:01:51+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在水群的时候，无意间看到这个训练营的宣传，点进去看到是OS训练营还有项目实战，正好自己对OS比较感兴趣并且正想要一个项目来练练手，就报名了该训练营。并且将该训练营转给队友，发现他们也感兴趣，于是乎，我们三人又组起了队。</p>
<h2 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h2><p>第一阶段主要完成了rustlings的110道题的训练，前面100个主要针对某个小的知识点/语法，一般添加几个关键词，做几个小的移动就过了，难度并不大，收获比较大的还是后面的10道算法题，感觉做第一个的时候是最难的，后面的借鉴第一个很快就能写出来。比较喜欢这10的算法的原因是，因为之前有其他语言的经验，更加喜欢通过比较来学习，看rust跟其他语言编写同样功能的区别(又称<strong>用rust重写</strong>)。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>最近事情有点多，又要做读研的准备，又要做找工作的准备，希望自己渡劫成功，能够顺利完成吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-OSFantasy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-OSFantasy/" class="post-title-link" itemprop="url">2024开源操作系统训练营第一阶段总结-OSFantasy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 12:16:19" itemprop="dateCreated datePublished" datetime="2024-04-25T12:16:19+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段-Rust学习"><a href="#第一阶段-Rust学习" class="headerlink" title="第一阶段 - Rust学习"></a>第一阶段 - Rust学习</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>Rust作为rCore操作系统的开发语言，学习并掌握它对于后面学习rCore OS是非常重要的（关于我Rust学了个大概就去硬啃rCore差点自闭这件事）。</p>
<p>这次训练营也是我二刷了，上次23秋季由于被学校抓去打互联网+等比赛了，🤦‍♂️实在是没有时间弄了，进了二阶段就没然后了。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E7%BF%BB%E8%BD%A6.gif" alt="翻车gif"></p>
<p>一阶段时间过的好快，感觉还没学多少就过去了（时间都用去debug操作系统大赛的fatfs了🤦‍♂️）。所以总结的内容就比较普普通通了，各位大佬见谅🙏。</p>
<h2 id="1-环境与工具软件等"><a href="#1-环境与工具软件等" class="headerlink" title="1 环境与工具软件等"></a>1 环境与工具软件等</h2><p>由于本人并不是CS相关专业，过去主攻的是EE，所以CS里面的很多东西过去都没接触过。从23年秋季第一次接触训练营开始到现在，接触到了很多过去没有用过的工具软件以及一些开发环境，在此简单的列举了一些。</p>
<h3 id="1-1-git和github"><a href="#1-1-git和github" class="headerlink" title="1.1 git和github"></a>1.1 git和github</h3><p>是的，你没有看错。我之前真没怎么用过git和github。一方面原因是，上大学后搞的都是嵌入式裸机的开发，远古单片机IDE（Keil）不支持高级的代码版本管理，加上我的学习路线上也没碰到过使用代码版本管理，索性代码直接放本地（别人要的话就u盘拷贝🤦‍♂️），就很少用git去把代码放仓库（之前实习时迫不得已去折腾了下）。另一方面是，git和github有些时候真的太卡了（之前不会挂代理也不敢挂梯子）。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/32505a01374ea248b005d24e057e69da.png" alt="keil"></p>
<p>不过，现在熟悉了git的各个命令后，配合上github去做项目的代码版本管理是真爽呀。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/QQ%E5%9B%BE%E7%89%8720240425173300.gif" alt="胡桃摇"></p>
<p>个人过去常用的git命令和个人理解如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone 			&#x2F;&#x2F; 将repo(仓库)克隆到本地</span><br><span class="line">git pull			&#x2F;&#x2F; 合并远程repo的更新到本地</span><br><span class="line">git add .			&#x2F;&#x2F; 将更改的文件放入暂存区</span><br><span class="line">git commit -m &quot;&lt;message&gt;&quot; 	&#x2F;&#x2F; 创建一个新的提交，-m 后便是提交的消息</span><br><span class="line">git push		 	&#x2F;&#x2F; 将提交推到远程仓库</span><br><span class="line">git branch			&#x2F;&#x2F; 查看现有的分支</span><br><span class="line">git branch &lt;new_branch&gt;		&#x2F;&#x2F; 创键新的分支</span><br><span class="line">git checkout &lt;branch&gt;		&#x2F;&#x2F; 切换到某分支</span><br><span class="line">git status			&#x2F;&#x2F; 查看本地仓库状态</span><br></pre></td></tr></table></figure>
<p>还有一些比如本地新建的分支需要推到远程、放弃某文件的修改等命令，就没去记了。我是做相关操作的时候，看一下报错建议的命令或在搜一下、问一下gpt，然后改一下。</p>
<p>另外初次使用可能需要配置用户信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email your.email@example.com</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Linux操作系统（Ubuntu、CentOS）"><a href="#1-2-Linux操作系统（Ubuntu、CentOS）" class="headerlink" title="1.2 Linux操作系统（Ubuntu、CentOS）"></a>1.2 Linux操作系统（Ubuntu、CentOS）</h3><p>虽说之前玩jeston和个人博客的时候也用过，但是基本上就是靠readme+baidu+CtrlCV+GPT（而且用了就忘），这次也算是又学习并加深了了解吧。这里就简单的列一下这期间用到的还记得的命令吧（大佬们清点喷555）</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/4f0a8fc3601565ed6fab6b7ce506f375.gif" alt="派蒙抱大腿"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ls                      	# 列出当前目录下的文件和文件夹</span><br><span class="line">cd [目录名]			# 改变当前目录</span><br><span class="line">sudo [命令]			# 以超级用户身份执行命令</span><br><span class="line">sudo apt install [包名]		# 以超级用户身份通过apt安装软件包</span><br><span class="line">apt-get install [包名]		# 通过apt-get安装软件包</span><br><span class="line">touch [文件名]			# 创建一个空文件或修改文件的时间戳</span><br><span class="line">vim [文件名]			# 打开文件进行编辑</span><br><span class="line">rm [文件名&#x2F;目录名]		# 删除文件或目录</span><br><span class="line">make				# 用于编译程序的命令</span><br><span class="line">cp [源文件&#x2F;目录] [目标文件&#x2F;目录]	# 复制文件或目录</span><br><span class="line">mv [源文件&#x2F;目录] [目标文件&#x2F;目录]	# 移动或重命名文件或目录</span><br><span class="line">mkdir [目录名]			# 创建一个新的目录</span><br><span class="line">rmdir [目录名]			# 删除一个空目录</span><br><span class="line">pwd				# 显示当前工作目录的路径</span><br><span class="line">cat [文件名]			# 查看文件内容</span><br><span class="line">file [文件名]			# 查看文件信息</span><br><span class="line">tar [选项] [文件名]		# 打包或解包文件</span><br><span class="line">gzip [文件名]			# 压缩文件</span><br><span class="line">gunzip [文件名]			# 解压缩文件</span><br><span class="line">wget [URL]                      # 从网络上下载文件</span><br><span class="line">curl [URL]                      # 传输数据的工具，支持多种协议</span><br><span class="line">ssh [用户名]@[IP地址]		# 通过SSH协议远程登录到另一台计算机</span><br><span class="line">scp [源文件&#x2F;目录] [用户名]@[IP地址]:[目标路径] # 通过SSH远程拷贝文件</span><br><span class="line">df -h				# 显示磁盘使用情况</span><br><span class="line">du -h [文件名&#x2F;目录名]		# 显示文件或目录的磁盘使用情况</span><br><span class="line">free -m                         # 显示内存使用情况</span><br><span class="line">top                             # 显示实时的系统进程信息</span><br><span class="line">ps                              # 显示当前进程的快照</span><br><span class="line">kill [进程号]			# 结束一个进程</span><br><span class="line">logout                          # 注销当前会话</span><br><span class="line">reboot                          # 重新启动计算机</span><br><span class="line">shutdown -h now                 # 立即关机</span><br><span class="line">fdisk		              	# 一个用于磁盘分区的程序，可以创建、删除、修改和重新组织分区表</span><br><span class="line">losetup 			# 用于设置和控制Loop设备，它可以将一个文件模拟成块设备，常用于挂载文件系统镜像</span><br></pre></td></tr></table></figure>
<h3 id="1-3-RustRover"><a href="#1-3-RustRover" class="headerlink" title="1.3 RustRover"></a>1.3 RustRover</h3><p>强烈推荐，我刚开始是用的VSCode+RA插件或Vim+YouCompleteMe。后来换成rr后，感觉开发真的舒服了好多。一是因为二阶段写OS，在ubuntu里我用的VSCode写一会就会崩，比较卡。用Vim的话，代码文件一多切来切去麻烦的很；二是因为他的各个界面和PyCharm、IDEA是一样的，上手很快；三是多了很多有用的功能，比如你use了某个外部creat，rr会自动帮你在cargo.toml中加上依赖。</p>
<p>RustRover下载地址：<a href="https://www.jetbrains.com/zh-cn/rust/" target="_blank" rel="noopener">https://www.jetbrains.com/zh-cn/rust/</a></p>
<p>Linux环境安装步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 下载</span><br><span class="line">2. cd到下载的路径</span><br><span class="line">3. 解压下载的安装包：</span><br><span class="line">4. cd到解压的路径</span><br><span class="line">5. cd bin</span><br><span class="line">6. .&#x2F;rustrover.sh</span><br><span class="line">7. 勾选一些东西确认安装后，等待片刻，便会进入到欢迎界面</span><br></pre></td></tr></table></figure>
<p>在欢迎界面左下角点击设置图标，再点击(Create Desktop Entry)将rustrover添加到桌面目录。之后便可以使用了。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/54e8072598ba9d75c642cbbefc71cc35.jpg" alt="xiao"></p>
<h2 id="2-Rust知识"><a href="#2-Rust知识" class="headerlink" title="2 Rust知识"></a>2 Rust知识</h2><h3 id="2-1-Rust学习资料"><a href="#2-1-Rust学习资料" class="headerlink" title="2.1 Rust学习资料"></a>2.1 Rust学习资料</h3><p>1.<a href="https://course.rs/about-book.html" target="_blank" rel="noopener">Rust 中文圣经</a></p>
<p>2.<a href="https://rustwiki.org/zh-CN/book/" target="_blank" rel="noopener">Rust 程序设计语言</a></p>
<p>3.<a href="https://rustwiki.org/docs/" target="_blank" rel="noopener">Rust 中文文档汇总</a></p>
<p>4.<a href="https://rustwiki.org/zh-CN/" target="_blank" rel="noopener">Rust 官方文档中文翻译</a></p>
<p>5.<a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust" target="_blank" rel="noopener">Rust 半小时学习</a><br>半小时看不完呀！</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/13a7d07756aae4d99f0acd1cb497b570.gif" alt="派蒙吃惊"></p>
<h3 id="2-2-个人觉得Rust比较有意思的知识点"><a href="#2-2-个人觉得Rust比较有意思的知识点" class="headerlink" title="2.2 个人觉得Rust比较有意思的知识点"></a>2.2 个人觉得Rust比较有意思的知识点</h3><h4 id="2-2-1-所有权（Ownership）和生命周期（Lifetimes）"><a href="#2-2-1-所有权（Ownership）和生命周期（Lifetimes）" class="headerlink" title="2.2.1 所有权（Ownership）和生命周期（Lifetimes）:"></a>2.2.1 所有权（Ownership）和生命周期（Lifetimes）:</h4><ul>
<li>Rust的所有权和生命周期机制，可以防止诸如空悬指针、缓冲区溢出等内存安全问题。</li>
<li>在Rust中，每个值都有且只有一个所有者。</li>
<li>而在C语言中，并没有所有权概念，内存管理完全由程序员负责，这就可能导致内存泄漏和野指针等问题。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = s1;</span><br><span class="line">    <span class="comment">// 此时 s1 已经失效，不能被使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="keyword">char</span> *s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *s2 = s1; </span><br><span class="line"><span class="comment">// 此时 s1 和 s2 都指向相同的内存</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-借用检查（Borrowing）"><a href="#2-2-2-借用检查（Borrowing）" class="headerlink" title="2.2.2 借用检查（Borrowing）:"></a>2.2.2 借用检查（Borrowing）:</h4></li>
<li>Rust的数据借用可以允许多个读访问，但只要有一个可变借用，就不能有其他读或写访问。</li>
<li>C语言没有这样的机制，因此需要手动管理指针和数据的共享。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">        <span class="comment">// 在此作用域内，不能借用 s 的其他引用</span></span><br><span class="line">    &#125; <span class="comment">// r1 超出作用域，s 可以被再次借用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p1 = s;</span><br><span class="line"><span class="keyword">char</span> *p2 = s; <span class="comment">// p1 和 p2 都指向相同的内存</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-模式匹配（Pattern-Matching）"><a href="#2-2-3-模式匹配（Pattern-Matching）" class="headerlink" title="2.2.3 模式匹配（Pattern Matching）:"></a>2.2.3 模式匹配（Pattern Matching）:</h4></li>
<li>Rust提供了强大的模式匹配功能，可以用于枚举、结构体、元组和字面量等。</li>
<li>C语言没有内置的模式匹配功能，通常需要使用<code>switch</code>语句和多个<code>if-else</code>链来实现。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> coin = Coin::Penny;</span><br><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">    Coin::Penny =&gt; <span class="built_in">println!</span>(<span class="string">"Penny"</span>),</span><br><span class="line">    Coin::Nickel =&gt; <span class="built_in">println!</span>(<span class="string">"Nickel"</span>),</span><br><span class="line">    Coin::Dime =&gt; <span class="built_in">println!</span>(<span class="string">"Dime"</span>),</span><br><span class="line">    Coin::Quarter =&gt; <span class="built_in">println!</span>(<span class="string">"Quarter"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C </span></span><br><span class="line"><span class="keyword">switch</span> (coin) &#123;</span><br><span class="line">    <span class="keyword">case</span> PENNY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Penny"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NICKEL:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Nickel"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DIME:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Dime"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QUARTER:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Quarter"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-并发（Concurrency）"><a href="#2-2-4-并发（Concurrency）" class="headerlink" title="2.2.4 并发（Concurrency）:"></a>2.2.4 并发（Concurrency）:</h4></li>
<li>Rust提供了安全并发的工具，如<code>std::thread</code>、<code>Arc</code>（原子引用计数）和<code>Mutex</code>（互斥锁）。</li>
<li>C语言标准库没有内置的并发工具，通常需要使用操作系统提供的线程库（如POSIX线程）和同步原语。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust</span></span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">    <span class="comment">// 在新线程中运行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">handle.join().unwrap();</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C </span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">int</span> status = pthread_create(&amp;thread, <span class="literal">NULL</span>, &amp;thread_function, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br><span class="line">pthread_join(thread, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-错误处理（Error-Handling）"><a href="#2-2-5-错误处理（Error-Handling）" class="headerlink" title="2.2.5 错误处理（Error Handling）:"></a>2.2.5 错误处理（Error Handling）:</h4></li>
<li>Rust使用<code>Result</code>和<code>Option</code>类型来处理可能的错误或空值，这鼓励开发人员进行显式的错误处理。</li>
<li>C语言通常使用整数错误码和返回值，这可能导致错误被忽略或错误处理。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">open_file</span></span>(file_name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;File, io::Error&gt; &#123;</span><br><span class="line">    File::open(file_name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name)</span> </span>&#123;</span><br><span class="line">    FILE *file = fopen(file_name, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2>说来惭愧，这次训练营第一阶段大部分时间花在折腾OS大赛上了。本来到rCore的ch7时都挺顺利的，结果尝试去运行OS大赛的FAT32镜像里的测例就碰壁了。先是easyfs和fat32不是一个东西，得把照着rCore写的OS的fs换成支持fat32的，瞎折腾了两周总算是能读取fat32里的文件了。然后又发现大赛OS的elf文件导入OS运行又有问题，瞎折腾也搞不出来了（基础不牢靠，不懂为啥会loadpage Fault），索性打算重新复习。</li>
</ul>
<p>这次训练营又学到了很多新的知识，不过也能很清楚地感觉到掌握的不牢靠，后面还需不断加强巩固。同时我也知道了如果自己后面想往OS方向发展，还有很多需要去学习的。说实话，刚开始搞rCore的时候感觉还挺好的，而后到了ch4后，计组等知识的欠缺就很致命了，搞的差点放弃了（fat32那也是，不过好在搞出来了）。然后到了运行OS大赛的elf这就真搞不懂了，只能试着去好好复习下Rust、看看计组、CSAPP等后，再来看看了。</p>
<p>感激社区提供了这样一个学习平台，它为我打开了一扇探索操作系统奥秘的大门。希望后续的学习我还能够坚持下去吧！</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/800a36d0ca944c3b35410e3dfabdbae9.jpg" alt="npn"></p>
<h2 id="4-图片记录"><a href="#4-图片记录" class="headerlink" title="4 图片记录"></a>4 图片记录</h2><p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240425175537.jpg" alt="1"></p>
<p>照着rCore写的FeatOS移植FAT32文件系统成功</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/summary-of-phase-one-puckpone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/summary-of-phase-one-puckpone/" class="post-title-link" itemprop="url">puck's summary of stage1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 10:32:22" itemprop="dateCreated datePublished" datetime="2024-04-25T10:32:22+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024春操作系统训练营一阶段总结"><a href="#2024春操作系统训练营一阶段总结" class="headerlink" title="2024春操作系统训练营一阶段总结"></a>2024春操作系统训练营一阶段总结</h1><p>水群的时候看到了别人分享的邀请链接，于是就报名了训练营</p>
<p>刚接触rust，很多东西理解起来很困难，尤其是lifetime和闭包、迭代器这些内容。</p>
<p>虽然写完了rustling，但还是有许多细节掌握得不够熟练，最后那十道algorithm一做一个不吱声🤡</p>
<p>参考的书籍有 <a href="https://kaisery.github.io/trpl-zh-cn/title-page.html" target="_blank" rel="noopener">rust程序设计语言 </a> <a href="https://course.rs/about-book.html" target="_blank" rel="noopener">rust语言圣经</a></p>
<p>以及 <a href="https://doc.rust-lang.org/rust-by-example/" target="_blank" rel="noopener">rust by example</a>   （<a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a> 我不太会用😅）</p>
<p>对了，rustling里面好像没有异步，记得去补一下</p>
<p>希望下个阶段顺利🦀🦀</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/blog-hehepig166/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/blog-hehepig166/" class="post-title-link" itemprop="url">blog-hehepig166</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 10:19:26" itemprop="dateCreated datePublished" datetime="2024-04-25T10:19:26+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024-春夏季训练营记录"><a href="#2024-春夏季训练营记录" class="headerlink" title="2024 春夏季训练营记录"></a>2024 春夏季训练营记录</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文为训练营的每日实践记录索引，主要为按日期较随意地写下每天的记录与想法。</p>
<p>同时还包含对其他资料、笔记的索引。</p>
<p>更详细的记录在 github 仓库里 <a href="https://github.com/hehepig166/2024-OS-camp-notes" target="_blank" rel="noopener">https://github.com/hehepig166/2024-OS-camp-notes</a></p>
<h2 id="工具与资料"><a href="#工具与资料" class="headerlink" title="工具与资料"></a>工具与资料</h2><p>训练营社区 <a href="https://opencamp.cn/os2edu/camp/2024spring/" target="_blank" rel="noopener">https://opencamp.cn/os2edu/camp/2024spring/</a></p>
<p>Github LearningOS <a href="https://github.com/Learningos" target="_blank" rel="noopener">https://github.com/Learningos</a></p>
<p>Open-Source OS Training Comp 2024 <a href="https://github.com/LearningOS/rust-based-os-comp2024" target="_blank" rel="noopener">https://github.com/LearningOS/rust-based-os-comp2024</a></p>
<ul>
<li><p>Rust 学习</p>
<ul>
<li>The Rust Programming Language <a href="https://doc.rust-lang.org/book/index.html" target="_blank" rel="noopener">https://doc.rust-lang.org/book/index.html</a></li>
<li>Rust By Example <a href="https://doc.rust-lang.org/rust-by-example/index.html" target="_blank" rel="noopener">https://doc.rust-lang.org/rust-by-example/index.html</a></li>
<li>ChatGPT <a href="https://chat.openai.com/" target="_blank" rel="noopener">https://chat.openai.com/</a></li>
<li>rustlings <a href="https://github.com/rust-lang/rustlings" target="_blank" rel="noopener">https://github.com/rust-lang/rustlings</a></li>
<li>中文视频（参考 The Rust Programming Language） <a href="https://www.bilibili.com/video/BV1hp4y1k7SV" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1hp4y1k7SV</a></li>
<li>其实不妨试试在 LeetCode 上用 Rust 写题熟悉语法与性能更高的写法</li>
<li>The Little Book of Rust Macros <a href="https://veykril.github.io/tlborm/" target="_blank" rel="noopener">https://veykril.github.io/tlborm/</a></li>
</ul>
</li>
<li><p>实验指导书</p>
<ul>
<li><a href="https://rcore-os.cn/arceos-tutorial-book/ch01-02.html" target="_blank" rel="noopener">https://rcore-os.cn/arceos-tutorial-book/ch01-02.html</a></li>
<li><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html" target="_blank" rel="noopener">https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html</a></li>
<li><a href="https://learningos.cn/rCore-Tutorial-Guide-2024S/0setup-devel-env.html" target="_blank" rel="noopener">https://learningos.cn/rCore-Tutorial-Guide-2024S/0setup-devel-env.html</a></li>
</ul>
</li>
</ul>
<h2 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h2><table>
<thead>
<tr>
<th align="left">一</th>
<th>二</th>
<th>三</th>
<th>四</th>
<th>五</th>
<th>六</th>
<th>日</th>
</tr>
</thead>
<tbody><tr>
<td align="left">04-01</td>
<td>04-02</td>
<td>04-03</td>
<td>04-04</td>
<td>04-05</td>
<td>04-06</td>
<td><a href="#04-07">04-07</a> (开营)</td>
</tr>
<tr>
<td align="left"><a href="#04-08">04-08</a> (第一阶段)</td>
<td><a href="#04-09">04-09</a></td>
<td><a href="#04-10">04-10</a></td>
<td><a href="#04-11">04-11</a></td>
<td><a href="#04-12">04-12</a></td>
<td><a href="#04-13">04-13</a></td>
<td><a href="#04-14">04-14</a></td>
</tr>
<tr>
<td align="left">04-15</td>
<td><a href="#04-16">04-16</a></td>
<td><a href="#04-17">04-17</a></td>
<td>04-18</td>
<td>04-19</td>
<td>04-20</td>
<td><a href="#04-21">04-21</a></td>
</tr>
<tr>
<td align="left"><a href="#04-22">04-22</a></td>
<td><a href="#04-23">04-23</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="04-07"><a href="#04-07" class="headerlink" title="04-07"></a>04-07</h2><blockquote>
<p>群公告<br>欢迎大家加入春夏季操作系统训练营！<br>4月7日正式开营，已报名的同学请及时学习导学视频内容！<br>网址:<a href="https://opencamp.cn/os2edu/camp/2024spring/stage/0?tab=video" target="_blank" rel="noopener">https://opencamp.cn/os2edu/camp/2024spring/stage/0?tab=video</a></p>
<p>在训练营常见问题Q&amp;A文档<a href="https://docs.qq.com/doc/DY3VMc0tOc29KTWZ5" target="_blank" rel="noopener">https://docs.qq.com/doc/DY3VMc0tOc29KTWZ5</a> 中，对于本期训练营有一些基本问题的介绍，也可以在群里询问</p>
<p>2024春夏季训练营启动仪式回放<br>录制文件：<a href="https://meeting.tencent.com/v2/cloud-record/share?id=95ecb9c0-64f2-4934-a671-78474f735af2&amp;from=3&amp;record_type=2" target="_blank" rel="noopener">https://meeting.tencent.com/v2/cloud-record/share?id=95ecb9c0-64f2-4934-a671-78474f735af2&amp;from=3&amp;record_type=2</a><br>密码：0407</p>
</blockquote>
<ul>
<li><p>开营仪式</p>
<ul>
<li><p>rustlings -&gt; Rust 学习</p>
</li>
<li><p>rcore -&gt; Rust 重写内核实验</p>
</li>
<li><p>ArceOS -&gt; 组件化 OS 项目</p>
</li>
</ul>
</li>
</ul>
<p>之前几周已经开始学习 Rust，做了 rust-lang 下的 rustlings</p>
<p>rust-lang::rustlings <a href="https://github.com/rust-lang/rustlings" target="_blank" rel="noopener">https://github.com/rust-lang/rustlings</a></p>
<p>我的解答与极其简陋随性的学习日志 <a href="https://github.com/hehepig166/my-solution-to-rustlings" target="_blank" rel="noopener">https://github.com/hehepig166/my-solution-to-rustlings</a></p>
<p>（主要是 Rust 资料实在是太多了，我就只写一点关键词提一下记忆即可）</p>
<p>配置了一下 wsl</p>
<h2 id="04-08"><a href="#04-08" class="headerlink" title="04-08"></a>04-08</h2><blockquote>
<p>@所有人  各位同学，第一阶段“Rust编程语言 &amp; Rustlings答疑”第一次课程将于今晚8点开始，今晚的主要内容为Rustlings练习入门、基本数据类型，slice类型，所有权等，总共一个课时，请大家预留时间，按时进入课堂！！</p>
<p>上课方式：点击 <a href="https://opencamp.cn/os2edu/camp/2024spring/stage/1" target="_blank" rel="noopener">https://opencamp.cn/os2edu/camp/2024spring/stage/1</a> 链接，签到并进入课堂进行直播上课</p>
</blockquote>
<p><a href="https://learningos.cn/rust-rustlings-2024-spring-ranking/" target="_blank" rel="noopener">https://learningos.cn/rust-rustlings-2024-spring-ranking/</a></p>
<p><a href="https://github.com/LearningOS/rust-rustlings-2024-spring-hehepig166" target="_blank" rel="noopener">https://github.com/LearningOS/rust-rustlings-2024-spring-hehepig166</a></p>
<p>使用 ssh 链接 clone，用 ssh 鉴权</p>
<p>wsl2 /mnt/ 下 rustlings 更新编译可能会出问题，开发最好不要在 /mnt 目录下操作</p>
<ul>
<li>第一阶段<ul>
<li>[2024春夏季OS训练营–rustling训练]<ul>
<li>要求：<strong>必须完成</strong> 。（大部分其实和 rust-lang 里的 rustlings 一样，多了 algorithm 章节以及 test 章节中的一些练习）</li>
</ul>
</li>
<li>（Option）<a href="https://dtolnay.github.io/rust-quiz/1" target="_blank" rel="noopener">32 Rust Quizes</a><ul>
<li>要求：小练习全部通过。（<strong>非必须完成</strong>）</li>
</ul>
</li>
<li>（Option）<a href="http://llever.com/exercism-rust-zh/index.html" target="_blank" rel="noopener">exercisms.io 快速练习(88+道题目的中文详细描述)</a><ul>
<li>要求：大部分练习会做或能读懂。（<strong>非必须完成</strong>）</li>
<li><a href="https://exercism.org/" target="_blank" rel="noopener">https://exercism.org/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>module 的 pub 关键字只往上 pub 一层</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> delicious_snacks &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Fix these use statements</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> self::fruits::PEAR <span class="keyword">as</span> fruit;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> self::veggies::CUCUMBER <span class="keyword">as</span> veggie;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> fruits &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">const</span> PEAR: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Pear"</span>;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">const</span> APPLE: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Apple"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> veggies &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">const</span> CUCUMBER: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Cucumber"</span>;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">const</span> CARROT: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Carrot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"favorite snacks: &#123;&#125; and &#123;&#125;"</span>,</span><br><span class="line">        delicious_snacks::fruit,</span><br><span class="line">        delicious_snacks::veggie</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let a = delicious_snacks::fruits::PEAR;     // 无法访问</span></span><br><span class="line">    <span class="keyword">let</span> b = delicious_snacks::fruit;               <span class="comment">// 可以访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="04-09"><a href="#04-09" class="headerlink" title="04-09"></a>04-09</h2><p><code>std::f64::NAN</code></p>
<p>Rust 中两个 <code>NAN</code> 是不相等的，要判断一个浮点数是不是 <code>NAN</code>，可以用 <code>.is_nan()</code> 函数来判断。</p>
<p>完成了 rust-lang 里的 rustlings。</p>
<blockquote>
<p>在 Rust 中，<code>?</code> 是一个简便的错误处理操作符，通常用于简化对 <code>Result</code> 或 <code>Option</code> 类型的值进行处理的代码。它的作用是在操作成功时返回成功的结果，如果遇到错误则将错误提早返回。</p>
<p>在函数中使用 <code>?</code> 时，该函数的返回类型必须是 <code>Result</code> 或 <code>Option</code>。如果表达式的结果是 <code>Ok</code>（对于 <code>Result</code> 类型）或 <code>Some</code>（对于 <code>Option</code> 类型），则 <code>?</code> 会将其中的值提取出来并返回；如果结果是 <code>Err</code> 或 <code>None</code>，则整个函数会提前返回并将 <code>Err</code> 或 <code>None</code> 作为整个函数的返回值。</p>
</blockquote>
<h2 id="04-10"><a href="#04-10" class="headerlink" title="04-10"></a>04-10</h2><blockquote>
<p>@所有人 各位同学，第一阶段“Rust编程语言 &amp; Rustlings答疑”第二次课程将于今晚8点开始，今晚的主要内容为Rustlings答疑，总共一个课时，请大家预留时间，按时进入课堂！！</p>
<p>上课方式：点击 <a href="https://opencamp.cn/os2edu/camp/2024spring/stage/1" target="_blank" rel="noopener">https://opencamp.cn/os2edu/camp/2024spring/stage/1</a> 链接，签到并进入课堂进行直播上课。</p>
<p>如果同学们有什么问题也可以在问题收集页面<a href="https://docs.qq.com/doc/DSXFzRkdodExxQUVO给老师提一下哦～" target="_blank" rel="noopener">https://docs.qq.com/doc/DSXFzRkdodExxQUVO给老师提一下哦～</a></p>
</blockquote>
<p>rustlings test 章节</p>
<ul>
<li>条件编译</li>
</ul>
<p><code>#[cfg()]</code></p>
<blockquote>
<p><code>cfg()</code> 可以接受一些不同的条件，用于控制编译时的行为。这些条件可以是 Rust 编译器理解的一些特定标识符，也可以是自定义的条件。下面是一些常见的 <code>cfg()</code> 条件：</p>
<ul>
<li><code>target_os</code>: 目标操作系统，如 <code>&quot;windows&quot;</code>, <code>&quot;linux&quot;</code>, <code>&quot;macos&quot;</code> 等。</li>
<li><code>target_arch</code>: 目标架构，如 <code>&quot;x86&quot;</code>, <code>&quot;x86_64&quot;</code>, <code>&quot;arm&quot;</code> 等。</li>
<li><code>target_env</code>: 目标环境，如 <code>&quot;gnu&quot;</code>, <code>&quot;msvc&quot;</code>, <code>&quot;musl&quot;</code> 等。</li>
<li><code>target_pointer_width</code>: 目标指针宽度，如 <code>&quot;32&quot;</code>, <code>&quot;64&quot;</code> 等。</li>
<li><code>feature</code>: 启用的特性，如 <code>&quot;myfeature&quot;</code>。</li>
<li><code>any()</code>: 如果任一条件为真则为真，语法为 <code>cfg(any(condition1, condition2, ...))</code>。</li>
<li><code>all()</code>: 如果所有条件为真则为真，语法为 <code>cfg(all(condition1, condition2, ...))</code>。</li>
<li><code>not()</code>: 取反，语法为 <code>cfg(not(condition))</code>。</li>
<li>自定义条件：你可以在 <code>build.rs</code> 或者 <code>Cargo.toml</code> 中定义自己的条件，然后在 <code>cfg()</code> 中使用。</li>
</ul>
<p>这些条件可以根据实际需要组合使用，以便根据不同的情况编译不同的代码。</p>
</blockquote>
<ul>
<li>外部链接 FFI(Foreign Function Interface)</li>
</ul>
<p><code>extern</code></p>
<p>这段代码指定 <code>my_demo_function</code> 与 <code>my_demo_function_alias</code> 从符号表中找名字为<code>my_demo_function</code>的函数链接。</p>
<p>而在 <code>Foo::my_demo_function</code> 中又指定了 <code>#[no_mangle]</code> ，即在编译后的目标文件中的符号名称可见并保持不变，被上面两个 extern 找到并使用。</p>
<p>注意这里利用这个东西，使这个函数的的 private 属性失效了。 FFI</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests9.rs</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"Rust"</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[link_name = <span class="meta-string">"my_demo_function"</span>]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_demo_function</span></span>(a: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[link_name = <span class="meta-string">"my_demo_function"</span>]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_demo_function_alias</span></span>(a: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> Foo &#123;</span><br><span class="line">    <span class="comment">// No `extern` equals `extern "Rust"`.</span></span><br><span class="line">    <span class="meta">#[no_mangle]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_demo_function</span></span>(a: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">test_success</span></span>() &#123;</span><br><span class="line">        <span class="comment">// The externally imported functions are UNSAFE by default</span></span><br><span class="line">        <span class="comment">// because of untrusted source of other languages. You may</span></span><br><span class="line">        <span class="comment">// wrap them in safe Rust APIs to ease the burden of callers.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// SAFETY: We know those functions are aliases of a safe</span></span><br><span class="line">        <span class="comment">// Rust function.</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            my_demo_function(<span class="number">123</span>);</span><br><span class="line">            my_demo_function_alias(<span class="number">456</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析 traits </p>
<p>parse() 返回一个 Result&lt;i64, xxxErr&gt; 类型的东西，然后 ? 操作符对它进行处理，要是是 i64，就传给 x 然后正常继续，要是是 Err 就提前结束当前 main() ，调用 from 方法把 Err 自动转成 Box 作为 main 的返回结果？</p>
</li>
</ul>
<p>traits 类似 C++ 中的虚基类和虚函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> pretend_user_input = <span class="string">"42"</span>;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i64</span> = pretend_user_input.parse()?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"output=&#123;:?&#125;"</span>, PositiveNonzeroInteger::new(x)?);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>algorithm</li>
</ul>
<p>区别 <code>ref mut root</code> 和 <code>mut &amp;root</code></p>
<h2 id="04-11"><a href="#04-11" class="headerlink" title="04-11"></a>04-11</h2><p>rustlings algorithm5 bfs, algorithm6 dfs</p>
<p>“闭包”</p>
<h2 id="04-12"><a href="#04-12" class="headerlink" title="04-12"></a>04-12</h2><blockquote>
<p>@所有人 各位同学，第一阶段“Rust编程语言 &amp; Rustlings答疑”第三次课程将于今晚8点开始，今晚的主要内容为crate，option，trait和泛型及生命周期，总共一个课时，请大家预留时间，按时进入课堂！！</p>
<p>上课方式：点击 <a href="https://opencamp.cn/os2edu/camp/2024spring/stage/1" target="_blank" rel="noopener">https://opencamp.cn/os2edu/camp/2024spring/stage/1</a> 链接，签到并进入课堂进行直播上课。</p>
<p>如果同学们有什么问题也可以在问题收集页面<a href="https://docs.qq.com/doc/DSXFzRkdodExxQUVO给老师提一下哦" target="_blank" rel="noopener">https://docs.qq.com/doc/DSXFzRkdodExxQUVO给老师提一下哦</a></p>
</blockquote>
<p>rustlings algorithm7,8 stack, algorithm9 heap, algorithm10 graph</p>
<p>rustlings 完成了</p>
<p>继续学习rust生命周期</p>
<p>表达式 vs. 语句</p>
<p>super::</p>
<p>泛型, trait, 生命周期</p>
<p>trait 作为参数，可以指定多个trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个代码作用相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;<span class="keyword">impl</span> Summary) &#123;	<span class="comment">// item 为包含了Summary trait的一个引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;	<span class="comment">// item 为包含了Summary trait的一个引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个 trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;(<span class="keyword">impl</span> Summary + Display));</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: &amp;T);</span><br><span class="line"></span><br><span class="line"><span class="comment">// where</span></span><br><span class="line"><span class="comment">// 以下两个代码效果相同</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fun</span></span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;U, u: &amp;U) -&gt; <span class="built_in">i32</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fun</span></span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; <span class="built_in">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	T:Display + <span class="built_in">Clone</span>,</span><br><span class="line">	U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用的生命周期</p>
<p>做一做 rust quiz</p>
<h2 id="04-13"><a href="#04-13" class="headerlink" title="04-13"></a>04-13</h2><p>使用工具 rustfmt 可以自动将代码格式化。有助于分析代码。</p>
<p>代码分析</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> m &#123;</span><br><span class="line">    ($($s:stmt)*) =&gt; &#123;</span><br><span class="line">        $(</span><br><span class="line">            &#123; <span class="built_in">stringify!</span>($s); <span class="number">1</span> &#125;</span><br><span class="line">        )&lt;&lt;*</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print!</span>(</span><br><span class="line">        <span class="string">"&#123;&#125;&#123;&#125;&#123;&#125;"</span>,</span><br><span class="line">        m! &#123; <span class="keyword">return</span> || <span class="literal">true</span> &#125;,</span><br><span class="line">        m! &#123; (<span class="keyword">return</span>) || <span class="literal">true</span> &#125;,</span><br><span class="line">        m! &#123; &#123;<span class="keyword">return</span>&#125; || <span class="literal">true</span> &#125;,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是纯秀语法，没实际意义。</p>
<p>上面定义了一个宏规则 <code>m</code>。</p>
<p> <code>$()*</code> 代表匹配一个或多个。</p>
<p><code>$s:stmt</code>代表 s 是一个 statement。</p>
<p><code>=&gt; {}</code> 表示匹配到模式后要展开成的代码块规则。</p>
<p><code>$()&lt;&lt;*</code> 表示对每个 statement 得到的代码块用 <code>&lt;&lt;</code> 连接。</p>
<p>关键在于分析三行代码中各自有几个 statement。</p>
<p>第一个 <code>return || true</code>，是一个返回闭包 <code>|| true</code> 的 return 语句。</p>
<p>第二个 <code>(return) || true</code>，是一个逻辑或语句。（虽然过不了编译，但是后面是转成字符串所以没事）。</p>
<p>第三个 <code>{return} || true</code> 是两个语句，一个是 <code>{return}</code> 语句块，另一个是 <code>|| true</code> 闭包。</p>
<p>展开后，我的理解是这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print!</span>(</span><br><span class="line">        <span class="string">"&#123;&#125;&#123;&#125;&#123;&#125;"</span>,</span><br><span class="line">        &#123; <span class="string">"return || true"</span>; <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="string">"(return) || true"</span>; <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="string">"&#123;return&#125;"</span>; <span class="number">1</span> &#125;&lt;&lt;&#123; <span class="string">"|| true"</span>; <span class="number">1</span> &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="04-14"><a href="#04-14" class="headerlink" title="04-14"></a>04-14</h2><p>继续看看 rust quiz</p>
<h2 id="04-16"><a href="#04-16" class="headerlink" title="04-16"></a>04-16</h2><p>去看了吉卜力展</p>
<h2 id="04-17"><a href="#04-17" class="headerlink" title="04-17"></a>04-17</h2><p>rust quiz</p>
<p>rcore 实验一</p>
<p>学习：Rust 生命周期</p>
<ul>
<li><p>无界生命周期 unsafe</p>
</li>
<li><p>生命周期约束 HRTB</p>
<ul>
<li><p><code>&#39;a: &#39;b</code> 表示 <code>&#39;a</code> 至少活得跟 <code>&#39;b</code> 一样久</p>
</li>
<li><p><code>T: &#39;a</code> 类型 <code>T</code> 必须比 <code>&#39;a</code> 活得久</p>
</li>
</ul>
</li>
<li><p>生命周期与子类型</p>
<ul>
<li>子类型至少比父类型大</li>
</ul>
</li>
<li><p>引用的生命周期：从借用处开始，直到最后一次使用的地方</p>
</li>
<li><p>reborrow</p>
<ul>
<li><pre><code class="rust"><span class="keyword">let</span> <span class="keyword">mut</span> p = Point {x: <span class="number">0</span>, y: <span class="number">0</span>};
<span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> p;
<span class="keyword">let</span> rr: &amp;Point = &amp;*r;
&lt;!--￼<span class="number">6</span>--&gt;

* &gt;清空内存前，我们插入了一条奇怪的汇编指令 `fence.i` ，它是用来清理 i-cache 的。 我们知道， 缓存又分成 **数据缓存** (d-cache) 和 **指令缓存** (i-cache) 两部分，分别在 CPU 访存和取指的时候使用。 通常情况下， CPU 会认为程序的代码段不会发生变化，因此 i-cache 是一种只读缓存。 但在这里，我们会修改会被 CPU 取指的内存区域，使得 i-cache 中含有与内存不一致的内容， 必须使用 `fence.i` 指令手动清空 i-cache ，让里面所有的内容全部失效， 才能够保证程序执行正确性。</code></pre>
</li>
</ul>
</li>
<li><p>特权级切换</p>
<ul>
<li>硬件机制<ul>
<li>U/S 特权级</li>
<li>相关 CSR<ul>
<li>sstatus</li>
<li>spec</li>
<li>scause</li>
<li>stval</li>
<li>stvec</li>
</ul>
</li>
</ul>
</li>
<li>用户栈、内核栈</li>
<li>trap 管理</li>
</ul>
</li>
</ul>
<ul>
<li>荣誉准则</li>
</ul>
<blockquote>
<ol>
<li><p>在完成本次实验的过程（含此前学习的过程）中，我曾分别与 <strong>以下各位</strong> 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：</p>
<blockquote>
<p><em>《你交流的对象说明》</em></p>
</blockquote>
</li>
<li><p>此外，我也参考了 <strong>以下资料</strong> ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：</p>
<blockquote>
<p><em>《你参考的资料说明》</em></p>
</blockquote>
</li>
<li><p>我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。</p>
</li>
<li><p>我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。</p>
</li>
</ol>
</blockquote>
<h2 id="04-23"><a href="#04-23" class="headerlink" title="04-23"></a>04-23</h2><p>Rust 学习</p>
<ul>
<li><p>闭包（匿名函数）</p>
<ul>
<li><p>本质：拥有可能关联上下文的匿名函数体</p>
</li>
<li><p>允许捕获被定义时所在作用域中的值（不像函数，必须显式传参）</p>
</li>
<li><pre><code class="rust"><span class="function"><span class="keyword">fn</span> <span class="title">add_one_v1</span>     </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> { x+<span class="number">1</span> }
<span class="keyword">let</span> add_one_v2 =  |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> { x+<span class="number">1</span> };
<span class="keyword">let</span> add_one_v3 =  |x|             { x+<span class="number">1</span> };
<span class="keyword">let</span> add_one_v4 =  |x|               x+<span class="number">1</span>  ;</code></pre>
<p>后面两个要编译必须使用。</p>
</li>
<li><p>使用 move 强制获取所有权</p>
</li>
<li><p>Fn trait</p>
<ul>
<li>FnOnce</li>
<li>FnMut</li>
<li>Fn</li>
</ul>
</li>
</ul>
</li>
<li><p>智能指针</p>
<ul>
<li>Box    -&gt; 将值放在堆上而非栈上<ul>
<li>针对编译时位置大小的类型</li>
<li>有大量数据并确保数据不被拷贝的情况下转移所有权时</li>
<li>拥有一个值并只关心它的类型是否实现了特定trait而非具体类型时</li>
<li>Deref trait</li>
</ul>
</li>
<li>Rc       -&gt; 引用计数<ul>
<li>图</li>
<li>clone</li>
<li>克隆 <code>Rc&lt;T&gt;</code> 会增加其引用计数</li>
<li>不可变引用</li>
</ul>
</li>
<li>RefCell  -&gt; 内部可变性指针<ul>
<li>Interior mutability<ul>
<li>该数据结构中使用了 unsafe 代码来模糊 Rust 通常的可变性和借用规则</li>
</ul>
</li>
<li>任意时刻，只能拥有一个可变引用或任意数量的不可变引用之一</li>
<li>引用必须总是有效的</li>
</ul>
</li>
</ul>
</li>
<li><p>async</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/rust%E5%AD%A6%E4%B9%A0blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/rust%E5%AD%A6%E4%B9%A0blog/" class="post-title-link" itemprop="url">rust学习blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 09:46:39" itemprop="dateCreated datePublished" datetime="2024-04-25T09:46:39+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Rust学习总结报告"><a href="#Rust学习总结报告" class="headerlink" title="Rust学习总结报告"></a>Rust学习总结报告</h1><p>Rust是一种注重安全、性能和并发性的系统编程语言。在过去的几周里，我深入学习了Rust语言，对其有了更深入的了解。本报告将总结我所学习的Rust知识点，包括所有权、借用、生命周期、类型系统、模式匹配、错误处理、并发编程等。</p>
<h2 id="1-所有权"><a href="#1-所有权" class="headerlink" title="1. 所有权"></a>1. 所有权</h2><p>Rust的核心特性之一是所有权（Ownership），它控制了程序中的资源分配和释放。所有权规则包括三条：每个值都有一个变量，称为其所有者；同一时间内只能有一个所有者；当所有者离开作用域时，值将被丢弃。所有权机制有助于避免内存泄漏和数据竞争问题。</p>
<h2 id="2-借用"><a href="#2-借用" class="headerlink" title="2. 借用"></a>2. 借用</h2><p>借用（Borrowing）允许我们在不转移所有权的情况下访问数据。Rust通过两种借用方式来实现：可变借用（&amp;mut T）和不可变借用（&amp;T）。借用规则包括：同一时间内只能有一个可变借用或多个不可变借用；借用者不能超过所有者的生命周期。</p>
<h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. 生命周期</h2><p>生命周期（Lifetimes）是Rust确保引用有效性的关键概念。Rust通过生命周期参数（如’a、’b等）来标注引用的存活时间。生命周期的主要作用是防止悬垂引用和数据竞争。在函数和结构体定义中，我们需要为引用参数和字段指定生命周期参数，以告诉编译器引用之间的关系。</p>
<h2 id="4-类型系统"><a href="#4-类型系统" class="headerlink" title="4. 类型系统"></a>4. 类型系统</h2><p>Rust的类型系统非常丰富，包括标量类型、复合类型、自定义类型等。标量类型包括整数、浮点数、布尔值和字符；复合类型包括元组、数组、切片和字符串；自定义类型包括结构体、枚举和联合。Rust还提供了类型推导、类型别名、泛型等特性，方便开发者编写灵活、可重用的代码。</p>
<h2 id="5-模式匹配"><a href="#5-模式匹配" class="headerlink" title="5. 模式匹配"></a>5. 模式匹配</h2><p>模式匹配（Pattern Matching）是Rust中一个强大的控制流和数据处理工具。通过模式匹配，我们可以检查数据类型、解构复合数据、绑定变量等。Rust支持模式匹配的语法包括匹配守卫（match guard）、模式绑定（@）和模式切片等。模式匹配让我们的代码更加简洁、易读和健壮。</p>
<h2 id="6-错误处理"><a href="#6-错误处理" class="headerlink" title="6. 错误处理"></a>6. 错误处理</h2><p>Rust的错误处理机制主要包括两种：可恢复错误（Result&lt;T, E&gt;）和不可恢复错误（panic!宏）。可恢复错误用于处理可能失败的运算，如文件操作、网络请求等；不可恢复错误用于处理无法恢复的场景，如程序逻辑错误。Rust还提供了?运算符，简化了错误处理的代码编写。</p>
<h2 id="7-并发编程"><a href="#7-并发编程" class="headerlink" title="7. 并发编程"></a>7. 并发编程</h2><p>Rust提供了丰富的并发编程支持，包括线程、通道、互斥锁等。Rust的线程安全特性得益于所有权和借用机制，使得在多线程环境中共享数据变得简单。通道（Channel）是Rust中的一种并发数据结构，用于线程之间的消息传递。Rust还提供了跨线程共享数据的同步机制，如Arc<T>和Mutex<T>。<br>总之，Rust是一门具有高性能、内存安全和并发性的编程语言。通过学习Rust，我掌握了所有权、借用、生命周期、类型系统、模式匹配、错误处理和并发编程等知识点。这些知识点不仅让我对Rust有了更深入的了解，还提高了我的编程水平。在未来的工作中，我会继续学习和实践Rust，为我国软件产业的发展贡献力量。</T></T></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/04/25/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%88%98%E5%90%AF%E4%B8%9C%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/04/25/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%88%98%E5%90%AF%E4%B8%9C%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2024春季开源操作系统训练营刘启东一阶段总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-25 09:13:51" itemprop="dateCreated datePublished" datetime="2024-04-25T09:13:51+00:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-19 09:19:45" itemprop="dateModified" datetime="2025-05-19T09:19:45+00:00">2025-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Rust一阶段总结"><a href="#Rust一阶段总结" class="headerlink" title="Rust一阶段总结"></a>Rust一阶段总结</h1><h1 id="零、个人照片"><a href="#零、个人照片" class="headerlink" title="零、个人照片"></a>零、个人照片</h1><p>随便放张生活照吧，很久之前拍的了，呵呵~时间过得真快</p>
<p><img src="https://ikun-1322198038.cos.ap-guangzhou.myqcloud.com/undefined202404242218564.jpg" alt></p>
<h1 id="一、本次参赛情况概述"><a href="#一、本次参赛情况概述" class="headerlink" title="一、本次参赛情况概述"></a>一、本次参赛情况概述</h1><p>本人也是上届训练营参营成员，不过那时候是和一个水友组的队，基本只有我一个人在努力写题。想起上次训练营我啥也不会，也没看过<a href="https://rustwiki.org/zh-CN/book/title-page.html" target="_blank" rel="noopener">《Rust语言程序设计》</a>，抱着<a href="https://course.rs/about-book.html" target="_blank" rel="noopener">《Rust圣经》</a>+ChatGPT硬啃，勉强过了一阶段的100题，后面由于二阶段实在是有点复杂，迫于学业和项目组项目压力，勉强做了两个就做不下去了。</p>
<p>这次拉了两个工作室成员，都是有一定工程基础的，有一位成员在此之前接触过Rust，所以这次一阶段至少还算轻松，不会了线下相互请教一下，最终也是慢悠悠地过了一阶段。当然这次总结我倒不打算主要讲Rust代码上的东西，哈哈，相比较于程序设计，我倒感觉思想上的收获更多。</p>
<h1 id="二、rustlings任务完成心得"><a href="#二、rustlings任务完成心得" class="headerlink" title="二、rustlings任务完成心得"></a>二、rustlings任务完成心得</h1><p>这次任务，我将之前的（多）线程、外部导入函数、裸指针、所有权与借用以及模式匹配更层次地理解了一遍。想起我上次都是靠GPT撑过来的，属实确实有点搞笑了，这里我总结一下如何跟着这个Rust训练营的学习方法：</p>
<h2 id="2-1看官方文档"><a href="#2-1看官方文档" class="headerlink" title="2.1看官方文档"></a>2.1看官方文档</h2><p>这里的官方有多个含义。</p>
<p>首先是训练营官方给出的环境搭建文档，跑软件不可避免要进行环境搭建，最简单也得学会用docker，学会了搭建最基础的环境，才能整式开始学习之旅。</p>
<p>然后是看《Rust程序设计》这本mdbook，一阶段很多知识点，其实可以从这本书找到答案，换句话说，这本书相当于rustlings的提示手册了，仔细钻研这本书，还是可以学到很多东西的，如果直接去看《Rust圣经》 对没有基础的同学来说还是容易劝退</p>
<p>最后就是看Rust语言的官方文档了，有中英双语版本，可以看到每个函数的具体解释，这里我推荐使用<code>zeal</code>这个<a href="https://zealdocs.org/download.html" target="_blank" rel="noopener">软件</a>安装Rust的文档进行查看，不需要联网，支持全局查找，还是很不错的</p>
<h2 id="2-2看他人博客"><a href="#2-2看他人博客" class="headerlink" title="2.2看他人博客"></a>2.2看他人博客</h2><p>虽然很多文档都有，但是大部分都是英文的，可惜我们一组3个成员英语都不太好，只能硬啃文档。另一种好的方法是去找别人学习源码的笔记，一遍写得好的笔记也是能传递很多知识的，我在仔细翻阅他们的笔记之后，加深了对所有权和一些陷阱的理解</p>
<h2 id="2-3多动手实验"><a href="#2-3多动手实验" class="headerlink" title="2.3多动手实验"></a>2.3多动手实验</h2><p>当然，理工科的东西还是以动手为主。我们由于本身有工程基础，于是乎就开始拉几台服务器自己装下环境，在ubuntu装，在windows装，在WSL装，在classroom装，都装一遍，写好通用的执行流程和坑点，加深对Rust的理解。</p>
<p>不过说实话，如果操作系统训练营要成为一门面向大众的训练营，以目前的文档详细程度来说，其实在文档上面下的功夫依旧不够，代入一个新手的视角来看，配置gitHub秘钥是陌生的，github进在线classroom运行时陌生的，git是陌生的，如果仅仅只有LInux基础还是很容易劝退，这就必须要个人有一点自主学习，热爱钻研的能力才能坚持下去，很多工程新手要完成这个阶段也得两三天。就我个人刚入门工程项目的时候，我自学git就很容易犯低级错误，或者进行不规范的操作，我觉得训练营至少要给出一遍基础操作，这样就能带动更广泛的学生参与进来。只要过了环境配置，后面通过一阶段那就只是坚持下去就能完成的事情了。</p>
<h1 id="三、完成rustlings过程中遇到的困难"><a href="#三、完成rustlings过程中遇到的困难" class="headerlink" title="三、完成rustlings过程中遇到的困难"></a>三、完成rustlings过程中遇到的困难</h1><h2 id="3-1语法不熟悉"><a href="#3-1语法不熟悉" class="headerlink" title="3.1语法不熟悉"></a>3.1语法不熟悉</h2><p>其实环顾rustlings和《Rust语言程序设计》，这两者都没有重点讲Option是什么，Result是什么，unwarp()是什么，都需要自己去找额外的文档进行理解，很多需要的函数，不如trip(),insert(),get_mut(),as_mut(),as_ref()这些奇怪的函数，但是其实这些挺基础的，如果不会这些，不知道某些函数的返回值是什么类型，OPtion有什么用，其实是很难写下去的。鉴于以往学C++的经验，我自己重新学习了一下Rust的基本数据结构，以及基本数据结构的内置方法，还有一些通用方法和获取指针的方法，这些都是比较重要的。</p>
<h2 id="3-2STL不会用"><a href="#3-2STL不会用" class="headerlink" title="3.2STL不会用"></a>3.2STL不会用</h2><p>这次新增了一些算法题，颇有种使用C构建数据结构写算法的感觉，不过还好是填空的模式，对于没有掌握全部数据结构的我来说，还是能勉强接受的。致辞的算法题都是基于基本的容器进行操作的，比如bfs就是基于queue，算法里面使用deque，还有后面使用vec充当邻接表，还用到了hashMap当做node进行映射，不会使用容器做这些还是稍微有些困难的，当然，稍微学学容器方法还是可以写出来的</p>
<h1 id="四、本次一阶段的收获"><a href="#四、本次一阶段的收获" class="headerlink" title="四、本次一阶段的收获"></a>四、本次一阶段的收获</h1><p>这次一阶段，我个人和另外的成员承担的项目任务更轻松了一点，拉了两个人来一起学习，还是蛮不错的</p>
<p>掌握了更多的学习途径和方法，从“正确的方向”巩固了Rust的语言基础，我现在感觉Rust+cargo越来越好用了，中途踩了几个小坑，每犯一次错误都能学到东西，嘿嘿~</p>
<h1 id="五、自己找的学习资源汇总"><a href="#五、自己找的学习资源汇总" class="headerlink" title="五、自己找的学习资源汇总"></a>五、自己找的学习资源汇总</h1><p>权当分享啦~</p>
<p>5.1<a href="https://rustwiki.org/zh-CN/book/title-page.html" target="_blank" rel="noopener">Rust 程序设计语言 - Rust 程序设计语言 中文版 (rustwiki.org)</a></p>
<p>5.2<a href="https://rustwiki.org/zh-CN/std/index.html" target="_blank" rel="noopener">std - Rust (rustwiki.org)</a></p>
<p>5.3<a href="https://rustwiki.org/docs/" target="_blank" rel="noopener">Rust 中文文档 | Rust 文档网 (rustwiki.org)</a></p>
<p>5.4<a href="https://course.rs/about-book.html" target="_blank" rel="noopener">关于本书 - Rust语言圣经(Rust Course)</a></p>
<p>5.5<a href="https://rust-book.junmajinlong.com/ch1/00.html" target="_blank" rel="noopener">Rust入门第一课 - Rust入门秘籍 (junmajinlong.com)</a></p>
<p>5.6<a href="https://rustmagazine.github.io/rust_magazine_2021/index.html" target="_blank" rel="noopener">介绍 - Rust精选 (rustmagazine.github.io)</a></p>
<p>5.7<a href="https://rustwiki.org/zh-CN/rust-by-example/index.html" target="_blank" rel="noopener">简介 - 通过例子学 Rust 中文版 (rustwiki.org)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/43/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/43/">43</a><span class="page-number current">44</span><a class="page-number" href="/blog/page/45/">45</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/69/">69</a><a class="extend next" rel="next" href="/blog/page/45/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
