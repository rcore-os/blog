<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/6/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">733</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">640</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/21/2025%E5%B9%B4%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-moot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/21/2025%E5%B9%B4%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-moot/" class="post-title-link" itemprop="url">2025年春夏开源操作系统训练营前三阶段总结-moot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-21 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-21T00:00:00+00:00">2025-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/" itemprop="url" rel="index"><span itemprop="name">ArceOS</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/x86/" itemprop="url" rel="index"><span itemprop="name">x86</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>过去一个月，由于我对 ArceOS 的架构理解较少，为了快速掌握 ArceOS 的架构，<strong><em>Unikernel</em></strong> 和 <strong><em>宏内核</em></strong>，我的主要目标改进 <strong><em>oscamp</em></strong>，为其完善对 <strong><em>x86_64</em></strong> 的支持。同时还做了对内核组件 <strong><em>x86_rtc</em></strong> 说明文档和测试的完善。<br>最直接的收获有两点：</p>
<ul>
<li><strong>Unikernel 思想</strong> —— “用户态就是内核的一部分” 的最小可信边界，让我重新审视传统多进程操作系统里“内核/用户”硬隔离的成本。</li>
<li><strong>宏内核工程学</strong> —— 模块划分、内核线程、系统调用网关、设备驱动归一化，这些都在 Starry/ArceOS 的设计里有了“先行者版本”。</li>
</ul>
<hr>
<h2 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h2><h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><p>为了快速掌握 ArceOS 的架构，<strong><em>Unikernel</em></strong> 和 <strong><em>宏内核</em></strong>，我选择了改进 <strong><em>oscamp</em></strong>，为其完善对 <strong><em>x86_64</em></strong> 的支持这一项工作。并开始了对 <strong><em>x86_64</em></strong> 的学习。</p>
<h3 id="第二、三周"><a href="#第二、三周" class="headerlink" title="第二、三周"></a>第二、三周</h3><p>主要是做代码工作，以下是一些总结<br>RISC‑V 是通过 <code>scause</code> + <code>stval</code>；x86‑64 要区分 <strong>Exception Class</strong>（#PF/#UD）与 <strong>IRQ Vector</strong>，且栈布局不一样。<br>对 <strong><em>x86_64</em></strong> 的支持这一项工作需要完成以下的功能实现：</p>
<ol>
<li>改进 <strong><em>context.rs</em></strong>，保存相关的寄存器，并完善 <strong><em>context_switch</em></strong> 和 <strong><em>enter_uspace</em></strong>。<ul>
<li>保存/恢复的寄存器集对齐 <strong>SysV x86‑64</strong> 调用约定：<code>RBX RBP R12‑R15</code> + <code>CR3</code> + <code>RFLAGS</code>；<code>FPU/AVX</code> 延后到 lazy fp 任务。</li>
<li><code>context_switch(old, new)</code> = 保存旧任务栈顶 → 恢复新任务栈顶 → <em><code>iretq</code></em>；为支持 <code>SMP</code>，加了 <code>core::arch::asm!(&quot;swapgs&quot;)</code> 保证每 CPU 的 GS 基址切换。</li>
<li>进入用户态 (<code>enter_uspace</code>)：手动构造 <em><code>iretq</code></em> 帧：<code>SS|RSP|RFLAGS|CS|RIP</code>，再写 <code>CR3 = user_pml4</code>; 关中断→加载帧→开中断→ <em><code>iretq</code></em>。</li>
</ul>
</li>
<li>改进 <strong><em>trap.S</em></strong><ul>
<li><strong>IDT 256 项</strong>：<code>0x20</code> 时钟、<code>0x80</code> 软中断、<code>0x0E</code> #PF……全部指向统一的 <code>trap_entry</code>；硬中断通过 APIC 自动切到 <strong>IST[0] emergency stack</strong> 防止内核栈溢出。</li>
<li><code>trap.rs</code> 根据向量号派发到 <code>handle_page_fault / handle_irq / handle_syscall</code>。</li>
</ul>
</li>
<li>改进 <strong><em>syscall.rs</em></strong> 和 <strong><em>syscall.S</em></strong><ul>
<li>选 <code>SYSCALL/SYSRET</code> 而非 <code>INT 0x80</code>；入口先 <code>swapgs</code> 用 GS 保存/恢复用户栈。</li>
<li>按 SysV ABI <code>RAX</code>=nr，<code>RDI RSI RDX R10 R8 R9</code> 传六参 —— 在汇编里把寄存器序列化到栈，统一传给 <code>x86_syscall_handler()</code>。</li>
<li>退出路径：恢复通用寄存器 → <code>swapgs</code> → <code>sysretq</code></li>
</ul>
</li>
</ol>
<h3 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h3><p>对内核组件 <strong><em>x86_rtc</em></strong> 说明文档和测试的完善。<br><a href="https://github.com/MTttth/x86_rtc.git" target="_blank" rel="noopener">repo</a></p>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><ul>
<li><strong>Transparent HugePages</strong>：复用前期完成的巨页 API，引入 <code>khugepaged</code> 合并线程。</li>
<li><strong>vDSO</strong>：把高频 <code>clock_gettime</code> 胶水放到用户态，加速 Sys‑API。</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/20/Lfan-ke%EF%BC%9AGPGPU%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/20/Lfan-ke%EF%BC%9AGPGPU%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/" class="post-title-link" itemprop="url">GPU GPGPU GPGPGPU！</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-20 13:07:00" itemprop="dateCreated datePublished" datetime="2025-06-20T13:07:00+00:00">2025-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/" itemprop="url" rel="index"><span itemprop="name">ArceOS</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/" itemprop="url" rel="index"><span itemprop="name">阶段四</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/" itemprop="url" rel="index"><span itemprop="name">2025S</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/" itemprop="url" rel="index"><span itemprop="name">OpenCL</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/" itemprop="url" rel="index"><span itemprop="name">GPU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/" itemprop="url" rel="index"><span itemprop="name">GPGPU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/" itemprop="url" rel="index"><span itemprop="name">POCL</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/" itemprop="url" rel="index"><span itemprop="name">WGPU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/" itemprop="url" rel="index"><span itemprop="name">Vortex</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/stage4/" itemprop="url" rel="index"><span itemprop="name">stage4</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/stage4/virtio-v1-2/" itemprop="url" rel="index"><span itemprop="name">virtio-v1.2</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/stage4/virtio-v1-2/Virtio/" itemprop="url" rel="index"><span itemprop="name">Virtio</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/stage4/virtio-v1-2/Virtio/%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">补完计划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>解析`WebGPU`、`Virtio1.2`规范，以及`WGPU`、`Vortex`源码，探索异步操作系统与内核态GPU资源管理的结合方案。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/06/20/Lfan-ke%EF%BC%9AGPGPU%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/20/2025-oscamp-blog-of-hailong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/20/2025-oscamp-blog-of-hailong/" class="post-title-link" itemprop="url">2025 oscamp blog of hailong</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-20 12:43:27" itemprop="dateCreated datePublished" datetime="2025-06-20T12:43:27+00:00">2025-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一阶段-rust基础"><a href="#第一阶段-rust基础" class="headerlink" title="第一阶段 rust基础"></a>第一阶段 rust基础</h2><p>rustlings比较顺利，已关注rust好几年了，也一直跟进rust的发展和变化，用了大概几天的时间突击完成</p>
<h2 id="第二阶段-rcore"><a href="#第二阶段-rcore" class="headerlink" title="第二阶段 rcore"></a>第二阶段 rcore</h2><p>这是我第一次接触操作系统，印象还都停留在原来的书本上，概念上，都是理论，没有真正接触操作系统是什么样的，所以，这个机会能让我了解探究操作系统内部真正的原理和运行逻辑，解开我心中的多年的疑惑，很是开心到起飞。</p>
<p>总体印象最深的就是操作系统内核是以什么形态存在的，上下文如何切换，进程空间如何形成，页表是如何实现的，跳板页又是怎么回事</p>
<h2 id="第三阶段-ArceOS"><a href="#第三阶段-ArceOS" class="headerlink" title="第三阶段 ArceOS"></a>第三阶段 ArceOS</h2><p>这个和我预期不一样，没有沿着rcore继续走，这是一个全新的设计，一时间，有点慌乱，不能和rcore相关的思路很自然的顺承下来，显然这个更具有前瞻性，为此我也花了好多时间来梳理这个逻辑和rcore都关联起来。这个模块化设计的理念很突出，相互之间的关联及细节，需要仔细的研读和体会。</p>
<h2 id="第三阶段的具体case"><a href="#第三阶段的具体case" class="headerlink" title="第三阶段的具体case"></a>第三阶段的具体case</h2><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>对println!() 把颜色表示直接加入后，可以显示颜色，<br>如在当前文件写了一个宏print_with_color!，让后让println!去去调用此宏，就得不到正确结果，提示找不到这个宏，查了资料，和 $crate有关，宏的暴露方式有关，引用路径，由于时间关系，后面调研</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>开始的时候，从rust官方移植，这个太痛苦了，依赖太多了，最后放弃。<br>自己写个简单的，只是利用了官方的<br>use core::hash::Hasher;<br>use core::hash::Hash;<br>这两个hash算法，主体采用了最简单的线性插入算法</p>
<h3 id="bumpallocator"><a href="#bumpallocator" class="headerlink" title="bumpallocator"></a>bumpallocator</h3><p>需要仔细理解题意和上下文，思路选用：<br>申请一直从可用空间起始向前申请，<br>释放如果全部的空间都释放了，就把下一个可用空间调整到开始</p>
<h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><p>采用递归的方式，一层一层的先找到所在当前目录<br>增加当前目录的，更改命名的方法，查找相应的文件，删除后，再插入一个，因为当前存储使用的是BtreeMap，不能更改index</p>
<h3 id="hv"><a href="#hv" class="headerlink" title="hv"></a>hv</h3><p>这个耗费了我好多时间，主要是因为运行例程会卡住，后来发现可能是qemu的版本问题，升级到9.2后，还是一样卡住，当时环境为windows11，wsl2，卡在这里，不同的情况卡的还不一样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write file <span class="string">'payload/skernel2/skernel2'</span> into disk.img</span><br></pre></td></tr></table></figure>
<p>最后没有办法，找一台空闲机器，实在不行，我就安装裸机linux系统，所以先尝试装了另一种虚拟机，virtualbox7.18，也花了些时间，配置好环境后，默认的qemu为6.x时，还是会出错，不过不是卡主的问题，是会触发异常访问，升级到9.2.x后，按照预期执行了，难道说，wsl2在某些情况就是不行，我真是难过。</p>
<p>之后遇到提交github，出错，musl.cc被block，</p>
<blockquote>
<p>下载不下来：<br>    wget <a href="https://musl.cc/riscv64-linux-musl-cross.tgz" target="_blank" rel="noopener">https://musl.cc/riscv64-linux-musl-cross.tgz</a>  </p>
</blockquote>
<p>下载不下来，终于等来了替代方案</p>
<blockquote>
<p>   wget <a href="https://musl.cc.timfish.dev/riscv64-linux-musl-cross.tgz" target="_blank" rel="noopener">https://musl.cc.timfish.dev/riscv64-linux-musl-cross.tgz</a><br>最后，终于得以解决</p>
</blockquote>
<h3 id="sys-mmap"><a href="#sys-mmap" class="headerlink" title="sys_mmap"></a>sys_mmap</h3><p>参数和返回值我理解出现偏差，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sys_mmap</span></span>(</span><br><span class="line">    addr: *<span class="keyword">mut</span> <span class="built_in">usize</span>,</span><br><span class="line">    length: <span class="built_in">usize</span>,</span><br><span class="line">    prot: <span class="built_in">i32</span>,</span><br><span class="line">    flags: <span class="built_in">i32</span>,</span><br><span class="line">    fd: <span class="built_in">i32</span>,</span><br><span class="line">    _offset: <span class="built_in">isize</span>,</span><br><span class="line">) -&gt; <span class="built_in">isize</span></span><br></pre></td></tr></table></figure>
<p>参数addr为0时要特别注意，需要寻找一空间，还有地址和size的对齐。返回值，当开始时认为0是成功，为负时，返回失败原因，后来再三确认失败返回0，成功返回地址，isize作为地址返回，有点不符合直觉？</p>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>期待第四阶段</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/19/2025spring-rust-based-os-comp-stage4-report-loichyan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/19/2025spring-rust-based-os-comp-stage4-report-loichyan/" class="post-title-link" itemprop="url">2025春夏季开源操作系统训练营第四阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-19 11:12:13" itemprop="dateCreated datePublished" datetime="2025-06-19T11:12:13+00:00">2025-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前三阶段总结"><a href="#前三阶段总结" class="headerlink" title="前三阶段总结"></a>前三阶段总结</h2><ul>
<li><a href="./2025spring-rust-based-os-comp-stage2-report-loichyan.md">前两阶段总结</a></li>
<li><a href="./2025spring-rust-based-os-comp-stage3-report-loichyan.md">第三阶段总结</a></li>
</ul>
<h2 id="主要收获"><a href="#主要收获" class="headerlink" title="主要收获"></a>主要收获</h2><p>在第四阶段中，更多的时间留给了自由探索．虽然起初缺少具体的目标有些令人摸不着头脑，不过跟随老师的引导，也一步步确立了整个阶段的目标：基于 uring<a href="https://en.wikipedia.org/wiki/Io_uring" target="_blank" rel="noopener">^1</a> 机制实现异步系统调用．尽管最后只实现了基于 uring 的异步 IPC 机制，一路上走来也有许多收获．</p>
<h3 id="Rust-的异步机制"><a href="#Rust-的异步机制" class="headerlink" title="Rust 的异步机制"></a>Rust 的异步机制</h3><p>虽然有一些 Rust 异步编程经验，但尚未从更底层的角度了解过 Rust 的异步模型．在第一周中，通过动手实现一个简易的异步运行时 <a href="https://github.com/loichyan/openoscamp-2025s/tree/cffb2c29bc7eb522de66337093caf4255c9f7bca/local-executor" target="_blank" rel="noopener">local-executor</a>，认识到 Rust 的异步原语 <code>Future</code> 是如何与运行时交互的．以及深入到内存安全层面上，了解了 Rust 中如何通过 <a href="https://doc.rust-lang.org/core/pin/index.html" target="_blank" rel="noopener"><code>pin</code></a> 语义来巧妙的保证自引用结构体的安全性．尽管这并不是一个完美的模型——几乎所有涉及到 <code>pin</code> 语义的数据结构和函数都需要 <code>unsafe</code> 代码，而这些 <code>unsafe</code> 代码所需的诸多安全性保证又着实有些令人头大．因为，Rust 提供了静态安全性，而编译器会基于这些安全保证进行比较“激进”的优化．所以，Rust 中的 <code>unsafe</code> 要比其他生来便“不安全”的语言更加不安全，对开发者的要求也更高．</p>
<p>在第三周的探索中，又了解到一个之前从未考虑过的问题——<code>Future</code> 的终止安全性<a href="https://github.com/loichyan/openoscamp-2025s/discussions/6" target="_blank" rel="noopener">^2</a>．而这对于实现基于共享内存的异步通信机制来说尤其关键，稍有不慎就会引发难以察觉的漏洞．在后来着手实现异步通信机制的时候，又对这个问题进行了更深入的思考，并在现有方案的基础上提出了<a href="https://github.com/loichyan/openoscamp-2025s/blob/cffb2c29bc7eb522de66337093caf4255c9f7bca/evering/src/resource.md" target="_blank" rel="noopener">另外几个可行的思路</a>．</p>
<h3 id="原子类型和内存排序"><a href="#原子类型和内存排序" class="headerlink" title="原子类型和内存排序"></a>原子类型和内存排序</h3><p>尽管曾了解过原子类型和内存排序相关的知识，但从未真正彻底搞懂过，直到在第二周的探索中发现了一本优秀的电子书 <em>Rust Atomics and Locks</em><a href="https://marabos.nl/atomics/" target="_blank" rel="noopener">^3</a>．这本书从抽象的并发模型深入到具体的硬件细节，比较全面的介绍了几种原子操作和内存排序的设计初衷以及对应的汇编层面实现．结合这本书和自己的思考，又经过悉心整理最终形成了一篇比较详实的<a href="https://github.com/loichyan/openoscamp-2025s/discussions/7" target="_blank" rel="noopener">学习笔记</a>．尽管在实践时还不能完全掌握各种内存排序的选择，通过翻看笔记以及参考相似场景下现有项目的做法，也都能找到一个安全正确的选项．</p>
<h3 id="基于-uring-的异步通信"><a href="#基于-uring-的异步通信" class="headerlink" title="基于 uring 的异步通信"></a>基于 uring 的异步通信</h3><p>经过两周的调查和学习，最终在第三周完成了基于 uring 的异步通信框架 <a href="https://github.com/loichyan/openoscamp-2025s/blob/cffb2c29bc7eb522de66337093caf4255c9f7bca/evering/src/lib.md" target="_blank" rel="noopener">evering</a>，同时利用 GitHub Pages 部署了它详细的<a href="https://loichyan.github.io/openoscamp-2025s/evering" target="_blank" rel="noopener">设计文档</a>．</p>
<p>evering 最重要的两个数据结构是用来管理消息队列的 <code>Uring</code> 和用来管理操作生命周期的 <code>Driver</code>．<code>Uring</code> 的实现借鉴了 io_uring 的做法<a href="https://kernel.dk/io_uring.pdf" target="_blank" rel="noopener">^4</a>，但结合 Rust 的特性做了一些简化．比如，io_uring 支持 <code>IOSQE_IO_LINK</code> 来要求响应侧顺序处理请求．而在 Rust 中，每个异步请求都被封装为 <code>Future</code>，故可以利用 <code>.await</code> 来在请求侧实现顺序请求．<code>Driver</code> 的实现则借鉴了 <a href="https://github.com/tokio-rs/tokio-uring" target="_blank" rel="noopener">tokio-uring</a> 和 <a href="https://github.com/ringbahn/ringbahn" target="_blank" rel="noopener">ringbahn</a>．但相比后两者，evering 提供了更灵活、通用的异步操作管理机制．</p>
<p>不过，目前 evering 相对简陋，仅支持 SPSC，因此请求侧或响应侧只能在单线程上使用．也许未来可以实现 MPSC 的队列，以便于更好的与现有的异步生态（比如 <code>tokio</code>）兼容．</p>
<h3 id="基于-evering-的异步-IPC"><a href="#基于-evering-的异步-IPC" class="headerlink" title="基于 evering 的异步 IPC"></a>基于 evering 的异步 IPC</h3><p>经过三周的铺垫，第四周正式开始实践跨进程的异步通信．在第三周中，基于 evering 实现了简易的跨线程异步通信 <a href="https://github.com/loichyan/openoscamp-2025s/tree/cffb2c29bc7eb522de66337093caf4255c9f7bca/examples/evering-threaded" target="_blank" rel="noopener">evering-threaded</a>，而对跨进程来说，主要的难点就是内存的共享．好在 Linux 提供了易于使用的共享内存接口，基于 <a href="https://man7.org/linux/man-pages/man3/shm_open.3.html" target="_blank" rel="noopener">shm_open(3)</a>，<a href="https://man7.org/linux/man-pages/man2/memfd_create.2.html" target="_blank" rel="noopener">memfd_create(2)</a> 和 <a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener">mmap(2)</a> 可以轻松在不同进程之间建立共享内存区．而 <a href="https://man7.org/linux/man-pages/man3/ftruncate.3p.html" target="_blank" rel="noopener">ftruncate(3p)</a> 配合缺页延迟加载机制，使得程序启动后仅需一次初始化就能配置好可用的共享内存区间．不过，目前 evering 只能做到基础的“对拍式”的通信方式．而近期字节跳动开源的 <a href="https://github.com/cloudwego/shmipc-rs" target="_blank" rel="noopener">shmipc</a> 则是一个相对成熟、全面的异步通信框架，这对未来 evering 的改进提供了方向．</p>
<h3 id="基于-evering-的异步系统调用"><a href="#基于-evering-的异步系统调用" class="headerlink" title="基于 evering 的异步系统调用"></a>基于 evering 的异步系统调用</h3><p>由于时间相对仓促，加之备研要占用大量的时间，遗憾的是，在第四阶段并没有完成最初的目标——实现基于 uring 的异步系统调用．与 <code>用户线程 &lt;-&gt; 用户线程</code> 的通信相比，<code>用户线程 &lt;-&gt; 内核线程</code> 的通信要额外处理内核任务的调度和用户进程的生命周期管理．即如何处理多个不同用户进程的请求，以及用户进程意外退出后对应内核任务的清理．而就共享内存而言，由于用户对内核单向透明，这看起来似乎比 IPC 的共享内存更容易解决．</p>
<h3 id="用户态线程与协程的调度"><a href="#用户态线程与协程的调度" class="headerlink" title="用户态线程与协程的调度"></a>用户态线程与协程的调度</h3><p>去年的夏令营中，<a href="https://github.com/KMSorSMS/embassy_preempt" target="_blank" rel="noopener">embassy-preempt</a> 实现了内核中线程和协程的混合调度．那么用户态的协程能否被内核混合调度呢？在实现异步系统调用的前提下，当用户态线程由于内核尚未完成调用处理而让权（通过 <a href="https://man7.org/linux/man-pages/man2/sched_yield.2.html" target="_blank" rel="noopener">sched_yield(2)</a> 等系统调用）时，实际上，内核可以获知该线程应何时被唤醒．这就与 Rust 协程中的 <code>Waker</code> 机制非常相似，而用户态的让权又与 <code>.await</code> 很类似．基于这些，那么可以将一个实现异步系统调用的用户线程转换为一个用户协程．此后，内核就充当了这个协程的运行时和调度器的角色．</p>
<p>而相比用户态的线程，使用协程的一个显著优点是，对用户任务的唤醒实际上相当于执行一次 <code>Future::poll</code>．这意味着，当用户主动让权时，它不需要保存任何上下文——用户任务的唤醒本质上变成了函数调用，而主动让权表示该函数的返回．如此便能够进一步减少用户和内核切换的开销，以及系统中所需执行栈的数量．当然，当用户协程被抢占时，它便回退成了类似线程的有独立执行栈和上下文的存在．</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过近两个月的学习，对操作系统和异步编程的许多方面都有了一些相对清晰的认知．非常感谢夏令营中各位老师的付出和历届同学的努力，学习的过程中让我切身的感受到操作系统发展到现在那段波澜壮阔的历史，以及在不断推陈出新的技术潮流中一点微不足道的参与感．尽管最后没能完成目标有些遗憾，不过，这也为将来再次参加夏令营留下了充足的理由 :P</p>
<!-- dprint-ignore-start -->

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/18/2025s-os-camp-4-summary-noah/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/18/2025s-os-camp-4-summary-noah/" class="post-title-link" itemprop="url">2025年春夏开源操作系统训练营四阶段总结-noah-低侵入式的异步协程运行时</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-18 23:59:00" itemprop="dateCreated datePublished" datetime="2025-06-18T23:59:00+00:00">2025-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>非常高兴能参加到开源操作系统训练营第四阶段的学习，跟大家一起进步。经历完这四个阶段，自己有非常大的收获，让我理解了操作系统内部的运行机制，通过组件化的管理来实现更现代化的操作系统，最终在操作系统中支持异步机制提高操作系统的性能。</p>
<p>在每周的学习过程中，非常感谢<a href="https://space.bilibili.com/507884048" target="_blank" rel="noopener">向勇老师</a>给与了很多的指导和鼓励，成为了我前进的支柱。同时也要感谢<a href="https://github.com/zjp-CN" target="_blank" rel="noopener">周积萍</a>学长给与了很多帮助和支持以及建设性的意见，让我遇到困难时不迷茫。在第四阶段的过程中，也从其他同学那学到了很多，能便捷的获取到学习资料和代码，当有疑惑了也有人能够理解你，跟你一起深入到技术中进行讨论，那种感觉真是舒服。</p>
<h2 id="每周工作"><a href="#每周工作" class="headerlink" title="每周工作"></a>每周工作</h2><p>对于一个程序员来说，时间总是不够的，在四周时间里，我主要做了以下几个方面的工作：</p>
<p><strong>第一周 - 回顾</strong></p>
<p>当我第一周(2025-06-01)加入训练营的时候，发现去年的学长大佬们已经早早的开始了自己的课题。我就从基础慢慢开始，这周主要是把文档中的例会视频都看了一遍，基本了解了协程异步的作用以及目前是如何把异步应用到操作系统内核当中去的。</p>
<p><strong>第二周 - 定目标</strong></p>
<p>在看例会视频的时候，我发现有学长讨论 rust 异步的函数着色问题，碰巧我之前在写 rust 的时候也遇到了这个问题，很多时候一套逻辑代码，要分别实现一个同步版本一个异步版本，从一些学长的代码中看确实是分开写的，比如<a href="https://github.com/AsyncModules/async-os/tree/main/modules" target="_blank" rel="noopener">赵方亮学长的仓库</a>，在 2025-06-07 例会讨论中，有同学在参加 “大学生操作系统大赛” 的时候也遇到了此问题，最近在学习 zig 这门语言，说是能解决这个问题，我便想借着这个机会深入研究下。也是对于函数着色问题的一些自己的尝试，于是便确立了如下目标：</p>
<ul>
<li>长期目标：实现低侵入式的异步协程框架，服务于操作系统内核</li>
<li>本期目标：实现简单的异步协程运行时 (zig)</li>
</ul>
<p>后续在调研的过程中，发现 rust 的异步机制，是基于 Future 来实现的，这是一种无栈协程，跟我之前理解的 Go 语言的那种有栈协程还不一样。</p>
<p><strong>第三周 - 学习和实验</strong></p>
<p>后续的两个周，主要是学习文档中的异步协程资料，编写实验代码，验证自己的想法。</p>
<ul>
<li><p>学习内容</p>
<ul>
<li><a href="https://www.less-bug.com/posts/c-implement-a-mini-stackless-coroutine-framework-minico/" target="_blank" rel="noopener">C：实现一个迷你无栈协程框架——Minico</a> - 理解什么是无栈协程</li>
<li><a href="https://blog.aloni.org/posts/a-stack-less-rust-coroutine-100-loc/" target="_blank" rel="noopener">stack-less rust coroutine 100-loc</a> - 理解 rust 无栈协程</li>
<li><a href="https://course.rs/advance/async/future-excuting.html" target="_blank" rel="noopener">Rust 圣经 - 手写 Future Runtime</a> - 理解 Waker 机制</li>
<li><a href="https://web.archive.org/web/20220527113808/https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/supporting-windows" target="_blank" rel="noopener">200 行代码绿色线程</a> - 如何从零实现协程(绿色线程)</li>
</ul>
</li>
<li><p>实验部分</p>
<p>  基于上面的学习的内容，进行了如下实验来验证想法：</p>
<ul>
<li>实现在 zig 中调用 rust 封装的绿色线程任务</li>
<li>实现基于 Future 的异步运行时 (用 zig 语言)</li>
<li>用 asm + zig 实现有栈协程切换机制</li>
</ul>
</li>
</ul>
<p><strong>第四周 - 代码结合</strong></p>
<ul>
<li>异步协程运行时 xasync 框架代码编写<ul>
<li>基本完成跑通简单测例</li>
<li>同时初步解决了函数着色问题</li>
</ul>
</li>
</ul>
<p>完成上述四周的工作后，基本实现我在开源操作系统训练营本阶段的目标，符合预期。</p>
<h2 id="xasync-异步协程运行时"><a href="#xasync-异步协程运行时" class="headerlink" title="xasync 异步协程运行时"></a>xasync 异步协程运行时</h2><h3 id="使用者角度"><a href="#使用者角度" class="headerlink" title="使用者角度"></a>使用者角度</h3><p>我在设计 xasync 异步协程的时候，借鉴了 <a href="https://kristoff.it/blog/zig-colorblind-async-await/" target="_blank" rel="noopener">zig 协程</a> 的设计思路，感觉 zig 协程更容易让使用者理解和减轻负担，那么从使用者的角度出发，什么样的协程用起来才是最舒服的，我认为尽量保持一套代码，只通过一些简单的标记就可以实现同步和异步的切换，是更加友好的协程框架实现方式。下面是我理解的伪代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var is_async &#x3D; true &#x2F;&#x2F; 如果关闭后，底层会走阻塞逻辑</span><br><span class="line"></span><br><span class="line">fn read(file) &#123;</span><br><span class="line">    if (is_async) &#123;</span><br><span class="line">        scheudle(future:run(sys_read(file))) &#x2F;&#x2F; 生成 future，交给 executor 和 eventloop 调度处理</span><br><span class="line">        suspend()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sys_read(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn long_time_action() &#123;</span><br><span class="line">    read(&quot;large file&quot;)</span><br><span class="line">    sleep(100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn other_action() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let frame &#x3D; xasync(long_time_action) &#x2F;&#x2F; 使用者也可以用 xasync 来标记上层代码是异步的</span><br><span class="line">    &#x2F;&#x2F; xawait(frame) &#x2F;&#x2F; 需要等待的时候才等待</span><br><span class="line">    </span><br><span class="line">    other_action()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的注释，可以仔细看下调用流程，这是我个人期望的协程框架使用方式的理解。</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="https://github.com/osxspace/qhos/blob/main/output/asyncos/xasync.png?raw=true" alt="总体设计图"></p>
<p>上面是架构设计图，分为前后两部分把 <code>有栈协程</code> 和 <code>无栈协程</code> 结合起来，其中<code>红线理解为前进</code> <code>蓝线理解为返回</code>，比方说协程切换的前进返回、Future poll 前进和状态返回、协程调度的前进和唤醒的返回等。</p>
<p>目前图中描述的是有三个协程(绿色线程)在需要的场景下不断让出执行权，在异步任务结束后能随时切换到具体的任务上继续执行。这种机制在需要等待返回结果的情况下尤为重要。后续会优化成协程池方便使用。</p>
<p>下面从测例的角度简单剖析下实现代码和原理。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><strong>测例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const Counter &#x3D; struct &#123;</span><br><span class="line">    const Self &#x3D; @This();</span><br><span class="line">    num: u32,</span><br><span class="line">    max: u32,</span><br><span class="line"></span><br><span class="line">    fn init(num: u32, max: u32) Self &#123;</span><br><span class="line">        return .&#123;</span><br><span class="line">            .num &#x3D; num,</span><br><span class="line">            .max &#x3D; max,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn doCount(ctx: *Context) Result &#123;</span><br><span class="line">        const counter &#x3D; @as(*Counter, @ptrCast(@alignCast(ctx.payload)));</span><br><span class="line">        if (counter.num &lt; counter.max) &#123;</span><br><span class="line">            std.debug.print(&quot;counter num &#x3D; &#123;&#125;\n&quot;, .&#123;counter.num&#125;);</span><br><span class="line">            counter.num +&#x3D; 1;</span><br><span class="line">            return .wait;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return .&#123; .done &#x3D; &amp;counter.num &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn doNextCount(result: ?*anyopaque, ctx: *Context) *Future &#123;</span><br><span class="line">        var counter &#x3D; @as(*Counter, @ptrCast(@alignCast(ctx.payload)));</span><br><span class="line"></span><br><span class="line">        const num &#x3D; @as(*u32, @ptrCast(@alignCast(result)));</span><br><span class="line">        const value &#x3D; num.*;</span><br><span class="line"></span><br><span class="line">        counter.num &#x3D; 0;</span><br><span class="line">        counter.max &#x3D; value + 5;</span><br><span class="line"></span><br><span class="line">        return run(Counter.doCount, counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test &quot;counter-chain-done&quot; &#123;</span><br><span class="line">    const allocator &#x3D; std.testing.allocator;</span><br><span class="line"></span><br><span class="line">    var executor &#x3D; Executor.init(allocator);</span><br><span class="line">    defer executor.deinit();</span><br><span class="line"></span><br><span class="line">    var counter &#x3D; Counter.init(0, 5);</span><br><span class="line">    const fut &#x3D; runWithAllocator(allocator, Counter.doCount, &amp;counter).chain(Counter.printNum); &#x2F;&#x2F; 这里支持链式调用</span><br><span class="line"></span><br><span class="line">    executor.schedule(fut);</span><br><span class="line"></span><br><span class="line">    executor.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是把一个 Counter 计数器，改成了异步机制，当 num &gt; max 的时候才会终止运行。在实现的时候利用 zig uinon(enum) 的特性，尽量做到了零成本抽象。</p>
<p><strong>支持组合</strong></p>
<p>还支持了 Then 组合操作，因为在封装 Future 代码的时候可能要把原有的阻塞代码拆成多个 Future 逐步执行。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test &quot;counter-chain-counter&quot; &#123;</span><br><span class="line">    const allocator &#x3D; std.testing.allocator;</span><br><span class="line"></span><br><span class="line">    var executor &#x3D; Executor.init(allocator);</span><br><span class="line">    defer executor.deinit();</span><br><span class="line"></span><br><span class="line">    var counter &#x3D; Counter.init(0, 5);</span><br><span class="line">    const fut &#x3D; runWithAllocator(allocator, Counter.doCount, &amp;counter).chain(Counter.doNextCount); &#x2F;&#x2F; 这里支持链式调用</span><br><span class="line"></span><br><span class="line">    executor.schedule(fut);</span><br><span class="line"></span><br><span class="line">    executor.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续还会在 Future 上进行扩展支持 Join 等更多组合操作。</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor 中有两个队列：</p>
<ul>
<li>ready_queue: std.ArrayList(*Future) - 调度队列，供调用者放入 Future 任务</li>
<li>futs: std.ArrayList(*Future) - 执行队列，实际调度器处理的 Future 任务</li>
</ul>
<p>Future 先是进入到调度队列，如果调度开始执行后，会从调度队列取出任务放入执行队列，这时候执行队列中可能还有其他未完成的任务，当 Future 结束后会从执行队列中移除，如果执行队列中的所有任务都是等待状态，则 Executor 处于 idle 状态，等待 event_loop 唤醒，具体使用方式在上面的测例代码中已体现。</p>
<p>目前调度策略比较简单，而且没有经过任何优化，后续会不断完善。</p>
<h3 id="Coroutine-绿色线程"><a href="#Coroutine-绿色线程" class="headerlink" title="Coroutine(绿色线程)"></a>Coroutine(绿色线程)</h3><p>目前已经支持协程间的切换，下面的代码是非对称协程的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var base_coro: Coroutine &#x3D; undefined;</span><br><span class="line">var count_coro: Coroutine &#x3D; undefined;</span><br><span class="line">var count: i32 &#x3D; 1;</span><br><span class="line"></span><br><span class="line">fn addCount() void &#123;</span><br><span class="line">    count +&#x3D; 1;</span><br><span class="line">    base_coro.resumeFrom(&amp;count_coro);</span><br><span class="line">    count +&#x3D; 1;</span><br><span class="line">    base_coro.resumeFrom(&amp;count_coro);</span><br><span class="line">    count +&#x3D; 1;</span><br><span class="line">    base_coro.resumeFrom(&amp;count_coro);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &quot;simple counter suspend and resume coroutine&quot; &#123;</span><br><span class="line">    const allocator &#x3D; std.testing.allocator;</span><br><span class="line"></span><br><span class="line">    base_coro &#x3D; try Coroutine.init(allocator, null);</span><br><span class="line">    defer base_coro.deinit();</span><br><span class="line">    count_coro &#x3D; try Coroutine.init(allocator, addCount);</span><br><span class="line">    defer count_coro.deinit();</span><br><span class="line"></span><br><span class="line">    try std.testing.expect(1 &#x3D;&#x3D; count);</span><br><span class="line"></span><br><span class="line">    count_coro.resumeFrom(&amp;base_coro);</span><br><span class="line">    try std.testing.expect(2 &#x3D;&#x3D; count);</span><br><span class="line"></span><br><span class="line">    count_coro.resumeFrom(&amp;base_coro);</span><br><span class="line">    try std.testing.expect(3 &#x3D;&#x3D; count);</span><br><span class="line"></span><br><span class="line">    count_coro.resumeFrom(&amp;base_coro);</span><br><span class="line">    try std.testing.expect(4 &#x3D;&#x3D; count);</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;all finished\n&quot;, .&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个测试就是用协程的方式去执行 addCount 所在的 count_coro 协程，在 addCount 中也可以随时切换调用者协程 base_coro，执行原有逻辑。</p>
<p>还支持了函数参数的传递，在上下文切换的时候，不是两个函数的切换，是通过一个中间函数 <code>call</code>，它会根据汇编传过来的参数指针地址，转换成具体的 *Coroutine，再从其中拿出 func_ptr 和 args_ptr，就相当于中间层转发了一下。从下面的代码看目前参数类型都是定死的，有点牵强，目前够用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn call(coro_ptr_int: u64) void &#123;</span><br><span class="line">    const coro: *Coroutine &#x3D; @ptrFromInt(coro_ptr_int);</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;current coro address: 0x&#123;x&#125;\n&quot;, .&#123;@intFromPtr(coro)&#125;);</span><br><span class="line"></span><br><span class="line">    if (coro.frame.func_ptr !&#x3D; null) &#123;</span><br><span class="line">        if (coro.frame.args_ptr !&#x3D; null) &#123;</span><br><span class="line">            const func_ptr &#x3D; @as(*const fn (*const anyopaque) void, @ptrCast(coro.frame.func_ptr.?));</span><br><span class="line">            const args_ptr &#x3D; coro.frame.args_ptr.?;</span><br><span class="line">            func_ptr(args_ptr);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            const func_ptr &#x3D; @as(*const fn () void, @ptrCast(coro.frame.func_ptr.?));</span><br><span class="line">            func_ptr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std.debug.print(&quot;the func pointer is null\n&quot;, .&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h3><p>事件响应机制也就是 eventloop (reactor 模型)，其实是所有异步协程实现的底层支持，我甚至认为就算不用异步，只用事件机制和回调的方式也能做到高性能。这一部分在本期训练营并没有深入的去学习，目前只是实现了一个大概。如果这层封装好了，做成一层统一的抽象去处理 epoll、io_uring、iocp、kqueue 以及中断信号量等，也将会有很大的收获，给自己挖个坑，明年把这部分填上。</p>
<p>eventloop 的核心代码就是用一个循环，不停的调用系统需要等待的函数，等待系统给出响应，这里用的是 epoll_wait，这些系统提供的函数其实在操作系统里面都有自己的实现，一般性能都比较高，而且可以阻塞也可以非阻塞。当系统给出响应后，再触发回调去唤醒 Executor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pub fn poll(self: *Self, timeout_ms: i32) !usize &#123;</span><br><span class="line">    try self.events.resize(16); &#x2F;&#x2F; 预分配事件数组，先这么写</span><br><span class="line"></span><br><span class="line">    const n &#x3D; std.posix.epoll_wait(self.epfd, self.events.items, timeout_ms);</span><br><span class="line"></span><br><span class="line">    for (self.events.items[0..n]) |event| &#123;</span><br><span class="line">        const fd &#x3D; event.data.fd;</span><br><span class="line"></span><br><span class="line">        if (self.callbacks.get(fd)) |callback| &#123;</span><br><span class="line">            if (event.events &amp; std.posix.system.EPOLL.IN !&#x3D; 0) &#123;</span><br><span class="line">                var buf: [8]u8 &#x3D; undefined;</span><br><span class="line">                _ &#x3D; std.posix.read(fd, &amp;buf) catch &#123;&#125;; &#x2F;&#x2F; 这里目前只处理了 timer 的情况</span><br><span class="line"></span><br><span class="line">                if (callback.callback_fn) |func| &#123;</span><br><span class="line">                    func(callback.user_data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn run(self: *Self) !void &#123;</span><br><span class="line">        self.running &#x3D; true;</span><br><span class="line"></span><br><span class="line">        while (self.running) &#123;</span><br><span class="line">            _ &#x3D; try self.poll(100); &#x2F;&#x2F; 100ms 超时</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整体组合-xasync"><a href="#整体组合-xasync" class="headerlink" title="整体组合 xasync"></a>整体组合 xasync</h3><p>把上面各部分组合起来，看看能不能达到预期效果。</p>
<p><strong>Timer</strong></p>
<p>这部分注册一个 TimerHandle 到 event loop 当中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const Timer &#x3D; struct &#123;</span><br><span class="line">    const Self &#x3D; @This();</span><br><span class="line"></span><br><span class="line">    handle: TimerHandle,</span><br><span class="line">    completed: bool &#x3D; false,</span><br><span class="line">    waker: ?*const Waker &#x3D; null,</span><br><span class="line"></span><br><span class="line">    fn init(nanoseconds: u64) !Self &#123;</span><br><span class="line">        const handle &#x3D; try TimerHandle.init(&amp;global_event_loop, nanoseconds); &#x2F;&#x2F; 注册给 event_loop</span><br><span class="line">        return .&#123;</span><br><span class="line">            .handle &#x3D; handle,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn deinit(self: *Self) void &#123;</span><br><span class="line">        self.handle.deinit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn timerCompletedCallback(data: ?*anyopaque) void &#123; &#x2F;&#x2F; event_loop 回调</span><br><span class="line">        if (data) |ptr| &#123;</span><br><span class="line">            const timer: *Timer &#x3D; @ptrCast(@alignCast(ptr));</span><br><span class="line">            timer.completed &#x3D; true;</span><br><span class="line">            std.debug.print(&quot;timer callback completed!\n&quot;, .&#123;&#125;);</span><br><span class="line">            if (timer.waker) |waker| &#123;</span><br><span class="line">                waker.wake(); &#x2F;&#x2F; 唤醒</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; future poll</span><br><span class="line">    fn poll(ctx: *Context) Result &#123;</span><br><span class="line">        const timer: *Timer &#x3D; @ptrCast(@alignCast(ctx.payload));</span><br><span class="line">        if (timer.completed) &#123;</span><br><span class="line">            std.debug.print(&quot;poll timer is completed\n&quot;, .&#123;&#125;);</span><br><span class="line">            return .&#123; .done &#x3D; null &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timer.waker &#x3D; ctx.waker;</span><br><span class="line">            return .wait;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Sleep</strong></p>
<p>这部分把 Timer 包装成 Future</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">fn sleep(nanoseconds: u64) void &#123;</span><br><span class="line">    std.debug.print(&quot;sleep comes in\n&quot;, .&#123;&#125;);</span><br><span class="line">    if (!sys_is_block) &#123;</span><br><span class="line">        const timer_ptr &#x3D; global_runtime.allocator.create(Timer) catch unreachable;</span><br><span class="line">        timer_ptr.* &#x3D; Timer.init(nanoseconds) catch unreachable;</span><br><span class="line"></span><br><span class="line">        const callback &#x3D; EventCallback&#123;</span><br><span class="line">            .callback_fn &#x3D; Timer.timerCompletedCallback,</span><br><span class="line">            .user_data &#x3D; timer_ptr,</span><br><span class="line">        &#125;;</span><br><span class="line">        timer_ptr.handle.setCallback(callback) catch unreachable;</span><br><span class="line"></span><br><span class="line">        const timer_fut &#x3D; future.runWithAllocator(global_runtime.allocator, Timer.poll, timer_ptr).chain(struct &#123;</span><br><span class="line">            fn thenFn(_: ?*anyopaque, ctx: *Context) *Future &#123;</span><br><span class="line">                const timer &#x3D; @as(*Timer, @ptrCast(@alignCast(ctx.payload)));</span><br><span class="line">                ctx.allocator.destroy(timer);</span><br><span class="line">                return future.done(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.thenFn);</span><br><span class="line"></span><br><span class="line">        global_runtime.executor.schedule(timer_fut);</span><br><span class="line"></span><br><span class="line">        global_runtime.switchTaskToBase(); &#x2F;&#x2F; 类似 suspend - 这个地方实现还有点歧义</span><br><span class="line">        &#x2F;&#x2F; global_runtime.switchToExecutor(); &#x2F;&#x2F; 如果需要等待返回结果则需要切换到 executor 等待其 resume 回来</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std.Thread.sleep(nanoseconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn delay() void &#123;</span><br><span class="line">    std.debug.print(&quot;delay comes in\n&quot;, .&#123;&#125;);</span><br><span class="line">    sleep(5 * std.time.ns_per_s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main</strong></p>
<p>整合完毕后对于使用者来说，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xasync(delay);</span><br><span class="line">&#x2F;&#x2F; xawait(); &#x2F;&#x2F; 需要等待的时候开启</span><br><span class="line">std.debug.print(&quot;hello xasync\n&quot;, .&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><strong>不等待完成</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delay comes <span class="keyword">in</span></span><br><span class="line">sleep comes <span class="keyword">in</span></span><br><span class="line">hello xasync                - 注意这里，没有等待 timer 异步执行结束，而是直接返回</span><br><span class="line">timer callback completed!</span><br><span class="line">poll timer is completed     - 注意这里，timer 结束了</span><br><span class="line">main will quit</span><br><span class="line">event loop quit</span><br></pre></td></tr></table></figure>

<p><strong>等待完成</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delay comes <span class="keyword">in</span></span><br><span class="line">sleep comes <span class="keyword">in</span></span><br><span class="line">timer callback completed!</span><br><span class="line">poll timer is completed</span><br><span class="line">hello xasync                - 注意这里，虽然底层是异步协程执行，但是这里等待 timer 执行完毕才打印</span><br><span class="line">main will quit</span><br><span class="line">event loop quit</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从目前执行效果和 API 的调用方式看符合预期，基本达成了本期的目标：<code>实现简单的异步协程运行时 (zig)</code>，按照这种方式解决<code>函数着色问题</code>是有希望的。</p>
<p>虽然本期目标基本达成，但是中间学习的过程中还是有很多技术细节没有完全搞懂，有些学习资料没有完全看完，后续还要继续努力。</p>
<h2 id="后续规划"><a href="#后续规划" class="headerlink" title="后续规划"></a>后续规划</h2><ul>
<li>参数和返回值的类型支持且能自动推导</li>
<li>支持线程池 thread pool</li>
<li>eventloop 完善</li>
<li>是否后台调度支持用户配置 - 现在需要改代码来实现</li>
<li>支持 rust 调用</li>
<li>封装 asyncio</li>
<li>集成到 arceos/rcore 中</li>
<li>性能对比测试</li>
</ul>
<h2 id="答疑和思考"><a href="#答疑和思考" class="headerlink" title="答疑和思考"></a>答疑和思考</h2><p><strong>为什么要用 zig 写</strong></p>
<ul>
<li>没有任何原因，个人偏好，peace &amp; love.</li>
</ul>
<p><strong>实现代码在哪里</strong></p>
<ul>
<li><a href="https://github.com/osxspace/qhos/tree/main/output/xasync1" target="_blank" rel="noopener">xasync1</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/18/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A54%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/18/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A54%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/" class="post-title-link" itemprop="url">2025春夏开源操作系统训练营4阶段总结-明扬</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-18 22:33:44" itemprop="dateCreated datePublished" datetime="2025-06-18T22:33:44+00:00">2025-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中断驱动的协程异步网络-在ArceOS中实现"><a href="#中断驱动的协程异步网络-在ArceOS中实现" class="headerlink" title="中断驱动的协程异步网络 - 在ArceOS中实现"></a>中断驱动的协程异步网络 - 在ArceOS中实现</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>时间过的飞快，转眼间，训练营四阶段已经迎来尾声。<br>我由于去年已经参加过一届训练营，所以本次我提前一个月晋级到了四阶段，与向勇老师确定了我的课题方向：“中断驱动的协程异步网络”。<br>在后续周会的沟通中，向老师也给了我更具挑战性的目标：“在VisionFive2开发板上验证我的工作”。</p>
<h2 id="二、历程"><a href="#二、历程" class="headerlink" title="二、历程"></a>二、历程</h2><p>在四阶段，我主要完成了以下几个里程碑：</p>
<h3 id="Rust异步运行时"><a href="#Rust异步运行时" class="headerlink" title="Rust异步运行时"></a>Rust异步运行时</h3><p>因为我之前曾经在工作中编写过面向 WASM 平台的 Rust 异步运行时，所以第一个里程碑并没有花掉我太多时间。<br>为了给自己增加一些挑战，我还额外实现了常见的异步运行时辅助数据结构与函数，如：<code>mutex</code>，<code>spawn</code>, <code>block_on</code>, <code>join</code> 等。</p>
<h3 id="异步版本的网络操作"><a href="#异步版本的网络操作" class="headerlink" title="异步版本的网络操作"></a>异步版本的网络操作</h3><p>在完成 Rust 异步运行时后，我便开始着手实现异步版本的网络API。<br>我为所有网络操作中包含<code>block_on</code>的函数都编写了异步版本，并实现了网络操作的异步化。其中包括:</p>
<ul>
<li><code>socket.recv_async()</code></li>
<li><code>socket.send_async()</code></li>
<li><code>socket.accept_async()</code></li>
<li><code>socket.connect_async()</code></li>
</ul>
<h3 id="PLIC中断驱动的Future唤醒"><a href="#PLIC中断驱动的Future唤醒" class="headerlink" title="PLIC中断驱动的Future唤醒"></a>PLIC中断驱动的Future唤醒</h3><p>实现以上异步网络操作后，网络异步仍然是以Poll驱动的，而不是以真实的物理世界事件驱动的。<br>为了实现真正的异步网络，我需要实现一个中断驱动的Future唤醒机制。<br>在 RISC-V 架构中，PLIC 是中断控制器，可以用于实现中断驱动的Future唤醒机制。<br>我为 ArceOS 移植了 PLIC 驱动，并实现了 VirtIO-Net 设备的 PLIC 中断驱动的 Future 唤醒机制。</p>
<h3 id="将ArceOS移植到VisionFive2开发板"><a href="#将ArceOS移植到VisionFive2开发板" class="headerlink" title="将ArceOS移植到VisionFive2开发板"></a>将ArceOS移植到VisionFive2开发板</h3><p>在完成以上工作后，距离训练营结束仍然有一个半月的时间。这次组会中，向老师给了我一个更具挑战性的目标：将 ArceOS 移植到 VisionFive2 开发板，并在 VisionFive2 开发板上验证我的工作。我也就正式开始了移植工作。<br>开发板板载了 u-boot 和 OpenSBI v1.2，我可以直接从 u-boot 启动 ArceOS。<br>幸好我手中还有 jTag 调试器，向老师也给我提供了其他前辈同学的移植经验。<br>感谢萧络元同学的代码仓库，我很快便完成了 ArceOS 的移植。<br>VF2 开发版与常见 RISC-V 开发版有些许不同，例如：<br>    * S 态可用内存起点为 0x4000_0000 而不是 0x8000_0000<br>    * OpenSBI v1.2 支持 SBI v1.0 规范，但未实现 Console Extension。所以日志打印时需要使用 Legacy Console API。<br>以及 u-boot 启动与 Qemu 启动也有些差异，现代镜像打包时更多采用 itb 格式，同时将 dtb 打包进 itb 中。<br>总的来说，移植工作并不算太难，但是当系统无法加载又没有任何日志输出的时候，还是需要些裸机的调试手段，例如直接通过汇编调用串口打印，或者 sbi call 字符打印来确定程序执行到了哪里，是否进入内核代码。</p>
<h3 id="为VisionFile2启用中断驱动的异步网络"><a href="#为VisionFile2启用中断驱动的异步网络" class="headerlink" title="为VisionFile2启用中断驱动的异步网络"></a>为VisionFile2启用中断驱动的异步网络</h3><p>在完成 ArceOS 的移植后，我便开始着手为 VisionFive2 开发板编写网卡驱动，启用中断功能，复现我在 Qemu 中完成的功能。这是本次训练营中我遇到的最大挑战。<br>首先，启动真实的网卡设备异常复杂，需要按顺序依次启动不下10个时钟信号与复位信号。<br>然后，VF2 平台使用的网络设备为 dwmac-5.2，参考 Linux 内核中驱动实现时，其历史悠久，代码量庞大，支持功能多且复杂，兼容设备多，还需要兼容多个平台和历史版本，硬啃 Linux 内核驱动代码基本上不太现实。<br>在必要时候还需要配合 PHY 芯片的同步配置，与设备寄存器交互通过 MMIO 映射，而与 PHY 芯片交互则需要通过 MDIO 总线，Clause 22/45 协议。</p>
<p>同时还需要学习众多的 MMIO 寄存器偏移量，与每个 bit 对应的功能含义，了解 GMAC/DMA/MTL/PHY 相关寄存器。<br>也学习了 ring buffer 的实现，以及如何使用 ring buffer 实现网络数据收发。</p>
<p>最终我还是没能在 VF2 平台开启中断功能，根据与厂家工程师的交流，PHY 芯片中断引脚并未接入 PLIC 中断控制器，所以无法使用 PLIC 中断驱动网络功能。</p>
<p>遗憾未能亲眼见到自己的工作在真实硬件上运行，但是通过本阶段的学习，我还是学到了海量的知识。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过本次训练营，我弥补了我知识体系中的许多空白，包括：</p>
<ul>
<li>PLIC 中断控制器</li>
<li>网卡驱动</li>
<li>U-Boot 运作原理</li>
<li>真实硬件是如何运作的</li>
</ul>
<h2 id="四、致谢"><a href="#四、致谢" class="headerlink" title="四、致谢"></a>四、致谢</h2><p>感谢向勇、陈渝老师，以及所有帮助过我的老师和同学。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/16/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/16/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2025 春夏季开源操作系统训练营 学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-16 14:25:51" itemprop="dateCreated datePublished" datetime="2025-06-16T14:25:51+00:00">2025-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025-春夏季开源操作系统训练营-学习总结"><a href="#2025-春夏季开源操作系统训练营-学习总结" class="headerlink" title="2025 春夏季开源操作系统训练营 学习总结"></a>2025 春夏季开源操作系统训练营 学习总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实验环境</span><br><span class="line">Mac mini Apple M4</span><br><span class="line">MacOS 15.4.1</span><br><span class="line">&#x2F;&#x2F; 备注（在国外的同学可以忽略）</span><br><span class="line">在配置实验环境时，一定要更换Homebrew、rustup和Cargo的镜像源。</span><br></pre></td></tr></table></figure>

<h2 id="第一阶段：Rust编程"><a href="#第一阶段：Rust编程" class="headerlink" title="第一阶段：Rust编程"></a>第一阶段：Rust编程</h2><p>由于参与过 <a href="http://opencamp.cn/" target="_blank" rel="noopener">http://opencamp.cn/</a> 的其他 Rust 训练营，本阶段相当于是复习阶段。然而笔者对很多 Rust 语法还是理解的不够，需要通过更多实际项目来加深学习。</p>
<h2 id="第二阶段：OS设计实现"><a href="#第二阶段：OS设计实现" class="headerlink" title="第二阶段：OS设计实现"></a>第二阶段：OS设计实现</h2><p>本阶段主要参考指导书完成实验 <a href="https://learningos.cn/rCore-Tutorial-Guide-2025S/" target="_blank" rel="noopener">https://learningos.cn/rCore-Tutorial-Guide-2025S/</a> </p>
<h3 id="1-Apple-Silicon-相关问题"><a href="#1-Apple-Silicon-相关问题" class="headerlink" title="1. Apple Silicon 相关问题"></a>1. Apple Silicon 相关问题</h3><blockquote>
<p>在第零章，指导书如是说：<br>经初步测试，使用 M1 芯片的 macOS 也可以运行本实验的框架，即我们的实验对平台的要求不是很高。但我们仍建议同学配置 Ubuntu 环境，以避免未知的环境问题。</p>
</blockquote>
<p>笔者在实验中确实遇到了一些问题，但都并非无法解决，具体情况如下：</p>
<h4 id="1-1-安装-qemu-可能需要-sudo"><a href="#1-1-安装-qemu-可能需要-sudo" class="headerlink" title="1.1 安装 qemu (可能需要 sudo)"></a>1.1 安装 qemu (可能需要 sudo)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install qemu</span><br><span class="line">qemu-img --version</span><br></pre></td></tr></table></figure>
<p>如果显示<code>qemu-img version 9.2.3</code>则说明安装成功。</p>
<h4 id="1-2-载入rustsbi-qemu-bin时卡死"><a href="#1-2-载入rustsbi-qemu-bin时卡死" class="headerlink" title="1.2 载入rustsbi-qemu.bin时卡死"></a>1.2 载入rustsbi-qemu.bin时卡死</h4><p>@lurenjia1213 修复了该问题，需要 Clone 下面的项目，重新编译，然后拷贝生成的rustsbi-qemu.bin 并覆盖实验项目中的文件。<br><a href="https://github.com/lurenjia1213/rustsbi-qemu/tree/main" target="_blank" rel="noopener">https://github.com/lurenjia1213/rustsbi-qemu/tree/main</a></p>
<h4 id="1-3-qemu-模拟器无法正确退出"><a href="#1-3-qemu-模拟器无法正确退出" class="headerlink" title="1.3 qemu 模拟器无法正确退出"></a>1.3 qemu 模拟器无法正确退出</h4><p>在ch3中，qemu模拟器无法正确退出，需要拷贝ch2中的<code>./src/boards/qemu.rs</code>到ch3。通过对比ch2和ch3的区别来修复问题，从而可以学习正确退出模拟器的方法。</p>
<blockquote>
<p>ch4 通过同样的方法在 BASE=1 的测试中还是无法正确退出，需要以后解决。</p>
</blockquote>
<h4 id="1-4-MacOS-没有-timeout-指令导致测例无法通过"><a href="#1-4-MacOS-没有-timeout-指令导致测例无法通过" class="headerlink" title="1.4 MacOS 没有 timeout 指令导致测例无法通过"></a>1.4 MacOS 没有 timeout 指令导致测例无法通过</h4><p>安装 <code>coreutils</code>, 用 <code>gtimeout</code> 来替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install coreutils</span><br><span class="line">&#x2F;&#x2F; 需要将下面这条指令写到保存环境变量的那个文件中</span><br><span class="line">alias timeout&#x3D;gtimeout</span><br></pre></td></tr></table></figure>


<h3 id="2-学习心得"><a href="#2-学习心得" class="headerlink" title="2. 学习心得"></a>2. 学习心得</h3><p>由于没有系统学习过操作系统的理论知识，学的比较慢，需要参考指导书和学习资源中的视频才慢慢掌握。虽然操作系统相关的内容学的不够扎实，但是对于 rust 的语法慢慢熟悉了起来。抱着学习 rust 的心态还学习到了操作系统的底层运行，很有收获。</p>
<h2 id="第三阶段：项目基础阶段-组件化操作系统"><a href="#第三阶段：项目基础阶段-组件化操作系统" class="headerlink" title="第三阶段：项目基础阶段 - 组件化操作系统"></a>第三阶段：项目基础阶段 - 组件化操作系统</h2><ul>
<li>尽管是第一次接触操作系统，在完成第二阶段以后，第三阶段给笔者的感觉不是很陌生（至少知道大概都在干什么）</li>
<li>课程视频和课件也很详细的给出了任务和学习目标，但是第三阶段的项目相比第二阶段要大很多</li>
<li>有时候不知道要去哪里干什么，只能通过给出的题目反向查找相关的内容。</li>
</ul>
<h3 id="1-遇到的问题和解决思路"><a href="#1-遇到的问题和解决思路" class="headerlink" title="1.遇到的问题和解决思路"></a>1.遇到的问题和解决思路</h3><ul>
<li>在UniKernel部分， 笔者在 MacOS 下面完成了任务，到了宏内核的部分涉及到了交叉编译的部分，似乎 MacOS 变得复杂了起来。折腾了一段时间之后，还是在一台 Linux 服务器上用 docker 完成了后续的任务。</li>
<li>这是笔者第一次使用 docker，遇到不懂的就让 Chatgpt 来生成指令，但是还是遇到了很多问题：<ol>
<li>hub.docker.com 被墙，根本创建不了 Linux 容器， 后来找到 nvcr.io/nvidia/pytorch:25.05-py3 解决了问题： <a href="https://catalog.ngc.nvidia.com/orgs/nvidia/containers/pytorch" target="_blank" rel="noopener">https://catalog.ngc.nvidia.com/orgs/nvidia/containers/pytorch</a></li>
<li>以为 root 之后就万事大吉，但是在运行容器的时候要加上 <code>--privieged</code>， 不然 <code>mount</code> 指令无法正确的找到目录的位置</li>
<li>运行容器的时候千万不要加 -rm， 不然停止容器的时候就永远地消失了<h3 id="2-学习心得-1"><a href="#2-学习心得-1" class="headerlink" title="2. 学习心得"></a>2. 学习心得</h3>由于上述笔者遇到的问题，反反复复搭环境搭了 3 次， 对各种 Linux 指令，以及各种组件的作用有了更深的理解。相比第二阶段，第三阶段的练习难度反而有所下降，但是 ArceOS 本身的内容是相当多的，需要更加系统的学习。 希望能在第四阶段有所收获。</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/15/manchangfengxu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/15/manchangfengxu/" class="post-title-link" itemprop="url">manchangfengxu</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-15 13:31:42" itemprop="dateCreated datePublished" datetime="2025-06-15T13:31:42+00:00">2025-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rust基础的总结"><a href="#rust基础的总结" class="headerlink" title="rust基础的总结"></a>rust基础的总结</h1><h2 id="一-基本数据类型与所有权"><a href="#一-基本数据类型与所有权" class="headerlink" title="一.基本数据类型与所有权"></a>一.基本数据类型与所有权</h2><h3 id="所有权系统核心规则"><a href="#所有权系统核心规则" class="headerlink" title="所有权系统核心规则"></a>所有权系统核心规则</h3><ol>
<li><strong>移动语义(Move)</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);  <span class="comment">// 堆分配</span></span><br><span class="line"><span class="keyword">let</span> s2 = s1;                    <span class="comment">// 所有权转移</span></span><br><span class="line"><span class="comment">// println!("&#123;&#125;", s1);           // 错误！s1 已失效</span></span><br></pre></td></tr></table></figure></li>
<li><strong>借用规则</strong>：<ul>
<li>任意时刻：<strong>一个</strong>可变引用 <strong>或</strong> 多个不可变引用</li>
<li>引用必须始终有效（悬垂指针禁止）</li>
</ul>
</li>
<li><strong>生命周期标注</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Slice-类型"><a href="#Slice-类型" class="headerlink" title="Slice 类型"></a>Slice 类型</h3><ul>
<li><strong>无所有权引用</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">let</span> hello: &amp;<span class="built_in">str</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];    <span class="comment">// 字符串切片</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> slice: &amp;[<span class="built_in">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];  <span class="comment">// 数组切片</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二-Crate-与模块系统"><a href="#二-Crate-与模块系统" class="headerlink" title="二.Crate 与模块系统"></a>二.Crate 与模块系统</h2><h3 id="Crate-类型"><a href="#Crate-类型" class="headerlink" title="Crate 类型"></a>Crate 类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>文件扩展名</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>二进制 Crate</td>
<td><code>main.rs</code></td>
<td>可执行程序</td>
</tr>
<tr>
<td>库 Crate</td>
<td><code>lib.rs</code></td>
<td>可复用代码库</td>
</tr>
</tbody></table>
<h3 id="模块可见性规则"><a href="#模块可见性规则" class="headerlink" title="模块可见性规则"></a>模块可见性规则</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;          <span class="comment">// pub 使模块公有</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用绝对路径访问</span></span><br><span class="line">crate::front_of_house::hosting::add_to_waitlist();</span><br></pre></td></tr></table></figure>

<h3 id="使用外部-Crate"><a href="#使用外部-Crate" class="headerlink" title="使用外部 Crate"></a>使用外部 Crate</h3><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.toml</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">"0.8.5"</span>  <span class="comment"># 语义化版本</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num = rand::thread_rng().gen_range(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-Option-与错误处理"><a href="#三-Option-与错误处理" class="headerlink" title="三. Option 与错误处理"></a>三. Option 与错误处理</h2><h3 id="Option-枚举"><a href="#Option-枚举" class="headerlink" title="Option 枚举"></a>Option<T> 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全解包</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">"Value: &#123;&#125;"</span>, i),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Missing value"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Result-lt-T-E-gt-错误处理"><a href="#Result-lt-T-E-gt-错误处理" class="headerlink" title="Result&lt;T, E&gt; 错误处理"></a>Result&lt;T, E&gt; 错误处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误传播简写</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_config</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(<span class="string">"config.toml"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理最佳实践"><a href="#错误处理最佳实践" class="headerlink" title="错误处理最佳实践"></a>错误处理最佳实践</h3><ol>
<li>优先使用 <code>Result</code> 而非 panic</li>
<li>使用 <code>?</code> 操作符传播错误</li>
<li>自定义错误类型实现 <code>std::error::Error</code></li>
</ol>
<h2 id="四-Trait-与泛型"><a href="#四-Trait-与泛型" class="headerlink" title="四. Trait 与泛型"></a>四. Trait 与泛型</h2><h3 id="Trait-定义与实现"><a href="#Trait-定义与实现" class="headerlink" title="Trait 定义与实现"></a>Trait 定义与实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    headline: <span class="built_in">String</span>,</span><br><span class="line">    location: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) -&gt; &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trait-Bound-语法糖"><a href="#Trait-Bound-语法糖" class="headerlink" title="Trait Bound 语法糖"></a>Trait Bound 语法糖</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法等价</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Display + <span class="built_in">Clone</span>&gt;(item: &amp;T) &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;(<span class="keyword">impl</span> Display + <span class="built_in">Clone</span>)) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生命周期进阶"><a href="#生命周期进阶" class="headerlink" title="生命周期进阶"></a>生命周期进阶</h3><p><strong>生命周期标注必要性</strong>：</p>
<ol>
<li>结构体持有引用时必须显式标注生命周期，确保引用的有效性</li>
<li>方法实现中：<ul>
<li><code>&amp;self</code> 参数隐含 <code>&amp;&#39;a self</code> 生命周期</li>
<li>返回值关联结构体生命周期（通过生命周期消除规则第三项）</li>
</ul>
</li>
<li>遵循Rust生命周期消除三规则：<ul>
<li>每个输入引用自动获得独立生命周期</li>
<li>单个输入引用时所有输出引用与其生命周期对齐</li>
<li>方法签名中 <code>&amp;self</code> 使输出引用与结构体生命周期对齐</li>
</ul>
</li>
</ol>
<p><strong>错误</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangling_reference</span></span>() -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"temporary"</span>);</span><br><span class="line">    &amp;s[..]  <span class="comment">// 错误！返回局部变量引用</span></span><br><span class="line">&#125; <span class="comment">// s离开作用域被丢弃</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">announce_and_return</span></span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Attention: &#123;&#125;"</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-智能指针"><a href="#五-智能指针" class="headerlink" title="五. 智能指针"></a>五. 智能指针</h2><h3 id="常用智能指针对比"><a href="#常用智能指针对比" class="headerlink" title="常用智能指针对比"></a>常用智能指针对比</h3><table>
<thead>
<tr>
<th>类型</th>
<th>所有权</th>
<th>线程安全</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>Box&lt;T&gt;</code></td>
<td>单一</td>
<td>是</td>
<td>堆分配、递归类型</td>
</tr>
<tr>
<td><code>Rc&lt;T&gt;</code></td>
<td>共享</td>
<td>否</td>
<td>单线程引用计数</td>
</tr>
<tr>
<td><code>Arc&lt;T&gt;</code></td>
<td>共享</td>
<td>是</td>
<td>多线程引用计数</td>
</tr>
<tr>
<td><code>RefCell&lt;T&gt;</code></td>
<td>可变</td>
<td>否</td>
<td>运行时借用检查</td>
</tr>
</tbody></table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Box 用于递归类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rc 共享所有权</span></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">let</span> a = Rc::new(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> b = Rc::clone(&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefCell 运行时借用检查</span></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="number">42</span>);</span><br><span class="line">*c.borrow_mut() += <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="六-迭代器与闭包"><a href="#六-迭代器与闭包" class="headerlink" title="六.迭代器与闭包"></a>六.迭代器与闭包</h2><h3 id="闭包类型推断"><a href="#闭包类型推断" class="headerlink" title="闭包类型推断"></a>闭包类型推断</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add_one = |x| x + <span class="number">1</span>;         <span class="comment">// 类型自动推导</span></span><br><span class="line"><span class="keyword">let</span> print = || <span class="built_in">println!</span>(<span class="string">"hello"</span>); <span class="comment">// 无参闭包</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包捕获模式"><a href="#闭包捕获模式" class="headerlink" title="闭包捕获模式"></a>闭包捕获模式</h3><table>
<thead>
<tr>
<th>捕获方式</th>
<th>关键字</th>
<th>所有权</th>
</tr>
</thead>
<tbody><tr>
<td>不可变借用</td>
<td>`</td>
<td></td>
</tr>
<tr>
<td>可变借用</td>
<td>`</td>
<td>mut</td>
</tr>
<tr>
<td>值捕获</td>
<td><code>move</code></td>
<td>转移</td>
</tr>
</tbody></table>
<h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"><span class="keyword">let</span> sum: <span class="built_in">i32</span> = v.iter()</span><br><span class="line">    .map(|x| x * <span class="number">2</span>)        <span class="comment">// 加倍</span></span><br><span class="line">    .filter(|x| x % <span class="number">4</span> == <span class="number">0</span>) <span class="comment">// 过滤4的倍数</span></span><br><span class="line">    .sum();                 <span class="comment">// 求和</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    count: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-并发与异步编程"><a href="#七-并发与异步编程" class="headerlink" title="七.并发与异步编程"></a>七.并发与异步编程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"From spawned thread"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">handle.join().unwrap();</span><br></pre></td></tr></table></figure>

<h3 id="通道通信-mpsc"><a href="#通道通信-mpsc" class="headerlink" title="通道通信 (mpsc)"></a>通道通信 (mpsc)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx.send(<span class="string">"Message"</span>).unwrap();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Received: &#123;&#125;"</span>, rx.recv().unwrap());</span><br></pre></td></tr></table></figure>

<h3 id="共享状态-Mutex"><a href="#共享状态-Mutex" class="headerlink" title="共享状态 (Mutex)"></a>共享状态 (Mutex)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handles: <span class="built_in">Vec</span>&lt;_&gt; = (<span class="number">0</span>..<span class="number">10</span>).map(|_| &#123;</span><br><span class="line">    <span class="keyword">let</span> c = Arc::clone(&amp;counter);</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = c.lock().unwrap();</span><br><span class="line">        *num += <span class="number">1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).collect();</span><br></pre></td></tr></table></figure>

<h3 id="异步编程-async-await"><a href="#异步编程-async-await" class="headerlink" title="异步编程 (async/await)"></a>异步编程 (async/await)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_data</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">    reqwest::get(<span class="string">"https://api.example.com/data"</span>)</span><br><span class="line">        .<span class="keyword">await</span>?</span><br><span class="line">        .text()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> data = fetch_data().<span class="keyword">await</span>.unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Data: &#123;&#125;"</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八-常用集合类型"><a href="#八-常用集合类型" class="headerlink" title="八.常用集合类型"></a>八.常用集合类型</h2><h3 id="Vec-动态数组"><a href="#Vec-动态数组" class="headerlink" title="Vec 动态数组"></a>Vec<T> 动态数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::with_capacity(<span class="number">10</span>);</span><br><span class="line">v.extend([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全访问</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(val) = v.get(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second element: &#123;&#125;"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有权注意事项</span></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// v.push(4); // 编译错误！存在不可变引用时禁止修改</span></span><br></pre></td></tr></table></figure>

<h3 id="HashMap-lt-K-V-gt-哈希表"><a href="#HashMap-lt-K-V-gt-哈希表" class="headerlink" title="HashMap&lt;K, V&gt; 哈希表"></a>HashMap&lt;K, V&gt; 哈希表</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="string">"Blue"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry API 安全更新</span></span><br><span class="line">scores.entry(<span class="string">"Yellow"</span>).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="string">"Blue"</span>).and_modify(|e| *e += <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1 id="阶段二-os基础"><a href="#阶段二-os基础" class="headerlink" title="阶段二,os基础"></a>阶段二,os基础</h1><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><h3 id="与上下文-特权级有关的寄存器"><a href="#与上下文-特权级有关的寄存器" class="headerlink" title="与上下文, 特权级有关的寄存器"></a>与上下文, 特权级有关的寄存器</h3><ul>
<li>sstatus：包含了处理器的状态信息，包括特权级别和中断使能状态。恢复 sstatus 的值确保在返回用户态时，处理器的特权级别和中断状态与陷阱发生前一致。</li>
<li>sepc：保存了中断或异常发生时的程序计数器值。恢复 sepc 的值确保在返回用户态时，处理器能够从中断或异常发生的地方继续执行。</li>
<li>sscratch：保存了用户栈指针。在切换到用户态之前，将用户栈指针保存到 sscratch 寄存器中，以便在用户态下使用。</li>
<li>sret根据sstatus中的SPP位指示切换为用户态。（寄存器中的一个位，0,u_mode;1_,s_mode,s_mode）</li>
<li>scause: Trap原因/种类</li>
<li>stvec: trap_handle地址</li>
</ul>
<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><h3 id="SV39"><a href="#SV39" class="headerlink" title="SV39"></a>SV39</h3><ul>
<li>virtual page 39位, 38-12为虚拟页号</li>
<li>页表项PTE: Reserver: 10, PPN2: 26, PPN1: 9, PPN0: 9, RSW: 2, DAGUXWRV</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul>
<li>MMU地址转换</li>
<li>kernel address space最高位为 “跳板”, app ks, guard page</li>
<li>app address space, 最高位为跳板, TrapContext, UserStack, GP, Framed<h4 id="跳板意义"><a href="#跳板意义" class="headerlink" title="跳板意义:"></a>跳板意义:</h4>satp, 切换后,地址映射不同, 例如:上下文切换的restore, 在更改satp指令后, 保证下一条指令在不同的地址映射下能被正确寻址,保证指令的连续执行</li>
</ul>
<h3 id="TrapContext新增字段"><a href="#TrapContext新增字段" class="headerlink" title="TrapContext新增字段"></a>TrapContext新增字段</h3><p>在进行特权级转换时, 需要相应的sp以及satp的token</p>
<ul>
<li>pub kernel_satp: usize, 内核地址空间的 token</li>
<li>pub kernel_sp: usize, 当前应用在内核地址空间中的内核栈栈顶的虚拟地址</li>
<li>pub trap_handler: usize, 内核中 trap handler 入口点的虚拟地址</li>
</ul>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><ul>
<li>获得父进程的地址空间</li>
<li>sepc + 4</li>
<li>a0返回参数更改,父子进程不相同</li>
<li>维护父子进程关系</li>
<li>fd, 死锁检测等</li>
</ul>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ul>
<li><p>stride算法:</p>
<ul>
<li>为TCB加上schedule块(struct), 同时预留了pass设置的接口</li>
<li>为sys_set_priority加入了对priority的设置 </li>
<li>将TaskManager块改为了用binaryheap存储, 并为TCB分配了Ord特性,每次选取都会取stride最小的调度</li>
</ul>
</li>
<li><p>向前兼容</p>
<ul>
<li>重写mmap和munmap(用到了remove_area_with_start_vpn)</li>
<li>重写了sys_get_time,用到了translate_va</li>
</ul>
</li>
</ul>
<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统本质上是一堆块上的抽象, 在内存中有缓存块对其进行映射.</p>
<p>进程维护一个文件描述符表,可映射到对应的缓存块</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ],</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    modified: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供对应的接口调用</span></span><br></pre></td></tr></table></figure>

<h3 id="easy-fs磁盘布局"><a href="#easy-fs磁盘布局" class="headerlink" title="easy-fs磁盘布局"></a>easy-fs磁盘布局</h3><ul>
<li><p>超级块 (Super Block)，用于定位其他连续区域的位置，检查文件系统合法性。</p>
</li>
<li><p>索引节点位图，长度为若干个块。它记录了索引节点区域中有哪些索引节点已经被分配出去使用了。</p>
</li>
<li><p>索引节点区域，长度为若干个块。其中的每个块都存储了若干个索引节点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据块位图，长度为若干个块。它记录了后面的数据块区域中有哪些已经被分配出去使用了。</p>
</li>
<li><p>数据块区域，其中的每个被分配出去的块保存了文件或目录的具体内容。</p>
</li>
</ul>
<h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>在引入线程后, 调度机制本质上是在线程块上进行切换. 会区分主线程和子线程</p>
<ul>
<li>创建线程不需要要建立新的地址空间</li>
<li>能够访问到进程所拥有的代码段， 堆和其他数据段</li>
<li>专有的用户态栈</li>
</ul>
<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><ul>
<li>在ProcessControlBlockInner加入了对mutex和sem的死锁检查块(all[], ava[], need[])</li>
<li>检测前对相应资源的need[] + 1</li>
<li>实现is_safe检测函数, 对finish==false和need &lt;= work的块, 回收allocation和finish=true,对标记flag=true, 当finish没有任何改变, 即本次循环flag==false时退出loop, 利用闭包all,检测finish所有线程是否全是true</li>
<li>若为unsafe, 则回退need, 返回-0xdead</li>
<li>若为safe, 则在down和lock之前drop(process_inner),防止线程堵塞无法释放资源, 在down和lock之后同时更新检查块中的矩阵</li>
<li>为up和unlock加上检查块的更新</li>
</ul>
<h3 id="Mutex实现问题"><a href="#Mutex实现问题" class="headerlink" title="Mutex实现问题"></a>Mutex实现问题</h3><ul>
<li>Mutex1的lock里,会一直尝试获取锁, 具体逻辑为当无法获得锁时,直接阻塞,让出cpu,直到被唤醒, 再重新尝试获得锁, unlock中释放锁,并且唤醒一个线程去竞争这个锁.</li>
<li>Mutex的lock,在无法获得锁时,直接堵塞,在unlock时,只有等待队列为空才释放锁.<pre><code>- 这里的unlock本质是锁资源的转移, A不释放锁, 而是唤醒一个直接使用这个资源的B线程(它醒来后直接运行临界区后的代码)</code></pre></li>
</ul>
<h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><h2 id="一-组件化内核基础与-Unikernel-模式"><a href="#一-组件化内核基础与-Unikernel-模式" class="headerlink" title="一, 组件化内核基础与 Unikernel 模式"></a><strong>一, 组件化内核基础与 Unikernel 模式</strong></h2><h3 id="组件化内核介绍"><a href="#组件化内核介绍" class="headerlink" title="组件化内核介绍"></a>组件化内核介绍</h3><h4 id="Unikernel-模式"><a href="#Unikernel-模式" class="headerlink" title="Unikernel 模式"></a>Unikernel 模式</h4><ul>
<li><strong>特点</strong>：<ul>
<li>应用与内核合一：编译为一个 Image，共享同一特权级（内核态）和地址空间。</li>
<li>无用户态 / 内核态切换：简单高效，但安全性较低（应用可直接访问内核资源）。</li>
</ul>
</li>
</ul>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><table>
<thead>
<tr>
<th>组件名称</th>
<th>功能描述</th>
<th>在实验中的作用</th>
</tr>
</thead>
<tbody><tr>
<td>axhal</td>
<td>硬件抽象层，屏蔽不同架构差异（如 Riscv64/ARM）</td>
<td>初始化串口、内存等硬件，提供底层 IO 接口</td>
</tr>
<tr>
<td>axruntime</td>
<td>内核运行时环境，负责引导流程、内存初始化、任务调度框架</td>
<td>执行内核启动流程，调用应用层代码</td>
</tr>
<tr>
<td>axstd</td>
<td>内核态标准库，提供基础数据结构和工具函数（如 println!）</td>
<td>实现字符终端输出功能</td>
</tr>
<tr>
<td>arceos_api</td>
<td>内核公共接口，定义组件间通信协议</td>
<td>统一组件间调用规范</td>
</tr>
</tbody></table>
<h4 id="Unikernel-的启动链"><a href="#Unikernel-的启动链" class="headerlink" title="Unikernel 的启动链"></a>Unikernel 的启动链</h4><ul>
<li><strong>硬件启动</strong>：通过 OpenSBI（Riscv 固件）加载内核 Image 到内存。</li>
<li><strong>引导阶段（axhal）</strong>：<ul>
<li>初始化 CPU 寄存器、MMU 分页（早期恒等映射）。</li>
<li>建立内核栈，为 Rust 运行时做准备。</li>
</ul>
</li>
<li><strong>运行时阶段（axruntime）</strong>：<ul>
<li>初始化内存分配器、日志系统。</li>
<li>调用应用层 main 函数，执行具体功能。</li>
</ul>
</li>
</ul>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="1-主函数-src-main-rs"><a href="#1-主函数-src-main-rs" class="headerlink" title="1. 主函数 src/main.rs"></a>1. 主函数 src/main.rs</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(feature = <span class="meta-string">"axstd"</span>, no_main)]</span> <span class="comment">// 若启用 axstd，不使用标准库的 main 入口</span></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"axstd"</span>)]</span> <span class="comment">// 根据 feature 条件编译</span></span><br><span class="line"><span class="keyword">use</span> axstd::println; <span class="comment">// 使用 axstd 的打印函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg_attr(feature = <span class="meta-string">"axstd"</span>, no_mangle)]</span> <span class="comment">// 避免符号名被修改</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, ArceOS!"</span>); <span class="comment">// 调用 axhal 提供的串口输出功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-依赖管理-Cargo-toml"><a href="#2-依赖管理-Cargo-toml" class="headerlink" title="2. 依赖管理 Cargo.toml"></a>2. 依赖管理 Cargo.toml</h4><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">axstd</span> = &#123; workspace = <span class="literal">true</span> &#125; // 引入 axstd 组件，支持标准库功能</span><br><span class="line"><span class="attr">arceos_api</span> = &#123; workspace = <span class="literal">true</span> &#125; // 引入内核公共接口</span><br></pre></td></tr></table></figure>

<h4 id="3-features-动态配置"><a href="#3-features-动态配置" class="headerlink" title="3. features 动态配置"></a>3. features 动态配置</h4><ul>
<li><strong>作用</strong>：通过编译参数控制组件的启用，实现 “按需构建”。</li>
<li><strong>示例</strong>：<ul>
<li>axstd 组件通过 feature = “axstd” 控制是否包含。</li>
<li>实验中默认启用 axstd，因此能使用 println!。</li>
</ul>
</li>
</ul>
<h4 id="println"><a href="#println" class="headerlink" title="println!"></a>println!</h4><p>通过更改ulib下axstd,macros文件中的println!</p>
<h4 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"alloc"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> collections;</span><br></pre></td></tr></table></figure>
<p>暴露自己写的collections</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.hashbrown]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.14"</span></span><br><span class="line"><span class="attr">default-features</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>用了官方库的core版本</p>
<h2 id="二-内存管理与多任务基础"><a href="#二-内存管理与多任务基础" class="headerlink" title="二, 内存管理与多任务基础"></a><strong>二, 内存管理与多任务基础</strong></h2><h4 id="1-分页的两个阶段"><a href="#1-分页的两个阶段" class="headerlink" title="1. 分页的两个阶段"></a>1. 分页的两个阶段</h4><table>
<thead>
<tr>
<th>阶段</th>
<th>目标</th>
<th>实现方式</th>
<th>关键组件</th>
</tr>
</thead>
<tbody><tr>
<td>早期启用（必须）</td>
<td>快速建立基本映射，保证内核启动</td>
<td>1GB 恒等映射（虚拟地址 = 物理地址）</td>
<td>axhal 中的 BOOT_PT_SV39 页表</td>
</tr>
<tr>
<td>后期重映射（可选，需 paging feature）</td>
<td>扩展地址空间，支持设备 MMIO</td>
<td>细粒度权限控制（如只读、可执行）</td>
<td>axmm 中的 AddrSpace、PageTable</td>
</tr>
</tbody></table>
<h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h4><table>
<thead>
<tr>
<th>算法</th>
<th align="center">原理</th>
</tr>
</thead>
<tbody><tr>
<td>TLSF</td>
<td align="center">两级 Bitmap + 链表管理空闲块</td>
</tr>
<tr>
<td>Buddy</td>
<td align="center">基于 2 的幂次分裂 / 合并空闲块</td>
</tr>
<tr>
<td>Slab</td>
<td align="center">为特定大小对象创建缓存池</td>
</tr>
</tbody></table>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>全局分配器：通过 <code>#[global_allocator]</code> 声明，实现 <code>GlobalAlloc</code> trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg_attr(all(target_os = <span class="meta-string">"none"</span>, not(test)), global_allocator)]</span></span><br><span class="line"><span class="keyword">static</span> GLOBAL_ALLOCATOR: GlobalAllocator = GlobalAllocator::new();</span><br></pre></td></tr></table></figure>

<h4 id="任务数据结构-TaskInner"><a href="#任务数据结构-TaskInner" class="headerlink" title="任务数据结构 TaskInner"></a>任务数据结构 <code>TaskInner</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskInner</span></span> &#123;</span><br><span class="line">    id: TaskId,           <span class="comment">// 唯一标识</span></span><br><span class="line">    name: <span class="built_in">String</span>,         <span class="comment">// 任务名称（调试用）</span></span><br><span class="line">    state: AtomicU8,      <span class="comment">// 状态（Running/Ready/Blocked/Exited）</span></span><br><span class="line">    kstack: <span class="built_in">Option</span>&lt;TaskStack&gt;, <span class="comment">// 任务栈（类似线程栈）</span></span><br><span class="line">    ctx: UnsafeCell&lt;TaskContext&gt;, <span class="comment">// 上下文（保存寄存器状态）</span></span><br><span class="line">    <span class="comment">// 其他字段：调度相关（如时间片、优先级）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协作式调度"><a href="#协作式调度" class="headerlink" title="协作式调度"></a>协作式调度</h4><p>FIFO 队列：任务按 “先到先服务” 原则执行，当前任务需主动让出 CPU（调用 <code>yield_now()</code>）。</p>
<h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><table>
<thead>
<tr>
<th>组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>axsync</td>
<td>同步原语（自旋锁、互斥锁）</td>
</tr>
<tr>
<td>axtask</td>
<td>调度接口（spawn/yield_now 等）</td>
</tr>
</tbody></table>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>EarlyAllocator实现要求比较低</p>
<h5 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h5><ul>
<li><strong>alloc</strong><ul>
<li>注意每次分配内存时候的对齐</li>
<li>预分配，检查是否与p_pos重叠</li>
<li>为count++<ul>
<li>注意每次分配内存时候的对齐</li>
<li>预分配,检查是否与p_pos重叠</li>
<li>为count++</li>
</ul>
</li>
</ul>
</li>
<li>dealloc<ul>
<li>单纯的count–</li>
<li>count==0时,就可以重置b_pos了</li>
</ul>
</li>
</ul>
<h5 id="page"><a href="#page" class="headerlink" title="page"></a>page</h5><ul>
<li><strong>alloc</strong><ul>
<li>检查alignment是否有效</li>
<li>获取分配的size进行对齐，同时检查是否越界</li>
<li>更新数据<ul>
<li>检查alignment是否有效</li>
<li>获取分配的size进行对齐,同时检查是否越界</li>
<li>更新数据</li>
</ul>
</li>
</ul>
</li>
<li>dealloc<ul>
<li>不要求实现</li>
</ul>
</li>
</ul>
<h2 id="三、调度-块设备-文件系统"><a href="#三、调度-块设备-文件系统" class="headerlink" title="三、调度,块设备,文件系统"></a><strong>三、调度,块设备,文件系统</strong></h2><h3 id="时钟中断："><a href="#时钟中断：" class="headerlink" title="时钟中断："></a>时钟中断：</h3><h4 id="代码（Riscv64-中断初始化）"><a href="#代码（Riscv64-中断初始化）" class="headerlink" title="代码（Riscv64 中断初始化）"></a>代码（Riscv64 中断初始化）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axhal/src/platform/riscv64_qemu_virt/mod.rs</span></span><br><span class="line">axhal::irq::register_handler(TIMER_IRQ_NUM, || &#123;</span><br><span class="line">    update_timer(); <span class="comment">// 更新系统时间</span></span><br><span class="line">    axtask::on_timer_tick(); <span class="comment">// 触发调度器更新</span></span><br><span class="line">&#125;);</span><br><span class="line">axhal::arch::enable_irqs(); <span class="comment">// 开中断</span></span><br></pre></td></tr></table></figure>


<h3 id="块设备驱动："><a href="#块设备驱动：" class="headerlink" title="块设备驱动："></a>块设备驱动：</h3><h4 id="Trait：BlockDriverOps"><a href="#Trait：BlockDriverOps" class="headerlink" title="Trait：BlockDriverOps"></a>Trait：BlockDriverOps</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BlockDriverOps</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">num_blocks</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u64</span>; <span class="comment">// 磁盘总块数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">block_size</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span>; <span class="comment">// 块大小（512 字节）</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_id: <span class="built_in">u64</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; DevResult; <span class="comment">// 读块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="文件系统："><a href="#文件系统：" class="headerlink" title="文件系统："></a>文件系统：</h3><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>文件系统（FileSystem）：如 FAT32、EXT4。</p>
<p>目录（Dir）：存储文件 / 子目录元数据。</p>
<p>文件（File）：存储具体数据，支持读写操作。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">VfsOps</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">root_dir</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;DirNode; <span class="comment">// 获取根目录</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lookup</span></span>(&amp;<span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;FileNode&gt;; <span class="comment">// 解析路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h4><p>块设备读取：通过 VirtIO Blk 驱动读取磁盘前 512 字节（引导扇区）。</p>
<p>解析 BPB：获取 FAT 表起始地址、簇大小等参数。</p>
<p>挂载文件系统：将 FAT32 的根目录挂载到 VFS 的 / 节点。</p>
<h4 id="应用加载示例（U-8-实验）"><a href="#应用加载示例（U-8-实验）" class="headerlink" title="应用加载示例（U.8 实验）"></a>应用加载示例（U.8 实验）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 FAT32 文件系统加载应用程序</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">load_app</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> root = vfs.root_dir();</span><br><span class="line">    <span class="keyword">let</span> file = root.lookup(path).ok_or(<span class="string">"文件不存在"</span>)?;</span><br><span class="line">    file.read_to_end() <span class="comment">// 读取文件内容到内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h3><h4 id="寻找ing"><a href="#寻找ing" class="headerlink" title="寻找ing"></a>寻找ing</h4><p>在axfs_ramf中实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> VfsNodeOps <span class="keyword">for</span> DirNode&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>文件时通过封装的BTreeMap管理的, 替换相应键值对即可</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">rename</span></span>(&amp;<span class="keyword">self</span>, src_path: &amp;<span class="built_in">str</span>, dst_path: &amp;<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<p>src和dst_path路径层级不一样<br>我使用了split_path_to_end来获取最终的文件名</p>
<h2 id="四-地址空间管理"><a href="#四-地址空间管理" class="headerlink" title="四, 地址空间管理"></a><strong>四, 地址空间管理</strong></h2><h3 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键修改：init_user_stack的lazy参数设为false</span></span><br><span class="line"><span class="keyword">let</span> ustack_top = init_user_stack(&amp;<span class="keyword">mut</span> uspace, <span class="literal">false</span>).unwrap(); <span class="comment">// 延迟映射</span></span><br></pre></td></tr></table></figure>

<p><strong>缺页异常处理流程</strong></p>
<ul>
<li>异常触发：用户态访问未映射地址（如栈写入），CPU 陷入内核。</li>
<li>处理逻辑：<ol>
<li>通过handle_page_fault函数申请物理页帧（alloc_frame）</li>
<li>在页表中建立虚拟地址与物理页帧的映射（pt.remap）</li>
</ol>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_page_fault</span></span>(...) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> frame = alloc_frame(<span class="literal">true</span>); <span class="comment">// 申请物理页</span></span><br><span class="line">    pt.remap(vaddr, frame, orig_flags); <span class="comment">// 建立映射</span></span><br><span class="line">    tlb.flush(); <span class="comment">// 刷新TLB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ELF-格式解析"><a href="#ELF-格式解析" class="headerlink" title="ELF 格式解析"></a>ELF 格式解析</h3><p>关键段：<br>LOAD 段：包含代码段（R E标志）和数据段（RW标志）。<br>BSS 段：未初始化数据，ELF 文件不存储，内核需预留空间并清零。<br>加载逻辑：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> segment <span class="keyword">in</span> elf.segments &#123;</span><br><span class="line">    if segment.type == LOAD &#123;</span><br><span class="line">        <span class="keyword">let</span> vaddr = segment.virt_addr;</span><br><span class="line">        <span class="keyword">let</span> phys_frame = alloc_frame(segment.mem_siz);</span><br><span class="line">        map_virtual_to_physical(vaddr, phys_frame, segment.flags);</span><br><span class="line">        <span class="keyword">if</span> segment.has_data &#123;</span><br><span class="line">            copy_file_data(vaddr, segment.file_offset, segment.file_siz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zero_memory(vaddr, segment.mem_siz); <span class="comment">// BSS段清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验实现-1"><a href="#实验实现-1" class="headerlink" title="实验实现"></a>实验实现</h3><p>得到aspace-&gt;分配内存-&gt;将文件信息写入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAP_SHARED = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;    <span class="comment">// 共享映射，对映射区域的修改会反映到文件中</span></span><br><span class="line"><span class="keyword">const</span> MAP_PRIVATE = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;   <span class="comment">// 私有映射，对映射区域的修改不会反映到文件中</span></span><br><span class="line"><span class="keyword">const</span> MAP_FIXED = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;     <span class="comment">// 必须使用指定的映射地址</span></span><br><span class="line"><span class="keyword">const</span> MAP_ANONYMOUS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>; <span class="comment">// 匿名映射，不与文件关联</span></span><br><span class="line"><span class="keyword">const</span> MAP_NORESERVE = <span class="number">1</span> &lt;&lt; <span class="number">14</span>; <span class="comment">// 不保留交换空间</span></span><br><span class="line"><span class="keyword">const</span> MAP_STACK = <span class="number">0x20000</span>;    <span class="comment">// 用于栈分配</span></span><br></pre></td></tr></table></figure>

<p>这里只处理MAP_PRIVATE,<br>同时addr.is_null(),可通过aspace.find_free_area寻找内存</p>
<h2 id="五-Hypervisor"><a href="#五-Hypervisor" class="headerlink" title="五, Hypervisor"></a><strong>五, Hypervisor</strong></h2><h3 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>Hypervisor（虚拟机监控器）是运行在物理硬件与虚拟机之间的虚拟化层软件，允许多个虚拟机共享物理资源，每个虚拟机拥有独立的虚拟硬件环境（如vCPU、vMem、vDevice）。</p>
<h4 id="1-2-核心功能"><a href="#1-2-核心功能" class="headerlink" title="1.2 核心功能"></a>1.2 核心功能</h4><ul>
<li><strong>资源虚拟化</strong>：模拟CPU、内存、设备等硬件资源</li>
<li><strong>隔离与调度</strong>：确保虚拟机之间资源隔离，并高效调度物理资源</li>
<li><strong>模式切换</strong>：在Host（Hypervisor）与Guest（虚拟机）之间双向切换</li>
</ul>
<h4 id="1-3-与模拟器的区别"><a href="#1-3-与模拟器的区别" class="headerlink" title="1.3 与模拟器的区别"></a>1.3 与模拟器的区别</h4><table>
<thead>
<tr>
<th>维度</th>
<th>Hypervisor</th>
<th>模拟器(Emulator)</th>
</tr>
</thead>
<tbody><tr>
<td>ISA一致性</td>
<td>虚拟环境与物理环境ISA一致</td>
<td>可模拟不同ISA（如x86模拟ARM）</td>
</tr>
<tr>
<td>指令执行</td>
<td>大部分指令直接在物理CPU执行</td>
<td>全部指令需翻译/解释执行</td>
</tr>
<tr>
<td>性能目标</td>
<td>高效（虚拟化开销低）</td>
<td>侧重仿真效果，性能要求低</td>
</tr>
</tbody></table>
<h4 id="1-4-虚拟化类型"><a href="#1-4-虚拟化类型" class="headerlink" title="1.4 虚拟化类型"></a>1.4 虚拟化类型</h4><ol>
<li><strong>I型Hypervisor</strong>：直接运行在硬件上（如Xen、KVM），性能高</li>
<li><strong>II型Hypervisor</strong>：运行在宿主OS上（如VirtualBox），依赖宿主资源管理</li>
</ol>
<h3 id="二-Riscv64虚拟化扩展（H扩展）"><a href="#二-Riscv64虚拟化扩展（H扩展）" class="headerlink" title="二. Riscv64虚拟化扩展（H扩展）"></a>二. Riscv64虚拟化扩展（H扩展）</h3><h4 id="2-1-特权级扩展"><a href="#2-1-特权级扩展" class="headerlink" title="2.1 特权级扩展"></a>2.1 特权级扩展</h4><p>新增特权级：</p>
<ul>
<li><strong>HS</strong>(Hypervisor Supervisor)：Host域的管理级，负责虚拟化控制</li>
<li><strong>VS</strong>(Virtual Supervisor)：Guest域的内核级，运行Guest OS内核</li>
<li><strong>VU</strong>(Virtual User)：Guest域的用户级，运行Guest应用</li>
</ul>
<p>特权级关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">物理机：M（最高） &gt; HS &gt; U</span><br><span class="line">虚拟机：VS（Guest内核） &gt; VU（Guest用户）</span><br></pre></td></tr></table></figure>

<h4 id="2-2-关键寄存器"><a href="#2-2-关键寄存器" class="headerlink" title="2.2 关键寄存器"></a>2.2 关键寄存器</h4><ul>
<li><strong>hstatus</strong>：控制Host与Guest的模式切换<ul>
<li>SPV位：指示进入HS前的模式（0：非虚拟化模式；1：来自Guest的VS模式）</li>
<li>SPVP位：控制HS是否有权限操作Guest的地址空间</li>
</ul>
</li>
<li><strong>vs[xxx]/hs[xxx]</strong>：分别用于Guest和Host的上下文管理</li>
<li><strong>misa</strong>：标识是否支持H扩展（bit7=1表示支持）</li>
</ul>
<h3 id="3-模式切换机制"><a href="#3-模式切换机制" class="headerlink" title="3. 模式切换机制"></a>3. 模式切换机制</h3><h4 id="3-1-从Host到Guest（run-guest函数）"><a href="#3-1-从Host到Guest（run-guest函数）" class="headerlink" title="3.1 从Host到Guest（run_guest函数）"></a>3.1 从Host到Guest（run_guest函数）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存Host寄存器状态</span></span><br><span class="line">sd ra, (hyp_ra)(a0)  <span class="comment">// 保存返回地址</span></span><br><span class="line"><span class="comment">// 加载Guest寄存器状态</span></span><br><span class="line">ld sstatus, guest_sstatus(a0)</span><br><span class="line"><span class="comment">// 执行sret指令切换到VS模式</span></span><br><span class="line">sret</span><br></pre></td></tr></table></figure>
<p>可参考guest.s</p>
<ul>
<li>a0指向的guest_reg区域 与 当前reg的替换<h4 id="3-2-VM-Exit处理（以SBI调用为例）"><a href="#3-2-VM-Exit处理（以SBI调用为例）" class="headerlink" title="3.2 VM-Exit处理（以SBI调用为例）"></a>3.2 VM-Exit处理（以SBI调用为例）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">    Trap::Exception(Exception::VirtualSupervisorEnvCall) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> sbi_msg = SbiMessage::from_regs(ctx.guest_regs.gpr);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(SbiMessage::Reset(Shutdown)) = sbi_msg &#123;</span><br><span class="line">            ax_println!(<span class="string">"Shutdown vm normally!"</span>);</span><br><span class="line">            <span class="comment">// 清理Guest资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>根据结果硬编码,更改guest_reg的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/04/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-joeschmo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/04/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-joeschmo/" class="post-title-link" itemprop="url">2025 春夏季开源操作系统训练营阶段总结-joeschmo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-04 20:48:14" itemprop="dateCreated datePublished" datetime="2025-06-04T20:48:14+00:00">2025-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage 1"></a>Stage 1</h2><p>这个阶段主要是学习Rust语法，因为之前有报名过训练营，所以做起来比较顺手，把基础语法又复习了一遍。</p>
<h2 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage 2"></a>Stage 2</h2><p>这个阶段主要是阅读实验指导书和源码。实验指导书非常重要，如果没有看明白的话对做实验有很大影响，所以要细心耐心看。时间有限的话，看精简版指导书即可。<br>完成实验部分需要重点理解几个点：</p>
<ol>
<li>任务切换机制，保存切换前后程序上下文</li>
<li>地址空间，多级页表机制</li>
<li>文件系统，操作与管理</li>
</ol>
<h2 id="Stage-3"><a href="#Stage-3" class="headerlink" title="Stage 3"></a>Stage 3</h2><p>这个阶段主要是看视频和PPT，并通过做6个实验来熟悉ArceOS的设计思想。相对于上一个阶段的实验会简单一些。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前有报名过两次训练营，但都没有坚持下来。对于如何平衡学习、工作和自我提升之间的平衡，是一个我现在以及将来都需要仔细思考的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/03/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-vipectuSSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/03/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-vipectuSSS/" class="post-title-link" itemprop="url">2025春夏开源操作系统训练营三阶段总结报告--vipectuSSS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-03 14:06:08" itemprop="dateCreated datePublished" datetime="2025-06-03T14:06:08+00:00">2025-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 05:03:17" itemprop="dateModified" datetime="2025-11-07T05:03:17+00:00">2025-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>这样的总结应该从何开始？我是从<a href="https://www.bilibili.com/" target="_blank" rel="noopener">Bilibili</a>刷视频偶然了解到与训练营相关的信息的。使用Rust语言编写操作系统的实践，我太喜欢这个方向了。因为我正学过一点Rust，也经学校老师的推荐看过CSAPP并完成了大多数的实验。其中我最喜欢的便是<code>shlab</code>和<code>attacklab</code>────写一个shell！实在是有趣不过，如果再写一个操作系统呢？好吧，我应该没有与之匹配的实力，不过开源操作系统训练营就这样给了我一个类似的机会。报名人数破千！全程免费！还有什么好说的呢，杀😡。</p>
<h1 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage 1"></a>Stage 1</h1><p>110道Rustling编程题，并没有耗费我太多功夫，更多的是重新熟悉一下语法。我觉得，学习Rust不仅是学会如何使用一门编程语言，更是了解更多的编程范式。例如<code>trait</code>背后的组合大于继承；函数式编程对现代编程语言深刻的影响：默认不可变、闭包、HOFs、链式操作等；所有权与生命周期机制，这种RAII思想是C++首创的（但是opt-out）。Rust编译器就是你最好的老师，更别说还有满地走的各式AI（<del><em>本总结经AI辅助完成</em></del>），2025年的今天，学习Rust不应该再是一件难事🥳。</p>
<h1 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage 2"></a>Stage 2</h1><p>到了OS设计实现，主要是完成5道rCore操作系统大实验编程题。我是提前进入该阶段，所以全程并没有看过相关学习视频，而是跟随<a href="https://learningos.cn/rCore-Tutorial-Guide-2025S/" target="_blank" rel="noopener">rCore-Tutorial-Guide</a>文档完成的🤓。</p>
<p>这阶段最耗时的是lab2───地址空间和lab5───并发，这两个不管哪个太痛苦了😭。lab2是因为分页机制本身就相对复杂，层层抽象，读内核新增的代码就花了我很久时间（光论这一点文件系统其实不遑多让，不过到这里我的读代码能力已经得到显著锻炼了，所以带给我的痛苦远不及地址空间🥱）。而lab5，单纯是我因为技术路线的左右互博而无限拖缓了进度，我一直在对死锁检测资源的获取上究竟是现场构建还是跟随进程保存之间反复横跳。倒不如说，是因为我在实现这两个的时候遭遇多方掣肘，导致我不停怀疑我自己，不停的重构。使用Rust编程不就是戴着脚镣在跳舞吗？我现在水平还不够，只能写出不够优美的实现，但是我不会放弃的😡。</p>
<h1 id="Stage-3"><a href="#Stage-3" class="headerlink" title="Stage 3"></a>Stage 3</h1><p>组件化操作系统，这大概是最各显神通的阶段了。我对这阶段的印象其实是一点草台味🤯，遇到各方面奇怪的问题，测试脚本死活不通过，各种不同的资料，到底要实现在哪里，我要怎么修改一个crate依赖的代码？我是个不撞南墙不愿意问别人的人，所以我全部都闭门造车自己解决了所有问题（真的吗？至少测例说我通过了）。但实际上，在讨论群里大家都很乐意回答别人的提问，每个人都有自己的“奇技淫巧”，应该让大家全都热烈讨论遇到的问题，才能让训练营变得更好😈。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>写到这里我已经有点精疲力竭。我在参与前三个阶段的过程中收获颇多，不只是对整个组件化操作系统的认识。还有各种在学习过程中对工具的使用，<code>helix</code>、<code>Zellij</code>，这些工具，我很早就下载了，只是因为它是Rust重写的老工具。现在呢？我需要<code>helix</code>丰富的快捷键，我需要<code>Zellij</code>的分屏。我开始熟悉，正是我开始迈出一步，参加了这次，<a href="https://opencamp.cn/os2edu/camp/2025spring" target="_blank" rel="noopener">2025 春夏季开源操作系统训练营</a>。</p>
<p>完成了三阶段的任务，我也疲惫了，进入了一种拖延的状态。五月二十二号，新建文件夹，想要完成这篇总结报告。一直到今天，我终于又想重新出发了。希望到了第四阶段，我可以找到新的方向。</p>
<p>编程的乐趣：⭐️⭐️⭐️⭐️<br>挑战的难度：⭐️⭐️⭐️<br>开源训练营：⭐️⭐️⭐️⭐️⭐️</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/blog/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/74/">74</a><a class="extend next" rel="next" href="/blog/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
