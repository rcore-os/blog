<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/6/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">740</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">646</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/07/07/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-jizhaoqin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/07/07/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-jizhaoqin/" class="post-title-link" itemprop="url">rCore2025-spring四阶段总结-jizhaoqin</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-07 15:00:00" itemprop="dateCreated datePublished" datetime="2025-07-07T15:00:00+00:00">2025-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025春操作系统训练营四阶段报告"><a href="#2025春操作系统训练营四阶段报告" class="headerlink" title="2025春操作系统训练营四阶段报告"></a>2025春操作系统训练营四阶段报告</h1><h2 id="第一阶段-Rust编程"><a href="#第一阶段-Rust编程" class="headerlink" title="第一阶段 - Rust编程"></a>第一阶段 - Rust编程</h2><ul>
<li>这一阶段主要就是了解学习Rust的语法和特性, 以及完成所有的rustlings题目, 以及实现一些基础的数据结构和算法, 为之后的项目内容做准备.</li>
<li>我对rust的语法已经比较熟悉了, 其实rustlings之前也做过一遍, 所以很快, 但数据结构和算法的rust实现有点忘了, 这部分花了点时间</li>
</ul>
<h2 id="第二阶段-OS设计实现"><a href="#第二阶段-OS设计实现" class="headerlink" title="第二阶段 - OS设计实现"></a>第二阶段 - OS设计实现</h2><ul>
<li>仓库连接: <a href="https://github.com/LearningOS/2025s-rcore-jizhaoqin" target="_blank" rel="noopener">https://github.com/LearningOS/2025s-rcore-jizhaoqin</a></li>
<li>这一阶段花了挺多时间, 因为一个完整的os内核内容和代码真的很多</li>
<li>chapter1 应用程序与基本执行环境<ul>
<li>这一届内容比较少, 主要是关于如何实现一个最小内核, 以及RustSBI使用的一些问题</li>
</ul>
</li>
<li>chapter2 批处理系统:<ul>
<li>由于我以前没有接触过risc-v指令集和汇编语言, 所以在理解汇编指令, 链接脚本, 还有特权级的切换方面花了很多时间, 最后也是能够理解实验里给的代码都有什么作用</li>
<li>另外, 我找了内容更多的v3版文档阅读前两章, 发现内容确实很详细, 但不适合做实验, 因为对我来说是在是太多了, 当个参考书挺好, 遇到camp文档疑惑的地方去查以下非常有用, 因为逻辑是一样的, 但是跟着v3文档一步一步写代码实在是很痛苦, 主要是进度太慢了, 没有反馈动力不足继续做下去了.</li>
<li>所以后来我就主要看camp文档了, 而且不再一步一步跟着自己实现, 主要是在每一章的练习部分, 在实现的过程中再去仔细理解每一个模块的作用, 这样会好很多对我来说, 理解地也很快.</li>
</ul>
</li>
<li>chapter3 多道程序与分时多任务<ul>
<li>这一章实现了简单的抢占式任务调度, 主要内容是程序上文的保存和切换</li>
</ul>
</li>
<li>chapter4 地址空间:<ul>
<li>这一章内存虚拟化是非常重要的内容, 之后内核态和用户态就会在内存映射上隔离, 区分更明显了, 同时对上下文切换的汇编代码进行了一些补充修改</li>
<li>这一章对多级页表的介绍其实不详细, 但是我以前实现过x86架构上一个简单的4级页表, 以及动态内存分配器, 所以整体理解没有问题, 但是需要了解更多关于SV39多级页表的一些细节</li>
</ul>
</li>
<li>chapter5 进程及进程管理:<ul>
<li>介绍了进程的抽象的实现, 在这个实验里相对于内存虚拟化来说并不难理解</li>
<li>通过进程实现经典的sys_fork()和sys_exec()系统调用</li>
<li>而且从这一张开始有了一个简单的shell了</li>
</ul>
</li>
<li>chapter6 文件系统与I/O重定向:<ul>
<li>os的又一大关键功能, 提供文件抽象和接口</li>
<li>这一章是目前为止最费劲的一章, 因为抽象层数太多了, 实现系统调用的时候非常容易搞乱, 而且到这里代码已经很多了, 层数也很深, 花了非常多的时间去理解调用的每一层都干了什么事, 但一些没有直接用到的API没有多看. 好在最后实现完成后, 本地测试一遍就通过了, 还是挺好的.</li>
</ul>
</li>
<li>chapter7 进程间通信:<ul>
<li>主要实现进程间管道通信, 这里基于文件抽象来实现</li>
<li>在shell里还实现了重定向符号<code>&gt;, &lt;</code></li>
</ul>
</li>
<li>chapter8<ul>
<li>简单的笔记:<ul>
<li>线程的用户态栈：确保在用户态的线程能正常执行函数调用；</li>
<li>线程的内核态栈：确保线程陷入内核后能正常执行函数调用；</li>
<li>线程的跳板页：确保线程能正确的进行用户态&lt;–&gt;内核态切换；</li>
<li>线程上下文：即线程用到的寄存器信息，用于线程切换。</li>
</ul>
</li>
<li>线程抽象, 并发的要求, 锁的实现, (一般)信号量与实现, 条件变量</li>
<li>这一节还好, 对锁还算比较了解, 然后互斥锁是2元信号量, 也比较好理解, 就是条件变量不熟悉, 因为结尾的练习似乎不太需要, 对这一部分也没有改动.</li>
</ul>
</li>
</ul>
<h2 id="第三阶段-组件化操作系统"><a href="#第三阶段-组件化操作系统" class="headerlink" title="第三阶段 - 组件化操作系统"></a>第三阶段 - 组件化操作系统</h2><ul>
<li>仓库连接: <a href="https://github.com/LearningOS/2025s-arceos-jizhaoqin" target="_blank" rel="noopener">https://github.com/LearningOS/2025s-arceos-jizhaoqin</a></li>
<li>[print_with_color]:<ul>
<li>可以使用ANSI转义序列, 修改终端输出的颜色</li>
<li>可以在用户层<code>println!</code>, <code>axstd</code>的输出宏定义处, 或者<code>axhal</code>处修改<code>putchar</code>, 影响的范围也不同</li>
</ul>
</li>
<li>[support_hashmap]:<ul>
<li>语言提供的<code>alloc</code>crate里中提供了一些常用的集合类型比如<code>Vec</code>和<code>BTreeMap</code>, 禁用标准库时只需要提供全局动态分配器就可以使用, 在Acreos里打开<code>alloc</code>feature就行</li>
<li>但是<code>HashMap</code>除了分配器还需要提供随机数生成器, 所以不在<code>alloc</code>crate里需要自己实现.</li>
</ul>
</li>
<li>[alt_alloc]:<ul>
<li>实现一个简单的分配器<code>BumpAllocator</code></li>
</ul>
</li>
<li>[ramfs_rename]:<ul>
<li>文件系统相关的实现和API</li>
<li>对于rename来说, 其实就是在目录文件的数据块里删除一个条目, 同时新增一个条目, 但都指向相同的索引节点, 理论上也可以直接修改条目中的文件名, 但更复杂需要做出大量修改(因为现有条目储存用的是<code>BTreeMap</code>把文件名作为key不支持修改), 会引入额外的逻辑开销而且不会提升性能, 所以使用现有的删除和新增功能就好了</li>
</ul>
</li>
<li>[sys_mmap]:<ul>
<li>同rCore里sys_mmap的实现类似</li>
</ul>
</li>
<li>[simple_hv]:<ul>
<li>hypervisor虚拟化相关的内容</li>
</ul>
</li>
</ul>
<h2 id="第四阶段-项目三-基于协程异步机制的操作系统-驱动"><a href="#第四阶段-项目三-基于协程异步机制的操作系统-驱动" class="headerlink" title="第四阶段 - 项目三: 基于协程异步机制的操作系统/驱动"></a>第四阶段 - 项目三: 基于协程异步机制的操作系统/驱动</h2><ul>
<li>仓库连接: <a href="https://github.com/jizhaoqin/arceos/tree/dev-async-irq" target="_blank" rel="noopener">https://github.com/jizhaoqin/arceos/tree/dev-async-irq</a></li>
<li>报告ppt连接: <a href="https://docs.google.com/presentation/d/1VZuvpDa1Ot9joiWxl2y-eviw-mX34QQXLZYLFYfCR1c/edit?usp=sharing" target="_blank" rel="noopener">https://docs.google.com/presentation/d/1VZuvpDa1Ot9joiWxl2y-eviw-mX34QQXLZYLFYfCR1c/edit?usp=sharing</a></li>
<li>选题方向:<ul>
<li>主要目标是尝试对部分非实时中断异步化, 具体以uart串口通信为例, 实时意味着需要立即处理完毕, 非实时中断则不要求中断信息能马上处理完毕, 对这种中断我们可以将其放在后台运行而不阻塞当前逻辑, 比较适合将其转化为异步任务进行处理. </li>
<li>需要注意的是, 我们一般要求所有中断都要求立即返回, 但这并不意味着中断已经处理完毕, 比如网络包下载, 或者高负载串口通信, 有些信息处理比较耗时, 这时为了快速结束中断, 我们可以将未经处理的数据放入缓冲区队列, 然后在结束中断前通知异步任务进行处理.</li>
<li>另外由于目前Arceos对几乎所有外部设备都采用轮询方式, 所以在异步化之前, 先要将其改造为基于中断的方式.</li>
</ul>
</li>
<li>过程:<ul>
<li>架构和具体目标: aarch64 qemu virt platform的uart中断异步改造.</li>
<li>首先在<code>axhal</code>中给对应platform注册uart中断并启用, qemu将terminal的用户输入模拟为串口通信, 经测试arceos能够按照预期以中断的方式接收串口信号. <ul>
<li>这一部分的难点在与梳理清楚arceos的中断架构, 注册和调用流程, 以及各架构<code>axhal</code>, <code>axruntime</code>, <code>axstd</code>, <code>arceos_api</code>之间以及内部的代码和依赖结构.</li>
</ul>
</li>
<li>之后尝试异步改造uart的中断处理函数. 如之前提到的, 我们将中断处理分为两个部分:<ul>
<li>第一部分是同步的, 需要原封不动地接受所有信息并将其推送到缓冲区队列, 并发送信号表明有数据需要处理.<ul>
<li>这一部分的难点在于如果处理程序是异步的, 我们如何从同步的中断处理函数中发出合适的通知信号.</li>
</ul>
</li>
<li>第二部分是异步的, 为数据处理程序, 在这里我们采取异步的方式, 由一个异步运行时维护有多个中断第二部分数据处理程序的队列(由于目前只注册了一个中断, 队列中只有uart中断的异步处理任务), 并进行调度, 与内核线程调度不同的是, 这些处理任务都在同一个线程中. <ul>
<li>这一部分的难点在与, 如何构建一个非标准库环境下的异步执行器, 来轮询和调度这些异步任务.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>成果:<ul>
<li>最终完成了aarch64 uart的中断注册, </li>
<li>实现了中断处理函数的异步改造, </li>
<li>构建一个内核异步运行时并进行调试, 以完成异步中断处理的执行和调度工作.</li>
</ul>
</li>
<li>未来可能的方向:<ul>
<li>整理代码结构, 符合arceos的规范, 形成良好的文档</li>
<li>尝试兼容更多中断类型, 用统一的异步中断处理异步运行时处理更多类型的非实时中断.</li>
<li>兼容更多架构</li>
<li>优化异步运行时的调度逻辑, 以及实现优先级调度等功能.</li>
<li>将异步运行时替换为更成熟的embassy</li>
</ul>
</li>
<li>实现过程中遇到的困难:<ul>
<li>尝试注册键盘中断进行测试, 发现需要开启qemu graphic实现显示设备驱动, 而且兼容性差, 所以不搞键盘中断了, 直接搞串口中断, 目前arceos的实现都是轮询;</li>
<li>x86_64 qemu q35 平台没查到COM1 uart的中断向量, 导致一直没能成功注册中断, 而且x86的x2apic架构比较复杂, 执行了irq映射难梳理, 最后花了很多时间也没搞明白中断向量到底是啥;</li>
<li>后来转向aarch64, 成功注册uart中断, 并测试表现良好符合预期;</li>
<li>尝试异步化改造中断处理, 查看embassy的实现有些复杂不好拆解, 最后决定从头手写一个简单的异步执行器, 花了好大力气才搞定, 测试能工作;</li>
<li>尝试把异步运行时和中断处理结合起来的时候总是有交叉依赖的问题, 最后把异步任务通知逻辑和执行逻辑分别放在<code>axhal</code>和<code>axruntime</code>, 才最终解决交叉依赖.</li>
<li>执行器阻塞线程不主动yield, 直到一个周期后被抢占才切换到其他线程, 而其他线程正常yield, 这使得执行器线程占用了几乎所有CPU时间</li>
<li>最后又更改了中断处理流程, 添加了两个缓冲区才最终把逻辑跑通</li>
</ul>
</li>
<li>其他:<ul>
<li>为较大项目添加特性是一件很困难的事, 除了考虑本特性的实现, 还要嵌合进整个项目的组织框架和编译逻辑中, 不敢想象如果没有好的代码架构, 抽象以及解耦, 可以想象越到后来, 最终将达到一个极限, 使得这一工作几乎不可能完成.</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/" class="post-title-link" itemprop="url">基于 uring 的异步 IPC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-30 23:00:00" itemprop="dateCreated datePublished" datetime="2025-06-30T23:00:00+00:00">2025-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异步通信框架-evering"><a href="#异步通信框架-evering" class="headerlink" title="异步通信框架: evering"></a>异步通信框架: evering</h2><p><a href="https://loichyan.github.io/openoscamp-2025s/evering" target="_blank" rel="noopener">evering</a> 是受 <a href="https://en.wikipedia.org/wiki/Io_uring" target="_blank" rel="noopener">io_uring</a> 启发的的异步通信框架，作为本文实现异步 IPC 的基石，它</p>
<ul>
<li>🦀 基于 Rust 异步模型</li>
<li>🐧 基于共享内存</li>
<li>📡 提供双向 SPSC 消息队列</li>
<li>🎬 提供灵活的资源管理机制</li>
</ul>
<p>evering 使用两个单生产者单消费者（SPSC）并发队列进行通信，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       Client                                     Server</span><br><span class="line">         |                                           |</span><br><span class="line">.-------&gt;|                                           |&lt;---------.</span><br><span class="line">|        |               Request Queue               |          |</span><br><span class="line">|   (Send Request)   --&gt;-(3)-&gt;-(2)-&gt;-(1)-&gt;-- (Receive Response) |</span><br><span class="line">|        |                                           |          |</span><br><span class="line">|        |                                           |          |</span><br><span class="line">| (Receive Response) --&lt;-(1)-&lt;-(2)-&lt;-(3)-&lt;--   (Send Request)   |</span><br><span class="line">|        |               Response Queue              |          |</span><br><span class="line">&#39;--------&#39;                                           &#39;----------&#39;</span><br></pre></td></tr></table></figure>

<p>受限于 SPSC 通信，目前 evering 只能遵循 thread-per-core 模型，不同于 tokio、async-std 等使用 work-stealing 的运行时．在基于 thread-per-core 的异步模型中，每个线程有一个局部的运行时，不同线程之间保持最小的通信，甚至完全独立．而基于 work-stealing 的异步模型中，任何异步任务都可能由于运行时的调度而被“偷”到其他线程上运行．二者相比有以下异同：</p>
<ul>
<li>在 thread-per-core 模型中，异步任务不必担心同步问题，即在 Rust 中不需要使用诸如 <code>impl Send + Future</code> 的类型，这可以大大简化异步编码体验．而在 work-stealing 模型中，几乎所有的异步任务都需要注意线程之间的同步，这样难免会带来一些额外的开销，也使得异步编码更为繁琐<a href="https://maciej.codes/2022-06-09-local-async.html" target="_blank" rel="noopener">^1</a>．</li>
<li>正如 work-stealing 这名称所示，在此类模型中，运行时会根据程序实时状态对不同线程上的异步任务进行负载均衡，使得每个线程都不会陷入长时间的忙碌或空间．而对于 thread-per-core 模型，由于异步任务不能在多线程之间共享，当处理某个 CPU 密集型任务时，很可能因为长时间阻塞而导致该线程上的其他任务迟迟得不到处理，最终出现较高的响应延迟．因此 thread-per-core 不适合 I/O 密集混合 CPU 密集的场景．</li>
</ul>
<h2 id="实验性异步-IPC-模型-evering-ipc"><a href="#实验性异步-IPC-模型-evering-ipc" class="headerlink" title="实验性异步 IPC 模型: evering-ipc"></a>实验性异步 IPC 模型: evering-ipc</h2><p><a href="https://github.com/loichyan/openoscamp-2025s/tree/final/examples/evering-ipc" target="_blank" rel="noopener">evering-ipc</a> 在 evering 的基础上，同时利用 Linux 的共享内存机制实现了异步 IPC．具体而言，要通信的两个进程使用以下所示的共享内存区进行同步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.-----------------------------------------------------------------------------.</span><br><span class="line">|                   |               |                   |                     |</span><br><span class="line">| [1] uring offsets | [2] allocator | [3] uring buffers | [4] free memory ... |</span><br><span class="line">| ^                 |               |                   |                   ^ |</span><br><span class="line">&#39;-|-------------------------------------------------------------------------|-&#39;</span><br><span class="line">  &#39;-- start of the shared memory (page aligned)                             |</span><br><span class="line">                                                 end of the shared memory --&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>[1]</em> 是整个共享内存区的起始，通过 mmap(2) 映射到地址空间中，因此是页对齐的．</li>
<li><em>[1]</em> 中包含 evering 的两个通信队列的偏移量，基于这个偏移量配合 evering 提供的构造队列的接口，可以确保两个进程看到的状态是相同的．</li>
<li><em>[2]</em> 中包含一个单线程的内存分配器，这个分配器通常由客户端使用．</li>
<li><em>[3]</em> 是通信队列的实际所在位置．</li>
<li><em>[4]</em> 是其余全部的空闲内存，这些内存由 <em>[2]</em> 中的分配器管理．</li>
</ul>
<p>在 evering-ipc 中，uring 仅用于传递静态类型且通常仅有十几到几十个字节的<em>消息</em>．而对于更大的以及编译期间无法确定大小的<em>数据</em>，它利用共享的空闲内存来传递．具体而言，</p>
<ol>
<li>客户端获取内存分配器，从中分配合适的内存块，并写入<em>请求体</em>作为待传递<em>数据</em>．</li>
<li>客户端将该内存块指针以及其他信息构造成<em>请求头</em>作为<em>消息</em>写入请求队列．</li>
<li>服务端接收并解析请求，得到<em>请求头</em>和<em>请求体</em>．</li>
<li>服务端处理请求，将处理结果构造<em>响应头</em>作为<em>消息</em>写入响应队列．</li>
<li>客户端收到响应，检查结果并执行后续流程．</li>
</ol>
<p>当服务端同样也需要传<em>响应体</em>作为<em>数据</em>时，有多种思路可以实现：</p>
<ol>
<li>将分配器加锁使它能同时在服务端和客户端使用．对于请求频率特别高的场景，锁可能会降低整体性能．</li>
<li>增加一个分配器供服务端使用．对于空闲内存分配比例的设定可能不容易权衡．</li>
<li>结合前两个思路，使用两个分配器，但空闲内存加锁，根据程序运行状况动态调整分配给两方的空闲内存．</li>
<li>空闲内存完全由客户端管理，在请求时，客户端分配合适大小的内存块供服务端写入<em>响应体</em>．实际中，客户端可能需要预请求一次来确定<em>响应体</em>的大小．</li>
</ol>
<p>evering-ipc 目前采用第 4 种思路．此外，不难发现，在 evering-ipc 中，数据都是通过指针进行传递的．而在程序运行时，共享内存通常被映射到不同的地址，因此实际传递的是数据块在共享内存中的偏移量．同时，共享内存区的起始地址都是页对齐的，这保证了所有基于相对偏移量得到的地址，即使在两个进程间不同，对齐也是一致的，从而满足 Rust 对不同类型内存布局的要求．</p>
<h2 id="多种-IPC-方案的性能测试-ipc-benchmark"><a href="#多种-IPC-方案的性能测试-ipc-benchmark" class="headerlink" title="多种 IPC 方案的性能测试: ipc-benchmark"></a>多种 IPC 方案的性能测试: ipc-benchmark</h2><p><a href="https://github.com/loichyan/openoscamp-2025s/tree/final/examples/ipc-benchmark" target="_blank" rel="noopener">ipc-benchmark</a> 针对多种 IPC 方案进行了关于通信延迟的性能测试，这些方案包括：</p>
<ul>
<li>基于 evering + memfd 的 IPC</li>
<li>基于 shmipc + memfd 的 IPC</li>
<li>基于 tokio + epoll + UDS 的 IPC</li>
<li>基于 tokio + io_uring + UDS 的 IPC</li>
<li>基于 monoio + io_uring + UDS 的 IPC</li>
</ul>
<p>其中，</p>
<ul>
<li>memfd 是 create_memfd(2) 创建的匿名内存．</li>
<li>UDS 是指 Unix Domain Socket．</li>
<li><a href="https://github.com/cloudwego/shmipc-rs" target="_blank" rel="noopener">shmipc</a> 是基于共享内存的高性能 IPC 框架．</li>
<li><a href="https://tokio.rs/" target="_blank" rel="noopener">tokio</a> 是基于 epoll(7) 和 work-stealing 模型的异步 I/O 运行时．</li>
<li><a href="https://github.com/tokio-rs/tokio-uring" target="_blank" rel="noopener">tokio-uring</a> 为 tokio 提供了基于 io_uring 的异步 I/O 实现．</li>
<li><a href="https://github.com/bytedance/monoio" target="_blank" rel="noopener">monoio</a> 是基于 io_uring 和 thread-per-core 模型的异步 I/O 运行时．</li>
</ul>
<p>对于每个框架我们采用如下测试方案：</p>
<ol>
<li>启动两个线程作为客户端和服务端．</li>
<li>客户端写入 <code>i32</code> 的请求头以及大小为 <code>buf_size</code> 的请求体．</li>
<li>服务端接收并校验请求头和请求体，随后同样写入 <code>i32</code> 的响应头和 <code>buf_size</code> 大小的响应体．</li>
<li>客户端接收并校验响应头和响应体．</li>
</ol>
<p>其中，<code>buf_size</code> 以字节为单位，由 4B 逐渐增长到 4M．</p>
<h3 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h3><p>详细的性能测试的结果见 <a href="https://github.com/loichyan/openoscamp-2025s/tree/ipc-benchmark" target="_blank" rel="noopener">https://github.com/loichyan/openoscamp-2025s/tree/ipc-benchmark</a>，下面我们将对该结果进行简略的分析．</p>
<img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_all.svg" class="" title="ipc-benchmark 完整测试结果对比">

<p>此图对比了完整的测试结果，其中 $x$ 轴是上述的 <code>buf_size</code>，而 $y$ 轴则是完成一次测试所需的平均时间．可以看到，随着数据大小的增长 evering 和 shmipc 明显优于其他三者，并且相对于表现最差的 tokio_epoll，二者分别有接近 50% 和 30% 的性能提升．</p>
<img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_first_5.svg" class="" title="ipc-benchmark 前五轮测试结果对比">

<p>此图对比了前五个测试的结果，此时数据并不算大，都在通常范围之内．这里能发现相对于另外三者，evering 和 shmipc 都有超过 80% 的性能提升．</p>
<img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_mid_5.svg" class="" title="ipc-benchmark 中五轮测试结果对比">

<p>此图对比了中间五轮测试的结果，此时数据大小开始逐渐出现大幅度的增长．可以看到，除了 evering 和 shmipc 外的三者针对大块数据的传输并无明显差异．</p>
<img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_last_5.svg" class="" title="ipc-benchmark 后五轮测试结果对比">

<p>此图对比了最后五轮测试的结果，此时数据大小已接近极端情况．这里能观察到与第一个对比图同样的结果．</p>
<h3 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h3><p>单从性能的角度来看，对于上述五种 IPC 方案，<code>evering &gt; shmipc &gt;&gt; monoio &gt; tokio_uring &gt; tokio_epoll</code>．</p>
<p>对比前两者，shmipc 支持 MPSC（多生产者多消费者）的通信方式，而本测试中仅使用 SPSC 的模型进行测试，因此无法发挥其完整的优势．另外，对共享内存处理的方式不同也可能导致了一些性能差异．而对于另外三者，由于使用 UDS 需要将数据在用户空间和内核空间来回拷贝，在面对大块数据时，这将大大降低整体性能．而对于极小的数据块，又由于系统调用等带来的开销，最终需要接近 10 倍的额外时间来完成测试．这一点可以在火焰图<a href="https://github.com/flamegraph-rs/flamegraph" target="_blank" rel="noopener">^2</a>中体现：</p>
<table>
<thead>
<tr>
<th align="center">evering (buf_size=4B)</th>
<th align="center">tokio-epoll (buf_size=4B)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4B_evering.jpg" class=""></td>
<td align="center"><img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4B_tokio_epoll.jpg" class=""></td>
</tr>
</tbody></table>
<p>此图中展示了在 4B 数据下，性能测试主体函数中各子过程的占比．其中，蓝色高亮部分是校验数据过程，用作参照．不难发现，evering 中主要时间都消耗在传递消息所需的多线程同步上了．而在 tokio-epoll 中则是多个与内核交互的函数调用占用主要时间．在后几轮测试中，当数据变得非常大时，这些消耗则变得无关紧要，此时的性能热点是数据传递引起的内存拷贝．下面的火焰图可以佐证：</p>
<table>
<thead>
<tr>
<th align="center">evering (buf_size=4M)</th>
<th align="center">tokio-epoll (buf_size=4M)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4M_evering.jpg" class=""></td>
<td align="center"><img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4M_tokio_epoll.jpg" class=""></td>
</tr>
</tbody></table>
<p>此图与上面两个图相同，不过这里的数据大小是 4M．很明显，当数据非常大时，evering 中绝大部分时间用来初始化需要传递的数据，但传递的过程几乎不占用太多时间．而 tokio-epoll 中的情况更加复杂，除了拷贝数据以外，还花费了相当一大部分时间执行内存分配，这些内存用于放置从内核空间传递来的数据．</p>
<p>至于后三者的性能差别，我们猜测主要是由于：</p>
<ol>
<li>设计架构不同，monoio 是单线程的 thread-per-core 模型，因此与我们的测试相性更好．</li>
<li>基于 io_uring 实现的异步 I/O 相对于基于 epoll 的，理论上会花费更少的时间在与内核交互上．并且测试中我们利用 io_uring_register(2) 做了进一步的优化，减少了传递小数据时内核处理的开销．</li>
</ol>
<h2 id="未完成的任务"><a href="#未完成的任务" class="headerlink" title="未完成的任务"></a>未完成的任务</h2><h3 id="让-evering-支持-MPSC"><a href="#让-evering-支持-MPSC" class="headerlink" title="让 evering 支持 MPSC"></a>让 evering 支持 MPSC</h3><p>正如开头所述，evering 目前只实现了 SPSC 队列，受限于此，不能很好的处理复杂的应用场景．而实现 MPSC 队列之后，客户端就能更好的与 tokio 等运行时协同工作．要实现这个目标，主要是对 evering 的队列结构 <code>RawUring</code> 和操作驱动结构 <code>Driver</code> 进行多线程改造，并且尽可能要实现无锁的数据结构．对于 <code>RawUring</code> 的改造可以参考现有的并发队列实现．而 <code>Driver</code> 底层依赖于 <a href="https://docs.rs/slab/latest/slab/" target="_blank" rel="noopener"><code>slab::Slab</code></a> 结构体，因此改造难度稍高．不过，目前 evering 已经支持使用固定大小的 <code>Slab</code>，基于这一点可以大幅降低多线程化的难度．</p>
<h3 id="基于-evering-实现系统调用"><a href="#基于-evering-实现系统调用" class="headerlink" title="基于 evering 实现系统调用"></a>基于 evering 实现系统调用</h3><p>evering-ipc 只适用于用户进程之间的通信，而本项目最初的目标是实现用户进程和内核的通信．对于这个目标，除了处理共享内存以外，可能还会遇到页表隔离的问题，以及用户进程意外退出后，对应内核异步任务的清理问题．更长远来看，当实现异步系统调用之后，那么可以将用户进程转彻底换成类似 Rust 中 <code>Future</code> 的无栈协程，从而将开销进一步降低．此外，迁移到异步系统调用时，不可避免的会破坏与现有同步代码的兼容性．因此，实现基于有栈绿色线程的异步系统调用也是一个值得尝试的目标．</p>
<!-- dprint-ignore-start -->

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/30/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90os%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E9%82%B5%E5%8D%93%E7%82%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/30/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90os%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E9%82%B5%E5%8D%93%E7%82%9C/" class="post-title-link" itemprop="url">第四阶段总结-邵卓炜</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-30 22:23:12" itemprop="dateCreated datePublished" datetime="2025-06-30T22:23:12+00:00">2025-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基于Iouring的异步运行时"><a href="#基于Iouring的异步运行时" class="headerlink" title="基于Iouring的异步运行时"></a>基于Iouring的异步运行时</h3><p>我首先选择完成的任务是<a href="https://github.com/Shao-ZW/kunio" target="_blank" rel="noopener">基于iouring的用户态异步运行时</a>，支持常见的文件和网络（Tcp）io。在我的实践经历来看，构建一个高性能的用户态异步运行时，就像是在应用程序内部再造了一个微型的操作系统，它接管了传统上由内核负责的部分调度和I/O管理职责，目的是为了消除内核/用户态切换的开销，并最大化I/O吞吐量。</p>
<p>为了实现的简单，我选择了thread-per-core 的任务调度模型。简单来说，thread-per-core可以理解为每个CPU核心分配一个独立的执行线程，每个线程（每个核心）都拥有自己的任务队列。当一个异步任务被提交时，它会被放入相应核心的任务队列中。这种设计有几个优势，一是减少竞争，由于每个线程操作自己的队列，线程间避免了共享锁的开销；二是缓存友好：任务和数据在特定核心上处理，能更好地利用CPU缓存，减少缓存失效，提高数据访问速度；三是不需要对每个任务有Send的限制。</p>
<p>IO接口的异步封装，负责与将os暴露的io接口改造成rust async/await异步语法的形式。传统的I/O模型（如 select, poll, epoll）虽然是非阻塞的，但它们本质上是“事件通知”模型——通知你有事件发生了，你再去读取数据。这依然涉及用户态和内核态之间的多次上下文切换。io_uring 则是提供了更为本质的异步io接口，一种全新的提交-完成模型————队列 (SQ)：用户态应用程序将各种I/O操作（如文件读写、网络套接字的发送接收等）封装成请求，批量地放入一个共享的内核提交队列中;完成队列 (CQ)：内核处理完这些I/O请求后，会将结果（成功与否、处理了多少字节等）批量地放入另一个共享的内核完成队列中。应用程序只需定期检查这个完成队列，就能得知哪些I/O操作已经完成，以及它们的结果。</p>
<h3 id="无锁ringbuffer-BBQ"><a href="#无锁ringbuffer-BBQ" class="headerlink" title="无锁ringbuffer BBQ"></a>无锁ringbuffer BBQ</h3><p>为了进一步优化我们比赛的OS内核的任务队列，我选择参考BBQ paper实现的<a href="https://github.com/Shao-ZW/bbring" target="_blank" rel="noopener">无锁ringbuffer</a>，虽然最终性能并不理想，但实现该结构是一个很有趣的历程。大多数lock-free ringbuffer基于version+idx组成的 Atmoicusize 作为头尾指针，并通过loop + CAS方式更新头尾指针，version主要用于解决ABA问题；而BBQ通过将数组分块，头尾指针变为头尾块指针，并且在每个块的内部额外维护2个指针（allocated/reserved）以及2个计数（committed/consumed），一个显然的好处是头节点可以直接通过FAA指令获取分配位置。我对我实现的bbq进行了性能测试，目前实现的BBQ的性能表现非常糟糕，对比crossbeam-arrayqueue，尤其在SPMC、MPMC场景下吞吐差距在10倍以上甚至更多。并且我在实践中认为算法本身还有些边缘情形处理的问题，感兴趣的同学可移步<a href="https://github.com/Shao-ZW/bbring/discussions/1" target="_blank" rel="noopener">讨论区</a>。无锁的设计总是“危险”而精妙的，哪怕论文给出算法伪代码，实现的过程依然是相当曲折的，内存序的问题，aba问题，以及如何调整测试复现特定的bug，这个过程只有踩过坑才能知道痛。</p>
<h3 id="os内核赛中组件化和异步化尝试"><a href="#os内核赛中组件化和异步化尝试" class="headerlink" title="os内核赛中组件化和异步化尝试"></a>os内核赛中组件化和异步化尝试</h3><p>关于我们的<a href="https://github.com/greatbridf/osdev" target="_blank" rel="noopener">比赛内核</a>，我和我的队友在原先宏内核的基础上做了大量的改动，内容聚焦在组件化拆分以及异步化改造，前者主要集中在工作量上的庞大，如果确定好组件的依赖，如何设计出合适接口，这都需要仔细考量；异步化的改造客观来说工作量也很大，这是async传染性带来的必然，（如果重头构建一个异步内核可能相对好点），所以说目前我们为了必然大范围的传染性，会使用block_on语义的函数做一个暂时解决方案。异步os一个大的优势是不需要对每个task分配内核栈，这确实会节约相当大的内存开销，但任务异步化引入的问题之一就是内核抢占，2024届内核赛获奖内核<a href="https://gitlab.eduxiji.net/educg-group-26010-2376550/T202418123993075-2940" target="_blank" rel="noopener">Phoenix</a>给出的解决方案是通过设置抢占标志允许至多一次的内核抢占，这是一个不错的方案，但通用性能否做的更好一点呢？或许早先组会上听到有无栈的结合是最佳的解决方案，但由于内核比赛测试临近，最近的工作在不停的修syscall，暂时没时间研究，希望能在决赛时拿出我们认为优秀的解决方案。</p>
<p>相关参考资料<br>monoio设计介绍[<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_12/monoio.html]" target="_blank" rel="noopener">https://rustmagazine.github.io/rust_magazine_2021/chapter_12/monoio.html]</a><br>iouring介绍[<a href="https://arthurchiao.art/blog/intro-to-io-uring-zh/]" target="_blank" rel="noopener">https://arthurchiao.art/blog/intro-to-io-uring-zh/]</a><br>BBQ论文[<a href="https://www.usenix.org/conference/atc22/presentation/wang-jiawei]" target="_blank" rel="noopener">https://www.usenix.org/conference/atc22/presentation/wang-jiawei]</a><br>AsyncOs[<a href="https://asyncos.github.io]">https://asyncos.github.io]</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/22/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-Wanderlust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/22/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-Wanderlust/" class="post-title-link" itemprop="url">2025春夏开源操作系统训练营四阶段总结报告-Wanderlust</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-22 11:40:42" itemprop="dateCreated datePublished" datetime="2025-06-22T11:40:42+00:00">2025-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>非常高兴能参加开源操作系统训练营第四阶段的学习，并与大家共同进步。</p>
<p>在此，我首先要感谢陈渝老师，您在每周学习中给予的指导和鼓励，成为了我前进的坚实支柱。同时，我也非常感谢其他同学，在第四阶段的学习中，我从大家那里学到了很多，无论是便捷地获取学习资料和代码，还是在遇到疑惑时能找到理解并深入探讨技术的伙伴，都让我受益匪浅。</p>
<p>经历完这四个阶段，我取得了显著的收获：不仅深刻理解了操作系统内部的运行机制，更掌握了通过组件化管理实现现代化操作系统的方法。具体而言，我成功完成了<code>arceos-org/oscamp</code>的<code>aarch64</code>架构支持，并为<code>starry-next</code>适配了<code>iperf</code>的<code>TCP</code>部分。</p>
<h1 id="任务1-完成arceos-org-oscamp对aarch64架构的支持"><a href="#任务1-完成arceos-org-oscamp对aarch64架构的支持" class="headerlink" title="任务1 完成arceos-org/oscamp对aarch64架构的支持"></a>任务1 完成<code>arceos-org/oscamp</code>对<code>aarch64</code>架构的支持</h1><ol>
<li><p>使用<code>QEMU</code>的<code>monitor info mtree</code> 和<code>monitor info block</code> 找出<code>pflash</code>区域，并在<a href="https://github.com/879650736/oscamp/blob/main/arceos/platforms/aarch64-qemu-virt.toml" target="_blank" rel="noopener">aarch64-qemu-virt.toml</a>中增加正确的映射区域，在<code>tour</code>代码中写入正确的<code>PFLASH_START</code></p>
</li>
<li><p>增加了<code>aarch64</code>部分的<a href="https://github.com/879650736/oscamp/blob/main/arceos/modules/axhal/src/arch/aarch64/context.rs" target="_blank" rel="noopener">uspace</a>代码，进行适配</p>
</li>
<li><p>对<a href="https://github.com/879650736/oscamp/blob/main/arceos/Makefile" target="_blank" rel="noopener">makefile</a>内的规则进行修改，修改<a href="https://github.com/879650736/oscamp/blob/main/arceos/scripts/make/utils.mk" target="_blank" rel="noopener"><code>payload</code>、<code>mk_pflash</code></a>对其他架构进行适配</p>
</li>
<li><p>增加<a href="https://github.com/879650736/oscamp/blob/main/arceos/payload/Makefile" target="_blank" rel="noopener">payload</a>(<a href="https://github.com/879650736/oscamp/blob/main/arceos/payload/hello_c/Makefile" target="_blank" rel="noopener">https://github.com/879650736/oscamp/blob/main/arceos/payload/hello_c/Makefile</a> )(<a href="https://github.com/879650736/oscamp/blob/main/arceos/payload/origin/Makefile" target="_blank" rel="noopener">https://github.com/879650736/oscamp/blob/main/arceos/payload/origin/Makefile</a> )内其他架构的编译规则，使<code>payload</code>对其他架构也能适配</p>
</li>
<li><p>增加<a href="https://github.com/879650736/oscamp/blob/main/scripts/tour_test.sh" target="_blank" rel="noopener">aarch64</a>的CI测试,并测试通过</p>
</li>
<li><p>pr：<a href="https://github.com/arceos-org/oscamp/pull/9" target="_blank" rel="noopener">https://github.com/arceos-org/oscamp/pull/9</a></p>
</li>
<li><p>fork仓库：<a href="https://github.com/879650736/oscamp" target="_blank" rel="noopener">https://github.com/879650736/oscamp</a></p>
</li>
</ol>
<h1 id="任务2-为starry-next适配iperf"><a href="#任务2-为starry-next适配iperf" class="headerlink" title="任务2 为starry-next适配iperf"></a>任务2 为<code>starry-next</code>适配<code>iperf</code></h1><ol>
<li><p>提交<a href="https://github.com/oscomp/starry-next/pull/56/files" target="_blank" rel="noopener">https://github.com/oscomp/starry-next/pull/56/files</a> 。修复了<code>oscomp/starry-next</code>中的c中的<code>sockaddr</code>和<code>arceos/axnet</code>中的<code>SocketAddr</code>的类型转换问题，改为使用trait直接将<code>sockaddr</code> 转换为<code>SocketAddr</code>，而不需要加一个中间层<code>SockAddr</code>,并测试通过。已合并。</p>
</li>
<li><p>提交<a href="https://github.com/oscomp/testsuits-for-oskernel/pull/52" target="_blank" rel="noopener">https://github.com/oscomp/testsuits-for-oskernel/pull/52</a> 。在为 <code>starry-next</code> 兼容 <code>iperf</code>的过程中，我发现一个段错误问题。具体来说，如果在<code>cJSON_New_Item</code> 函数中未对全局变量 <code>global_hooks</code>进行初始化，会导致空指针访问。然而，当我单独编译<code>cJSON</code>的相关代码时，并未复现此异常。我推测这可能是由于编译为 ELF 文件时，编译器进行了某种优化所致。将 <code>global_hooks</code>的初始化操作增加到<code>cJSON_New_Item</code>函数的起始位置后，该段错误便得以消除。</p>
</li>
<li><p><code>musl</code>无<code>openssl</code>库，使用<a href="https://github.com/879650736/starry-next-net/blob/test/apps/iperf/build_riscv.sh" target="_blank" rel="noopener">build_riscv.sh</a>, 进行openssl库的交叉编译</p>
</li>
<li><p>创建<a href="https://github.com/879650736/starry-next-net/blob/test/apps/iperf_wrap/Makefile" target="_blank" rel="noopener">iperf_wrap</a>， 进行本地编译载入测试</p>
</li>
<li><p>在<code>arceos/modules/axfs/src/mount.rs</code>中增加<code>/dev/urandom</code>的挂载,并增加了一个简单的<a href="https://github.com/879650736/axfs_crates/blob/main/axfs_devfs/src/urandom.rs" target="_blank" rel="noopener">urandom</a>的实现</p>
</li>
<li><p>修改iperf中 <code>autoreconf</code>的<a href="https://github.com/879650736/testsuits-for-oskernel/blob/pre-2025/iperf/configure.ac" target="_blank" rel="noopener">configure.ac</a>，增加<code>--disable-xxxx</code>选项的支持</p>
</li>
<li><p>实现可增加<code>--disable</code>参数去除部分 Linux 特有的选项如<code>SO_MAX_PACING_RATE</code>、<code>SO_BINDTODEVICE</code>、<code>IP_MTU_DISCOVER</code>等，为交叉编译提供支持，参考 <a href="https://github.com/879650736/testsuits-for-oskernel/blob/pre-2025/iperf/build.sh" target="_blank" rel="noopener">build.sh</a>,宏定义生成结果可通过<code>src/iperf_config.h</code>查看，也为调试提供方便。</p>
</li>
<li><p>允许用户在配置 <code>iperf3</code> 时，通过命令行参数禁用特定的功能或特性，特别是那些可能与特定操作系统（如 Linux）紧密相关的特性，以便于在其他平台或进行交叉编译时避免兼容性问题。</p>
<ul>
<li><p>在 <code>configure.ac</code> 文件中使用 <code>AC_ARG_ENABLE</code> 宏来定义新的配置选项。</p>
</li>
<li><p>以 <code>--disable-have-dont-fragment</code> 为例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check if Don't Fragment support should be disabled</span></span><br><span class="line">AC_ARG_ENABLE([have-dont-fragment],</span><br><span class="line">    [AS_HELP_STRING([--<span class="built_in">disable</span>-have-dont-fragment], [Disable Don<span class="string">'t Fragment (DF) packet support])],</span></span><br><span class="line"><span class="string">    [</span></span><br><span class="line"><span class="string">        case "$enableval" in</span></span><br><span class="line"><span class="string">        yes|"")</span></span><br><span class="line"><span class="string">            disable_have_dont_fragment=false</span></span><br><span class="line"><span class="string">            ;;</span></span><br><span class="line"><span class="string">        no)</span></span><br><span class="line"><span class="string">            disable_have_dont_fragment=true</span></span><br><span class="line"><span class="string">            ;;</span></span><br><span class="line"><span class="string">        *)</span></span><br><span class="line"><span class="string">            AC_MSG_ERROR([Invalid --enable-have-dont-fragment value])</span></span><br><span class="line"><span class="string">            ;;</span></span><br><span class="line"><span class="string">        esac</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    [disable_have_dont_fragment=false]</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if test "x$disable_have_dont_fragment" = "xtrue"; then</span></span><br><span class="line"><span class="string">    AC_MSG_WARN([Don'</span>t Fragment (DF) packet support disabled by user])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">"x<span class="variable">$iperf3_cv_header_dontfragment</span>"</span> = <span class="string">"xyes"</span>; <span class="keyword">then</span></span><br><span class="line">        AC_DEFINE([HAVE_DONT_FRAGMENT], [1], [Have IP_MTU_DISCOVER/IP_DONTFRAG/IP_DONTFRAGMENT sockopt.])</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><code>AC_ARG_ENABLE([have-dont-fragment], ...)</code> 定义了 <code>--disable-have-dont-fragment</code> 选项。<br>如果用户指定了 <code>--disable-have-dont-fragment</code>，则 <code>disable_have_dont_fragment</code> 变量被设置为 <code>true</code>。<br>如果 <code>disable_have_dont_fragment</code> 为 <code>true</code>，则会发出警告，并且不会定义 <code>HAVE_DONT_FRAGMENT</code> 宏。<br>否则（用户未禁用），并且如果 <code>Autoconf</code> 之前的检查 (<code>iperf3_cv_header_dontfragment</code>) 确认系统支持 <code>IP_MTU_DISCOVER</code> 等选项，则会定义 <code>HAVE_DONT_FRAGMENT</code> 宏。</p>
</li>
<li><p>针对 Linux 特有的套接字选项（如 <code>SO_MAX_PACING_RATE</code>、<code>SO_BINDTODEVICE、IP_MTU_DISCOVER</code>），提供 <code>--disable</code> 选项，以便在非 Linux 环境下（如交叉编译到嵌入式系统或其他操作系统）能够顺利编译，避免因缺少这些特性而导致的在其他环境下的运行错误。</p>
</li>
<li><p>其通用模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个名为 'have-feature-name' 的选项</span></span><br><span class="line">AC_ARG_ENABLE([have-feature-name],</span><br><span class="line">    [AS_HELP_STRING([--<span class="built_in">disable</span>-have-feature-name], [Disable support <span class="keyword">for</span> Feature Name])],</span><br><span class="line">    [</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$enableval</span>"</span> <span class="keyword">in</span></span><br><span class="line">        yes|<span class="string">""</span>)</span><br><span class="line">            disable_feature_name=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        no)</span><br><span class="line">            disable_feature_name=<span class="literal">true</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            AC_MSG_ERROR([Invalid --<span class="built_in">enable</span>-have-feature-name value])</span><br><span class="line">            ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">    ],</span><br><span class="line">    [disable_feature_name=<span class="literal">false</span>] <span class="comment"># 默认启用</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据用户选择和系统检测结果，决定是否定义宏</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="string">"x<span class="variable">$disable_feature_name</span>"</span> = <span class="string">"xtrue"</span>; <span class="keyword">then</span></span><br><span class="line">    AC_MSG_WARN([Feature Name support disabled by user])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 这里可以添加额外的系统特性检测，例如检查头文件、函数或套接字选项</span></span><br><span class="line">    <span class="comment"># if test "x$ac_cv_header_some_header" = "xyes"; then</span></span><br><span class="line">        AC_DEFINE([HAVE_FEATURE_NAME], [1], [Description of the feature macro.])</span><br><span class="line">    <span class="comment"># fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
<li><p>当修改了 <code>configure.ac</code> 文件后，仅仅保存文件是不够的。<code>configure.ac</code> 是 <code>Autoconf</code> 的输入文件，它需要被处理才能生成实际的 <code>configure</code> 脚本。这个处理过程就是通过运行 <code>autoreconf</code> 命令来完成的。</p>
</li>
<li><p><code>autoreconf</code> 命令会执行一系列工具（如 <code>aclocal</code>, <code>autoconf</code>, <code>autoheader</code>, <code>automake</code> 等），它们会：</p>
<ol>
<li>处理 <code>configure.ac</code>： 将 <code>configure.ac</code> 中的 <code>Autoconf</code> 宏转换为可执行的 <code>shell</code> 脚本代码，生成 <code>configure</code> 脚本。</li>
<li>生成 <code>config.h.in</code>： 如果你的 <code>configure.ac</code> 中使用了 <code>AC_CONFIG_HEADERS</code>，<code>autoheader</code> 会根据 <code>AC_DEFINE</code> 等宏生成 <code>config.h.in</code> 文件，这是一个模板文件，最终会被 <code>configure</code> 脚本处理成 <code>config.h</code>。</li>
<li>处理 <code>Makefile.am</code>： 如果项目使用了 <code>Automake</code>，<code>automake</code> 会处理 <code>Makefile.am</code> 文件，生成 <code>Makefile.in</code>。<br>因此，每次修改 <code>configure.ac</code> 后，你都必须在项目根目录运行 <code>autoreconf -fi</code> 命令，以确保这些修改能够体现在新生成的 <code>configure</code> 脚本中。 否则，你新添加的 <code>--disable-xxxx</code> 选项将不会被识别。</li>
</ol>
</li>
<li><p>在 <code>build.sh</code> 脚本中，可以根据编译目标或环境变量来决定是否添加这些 <code>--disable</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="built_in">disable</span>-have-dont-fragment --<span class="built_in">disable</span>-openssl --<span class="built_in">disable</span>-cpu-affinity  </span><br><span class="line">........</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在<code>api/src/imp</code>中进行<a href="https://github.com/879650736/starry-next-net/tree/test/api/src/imp" target="_blank" rel="noopener">syscall</a>的适配</p>
<ul>
<li><p>新增调用列表</p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/net/getsock.rs" target="_blank" rel="noopener"><code>sys_getsockname</code>、<code>sys_getpeername</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/net/poll.rs" target="_blank" rel="noopener"><code>sys_poll</code>、<code>sys_ppoll</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/net/recv.rs" target="_blank" rel="noopener"><code>sys_recvfrom</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/net/select.rs" target="_blank" rel="noopener"><code>sys_select</code>、<code>sys_pselect6</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/net/send.rs" target="_blank" rel="noopener"><code>sys_sendto</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/net/socket.rs" target="_blank" rel="noopener"><code>sys_socket</code>、<code>sys_socketpair</code>、<code>sys_bind</code>、<code>sys_connect</code>、<code>sys_setsockopt</code>、<code>sys_getsockopt</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/fs/fd_ops.rs" target="_blank" rel="noopener"><code>sys_fcntl</code>的<code>F_GETFL</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/fs/io.rs" target="_blank" rel="noopener"><code>sys_ftruncate</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/rusage.rs" target="_blank" rel="noopener"><code>sys_getrusage</code></a></p>
</li>
<li><p><a href="https://github.com/879650736/starry-next-net/blob/test/api/src/imp/time.rs" target="_blank" rel="noopener"><code>sys_clock_gettime</code>的<code>CLOCK_PROCESS_CPUTIME_ID</code></a></p>
</li>
<li><p>全部通过<a href="https://github.com/879650736/starry-next-net/tree/test/apps/libc/c" target="_blank" rel="noopener"><code>libc</code></a>测例测试，并测试通过</p>
</li>
</ul>
</li>
<li><p>对于跨平台elf调试，使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">assert(i == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>进行手动打断点结合<code>printf</code>一步步调试，最终找到<a href="https://github.com/oscomp/testsuits-for-oskernel/pull/52" target="_blank" rel="noopener">https://github.com/oscomp/testsuits-for-oskernel/pull/52</a> 的段错误的具体问题。</p>
</li>
<li><p><code>iperf3</code>测量原理</p>
<ul>
<li><strong>基本工作流程：</strong></li>
</ul>
<ol>
<li><strong>服务器端启动：</strong> 一台机器作为服务器端，启动 <code>iperf3</code> 并监听特定端口，等待客户端连接。</li>
<li><strong>客户端启动：</strong> 另一台机器作为客户端，启动 <code>iperf3</code> 并指定服务器的IP地址和端口，发起连接请求。</li>
<li><strong>数据传输：</strong> 连接建立后，客户端或服务器（取决于测试模式）开始发送数据包。</li>
<li><strong>性能测量：</strong> 双方在数据传输过程中记录时间、传输数据量、丢包等信息。</li>
<li><strong>结果报告：</strong> 传输结束后，客户端和/或服务器会计算并报告测量的网络性能指标。</li>
</ol>
<ul>
<li>在本机<code>apt install iperf3</code>后，自动安装并自启动了<code>/usr/lib/systemd/system/iperf3.service</code></li>
</ul>
<figure class="highlight plain"><figcaption><span>text </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iperf3.service - iperf3 server</span><br><span class="line">    Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;iperf3.service; enabled; preset: enabled)</span><br><span class="line">    Active: active (running) since Fri 2025-06-20 05:23:30 UTC; 7h ago</span><br><span class="line">      Docs: man:iperf3(1)</span><br><span class="line">  Main PID: 1326 (iperf3)</span><br><span class="line">    Tasks: 1 (limit: 9434)</span><br><span class="line">    Memory: 472.0K (peak: 5.4M swap: 440.0K swap peak: 440.0K)</span><br><span class="line">      CPU: 30.580s</span><br><span class="line">    CGroup: &#x2F;system.slice&#x2F;iperf3.service</span><br><span class="line">            └─1326 &#x2F;usr&#x2F;bin&#x2F;iperf3 --server --interval 0</span><br></pre></td></tr></table></figure>

<p>  每次开机后，<code>systemd</code> 会根据 <code>iperf3.service</code> 的定义，自动启动 <code>/usr/bin/iperf3 --server --interval 0</code> 命令，使其作为后台服务持续运行，等待客户端连接。</p>
<ul>
<li><p>当你在本机运行 <code>iperf3 -c 127.0.0.1</code> 时，这个命令会启动一个 <code>iperf3</code> 客户端进程。这个客户端进程会尝试连接到 <code>127.0.0.1</code>（即本机）上正在监听的 <code>iperf3</code> 服务器。<code>iperf3 -c 127.0.0.1</code> 会向服务器发送数据包，服务器接收这些包并进行统计。客户端也会统计发送的数据量和时间，最终报告发送端的吞吐量。</p>
</li>
<li><p>客户端和服务器之间建立 TCP 连接（默认）。客户端以尽可能快的速度向服务器发送数据，服务器接收并记录数据量。双方都记录开始和结束时间。通过传输的数据量除以传输时间，即可计算出吞吐量。</p>
</li>
<li><p>在<code>qemu</code>内运行的<code>starry-next</code>同理，因为<code>qemu</code>与主机是通过<code>NAT</code>。在 <code>qemu</code> 虚拟机内部运行的 <code>starry-next</code>（假设它也包含 <code>iperf3</code> 客户端或服务器）与主机之间的网络通信，会经过 <code>qemu</code> 的网络虚拟化层。</p>
</li>
<li><p>当 <code>qemu</code> 使用 NAT（网络地址转换）模式时，虚拟机拥有一个私有 IP 地址，它通过主机的 IP 地址访问外部网络。对于虚拟机来说，主机看起来像一个路由器。</p>
</li>
<li><p>场景 : <code>qemu</code> 内的 <code>iperf3</code> 客户端连接到主机上的 <code>iperf3</code> 服务器。</p>
</li>
<li><p><code>qemu</code> 虚拟机内的 <code>iperf3 -c &lt;主机IP地址&gt;</code>。</p>
</li>
<li><p>数据流：<code>qemu</code> 客户端 -&gt; <code>qemu</code> 虚拟网卡 -&gt; <code>qemu</code> NAT 转换 -&gt; 主机物理网卡 -&gt; 主机 <code>iperf3</code> 服务器。</p>
</li>
<li><p>这种测试测量的是虚拟机到主机之间的网络性能，包括 <code>qemu</code> NAT 层的开销。</p>
</li>
<li><p>无论哪种场景，<code>iperf3</code> 的基本客户端-服务器通信原理不变。<code>qemu</code> 的 NAT 模式只是在网络路径中增加了一个虚拟化的层，<code>iperf3</code> 测量的是经过这个虚拟化层后的实际吞吐量。 </p>
</li>
<li><p>关键设计点：</p>
</li>
<li><h3 id="处理程序中断信号（如-Ctrl-C）的机制。它使用了-signal-和-setjmp-longjmp-组合来实现非局部跳转，以便在接收到中断信号时能够优雅地退出并报告结果。"><a href="#处理程序中断信号（如-Ctrl-C）的机制。它使用了-signal-和-setjmp-longjmp-组合来实现非局部跳转，以便在接收到中断信号时能够优雅地退出并报告结果。" class="headerlink" title="处理程序中断信号（如 Ctrl+C）的机制。它使用了 signal 和 setjmp/longjmp 组合来实现非局部跳转，以便在接收到中断信号时能够优雅地退出并报告结果。"></a>处理程序中断信号（如 <code>Ctrl+C</code>）的机制。它使用了 <code>signal</code> 和 <code>setjmp/longjmp</code> 组合来实现非局部跳转，以便在接收到中断信号时能够优雅地退出并报告结果。</h3></li>
<li><p><code>iperf_catch_sigend</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">iperf_catch_sigend(<span class="keyword">void</span> (*handler)(<span class="keyword">int</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SIGINT</span></span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SIGTERM</span></span><br><span class="line">    signal(SIGTERM, handler);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SIGHUP</span></span><br><span class="line">    signal(SIGHUP, handler);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将 <code>sigend_handler</code> 函数注册为 <code>SIGINT</code>, <code>SIGTERM</code>, <code>SIGHUP</code> 这三个信号的处理函数。这意味着当程序接收到这些信号中的任何一个时，<code>sigend_handler</code> 函数就会被调用。</p>
</li>
<li><h3 id="信号处理的设置和跳转点"><a href="#信号处理的设置和跳转点" class="headerlink" title="信号处理的设置和跳转点"></a>信号处理的设置和跳转点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iperf_catch_sigend(sigend_handler); <span class="comment">// 注册信号处理函数</span></span><br><span class="line"><span class="keyword">if</span> (setjmp(sigend_jmp_buf))&#123; <span class="comment">// 设置跳转点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"caught SIGEND\n"</span>);</span><br><span class="line">    iperf_got_sigend(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>if (setjmp(sigend_jmp_buf))</code>： 这是 <code>setjmp/longjmp</code> 机制的关键。</li>
<li><code>setjmp(sigend_jmp_buf)</code>：<br>第一次调用时（正常执行流程）： 它会保存当前程序的执行上下文到<code>sigend_jmp_buf</code> 中，并返回 0。因此，<code>if (setjmp(...))</code>条件为假，程序会继续执行 if 语句块后面的代码。</li>
<li>当 <code>longjmp</code>被调用时（从信号处理函数中）：<code>longjmp</code> 会使用 <code>sigend_jmp_buf</code>中保存的上下文，使程序“跳回”到 <code>setjmp</code> 被调用的位置。此时，<code>setjmp</code> 会返回<code>longjmp</code> 传递的非零值（这里是 1）。因此，<code>if (setjmp(...))</code>条件为真，if 语句块内的代码会被执行。</li>
</ul>
</li>
<li><h3 id="sigend-handler-函数"><a href="#sigend-handler-函数" class="headerlink" title="sigend_handler 函数"></a><code>sigend_handler</code> 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> jmp_buf sigend_jmp_buf; <span class="comment">// 用于存储跳转上下文的缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __attribute__ ((noreturn))</span><br><span class="line">sigend_handler(<span class="keyword">int</span> sig)</span><br><span class="line">&#123;</span><br><span class="line">    longjmp(sigend_jmp_buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是实际的信号处理函数。<br><code>__attribute__ ((noreturn))</code>： 这是一个 GCC 扩展属性，告诉编译器这个函数不会返回（即它会通过 longjmp 跳转出去，而不是正常返回）。这有助于编译器进行优化，并避免一些警告。<br><code>longjmp(sigend_jmp_buf, 1);</code>： 这是核心操作。当<code>SIGINT</code>、<code>SIGTERM</code> 或 <code>SIGHUP</code> 信号被捕获时，这个函数会被调用，然后它会执行<code>longjmp</code>。</li>
<li><code>longjmp</code> 会将程序的执行流从当前位置（信号处理函数内部）直接跳转到 <code>setjmp(sigend_jmp_buf)</code>所在的位置。</li>
</ul>
</li>
<li><h3 id="iperf-got-sigend-函数"><a href="#iperf-got-sigend-函数" class="headerlink" title="iperf_got_sigend 函数"></a><code>iperf_got_sigend</code> 函数</h3><ul>
<li>捕获到中断信号后，实际执行清理、报告和退出的函数</li>
</ul>
</li>
<li><p>这段代码实现了一个健壮的信号处理机制，确保 <code>iperf3</code> 在接收到中断信号（如 <code>Ctrl+C</code>）时，能够：</p>
<ol>
<li>立即停止当前的数据传输。</li>
<li>收集并报告截至中断时的所有统计数据。</li>
<li>通过控制连接通知另一端的 iperf3 进程，以便对方也能感知到测试的结束并进行相应的处理。</li>
<li>最终优雅地退出程序。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="适配成功："><a href="#适配成功：" class="headerlink" title="适配成功："></a>适配成功：</h2><p>  <img src="./2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-Wanderlust/iperf-V.png" alt="iperf-V"><br>  <img src="./2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-Wanderlust/iperf-c.png" alt="iperf-c"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/21/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-elebirds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/21/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-elebirds/" class="post-title-link" itemprop="url">2025春夏季开源操作系统训练营第四阶段学习总结-elebirds</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-21 17:31:41" itemprop="dateCreated datePublished" datetime="2025-06-21T17:31:41+00:00">2025-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025春夏季开源操作系统训练营第四阶段学习总结"><a href="#2025春夏季开源操作系统训练营第四阶段学习总结" class="headerlink" title="2025春夏季开源操作系统训练营第四阶段学习总结"></a>2025春夏季开源操作系统训练营第四阶段学习总结</h1><p>2025春夏季我参加了开源操作系统训练营，第四阶段的任务是具体实践，以下是我在这个阶段的学习总结。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/06/21/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-elebirds/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/21/oscamp-stage4-summary-wyd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/21/oscamp-stage4-summary-wyd/" class="post-title-link" itemprop="url">oscamp_stage4_summary_wyd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-21 16:58:10" itemprop="dateCreated datePublished" datetime="2025-06-21T16:58:10+00:00">2025-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>非常高兴能参加今年的操作系统训练营，经过这四个阶段的学习，对操作系统的理解逐渐加深。在此过程中，对陈渝老师和郑友捷老师的耐心指导表示衷心感谢。</p>
<p>在第四阶段的学习中，我主要做了以下工作：</p>
<ol>
<li><h2 id="starry-next支持新特性：大页分配"><a href="#starry-next支持新特性：大页分配" class="headerlink" title="starry-next支持新特性：大页分配"></a>starry-next支持新特性：大页分配</h2><ol>
<li><h3 id="后端映射实现"><a href="#后端映射实现" class="headerlink" title="后端映射实现"></a>后端映射实现</h3><ol>
<li>修改后端数据结构，为<code>Linear</code>和<code>Alloc</code>这两种映射方式增加对齐参数<code>align</code>，该参数的类型为<code>PageSize</code>。根据对齐方式，分配相应的内存块。</li>
<li>修改物理页帧的分配方法<code>alloc_frame</code>，以4KB为单位，根据对齐参数大小，计算页面数量<code>num_pages</code>，调用全局分配器，分配<code>num_pages</code>个连续的物理页面，将这段连续内存的地址返回并映射到页表中，作为一整个页面。</li>
<li>修改释放方法<code>dealloc_frame</code>，基于以上<code>alloc_frame</code>，物理页帧的释放同理，根据对齐参数，以4KB为单位，计算需要释放的物理页帧数量，并调用全局分配器，释放这一段连续的物理内存。</li>
<li>修改空闲内存查找方法<code>find_free_area</code>，为适配不同的对齐要求，该函数首先对建议的起始地址<code>hint</code>进行对齐，然后执行两轮扫描，第一轮扫描处理<code>hint</code>之前的区域，以确定起始搜索位置，第二轮扫描检查各内存区域之间的空隙，跳过重叠和已占用的区域，检查满足对齐要求和大小的区域，最后检查末尾区域，验证并返回找到的地址。</li>
<li>修改<code>unmap</code>方法，考虑取消映射的内存区域可能存在不同对齐的情况，对<code>unmap</code>方法进行改进。首先验证起始地址和大小是否满足4K对齐，然后查找定位取消映射的内存块，根据每个内存块的对齐要求，验证对齐，最后执行取消映射。</li>
<li>增加一个<code>page_iter_wraper.rs</code>文件，包装<code>PageIter4K</code>，<code>PageIter2M</code>，<code>PageIter1G</code>为一个<code>PageIterWrapper</code>，方便遍历。</li>
<li>对线性映射，文件读写，DMA和懒分配的支持，在相关函数如<code>new_linear</code>，<code>process_area_data</code>，<code>handle_page_fault</code>中增加对齐参数支持不同页面的对齐要求。</li>
</ol>
</li>
<li><h3 id="内存扩展"><a href="#内存扩展" class="headerlink" title="内存扩展"></a>内存扩展</h3><ol>
<li>为测试大页尤其是1G大页的分配，读写和回收等情况，需要扩展平台内存以运行测例。<ol>
<li>修改<code>aarch64</code>架构配置文件，修改其物理内存大小为4G</li>
<li>修改<code>riscv64</code>架构配置文件，修改其物理内存大小为4G</li>
<li>修改<code>loongarch64</code>架构的配置文件，扩展其物理内存，并修改其物理基址和内核基址以避免内存重叠</li>
<li>修改<code>x86_64</code>架构的配置文件，扩展其物理内存，在<code>mmio-regions</code>新增高地址支持，修改<code>modules/axhal/src/mem.rs</code>文件，新增free_memory_region，扩展<code>x86_pc</code>中的<code>multiboot.S</code>支持高位地址空间</li>
</ol>
</li>
<li>扩展内存之后在所有架构下测试</li>
<li>将以上所做的修改工作落实成文档提交</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="分析和改进axalloc"><a href="#分析和改进axalloc" class="headerlink" title="分析和改进axalloc"></a>分析和改进axalloc</h2><ol>
<li>分析axalloc代码逻辑，撰写<a href="https://github.com/Ticonderoga2017/arceos_blog" target="_blank" rel="noopener">文档</a></li>
<li>改进axalloc<ol>
<li>新增<a href="https://github.com/Ticonderoga2017/arceos/blob/buddy_page/modules/axalloc/src/buddy_page.rs" target="_blank" rel="noopener">buddy_page.rs</a>，基于buddy算法，实现了一个页分配器，并添加相关的测试模块。实现思路如下：<ol>
<li><strong>初始化过程：</strong>将起始地址和结束地址对齐到页边界，内存基址对齐到1G边界（与arceos的<code>BitmapPageAllocator</code>保持一致），将整个内存区域分解为最大可能的2的幂次个块。</li>
<li><strong>分配算法：</strong>检查需要分配的页面数量和页面大小，验证其是否与<code>PAGE_SIZE</code>对齐，根据所需页面数量和对齐，计算所需阶数，查找可用块，将大块分割到所需大小，将多余部分加入对应的空闲链表，标记页面为已分配，更新使用统计。</li>
<li><strong>释放与合并算法：</strong>首先标记当前块为空闲，然后递归检查伙伴块是否空闲，如果是则合并，将最终合并的块加入到对应阶数的空闲链表。</li>
</ol>
</li>
<li>新增<a href="https://github.com/Ticonderoga2017/arceos/blob/buddy_page/modules/axalloc/src/tests.rs" target="_blank" rel="noopener">tests.rs</a>，提供一个基准测试模块，用于比较<code>BitmapPageAllocator</code>和<code>BuddyPageAllocator</code>两种页分配器的性能表现。该测试模块包含两个主要测试函数，用于评估不同分配器在碎片化和内存合并方面的表现 ，测试结果如下：<img src="oscamp-stage4-summary-wyd/image-20250621162956014.png" alt="image-20250621162956014"><ol>
<li><strong>合并效率测试结果：</strong>两个分配器都显示了 100% 的合并效率，这意味着它们都能完美地将释放的单页重新合并成大的连续内存块</li>
<li><strong>碎片化测试结果分析：</strong><ul>
<li><strong>Random Small Pattern（随机小块分配）:</strong><ul>
<li>Bitmap: 50.0% 碎片化率</li>
<li>Buddy: 83.3% 碎片化率</li>
<li><strong>BitmapPageAllocator 表现更好</strong></li>
</ul>
</li>
<li><strong>Mixed Size Pattern（混合大小分配）:</strong><ul>
<li>Bitmap: 41.7% 碎片化率</li>
<li>Buddy: 33.3% 碎片化率</li>
<li><strong>BuddyPageAllocator 表现更好</strong></li>
</ul>
</li>
<li><strong>Power-of-2 Pattern（2的幂次分配）:</strong><ul>
<li>Bitmap: 16.7% 碎片化率</li>
<li>Buddy: 33.3% 碎片化率</li>
<li><strong>BitmapPageAllocator 表现更好</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/21/%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%94%B9%E8%BF%9BStarry%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/21/%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%94%B9%E8%BF%9BStarry%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">开源操作系统训练营第四阶段总结-改进Starry文档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-21 02:23:23" itemprop="dateCreated datePublished" datetime="2025-06-21T02:23:23+00:00">2025-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="开源操作系统训练营第四阶段总结-改进Starry文档"><a href="#开源操作系统训练营第四阶段总结-改进Starry文档" class="headerlink" title="开源操作系统训练营第四阶段总结-改进Starry文档"></a>开源操作系统训练营第四阶段总结-改进Starry文档</h1><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>赶着入职前进入到了第四阶段，留给我的时间不多，都不到一周，但是陈老师没有放弃我，仍然耐心的给与了我如何开始学习Starry的指导，我非常感动。四阶段项目一群中的群友也给与了我很大的帮助，让我感受到了开源社区的魅力。</p>
<p>在四阶段学习中，我收获良多，由于不是计算机专业的学生，有许许多多的第一次：</p>
<ul>
<li>第一次学习操作系统：还是 RISCV 指令集的，在MacOS上跑代码没少折腾。很多内容让我回想起了本科学习计算机组成原理的时光（还是很不相同）。</li>
<li>第一次使用 docker：本来倔强的我想在 MacOS 上坚持到最后，没想到还是在第三阶段涉及到交叉编译的部分败下阵来，配置 docker 环境的时候可能由于网络问题也没少折腾。</li>
<li>第一次提交 PR：之前使用GitHub也只是上传论文的代码，单打独斗。在刚进入第四阶段的时候，陈老师很耐心的用一个修改 README.md 的机会指导我怎么提交 PR。第一次了解了团队合作乐趣。</li>
<li>第一次了解 GitHub 工作流：前三阶段大概知道有这么一个东西在给我们提交的文档打分，在第三阶段中 musl 被官方屏蔽了微软的访问之后一直访问超时，我才开始去理解其中的含义。</li>
</ul>
<p>闲聊了这么多，还是因为我入门尚浅，翻来覆去看代码也只知道还要学习的有很多，难以下手，留给我的时间又只有一周。还好陈老师给我指了一条明路——完善文档，接下来我就介绍一下这一周我的工作以及将来的计划。</p>
<h2 id="本周工作"><a href="#本周工作" class="headerlink" title="本周工作"></a>本周工作</h2><p>我的工作主要是分析starry-next，并阅读 starry-next tutorial book，从各个层面改进starry-next tutorial book，帮助自己和其他初学者更好地学习操作系统开发。</p>
<p>在开始完善文档之前，我阅读了郑友捷同学的综合论文训练——《组件化操作系统 ArceOS 的异构实践》，宏观的了解了 StarryOS 的设计理念和目标。在完善文档的过程中，郑友捷同学也给予了我很多建议和指导，在此表示感谢。</p>
<p>我的工作具体如下：</p>
<ol>
<li><p><a href="https://github.com/Azure-stars/Starry-Tutorial-Book/pull/23" target="_blank" rel="noopener">PR#23</a> 修复了指导书不能切换主题的bug, 可以切换到深色模式，便于完善文档时的调试（一边黑一边亮容易被吸引注意力）。</p>
</li>
<li><p><a href="https://github.com/Azure-stars/Starry-Tutorial-Book/pull/24" target="_blank" rel="noopener">PR#24</a> 在阅读完郑同学的论文之后，修改了文档的欢迎页，说明了 StarryOS 和 ArceOS 之间的关系和差别。因为从第三阶段到第四阶段，作为初学者的我一开始是一头雾水，不知道 Starry 要实现一个什么样的目标，所以我也在欢迎页添加了设计目标的说明（仍需完善）。在我与郑同学的交流中感觉到 Starry 的目标可能是：</p>
<ul>
<li><p>在 crate 层中希望能够开发一些独立的组件，一部分就像 ArceOS 一样，能够被任意类型内核复用， 一部分则是能够被其他的宏内核使用。</p>
</li>
<li><p>使 Starry 能够兼容 Linux 程序，即提供 POSIX API 接口。</p>
</li>
<li><p>完成作为一个宏内核该有的功能，包括进程管理、信号处理等。</p>
<p>作为一个第一次接触 Starry 的开发者，我觉得可能还需要一个更宏大的目标，或者更明确的商用的可能性来吸引更多的人加入我们的开源社区，并做出贡献。</p>
</li>
</ul>
</li>
<li><p><a href="https://github.com/Azure-stars/Starry-Tutorial-Book/pull/25" target="_blank" rel="noopener">pr#25</a> 在进入到第四阶段的时候，配置完环境后，只是按照 README.md 中给的指令运行了一遍，但是依然没有理解具体 Starry 究竟做了些什么，他的目标是什么。而且我在创建镜像的过程中遇到了一些问题——loop设备满了导致无法加载，我也是通过读了一遍Makefile的流程才定位到这个错误。因而我写了一个一个案例快速上手 Starry，介绍了这些指令内部的一些细节，帮助初学者快速理解。PS: 今天我再读的时候发现了其中的一些错误（镜像文件应该是给QEMU加载的，不是ArceOS的文件系统），而且没有介绍案例 nimbos 的主要作用，可能对于学习过操作系统的同学来说，不用说也知道是一个测试操作系统功能的测试集，从一个门外汉的角度来看，他就是测试了几个testcase而已。我会在后续的工作中对文档进行修正。</p>
</li>
<li><p><a href="https://github.com/Azure-stars/Starry-Tutorial-Book/pull/26" target="_blank" rel="noopener">pr#26</a> 可能对于大佬来说，各种 git 指令都已经理解透彻，烂熟于心，但对于初学者来说，只会用一个</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit <span class="string">"update XXX"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p> 在这之前我都没有创建过分支来提交PR，导致了一些混乱，因此在附录中添加了一个创建分支提交PR的标准流程。此外对于理解StarryOS究竟在做什么，理解他的工作流很有必要，因此我也在附录中添加了对于工作流相关的说明。</p>
</li>
</ol>
<h2 id="总结和将来的工作"><a href="#总结和将来的工作" class="headerlink" title="总结和将来的工作"></a>总结和将来的工作</h2><p>由于时间不多，我的水平有限，相比其他同学对社区的贡献，我的工作可能微不足道。如果社区的大佬们不嫌弃，入职工作之后我也愿意继续帮助完成文档（主要因为这个项目里面用到的Rust语法很全面，我想要学习rust， 还包含了很多汇编和c,将来也能对用rust驱动硬件做为一个参考）。</p>
<p>可能有一部分同学和我一样，在阶段一到阶段三主要注重于做题（阅读测例-&gt;知道预期的结果是什么-&gt;查看相关的接口和需要用到的函数-&gt;实现功能），完成任务即可。没有特别理解整体的设计和原理，因而到了阶段四之后没有了题目之后感到迷茫。</p>
<p>因而为了帮助第三阶段的同学能够丝滑的进入到第四阶段，我觉得当务之急是需要完善ArceOS的文档（我第三阶段完全就是参考PPT完成的，对于很多细节没有掌握）我接下来的工作就是理解ArceOS的细节，说明Starry如何使用了ArceOS的接口和模块。然后首先实现文档整体框架的从无到有，最后在掌握了细节和整体设计思路之后再完善指导书并修正其中的错误。也希望有大佬能够一起加入到完善文档队伍中，一起交流。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/21/2025%E5%B9%B4%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-moot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/21/2025%E5%B9%B4%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-moot/" class="post-title-link" itemprop="url">2025年春夏开源操作系统训练营前三阶段总结-moot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-21 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-21T00:00:00+00:00">2025-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/" itemprop="url" rel="index"><span itemprop="name">ArceOS</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/x86/" itemprop="url" rel="index"><span itemprop="name">x86</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>过去一个月，由于我对 ArceOS 的架构理解较少，为了快速掌握 ArceOS 的架构，<strong><em>Unikernel</em></strong> 和 <strong><em>宏内核</em></strong>，我的主要目标改进 <strong><em>oscamp</em></strong>，为其完善对 <strong><em>x86_64</em></strong> 的支持。同时还做了对内核组件 <strong><em>x86_rtc</em></strong> 说明文档和测试的完善。<br>最直接的收获有两点：</p>
<ul>
<li><strong>Unikernel 思想</strong> —— “用户态就是内核的一部分” 的最小可信边界，让我重新审视传统多进程操作系统里“内核/用户”硬隔离的成本。</li>
<li><strong>宏内核工程学</strong> —— 模块划分、内核线程、系统调用网关、设备驱动归一化，这些都在 Starry/ArceOS 的设计里有了“先行者版本”。</li>
</ul>
<hr>
<h2 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h2><h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><p>为了快速掌握 ArceOS 的架构，<strong><em>Unikernel</em></strong> 和 <strong><em>宏内核</em></strong>，我选择了改进 <strong><em>oscamp</em></strong>，为其完善对 <strong><em>x86_64</em></strong> 的支持这一项工作。并开始了对 <strong><em>x86_64</em></strong> 的学习。</p>
<h3 id="第二、三周"><a href="#第二、三周" class="headerlink" title="第二、三周"></a>第二、三周</h3><p>主要是做代码工作，以下是一些总结<br>RISC‑V 是通过 <code>scause</code> + <code>stval</code>；x86‑64 要区分 <strong>Exception Class</strong>（#PF/#UD）与 <strong>IRQ Vector</strong>，且栈布局不一样。<br>对 <strong><em>x86_64</em></strong> 的支持这一项工作需要完成以下的功能实现：</p>
<ol>
<li>改进 <strong><em>context.rs</em></strong>，保存相关的寄存器，并完善 <strong><em>context_switch</em></strong> 和 <strong><em>enter_uspace</em></strong>。<ul>
<li>保存/恢复的寄存器集对齐 <strong>SysV x86‑64</strong> 调用约定：<code>RBX RBP R12‑R15</code> + <code>CR3</code> + <code>RFLAGS</code>；<code>FPU/AVX</code> 延后到 lazy fp 任务。</li>
<li><code>context_switch(old, new)</code> = 保存旧任务栈顶 → 恢复新任务栈顶 → <em><code>iretq</code></em>；为支持 <code>SMP</code>，加了 <code>core::arch::asm!(&quot;swapgs&quot;)</code> 保证每 CPU 的 GS 基址切换。</li>
<li>进入用户态 (<code>enter_uspace</code>)：手动构造 <em><code>iretq</code></em> 帧：<code>SS|RSP|RFLAGS|CS|RIP</code>，再写 <code>CR3 = user_pml4</code>; 关中断→加载帧→开中断→ <em><code>iretq</code></em>。</li>
</ul>
</li>
<li>改进 <strong><em>trap.S</em></strong><ul>
<li><strong>IDT 256 项</strong>：<code>0x20</code> 时钟、<code>0x80</code> 软中断、<code>0x0E</code> #PF……全部指向统一的 <code>trap_entry</code>；硬中断通过 APIC 自动切到 <strong>IST[0] emergency stack</strong> 防止内核栈溢出。</li>
<li><code>trap.rs</code> 根据向量号派发到 <code>handle_page_fault / handle_irq / handle_syscall</code>。</li>
</ul>
</li>
<li>改进 <strong><em>syscall.rs</em></strong> 和 <strong><em>syscall.S</em></strong><ul>
<li>选 <code>SYSCALL/SYSRET</code> 而非 <code>INT 0x80</code>；入口先 <code>swapgs</code> 用 GS 保存/恢复用户栈。</li>
<li>按 SysV ABI <code>RAX</code>=nr，<code>RDI RSI RDX R10 R8 R9</code> 传六参 —— 在汇编里把寄存器序列化到栈，统一传给 <code>x86_syscall_handler()</code>。</li>
<li>退出路径：恢复通用寄存器 → <code>swapgs</code> → <code>sysretq</code></li>
</ul>
</li>
</ol>
<h3 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h3><p>对内核组件 <strong><em>x86_rtc</em></strong> 说明文档和测试的完善。<br><a href="https://github.com/MTttth/x86_rtc.git" target="_blank" rel="noopener">repo</a></p>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><ul>
<li><strong>Transparent HugePages</strong>：复用前期完成的巨页 API，引入 <code>khugepaged</code> 合并线程。</li>
<li><strong>vDSO</strong>：把高频 <code>clock_gettime</code> 胶水放到用户态，加速 Sys‑API。</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/20/Lfan-ke%EF%BC%9AGPGPU%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/20/Lfan-ke%EF%BC%9AGPGPU%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/" class="post-title-link" itemprop="url">GPU GPGPU GPGPGPU！</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-20 13:07:00" itemprop="dateCreated datePublished" datetime="2025-06-20T13:07:00+00:00">2025-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/" itemprop="url" rel="index"><span itemprop="name">ArceOS</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/" itemprop="url" rel="index"><span itemprop="name">阶段四</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/" itemprop="url" rel="index"><span itemprop="name">2025S</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/" itemprop="url" rel="index"><span itemprop="name">OpenCL</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/" itemprop="url" rel="index"><span itemprop="name">GPU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/" itemprop="url" rel="index"><span itemprop="name">GPGPU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/" itemprop="url" rel="index"><span itemprop="name">POCL</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/" itemprop="url" rel="index"><span itemprop="name">WGPU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/" itemprop="url" rel="index"><span itemprop="name">WebGPU</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/" itemprop="url" rel="index"><span itemprop="name">Vortex</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/stage4/" itemprop="url" rel="index"><span itemprop="name">stage4</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/stage4/virtio-v1-2/" itemprop="url" rel="index"><span itemprop="name">virtio-v1.2</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/stage4/virtio-v1-2/Virtio/" itemprop="url" rel="index"><span itemprop="name">Virtio</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E5%9B%9B/2025S/OpenCL/GPU/GPGPU/POCL/WGPU/WebGPU/Vortex/stage4/virtio-v1-2/Virtio/%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">补完计划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>解析`WebGPU`、`Virtio1.2`规范，以及`WGPU`、`Vortex`源码，探索异步操作系统与内核态GPU资源管理的结合方案。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/06/20/Lfan-ke%EF%BC%9AGPGPU%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/20/2025-oscamp-blog-of-hailong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/20/2025-oscamp-blog-of-hailong/" class="post-title-link" itemprop="url">2025 oscamp blog of hailong</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-20 12:43:27" itemprop="dateCreated datePublished" datetime="2025-06-20T12:43:27+00:00">2025-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-17 06:47:54" itemprop="dateModified" datetime="2025-11-17T06:47:54+00:00">2025-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一阶段-rust基础"><a href="#第一阶段-rust基础" class="headerlink" title="第一阶段 rust基础"></a>第一阶段 rust基础</h2><p>rustlings比较顺利，已关注rust好几年了，也一直跟进rust的发展和变化，用了大概几天的时间突击完成</p>
<h2 id="第二阶段-rcore"><a href="#第二阶段-rcore" class="headerlink" title="第二阶段 rcore"></a>第二阶段 rcore</h2><p>这是我第一次接触操作系统，印象还都停留在原来的书本上，概念上，都是理论，没有真正接触操作系统是什么样的，所以，这个机会能让我了解探究操作系统内部真正的原理和运行逻辑，解开我心中的多年的疑惑，很是开心到起飞。</p>
<p>总体印象最深的就是操作系统内核是以什么形态存在的，上下文如何切换，进程空间如何形成，页表是如何实现的，跳板页又是怎么回事</p>
<h2 id="第三阶段-ArceOS"><a href="#第三阶段-ArceOS" class="headerlink" title="第三阶段 ArceOS"></a>第三阶段 ArceOS</h2><p>这个和我预期不一样，没有沿着rcore继续走，这是一个全新的设计，一时间，有点慌乱，不能和rcore相关的思路很自然的顺承下来，显然这个更具有前瞻性，为此我也花了好多时间来梳理这个逻辑和rcore都关联起来。这个模块化设计的理念很突出，相互之间的关联及细节，需要仔细的研读和体会。</p>
<h2 id="第三阶段的具体case"><a href="#第三阶段的具体case" class="headerlink" title="第三阶段的具体case"></a>第三阶段的具体case</h2><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>对println!() 把颜色表示直接加入后，可以显示颜色，<br>如在当前文件写了一个宏print_with_color!，让后让println!去去调用此宏，就得不到正确结果，提示找不到这个宏，查了资料，和 $crate有关，宏的暴露方式有关，引用路径，由于时间关系，后面调研</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>开始的时候，从rust官方移植，这个太痛苦了，依赖太多了，最后放弃。<br>自己写个简单的，只是利用了官方的<br>use core::hash::Hasher;<br>use core::hash::Hash;<br>这两个hash算法，主体采用了最简单的线性插入算法</p>
<h3 id="bumpallocator"><a href="#bumpallocator" class="headerlink" title="bumpallocator"></a>bumpallocator</h3><p>需要仔细理解题意和上下文，思路选用：<br>申请一直从可用空间起始向前申请，<br>释放如果全部的空间都释放了，就把下一个可用空间调整到开始</p>
<h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><p>采用递归的方式，一层一层的先找到所在当前目录<br>增加当前目录的，更改命名的方法，查找相应的文件，删除后，再插入一个，因为当前存储使用的是BtreeMap，不能更改index</p>
<h3 id="hv"><a href="#hv" class="headerlink" title="hv"></a>hv</h3><p>这个耗费了我好多时间，主要是因为运行例程会卡住，后来发现可能是qemu的版本问题，升级到9.2后，还是一样卡住，当时环境为windows11，wsl2，卡在这里，不同的情况卡的还不一样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write file <span class="string">'payload/skernel2/skernel2'</span> into disk.img</span><br></pre></td></tr></table></figure>
<p>最后没有办法，找一台空闲机器，实在不行，我就安装裸机linux系统，所以先尝试装了另一种虚拟机，virtualbox7.18，也花了些时间，配置好环境后，默认的qemu为6.x时，还是会出错，不过不是卡主的问题，是会触发异常访问，升级到9.2.x后，按照预期执行了，难道说，wsl2在某些情况就是不行，我真是难过。</p>
<p>之后遇到提交github，出错，musl.cc被block，</p>
<blockquote>
<p>下载不下来：<br>    wget <a href="https://musl.cc/riscv64-linux-musl-cross.tgz" target="_blank" rel="noopener">https://musl.cc/riscv64-linux-musl-cross.tgz</a>  </p>
</blockquote>
<p>下载不下来，终于等来了替代方案</p>
<blockquote>
<p>   wget <a href="https://musl.cc.timfish.dev/riscv64-linux-musl-cross.tgz" target="_blank" rel="noopener">https://musl.cc.timfish.dev/riscv64-linux-musl-cross.tgz</a><br>最后，终于得以解决</p>
</blockquote>
<h3 id="sys-mmap"><a href="#sys-mmap" class="headerlink" title="sys_mmap"></a>sys_mmap</h3><p>参数和返回值我理解出现偏差，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sys_mmap</span></span>(</span><br><span class="line">    addr: *<span class="keyword">mut</span> <span class="built_in">usize</span>,</span><br><span class="line">    length: <span class="built_in">usize</span>,</span><br><span class="line">    prot: <span class="built_in">i32</span>,</span><br><span class="line">    flags: <span class="built_in">i32</span>,</span><br><span class="line">    fd: <span class="built_in">i32</span>,</span><br><span class="line">    _offset: <span class="built_in">isize</span>,</span><br><span class="line">) -&gt; <span class="built_in">isize</span></span><br></pre></td></tr></table></figure>
<p>参数addr为0时要特别注意，需要寻找一空间，还有地址和size的对齐。返回值，当开始时认为0是成功，为负时，返回失败原因，后来再三确认失败返回0，成功返回地址，isize作为地址返回，有点不符合直觉？</p>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>期待第四阶段</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/blog/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/74/">74</a><a class="extend next" rel="next" href="/blog/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
