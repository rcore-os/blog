<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/6/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">729</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">631</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/18/2025s-os-camp-4-summary-noah/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/18/2025s-os-camp-4-summary-noah/" class="post-title-link" itemprop="url">2025年春夏开源操作系统训练营四阶段总结-noah-低侵入式的异步协程运行时</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-18 23:59:00" itemprop="dateCreated datePublished" datetime="2025-06-18T23:59:00+00:00">2025-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>非常高兴能参加到开源操作系统训练营第四阶段的学习，跟大家一起进步。经历完这四个阶段，自己有非常大的收获，让我理解了操作系统内部的运行机制，通过组件化的管理来实现更现代化的操作系统，最终在操作系统中支持异步机制提高操作系统的性能。</p>
<p>在每周的学习过程中，非常感谢<a href="https://space.bilibili.com/507884048" target="_blank" rel="noopener">向勇老师</a>给与了很多的指导和鼓励，成为了我前进的支柱。同时也要感谢<a href="https://github.com/zjp-CN" target="_blank" rel="noopener">周积萍</a>学长给与了很多帮助和支持以及建设性的意见，让我遇到困难时不迷茫。在第四阶段的过程中，也从其他同学那学到了很多，能便捷的获取到学习资料和代码，当有疑惑了也有人能够理解你，跟你一起深入到技术中进行讨论，那种感觉真是舒服。</p>
<h2 id="每周工作"><a href="#每周工作" class="headerlink" title="每周工作"></a>每周工作</h2><p>对于一个程序员来说，时间总是不够的，在四周时间里，我主要做了以下几个方面的工作：</p>
<p><strong>第一周 - 回顾</strong></p>
<p>当我第一周(2025-06-01)加入训练营的时候，发现去年的学长大佬们已经早早的开始了自己的课题。我就从基础慢慢开始，这周主要是把文档中的例会视频都看了一遍，基本了解了协程异步的作用以及目前是如何把异步应用到操作系统内核当中去的。</p>
<p><strong>第二周 - 定目标</strong></p>
<p>在看例会视频的时候，我发现有学长讨论 rust 异步的函数着色问题，碰巧我之前在写 rust 的时候也遇到了这个问题，很多时候一套逻辑代码，要分别实现一个同步版本一个异步版本，从一些学长的代码中看确实是分开写的，比如<a href="https://github.com/AsyncModules/async-os/tree/main/modules" target="_blank" rel="noopener">赵方亮学长的仓库</a>，在 2025-06-07 例会讨论中，有同学在参加 “大学生操作系统大赛” 的时候也遇到了此问题，最近在学习 zig 这门语言，说是能解决这个问题，我便想借着这个机会深入研究下。也是对于函数着色问题的一些自己的尝试，于是便确立了如下目标：</p>
<ul>
<li>长期目标：实现低侵入式的异步协程框架，服务于操作系统内核</li>
<li>本期目标：实现简单的异步协程运行时 (zig)</li>
</ul>
<p>后续在调研的过程中，发现 rust 的异步机制，是基于 Future 来实现的，这是一种无栈协程，跟我之前理解的 Go 语言的那种有栈协程还不一样。</p>
<p><strong>第三周 - 学习和实验</strong></p>
<p>后续的两个周，主要是学习文档中的异步协程资料，编写实验代码，验证自己的想法。</p>
<ul>
<li><p>学习内容</p>
<ul>
<li><a href="https://www.less-bug.com/posts/c-implement-a-mini-stackless-coroutine-framework-minico/" target="_blank" rel="noopener">C：实现一个迷你无栈协程框架——Minico</a> - 理解什么是无栈协程</li>
<li><a href="https://blog.aloni.org/posts/a-stack-less-rust-coroutine-100-loc/" target="_blank" rel="noopener">stack-less rust coroutine 100-loc</a> - 理解 rust 无栈协程</li>
<li><a href="https://course.rs/advance/async/future-excuting.html" target="_blank" rel="noopener">Rust 圣经 - 手写 Future Runtime</a> - 理解 Waker 机制</li>
<li><a href="https://web.archive.org/web/20220527113808/https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/supporting-windows" target="_blank" rel="noopener">200 行代码绿色线程</a> - 如何从零实现协程(绿色线程)</li>
</ul>
</li>
<li><p>实验部分</p>
<p>  基于上面的学习的内容，进行了如下实验来验证想法：</p>
<ul>
<li>实现在 zig 中调用 rust 封装的绿色线程任务</li>
<li>实现基于 Future 的异步运行时 (用 zig 语言)</li>
<li>用 asm + zig 实现有栈协程切换机制</li>
</ul>
</li>
</ul>
<p><strong>第四周 - 代码结合</strong></p>
<ul>
<li>异步协程运行时 xasync 框架代码编写<ul>
<li>基本完成跑通简单测例</li>
<li>同时初步解决了函数着色问题</li>
</ul>
</li>
</ul>
<p>完成上述四周的工作后，基本实现我在开源操作系统训练营本阶段的目标，符合预期。</p>
<h2 id="xasync-异步协程运行时"><a href="#xasync-异步协程运行时" class="headerlink" title="xasync 异步协程运行时"></a>xasync 异步协程运行时</h2><h3 id="使用者角度"><a href="#使用者角度" class="headerlink" title="使用者角度"></a>使用者角度</h3><p>我在设计 xasync 异步协程的时候，借鉴了 <a href="https://kristoff.it/blog/zig-colorblind-async-await/" target="_blank" rel="noopener">zig 协程</a> 的设计思路，感觉 zig 协程更容易让使用者理解和减轻负担，那么从使用者的角度出发，什么样的协程用起来才是最舒服的，我认为尽量保持一套代码，只通过一些简单的标记就可以实现同步和异步的切换，是更加友好的协程框架实现方式。下面是我理解的伪代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var is_async &#x3D; true &#x2F;&#x2F; 如果关闭后，底层会走阻塞逻辑</span><br><span class="line"></span><br><span class="line">fn read(file) &#123;</span><br><span class="line">    if (is_async) &#123;</span><br><span class="line">        scheudle(future:run(sys_read(file))) &#x2F;&#x2F; 生成 future，交给 executor 和 eventloop 调度处理</span><br><span class="line">        suspend()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sys_read(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn long_time_action() &#123;</span><br><span class="line">    read(&quot;large file&quot;)</span><br><span class="line">    sleep(100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn other_action() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let frame &#x3D; xasync(long_time_action) &#x2F;&#x2F; 使用者也可以用 xasync 来标记上层代码是异步的</span><br><span class="line">    &#x2F;&#x2F; xawait(frame) &#x2F;&#x2F; 需要等待的时候才等待</span><br><span class="line">    </span><br><span class="line">    other_action()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的注释，可以仔细看下调用流程，这是我个人期望的协程框架使用方式的理解。</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="https://github.com/osxspace/qhos/blob/main/output/asyncos/xasync.png?raw=true" alt="总体设计图"></p>
<p>上面是架构设计图，分为前后两部分把 <code>有栈协程</code> 和 <code>无栈协程</code> 结合起来，其中<code>红线理解为前进</code> <code>蓝线理解为返回</code>，比方说协程切换的前进返回、Future poll 前进和状态返回、协程调度的前进和唤醒的返回等。</p>
<p>目前图中描述的是有三个协程(绿色线程)在需要的场景下不断让出执行权，在异步任务结束后能随时切换到具体的任务上继续执行。这种机制在需要等待返回结果的情况下尤为重要。后续会优化成协程池方便使用。</p>
<p>下面从测例的角度简单剖析下实现代码和原理。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><strong>测例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const Counter &#x3D; struct &#123;</span><br><span class="line">    const Self &#x3D; @This();</span><br><span class="line">    num: u32,</span><br><span class="line">    max: u32,</span><br><span class="line"></span><br><span class="line">    fn init(num: u32, max: u32) Self &#123;</span><br><span class="line">        return .&#123;</span><br><span class="line">            .num &#x3D; num,</span><br><span class="line">            .max &#x3D; max,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn doCount(ctx: *Context) Result &#123;</span><br><span class="line">        const counter &#x3D; @as(*Counter, @ptrCast(@alignCast(ctx.payload)));</span><br><span class="line">        if (counter.num &lt; counter.max) &#123;</span><br><span class="line">            std.debug.print(&quot;counter num &#x3D; &#123;&#125;\n&quot;, .&#123;counter.num&#125;);</span><br><span class="line">            counter.num +&#x3D; 1;</span><br><span class="line">            return .wait;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return .&#123; .done &#x3D; &amp;counter.num &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn doNextCount(result: ?*anyopaque, ctx: *Context) *Future &#123;</span><br><span class="line">        var counter &#x3D; @as(*Counter, @ptrCast(@alignCast(ctx.payload)));</span><br><span class="line"></span><br><span class="line">        const num &#x3D; @as(*u32, @ptrCast(@alignCast(result)));</span><br><span class="line">        const value &#x3D; num.*;</span><br><span class="line"></span><br><span class="line">        counter.num &#x3D; 0;</span><br><span class="line">        counter.max &#x3D; value + 5;</span><br><span class="line"></span><br><span class="line">        return run(Counter.doCount, counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test &quot;counter-chain-done&quot; &#123;</span><br><span class="line">    const allocator &#x3D; std.testing.allocator;</span><br><span class="line"></span><br><span class="line">    var executor &#x3D; Executor.init(allocator);</span><br><span class="line">    defer executor.deinit();</span><br><span class="line"></span><br><span class="line">    var counter &#x3D; Counter.init(0, 5);</span><br><span class="line">    const fut &#x3D; runWithAllocator(allocator, Counter.doCount, &amp;counter).chain(Counter.printNum); &#x2F;&#x2F; 这里支持链式调用</span><br><span class="line"></span><br><span class="line">    executor.schedule(fut);</span><br><span class="line"></span><br><span class="line">    executor.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是把一个 Counter 计数器，改成了异步机制，当 num &gt; max 的时候才会终止运行。在实现的时候利用 zig uinon(enum) 的特性，尽量做到了零成本抽象。</p>
<p><strong>支持组合</strong></p>
<p>还支持了 Then 组合操作，因为在封装 Future 代码的时候可能要把原有的阻塞代码拆成多个 Future 逐步执行。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test &quot;counter-chain-counter&quot; &#123;</span><br><span class="line">    const allocator &#x3D; std.testing.allocator;</span><br><span class="line"></span><br><span class="line">    var executor &#x3D; Executor.init(allocator);</span><br><span class="line">    defer executor.deinit();</span><br><span class="line"></span><br><span class="line">    var counter &#x3D; Counter.init(0, 5);</span><br><span class="line">    const fut &#x3D; runWithAllocator(allocator, Counter.doCount, &amp;counter).chain(Counter.doNextCount); &#x2F;&#x2F; 这里支持链式调用</span><br><span class="line"></span><br><span class="line">    executor.schedule(fut);</span><br><span class="line"></span><br><span class="line">    executor.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续还会在 Future 上进行扩展支持 Join 等更多组合操作。</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor 中有两个队列：</p>
<ul>
<li>ready_queue: std.ArrayList(*Future) - 调度队列，供调用者放入 Future 任务</li>
<li>futs: std.ArrayList(*Future) - 执行队列，实际调度器处理的 Future 任务</li>
</ul>
<p>Future 先是进入到调度队列，如果调度开始执行后，会从调度队列取出任务放入执行队列，这时候执行队列中可能还有其他未完成的任务，当 Future 结束后会从执行队列中移除，如果执行队列中的所有任务都是等待状态，则 Executor 处于 idle 状态，等待 event_loop 唤醒，具体使用方式在上面的测例代码中已体现。</p>
<p>目前调度策略比较简单，而且没有经过任何优化，后续会不断完善。</p>
<h3 id="Coroutine-绿色线程"><a href="#Coroutine-绿色线程" class="headerlink" title="Coroutine(绿色线程)"></a>Coroutine(绿色线程)</h3><p>目前已经支持协程间的切换，下面的代码是非对称协程的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var base_coro: Coroutine &#x3D; undefined;</span><br><span class="line">var count_coro: Coroutine &#x3D; undefined;</span><br><span class="line">var count: i32 &#x3D; 1;</span><br><span class="line"></span><br><span class="line">fn addCount() void &#123;</span><br><span class="line">    count +&#x3D; 1;</span><br><span class="line">    base_coro.resumeFrom(&amp;count_coro);</span><br><span class="line">    count +&#x3D; 1;</span><br><span class="line">    base_coro.resumeFrom(&amp;count_coro);</span><br><span class="line">    count +&#x3D; 1;</span><br><span class="line">    base_coro.resumeFrom(&amp;count_coro);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &quot;simple counter suspend and resume coroutine&quot; &#123;</span><br><span class="line">    const allocator &#x3D; std.testing.allocator;</span><br><span class="line"></span><br><span class="line">    base_coro &#x3D; try Coroutine.init(allocator, null);</span><br><span class="line">    defer base_coro.deinit();</span><br><span class="line">    count_coro &#x3D; try Coroutine.init(allocator, addCount);</span><br><span class="line">    defer count_coro.deinit();</span><br><span class="line"></span><br><span class="line">    try std.testing.expect(1 &#x3D;&#x3D; count);</span><br><span class="line"></span><br><span class="line">    count_coro.resumeFrom(&amp;base_coro);</span><br><span class="line">    try std.testing.expect(2 &#x3D;&#x3D; count);</span><br><span class="line"></span><br><span class="line">    count_coro.resumeFrom(&amp;base_coro);</span><br><span class="line">    try std.testing.expect(3 &#x3D;&#x3D; count);</span><br><span class="line"></span><br><span class="line">    count_coro.resumeFrom(&amp;base_coro);</span><br><span class="line">    try std.testing.expect(4 &#x3D;&#x3D; count);</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;all finished\n&quot;, .&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个测试就是用协程的方式去执行 addCount 所在的 count_coro 协程，在 addCount 中也可以随时切换调用者协程 base_coro，执行原有逻辑。</p>
<p>还支持了函数参数的传递，在上下文切换的时候，不是两个函数的切换，是通过一个中间函数 <code>call</code>，它会根据汇编传过来的参数指针地址，转换成具体的 *Coroutine，再从其中拿出 func_ptr 和 args_ptr，就相当于中间层转发了一下。从下面的代码看目前参数类型都是定死的，有点牵强，目前够用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn call(coro_ptr_int: u64) void &#123;</span><br><span class="line">    const coro: *Coroutine &#x3D; @ptrFromInt(coro_ptr_int);</span><br><span class="line"></span><br><span class="line">    std.debug.print(&quot;current coro address: 0x&#123;x&#125;\n&quot;, .&#123;@intFromPtr(coro)&#125;);</span><br><span class="line"></span><br><span class="line">    if (coro.frame.func_ptr !&#x3D; null) &#123;</span><br><span class="line">        if (coro.frame.args_ptr !&#x3D; null) &#123;</span><br><span class="line">            const func_ptr &#x3D; @as(*const fn (*const anyopaque) void, @ptrCast(coro.frame.func_ptr.?));</span><br><span class="line">            const args_ptr &#x3D; coro.frame.args_ptr.?;</span><br><span class="line">            func_ptr(args_ptr);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            const func_ptr &#x3D; @as(*const fn () void, @ptrCast(coro.frame.func_ptr.?));</span><br><span class="line">            func_ptr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std.debug.print(&quot;the func pointer is null\n&quot;, .&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h3><p>事件响应机制也就是 eventloop (reactor 模型)，其实是所有异步协程实现的底层支持，我甚至认为就算不用异步，只用事件机制和回调的方式也能做到高性能。这一部分在本期训练营并没有深入的去学习，目前只是实现了一个大概。如果这层封装好了，做成一层统一的抽象去处理 epoll、io_uring、iocp、kqueue 以及中断信号量等，也将会有很大的收获，给自己挖个坑，明年把这部分填上。</p>
<p>eventloop 的核心代码就是用一个循环，不停的调用系统需要等待的函数，等待系统给出响应，这里用的是 epoll_wait，这些系统提供的函数其实在操作系统里面都有自己的实现，一般性能都比较高，而且可以阻塞也可以非阻塞。当系统给出响应后，再触发回调去唤醒 Executor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pub fn poll(self: *Self, timeout_ms: i32) !usize &#123;</span><br><span class="line">    try self.events.resize(16); &#x2F;&#x2F; 预分配事件数组，先这么写</span><br><span class="line"></span><br><span class="line">    const n &#x3D; std.posix.epoll_wait(self.epfd, self.events.items, timeout_ms);</span><br><span class="line"></span><br><span class="line">    for (self.events.items[0..n]) |event| &#123;</span><br><span class="line">        const fd &#x3D; event.data.fd;</span><br><span class="line"></span><br><span class="line">        if (self.callbacks.get(fd)) |callback| &#123;</span><br><span class="line">            if (event.events &amp; std.posix.system.EPOLL.IN !&#x3D; 0) &#123;</span><br><span class="line">                var buf: [8]u8 &#x3D; undefined;</span><br><span class="line">                _ &#x3D; std.posix.read(fd, &amp;buf) catch &#123;&#125;; &#x2F;&#x2F; 这里目前只处理了 timer 的情况</span><br><span class="line"></span><br><span class="line">                if (callback.callback_fn) |func| &#123;</span><br><span class="line">                    func(callback.user_data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn run(self: *Self) !void &#123;</span><br><span class="line">        self.running &#x3D; true;</span><br><span class="line"></span><br><span class="line">        while (self.running) &#123;</span><br><span class="line">            _ &#x3D; try self.poll(100); &#x2F;&#x2F; 100ms 超时</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整体组合-xasync"><a href="#整体组合-xasync" class="headerlink" title="整体组合 xasync"></a>整体组合 xasync</h3><p>把上面各部分组合起来，看看能不能达到预期效果。</p>
<p><strong>Timer</strong></p>
<p>这部分注册一个 TimerHandle 到 event loop 当中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const Timer &#x3D; struct &#123;</span><br><span class="line">    const Self &#x3D; @This();</span><br><span class="line"></span><br><span class="line">    handle: TimerHandle,</span><br><span class="line">    completed: bool &#x3D; false,</span><br><span class="line">    waker: ?*const Waker &#x3D; null,</span><br><span class="line"></span><br><span class="line">    fn init(nanoseconds: u64) !Self &#123;</span><br><span class="line">        const handle &#x3D; try TimerHandle.init(&amp;global_event_loop, nanoseconds); &#x2F;&#x2F; 注册给 event_loop</span><br><span class="line">        return .&#123;</span><br><span class="line">            .handle &#x3D; handle,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn deinit(self: *Self) void &#123;</span><br><span class="line">        self.handle.deinit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn timerCompletedCallback(data: ?*anyopaque) void &#123; &#x2F;&#x2F; event_loop 回调</span><br><span class="line">        if (data) |ptr| &#123;</span><br><span class="line">            const timer: *Timer &#x3D; @ptrCast(@alignCast(ptr));</span><br><span class="line">            timer.completed &#x3D; true;</span><br><span class="line">            std.debug.print(&quot;timer callback completed!\n&quot;, .&#123;&#125;);</span><br><span class="line">            if (timer.waker) |waker| &#123;</span><br><span class="line">                waker.wake(); &#x2F;&#x2F; 唤醒</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; future poll</span><br><span class="line">    fn poll(ctx: *Context) Result &#123;</span><br><span class="line">        const timer: *Timer &#x3D; @ptrCast(@alignCast(ctx.payload));</span><br><span class="line">        if (timer.completed) &#123;</span><br><span class="line">            std.debug.print(&quot;poll timer is completed\n&quot;, .&#123;&#125;);</span><br><span class="line">            return .&#123; .done &#x3D; null &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timer.waker &#x3D; ctx.waker;</span><br><span class="line">            return .wait;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Sleep</strong></p>
<p>这部分把 Timer 包装成 Future</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">fn sleep(nanoseconds: u64) void &#123;</span><br><span class="line">    std.debug.print(&quot;sleep comes in\n&quot;, .&#123;&#125;);</span><br><span class="line">    if (!sys_is_block) &#123;</span><br><span class="line">        const timer_ptr &#x3D; global_runtime.allocator.create(Timer) catch unreachable;</span><br><span class="line">        timer_ptr.* &#x3D; Timer.init(nanoseconds) catch unreachable;</span><br><span class="line"></span><br><span class="line">        const callback &#x3D; EventCallback&#123;</span><br><span class="line">            .callback_fn &#x3D; Timer.timerCompletedCallback,</span><br><span class="line">            .user_data &#x3D; timer_ptr,</span><br><span class="line">        &#125;;</span><br><span class="line">        timer_ptr.handle.setCallback(callback) catch unreachable;</span><br><span class="line"></span><br><span class="line">        const timer_fut &#x3D; future.runWithAllocator(global_runtime.allocator, Timer.poll, timer_ptr).chain(struct &#123;</span><br><span class="line">            fn thenFn(_: ?*anyopaque, ctx: *Context) *Future &#123;</span><br><span class="line">                const timer &#x3D; @as(*Timer, @ptrCast(@alignCast(ctx.payload)));</span><br><span class="line">                ctx.allocator.destroy(timer);</span><br><span class="line">                return future.done(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.thenFn);</span><br><span class="line"></span><br><span class="line">        global_runtime.executor.schedule(timer_fut);</span><br><span class="line"></span><br><span class="line">        global_runtime.switchTaskToBase(); &#x2F;&#x2F; 类似 suspend - 这个地方实现还有点歧义</span><br><span class="line">        &#x2F;&#x2F; global_runtime.switchToExecutor(); &#x2F;&#x2F; 如果需要等待返回结果则需要切换到 executor 等待其 resume 回来</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std.Thread.sleep(nanoseconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn delay() void &#123;</span><br><span class="line">    std.debug.print(&quot;delay comes in\n&quot;, .&#123;&#125;);</span><br><span class="line">    sleep(5 * std.time.ns_per_s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main</strong></p>
<p>整合完毕后对于使用者来说，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xasync(delay);</span><br><span class="line">&#x2F;&#x2F; xawait(); &#x2F;&#x2F; 需要等待的时候开启</span><br><span class="line">std.debug.print(&quot;hello xasync\n&quot;, .&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><strong>不等待完成</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delay comes <span class="keyword">in</span></span><br><span class="line">sleep comes <span class="keyword">in</span></span><br><span class="line">hello xasync                - 注意这里，没有等待 timer 异步执行结束，而是直接返回</span><br><span class="line">timer callback completed!</span><br><span class="line">poll timer is completed     - 注意这里，timer 结束了</span><br><span class="line">main will quit</span><br><span class="line">event loop quit</span><br></pre></td></tr></table></figure>

<p><strong>等待完成</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delay comes <span class="keyword">in</span></span><br><span class="line">sleep comes <span class="keyword">in</span></span><br><span class="line">timer callback completed!</span><br><span class="line">poll timer is completed</span><br><span class="line">hello xasync                - 注意这里，虽然底层是异步协程执行，但是这里等待 timer 执行完毕才打印</span><br><span class="line">main will quit</span><br><span class="line">event loop quit</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从目前执行效果和 API 的调用方式看符合预期，基本达成了本期的目标：<code>实现简单的异步协程运行时 (zig)</code>，按照这种方式解决<code>函数着色问题</code>是有希望的。</p>
<p>虽然本期目标基本达成，但是中间学习的过程中还是有很多技术细节没有完全搞懂，有些学习资料没有完全看完，后续还要继续努力。</p>
<h2 id="后续规划"><a href="#后续规划" class="headerlink" title="后续规划"></a>后续规划</h2><ul>
<li>参数和返回值的类型支持且能自动推导</li>
<li>支持线程池 thread pool</li>
<li>eventloop 完善</li>
<li>是否后台调度支持用户配置 - 现在需要改代码来实现</li>
<li>支持 rust 调用</li>
<li>封装 asyncio</li>
<li>集成到 arceos/rcore 中</li>
<li>性能对比测试</li>
</ul>
<h2 id="答疑和思考"><a href="#答疑和思考" class="headerlink" title="答疑和思考"></a>答疑和思考</h2><p><strong>为什么要用 zig 写</strong></p>
<ul>
<li>没有任何原因，个人偏好，peace &amp; love.</li>
</ul>
<p><strong>实现代码在哪里</strong></p>
<ul>
<li><a href="https://github.com/osxspace/qhos/tree/main/output/xasync1" target="_blank" rel="noopener">xasync1</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/18/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A54%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/18/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A54%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/" class="post-title-link" itemprop="url">2025春夏开源操作系统训练营4阶段总结-明扬</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-18 22:33:44" itemprop="dateCreated datePublished" datetime="2025-06-18T22:33:44+00:00">2025-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中断驱动的协程异步网络-在ArceOS中实现"><a href="#中断驱动的协程异步网络-在ArceOS中实现" class="headerlink" title="中断驱动的协程异步网络 - 在ArceOS中实现"></a>中断驱动的协程异步网络 - 在ArceOS中实现</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>时间过的飞快，转眼间，训练营四阶段已经迎来尾声。<br>我由于去年已经参加过一届训练营，所以本次我提前一个月晋级到了四阶段，与向勇老师确定了我的课题方向：“中断驱动的协程异步网络”。<br>在后续周会的沟通中，向老师也给了我更具挑战性的目标：“在VisionFive2开发板上验证我的工作”。</p>
<h2 id="二、历程"><a href="#二、历程" class="headerlink" title="二、历程"></a>二、历程</h2><p>在四阶段，我主要完成了以下几个里程碑：</p>
<h3 id="Rust异步运行时"><a href="#Rust异步运行时" class="headerlink" title="Rust异步运行时"></a>Rust异步运行时</h3><p>因为我之前曾经在工作中编写过面向 WASM 平台的 Rust 异步运行时，所以第一个里程碑并没有花掉我太多时间。<br>为了给自己增加一些挑战，我还额外实现了常见的异步运行时辅助数据结构与函数，如：<code>mutex</code>，<code>spawn</code>, <code>block_on</code>, <code>join</code> 等。</p>
<h3 id="异步版本的网络操作"><a href="#异步版本的网络操作" class="headerlink" title="异步版本的网络操作"></a>异步版本的网络操作</h3><p>在完成 Rust 异步运行时后，我便开始着手实现异步版本的网络API。<br>我为所有网络操作中包含<code>block_on</code>的函数都编写了异步版本，并实现了网络操作的异步化。其中包括:</p>
<ul>
<li><code>socket.recv_async()</code></li>
<li><code>socket.send_async()</code></li>
<li><code>socket.accept_async()</code></li>
<li><code>socket.connect_async()</code></li>
</ul>
<h3 id="PLIC中断驱动的Future唤醒"><a href="#PLIC中断驱动的Future唤醒" class="headerlink" title="PLIC中断驱动的Future唤醒"></a>PLIC中断驱动的Future唤醒</h3><p>实现以上异步网络操作后，网络异步仍然是以Poll驱动的，而不是以真实的物理世界事件驱动的。<br>为了实现真正的异步网络，我需要实现一个中断驱动的Future唤醒机制。<br>在 RISC-V 架构中，PLIC 是中断控制器，可以用于实现中断驱动的Future唤醒机制。<br>我为 ArceOS 移植了 PLIC 驱动，并实现了 VirtIO-Net 设备的 PLIC 中断驱动的 Future 唤醒机制。</p>
<h3 id="将ArceOS移植到VisionFive2开发板"><a href="#将ArceOS移植到VisionFive2开发板" class="headerlink" title="将ArceOS移植到VisionFive2开发板"></a>将ArceOS移植到VisionFive2开发板</h3><p>在完成以上工作后，距离训练营结束仍然有一个半月的时间。这次组会中，向老师给了我一个更具挑战性的目标：将 ArceOS 移植到 VisionFive2 开发板，并在 VisionFive2 开发板上验证我的工作。我也就正式开始了移植工作。<br>开发板板载了 u-boot 和 OpenSBI v1.2，我可以直接从 u-boot 启动 ArceOS。<br>幸好我手中还有 jTag 调试器，向老师也给我提供了其他前辈同学的移植经验。<br>感谢萧络元同学的代码仓库，我很快便完成了 ArceOS 的移植。<br>VF2 开发版与常见 RISC-V 开发版有些许不同，例如：<br>    * S 态可用内存起点为 0x4000_0000 而不是 0x8000_0000<br>    * OpenSBI v1.2 支持 SBI v1.0 规范，但未实现 Console Extension。所以日志打印时需要使用 Legacy Console API。<br>以及 u-boot 启动与 Qemu 启动也有些差异，现代镜像打包时更多采用 itb 格式，同时将 dtb 打包进 itb 中。<br>总的来说，移植工作并不算太难，但是当系统无法加载又没有任何日志输出的时候，还是需要些裸机的调试手段，例如直接通过汇编调用串口打印，或者 sbi call 字符打印来确定程序执行到了哪里，是否进入内核代码。</p>
<h3 id="为VisionFile2启用中断驱动的异步网络"><a href="#为VisionFile2启用中断驱动的异步网络" class="headerlink" title="为VisionFile2启用中断驱动的异步网络"></a>为VisionFile2启用中断驱动的异步网络</h3><p>在完成 ArceOS 的移植后，我便开始着手为 VisionFive2 开发板编写网卡驱动，启用中断功能，复现我在 Qemu 中完成的功能。这是本次训练营中我遇到的最大挑战。<br>首先，启动真实的网卡设备异常复杂，需要按顺序依次启动不下10个时钟信号与复位信号。<br>然后，VF2 平台使用的网络设备为 dwmac-5.2，参考 Linux 内核中驱动实现时，其历史悠久，代码量庞大，支持功能多且复杂，兼容设备多，还需要兼容多个平台和历史版本，硬啃 Linux 内核驱动代码基本上不太现实。<br>在必要时候还需要配合 PHY 芯片的同步配置，与设备寄存器交互通过 MMIO 映射，而与 PHY 芯片交互则需要通过 MDIO 总线，Clause 22/45 协议。</p>
<p>同时还需要学习众多的 MMIO 寄存器偏移量，与每个 bit 对应的功能含义，了解 GMAC/DMA/MTL/PHY 相关寄存器。<br>也学习了 ring buffer 的实现，以及如何使用 ring buffer 实现网络数据收发。</p>
<p>最终我还是没能在 VF2 平台开启中断功能，根据与厂家工程师的交流，PHY 芯片中断引脚并未接入 PLIC 中断控制器，所以无法使用 PLIC 中断驱动网络功能。</p>
<p>遗憾未能亲眼见到自己的工作在真实硬件上运行，但是通过本阶段的学习，我还是学到了海量的知识。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过本次训练营，我弥补了我知识体系中的许多空白，包括：</p>
<ul>
<li>PLIC 中断控制器</li>
<li>网卡驱动</li>
<li>U-Boot 运作原理</li>
<li>真实硬件是如何运作的</li>
</ul>
<h2 id="四、致谢"><a href="#四、致谢" class="headerlink" title="四、致谢"></a>四、致谢</h2><p>感谢向勇、陈渝老师，以及所有帮助过我的老师和同学。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/16/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/16/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2025 春夏季开源操作系统训练营 学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-16 14:25:51" itemprop="dateCreated datePublished" datetime="2025-06-16T14:25:51+00:00">2025-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025-春夏季开源操作系统训练营-学习总结"><a href="#2025-春夏季开源操作系统训练营-学习总结" class="headerlink" title="2025 春夏季开源操作系统训练营 学习总结"></a>2025 春夏季开源操作系统训练营 学习总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实验环境</span><br><span class="line">Mac mini Apple M4</span><br><span class="line">MacOS 15.4.1</span><br><span class="line">&#x2F;&#x2F; 备注（在国外的同学可以忽略）</span><br><span class="line">在配置实验环境时，一定要更换Homebrew、rustup和Cargo的镜像源。</span><br></pre></td></tr></table></figure>

<h2 id="第一阶段：Rust编程"><a href="#第一阶段：Rust编程" class="headerlink" title="第一阶段：Rust编程"></a>第一阶段：Rust编程</h2><p>由于参与过 <a href="http://opencamp.cn/" target="_blank" rel="noopener">http://opencamp.cn/</a> 的其他 Rust 训练营，本阶段相当于是复习阶段。然而笔者对很多 Rust 语法还是理解的不够，需要通过更多实际项目来加深学习。</p>
<h2 id="第二阶段：OS设计实现"><a href="#第二阶段：OS设计实现" class="headerlink" title="第二阶段：OS设计实现"></a>第二阶段：OS设计实现</h2><p>本阶段主要参考指导书完成实验 <a href="https://learningos.cn/rCore-Tutorial-Guide-2025S/" target="_blank" rel="noopener">https://learningos.cn/rCore-Tutorial-Guide-2025S/</a> </p>
<h3 id="1-Apple-Silicon-相关问题"><a href="#1-Apple-Silicon-相关问题" class="headerlink" title="1. Apple Silicon 相关问题"></a>1. Apple Silicon 相关问题</h3><blockquote>
<p>在第零章，指导书如是说：<br>经初步测试，使用 M1 芯片的 macOS 也可以运行本实验的框架，即我们的实验对平台的要求不是很高。但我们仍建议同学配置 Ubuntu 环境，以避免未知的环境问题。</p>
</blockquote>
<p>笔者在实验中确实遇到了一些问题，但都并非无法解决，具体情况如下：</p>
<h4 id="1-1-安装-qemu-可能需要-sudo"><a href="#1-1-安装-qemu-可能需要-sudo" class="headerlink" title="1.1 安装 qemu (可能需要 sudo)"></a>1.1 安装 qemu (可能需要 sudo)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install qemu</span><br><span class="line">qemu-img --version</span><br></pre></td></tr></table></figure>
<p>如果显示<code>qemu-img version 9.2.3</code>则说明安装成功。</p>
<h4 id="1-2-载入rustsbi-qemu-bin时卡死"><a href="#1-2-载入rustsbi-qemu-bin时卡死" class="headerlink" title="1.2 载入rustsbi-qemu.bin时卡死"></a>1.2 载入rustsbi-qemu.bin时卡死</h4><p>@lurenjia1213 修复了该问题，需要 Clone 下面的项目，重新编译，然后拷贝生成的rustsbi-qemu.bin 并覆盖实验项目中的文件。<br><a href="https://github.com/lurenjia1213/rustsbi-qemu/tree/main" target="_blank" rel="noopener">https://github.com/lurenjia1213/rustsbi-qemu/tree/main</a></p>
<h4 id="1-3-qemu-模拟器无法正确退出"><a href="#1-3-qemu-模拟器无法正确退出" class="headerlink" title="1.3 qemu 模拟器无法正确退出"></a>1.3 qemu 模拟器无法正确退出</h4><p>在ch3中，qemu模拟器无法正确退出，需要拷贝ch2中的<code>./src/boards/qemu.rs</code>到ch3。通过对比ch2和ch3的区别来修复问题，从而可以学习正确退出模拟器的方法。</p>
<blockquote>
<p>ch4 通过同样的方法在 BASE=1 的测试中还是无法正确退出，需要以后解决。</p>
</blockquote>
<h4 id="1-4-MacOS-没有-timeout-指令导致测例无法通过"><a href="#1-4-MacOS-没有-timeout-指令导致测例无法通过" class="headerlink" title="1.4 MacOS 没有 timeout 指令导致测例无法通过"></a>1.4 MacOS 没有 timeout 指令导致测例无法通过</h4><p>安装 <code>coreutils</code>, 用 <code>gtimeout</code> 来替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install coreutils</span><br><span class="line">&#x2F;&#x2F; 需要将下面这条指令写到保存环境变量的那个文件中</span><br><span class="line">alias timeout&#x3D;gtimeout</span><br></pre></td></tr></table></figure>


<h3 id="2-学习心得"><a href="#2-学习心得" class="headerlink" title="2. 学习心得"></a>2. 学习心得</h3><p>由于没有系统学习过操作系统的理论知识，学的比较慢，需要参考指导书和学习资源中的视频才慢慢掌握。虽然操作系统相关的内容学的不够扎实，但是对于 rust 的语法慢慢熟悉了起来。抱着学习 rust 的心态还学习到了操作系统的底层运行，很有收获。</p>
<h2 id="第三阶段：项目基础阶段-组件化操作系统"><a href="#第三阶段：项目基础阶段-组件化操作系统" class="headerlink" title="第三阶段：项目基础阶段 - 组件化操作系统"></a>第三阶段：项目基础阶段 - 组件化操作系统</h2><ul>
<li>尽管是第一次接触操作系统，在完成第二阶段以后，第三阶段给笔者的感觉不是很陌生（至少知道大概都在干什么）</li>
<li>课程视频和课件也很详细的给出了任务和学习目标，但是第三阶段的项目相比第二阶段要大很多</li>
<li>有时候不知道要去哪里干什么，只能通过给出的题目反向查找相关的内容。</li>
</ul>
<h3 id="1-遇到的问题和解决思路"><a href="#1-遇到的问题和解决思路" class="headerlink" title="1.遇到的问题和解决思路"></a>1.遇到的问题和解决思路</h3><ul>
<li>在UniKernel部分， 笔者在 MacOS 下面完成了任务，到了宏内核的部分涉及到了交叉编译的部分，似乎 MacOS 变得复杂了起来。折腾了一段时间之后，还是在一台 Linux 服务器上用 docker 完成了后续的任务。</li>
<li>这是笔者第一次使用 docker，遇到不懂的就让 Chatgpt 来生成指令，但是还是遇到了很多问题：<ol>
<li>hub.docker.com 被墙，根本创建不了 Linux 容器， 后来找到 nvcr.io/nvidia/pytorch:25.05-py3 解决了问题： <a href="https://catalog.ngc.nvidia.com/orgs/nvidia/containers/pytorch" target="_blank" rel="noopener">https://catalog.ngc.nvidia.com/orgs/nvidia/containers/pytorch</a></li>
<li>以为 root 之后就万事大吉，但是在运行容器的时候要加上 <code>--privieged</code>， 不然 <code>mount</code> 指令无法正确的找到目录的位置</li>
<li>运行容器的时候千万不要加 -rm， 不然停止容器的时候就永远地消失了<h3 id="2-学习心得-1"><a href="#2-学习心得-1" class="headerlink" title="2. 学习心得"></a>2. 学习心得</h3>由于上述笔者遇到的问题，反反复复搭环境搭了 3 次， 对各种 Linux 指令，以及各种组件的作用有了更深的理解。相比第二阶段，第三阶段的练习难度反而有所下降，但是 ArceOS 本身的内容是相当多的，需要更加系统的学习。 希望能在第四阶段有所收获。</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/15/manchangfengxu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/15/manchangfengxu/" class="post-title-link" itemprop="url">manchangfengxu</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-15 13:31:42" itemprop="dateCreated datePublished" datetime="2025-06-15T13:31:42+00:00">2025-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rust基础的总结"><a href="#rust基础的总结" class="headerlink" title="rust基础的总结"></a>rust基础的总结</h1><h2 id="一-基本数据类型与所有权"><a href="#一-基本数据类型与所有权" class="headerlink" title="一.基本数据类型与所有权"></a>一.基本数据类型与所有权</h2><h3 id="所有权系统核心规则"><a href="#所有权系统核心规则" class="headerlink" title="所有权系统核心规则"></a>所有权系统核心规则</h3><ol>
<li><strong>移动语义(Move)</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);  <span class="comment">// 堆分配</span></span><br><span class="line"><span class="keyword">let</span> s2 = s1;                    <span class="comment">// 所有权转移</span></span><br><span class="line"><span class="comment">// println!("&#123;&#125;", s1);           // 错误！s1 已失效</span></span><br></pre></td></tr></table></figure></li>
<li><strong>借用规则</strong>：<ul>
<li>任意时刻：<strong>一个</strong>可变引用 <strong>或</strong> 多个不可变引用</li>
<li>引用必须始终有效（悬垂指针禁止）</li>
</ul>
</li>
<li><strong>生命周期标注</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Slice-类型"><a href="#Slice-类型" class="headerlink" title="Slice 类型"></a>Slice 类型</h3><ul>
<li><strong>无所有权引用</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">let</span> hello: &amp;<span class="built_in">str</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];    <span class="comment">// 字符串切片</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> slice: &amp;[<span class="built_in">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];  <span class="comment">// 数组切片</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二-Crate-与模块系统"><a href="#二-Crate-与模块系统" class="headerlink" title="二.Crate 与模块系统"></a>二.Crate 与模块系统</h2><h3 id="Crate-类型"><a href="#Crate-类型" class="headerlink" title="Crate 类型"></a>Crate 类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>文件扩展名</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>二进制 Crate</td>
<td><code>main.rs</code></td>
<td>可执行程序</td>
</tr>
<tr>
<td>库 Crate</td>
<td><code>lib.rs</code></td>
<td>可复用代码库</td>
</tr>
</tbody></table>
<h3 id="模块可见性规则"><a href="#模块可见性规则" class="headerlink" title="模块可见性规则"></a>模块可见性规则</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;          <span class="comment">// pub 使模块公有</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用绝对路径访问</span></span><br><span class="line">crate::front_of_house::hosting::add_to_waitlist();</span><br></pre></td></tr></table></figure>

<h3 id="使用外部-Crate"><a href="#使用外部-Crate" class="headerlink" title="使用外部 Crate"></a>使用外部 Crate</h3><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.toml</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">"0.8.5"</span>  <span class="comment"># 语义化版本</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num = rand::thread_rng().gen_range(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-Option-与错误处理"><a href="#三-Option-与错误处理" class="headerlink" title="三. Option 与错误处理"></a>三. Option 与错误处理</h2><h3 id="Option-枚举"><a href="#Option-枚举" class="headerlink" title="Option 枚举"></a>Option<T> 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全解包</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">"Value: &#123;&#125;"</span>, i),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Missing value"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Result-lt-T-E-gt-错误处理"><a href="#Result-lt-T-E-gt-错误处理" class="headerlink" title="Result&lt;T, E&gt; 错误处理"></a>Result&lt;T, E&gt; 错误处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误传播简写</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_config</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(<span class="string">"config.toml"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理最佳实践"><a href="#错误处理最佳实践" class="headerlink" title="错误处理最佳实践"></a>错误处理最佳实践</h3><ol>
<li>优先使用 <code>Result</code> 而非 panic</li>
<li>使用 <code>?</code> 操作符传播错误</li>
<li>自定义错误类型实现 <code>std::error::Error</code></li>
</ol>
<h2 id="四-Trait-与泛型"><a href="#四-Trait-与泛型" class="headerlink" title="四. Trait 与泛型"></a>四. Trait 与泛型</h2><h3 id="Trait-定义与实现"><a href="#Trait-定义与实现" class="headerlink" title="Trait 定义与实现"></a>Trait 定义与实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    headline: <span class="built_in">String</span>,</span><br><span class="line">    location: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) -&gt; &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trait-Bound-语法糖"><a href="#Trait-Bound-语法糖" class="headerlink" title="Trait Bound 语法糖"></a>Trait Bound 语法糖</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法等价</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Display + <span class="built_in">Clone</span>&gt;(item: &amp;T) &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;(<span class="keyword">impl</span> Display + <span class="built_in">Clone</span>)) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生命周期进阶"><a href="#生命周期进阶" class="headerlink" title="生命周期进阶"></a>生命周期进阶</h3><p><strong>生命周期标注必要性</strong>：</p>
<ol>
<li>结构体持有引用时必须显式标注生命周期，确保引用的有效性</li>
<li>方法实现中：<ul>
<li><code>&amp;self</code> 参数隐含 <code>&amp;&#39;a self</code> 生命周期</li>
<li>返回值关联结构体生命周期（通过生命周期消除规则第三项）</li>
</ul>
</li>
<li>遵循Rust生命周期消除三规则：<ul>
<li>每个输入引用自动获得独立生命周期</li>
<li>单个输入引用时所有输出引用与其生命周期对齐</li>
<li>方法签名中 <code>&amp;self</code> 使输出引用与结构体生命周期对齐</li>
</ul>
</li>
</ol>
<p><strong>错误</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangling_reference</span></span>() -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"temporary"</span>);</span><br><span class="line">    &amp;s[..]  <span class="comment">// 错误！返回局部变量引用</span></span><br><span class="line">&#125; <span class="comment">// s离开作用域被丢弃</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">announce_and_return</span></span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Attention: &#123;&#125;"</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-智能指针"><a href="#五-智能指针" class="headerlink" title="五. 智能指针"></a>五. 智能指针</h2><h3 id="常用智能指针对比"><a href="#常用智能指针对比" class="headerlink" title="常用智能指针对比"></a>常用智能指针对比</h3><table>
<thead>
<tr>
<th>类型</th>
<th>所有权</th>
<th>线程安全</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>Box&lt;T&gt;</code></td>
<td>单一</td>
<td>是</td>
<td>堆分配、递归类型</td>
</tr>
<tr>
<td><code>Rc&lt;T&gt;</code></td>
<td>共享</td>
<td>否</td>
<td>单线程引用计数</td>
</tr>
<tr>
<td><code>Arc&lt;T&gt;</code></td>
<td>共享</td>
<td>是</td>
<td>多线程引用计数</td>
</tr>
<tr>
<td><code>RefCell&lt;T&gt;</code></td>
<td>可变</td>
<td>否</td>
<td>运行时借用检查</td>
</tr>
</tbody></table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Box 用于递归类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rc 共享所有权</span></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">let</span> a = Rc::new(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> b = Rc::clone(&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefCell 运行时借用检查</span></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="number">42</span>);</span><br><span class="line">*c.borrow_mut() += <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="六-迭代器与闭包"><a href="#六-迭代器与闭包" class="headerlink" title="六.迭代器与闭包"></a>六.迭代器与闭包</h2><h3 id="闭包类型推断"><a href="#闭包类型推断" class="headerlink" title="闭包类型推断"></a>闭包类型推断</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add_one = |x| x + <span class="number">1</span>;         <span class="comment">// 类型自动推导</span></span><br><span class="line"><span class="keyword">let</span> print = || <span class="built_in">println!</span>(<span class="string">"hello"</span>); <span class="comment">// 无参闭包</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包捕获模式"><a href="#闭包捕获模式" class="headerlink" title="闭包捕获模式"></a>闭包捕获模式</h3><table>
<thead>
<tr>
<th>捕获方式</th>
<th>关键字</th>
<th>所有权</th>
</tr>
</thead>
<tbody><tr>
<td>不可变借用</td>
<td>`</td>
<td></td>
</tr>
<tr>
<td>可变借用</td>
<td>`</td>
<td>mut</td>
</tr>
<tr>
<td>值捕获</td>
<td><code>move</code></td>
<td>转移</td>
</tr>
</tbody></table>
<h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"><span class="keyword">let</span> sum: <span class="built_in">i32</span> = v.iter()</span><br><span class="line">    .map(|x| x * <span class="number">2</span>)        <span class="comment">// 加倍</span></span><br><span class="line">    .filter(|x| x % <span class="number">4</span> == <span class="number">0</span>) <span class="comment">// 过滤4的倍数</span></span><br><span class="line">    .sum();                 <span class="comment">// 求和</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    count: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-并发与异步编程"><a href="#七-并发与异步编程" class="headerlink" title="七.并发与异步编程"></a>七.并发与异步编程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"From spawned thread"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">handle.join().unwrap();</span><br></pre></td></tr></table></figure>

<h3 id="通道通信-mpsc"><a href="#通道通信-mpsc" class="headerlink" title="通道通信 (mpsc)"></a>通道通信 (mpsc)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx.send(<span class="string">"Message"</span>).unwrap();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Received: &#123;&#125;"</span>, rx.recv().unwrap());</span><br></pre></td></tr></table></figure>

<h3 id="共享状态-Mutex"><a href="#共享状态-Mutex" class="headerlink" title="共享状态 (Mutex)"></a>共享状态 (Mutex)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handles: <span class="built_in">Vec</span>&lt;_&gt; = (<span class="number">0</span>..<span class="number">10</span>).map(|_| &#123;</span><br><span class="line">    <span class="keyword">let</span> c = Arc::clone(&amp;counter);</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = c.lock().unwrap();</span><br><span class="line">        *num += <span class="number">1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).collect();</span><br></pre></td></tr></table></figure>

<h3 id="异步编程-async-await"><a href="#异步编程-async-await" class="headerlink" title="异步编程 (async/await)"></a>异步编程 (async/await)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_data</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">    reqwest::get(<span class="string">"https://api.example.com/data"</span>)</span><br><span class="line">        .<span class="keyword">await</span>?</span><br><span class="line">        .text()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> data = fetch_data().<span class="keyword">await</span>.unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Data: &#123;&#125;"</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八-常用集合类型"><a href="#八-常用集合类型" class="headerlink" title="八.常用集合类型"></a>八.常用集合类型</h2><h3 id="Vec-动态数组"><a href="#Vec-动态数组" class="headerlink" title="Vec 动态数组"></a>Vec<T> 动态数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::with_capacity(<span class="number">10</span>);</span><br><span class="line">v.extend([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全访问</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(val) = v.get(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second element: &#123;&#125;"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有权注意事项</span></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// v.push(4); // 编译错误！存在不可变引用时禁止修改</span></span><br></pre></td></tr></table></figure>

<h3 id="HashMap-lt-K-V-gt-哈希表"><a href="#HashMap-lt-K-V-gt-哈希表" class="headerlink" title="HashMap&lt;K, V&gt; 哈希表"></a>HashMap&lt;K, V&gt; 哈希表</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="string">"Blue"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry API 安全更新</span></span><br><span class="line">scores.entry(<span class="string">"Yellow"</span>).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="string">"Blue"</span>).and_modify(|e| *e += <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1 id="阶段二-os基础"><a href="#阶段二-os基础" class="headerlink" title="阶段二,os基础"></a>阶段二,os基础</h1><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><h3 id="与上下文-特权级有关的寄存器"><a href="#与上下文-特权级有关的寄存器" class="headerlink" title="与上下文, 特权级有关的寄存器"></a>与上下文, 特权级有关的寄存器</h3><ul>
<li>sstatus：包含了处理器的状态信息，包括特权级别和中断使能状态。恢复 sstatus 的值确保在返回用户态时，处理器的特权级别和中断状态与陷阱发生前一致。</li>
<li>sepc：保存了中断或异常发生时的程序计数器值。恢复 sepc 的值确保在返回用户态时，处理器能够从中断或异常发生的地方继续执行。</li>
<li>sscratch：保存了用户栈指针。在切换到用户态之前，将用户栈指针保存到 sscratch 寄存器中，以便在用户态下使用。</li>
<li>sret根据sstatus中的SPP位指示切换为用户态。（寄存器中的一个位，0,u_mode;1_,s_mode,s_mode）</li>
<li>scause: Trap原因/种类</li>
<li>stvec: trap_handle地址</li>
</ul>
<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><h3 id="SV39"><a href="#SV39" class="headerlink" title="SV39"></a>SV39</h3><ul>
<li>virtual page 39位, 38-12为虚拟页号</li>
<li>页表项PTE: Reserver: 10, PPN2: 26, PPN1: 9, PPN0: 9, RSW: 2, DAGUXWRV</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul>
<li>MMU地址转换</li>
<li>kernel address space最高位为 “跳板”, app ks, guard page</li>
<li>app address space, 最高位为跳板, TrapContext, UserStack, GP, Framed<h4 id="跳板意义"><a href="#跳板意义" class="headerlink" title="跳板意义:"></a>跳板意义:</h4>satp, 切换后,地址映射不同, 例如:上下文切换的restore, 在更改satp指令后, 保证下一条指令在不同的地址映射下能被正确寻址,保证指令的连续执行</li>
</ul>
<h3 id="TrapContext新增字段"><a href="#TrapContext新增字段" class="headerlink" title="TrapContext新增字段"></a>TrapContext新增字段</h3><p>在进行特权级转换时, 需要相应的sp以及satp的token</p>
<ul>
<li>pub kernel_satp: usize, 内核地址空间的 token</li>
<li>pub kernel_sp: usize, 当前应用在内核地址空间中的内核栈栈顶的虚拟地址</li>
<li>pub trap_handler: usize, 内核中 trap handler 入口点的虚拟地址</li>
</ul>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><ul>
<li>获得父进程的地址空间</li>
<li>sepc + 4</li>
<li>a0返回参数更改,父子进程不相同</li>
<li>维护父子进程关系</li>
<li>fd, 死锁检测等</li>
</ul>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ul>
<li><p>stride算法:</p>
<ul>
<li>为TCB加上schedule块(struct), 同时预留了pass设置的接口</li>
<li>为sys_set_priority加入了对priority的设置 </li>
<li>将TaskManager块改为了用binaryheap存储, 并为TCB分配了Ord特性,每次选取都会取stride最小的调度</li>
</ul>
</li>
<li><p>向前兼容</p>
<ul>
<li>重写mmap和munmap(用到了remove_area_with_start_vpn)</li>
<li>重写了sys_get_time,用到了translate_va</li>
</ul>
</li>
</ul>
<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统本质上是一堆块上的抽象, 在内存中有缓存块对其进行映射.</p>
<p>进程维护一个文件描述符表,可映射到对应的缓存块</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ],</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    modified: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供对应的接口调用</span></span><br></pre></td></tr></table></figure>

<h3 id="easy-fs磁盘布局"><a href="#easy-fs磁盘布局" class="headerlink" title="easy-fs磁盘布局"></a>easy-fs磁盘布局</h3><ul>
<li><p>超级块 (Super Block)，用于定位其他连续区域的位置，检查文件系统合法性。</p>
</li>
<li><p>索引节点位图，长度为若干个块。它记录了索引节点区域中有哪些索引节点已经被分配出去使用了。</p>
</li>
<li><p>索引节点区域，长度为若干个块。其中的每个块都存储了若干个索引节点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据块位图，长度为若干个块。它记录了后面的数据块区域中有哪些已经被分配出去使用了。</p>
</li>
<li><p>数据块区域，其中的每个被分配出去的块保存了文件或目录的具体内容。</p>
</li>
</ul>
<h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>在引入线程后, 调度机制本质上是在线程块上进行切换. 会区分主线程和子线程</p>
<ul>
<li>创建线程不需要要建立新的地址空间</li>
<li>能够访问到进程所拥有的代码段， 堆和其他数据段</li>
<li>专有的用户态栈</li>
</ul>
<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><ul>
<li>在ProcessControlBlockInner加入了对mutex和sem的死锁检查块(all[], ava[], need[])</li>
<li>检测前对相应资源的need[] + 1</li>
<li>实现is_safe检测函数, 对finish==false和need &lt;= work的块, 回收allocation和finish=true,对标记flag=true, 当finish没有任何改变, 即本次循环flag==false时退出loop, 利用闭包all,检测finish所有线程是否全是true</li>
<li>若为unsafe, 则回退need, 返回-0xdead</li>
<li>若为safe, 则在down和lock之前drop(process_inner),防止线程堵塞无法释放资源, 在down和lock之后同时更新检查块中的矩阵</li>
<li>为up和unlock加上检查块的更新</li>
</ul>
<h3 id="Mutex实现问题"><a href="#Mutex实现问题" class="headerlink" title="Mutex实现问题"></a>Mutex实现问题</h3><ul>
<li>Mutex1的lock里,会一直尝试获取锁, 具体逻辑为当无法获得锁时,直接阻塞,让出cpu,直到被唤醒, 再重新尝试获得锁, unlock中释放锁,并且唤醒一个线程去竞争这个锁.</li>
<li>Mutex的lock,在无法获得锁时,直接堵塞,在unlock时,只有等待队列为空才释放锁.<pre><code>- 这里的unlock本质是锁资源的转移, A不释放锁, 而是唤醒一个直接使用这个资源的B线程(它醒来后直接运行临界区后的代码)</code></pre></li>
</ul>
<h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><h2 id="一-组件化内核基础与-Unikernel-模式"><a href="#一-组件化内核基础与-Unikernel-模式" class="headerlink" title="一, 组件化内核基础与 Unikernel 模式"></a><strong>一, 组件化内核基础与 Unikernel 模式</strong></h2><h3 id="组件化内核介绍"><a href="#组件化内核介绍" class="headerlink" title="组件化内核介绍"></a>组件化内核介绍</h3><h4 id="Unikernel-模式"><a href="#Unikernel-模式" class="headerlink" title="Unikernel 模式"></a>Unikernel 模式</h4><ul>
<li><strong>特点</strong>：<ul>
<li>应用与内核合一：编译为一个 Image，共享同一特权级（内核态）和地址空间。</li>
<li>无用户态 / 内核态切换：简单高效，但安全性较低（应用可直接访问内核资源）。</li>
</ul>
</li>
</ul>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><table>
<thead>
<tr>
<th>组件名称</th>
<th>功能描述</th>
<th>在实验中的作用</th>
</tr>
</thead>
<tbody><tr>
<td>axhal</td>
<td>硬件抽象层，屏蔽不同架构差异（如 Riscv64/ARM）</td>
<td>初始化串口、内存等硬件，提供底层 IO 接口</td>
</tr>
<tr>
<td>axruntime</td>
<td>内核运行时环境，负责引导流程、内存初始化、任务调度框架</td>
<td>执行内核启动流程，调用应用层代码</td>
</tr>
<tr>
<td>axstd</td>
<td>内核态标准库，提供基础数据结构和工具函数（如 println!）</td>
<td>实现字符终端输出功能</td>
</tr>
<tr>
<td>arceos_api</td>
<td>内核公共接口，定义组件间通信协议</td>
<td>统一组件间调用规范</td>
</tr>
</tbody></table>
<h4 id="Unikernel-的启动链"><a href="#Unikernel-的启动链" class="headerlink" title="Unikernel 的启动链"></a>Unikernel 的启动链</h4><ul>
<li><strong>硬件启动</strong>：通过 OpenSBI（Riscv 固件）加载内核 Image 到内存。</li>
<li><strong>引导阶段（axhal）</strong>：<ul>
<li>初始化 CPU 寄存器、MMU 分页（早期恒等映射）。</li>
<li>建立内核栈，为 Rust 运行时做准备。</li>
</ul>
</li>
<li><strong>运行时阶段（axruntime）</strong>：<ul>
<li>初始化内存分配器、日志系统。</li>
<li>调用应用层 main 函数，执行具体功能。</li>
</ul>
</li>
</ul>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="1-主函数-src-main-rs"><a href="#1-主函数-src-main-rs" class="headerlink" title="1. 主函数 src/main.rs"></a>1. 主函数 src/main.rs</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(feature = <span class="meta-string">"axstd"</span>, no_main)]</span> <span class="comment">// 若启用 axstd，不使用标准库的 main 入口</span></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"axstd"</span>)]</span> <span class="comment">// 根据 feature 条件编译</span></span><br><span class="line"><span class="keyword">use</span> axstd::println; <span class="comment">// 使用 axstd 的打印函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg_attr(feature = <span class="meta-string">"axstd"</span>, no_mangle)]</span> <span class="comment">// 避免符号名被修改</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, ArceOS!"</span>); <span class="comment">// 调用 axhal 提供的串口输出功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-依赖管理-Cargo-toml"><a href="#2-依赖管理-Cargo-toml" class="headerlink" title="2. 依赖管理 Cargo.toml"></a>2. 依赖管理 Cargo.toml</h4><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">axstd</span> = &#123; workspace = <span class="literal">true</span> &#125; // 引入 axstd 组件，支持标准库功能</span><br><span class="line"><span class="attr">arceos_api</span> = &#123; workspace = <span class="literal">true</span> &#125; // 引入内核公共接口</span><br></pre></td></tr></table></figure>

<h4 id="3-features-动态配置"><a href="#3-features-动态配置" class="headerlink" title="3. features 动态配置"></a>3. features 动态配置</h4><ul>
<li><strong>作用</strong>：通过编译参数控制组件的启用，实现 “按需构建”。</li>
<li><strong>示例</strong>：<ul>
<li>axstd 组件通过 feature = “axstd” 控制是否包含。</li>
<li>实验中默认启用 axstd，因此能使用 println!。</li>
</ul>
</li>
</ul>
<h4 id="println"><a href="#println" class="headerlink" title="println!"></a>println!</h4><p>通过更改ulib下axstd,macros文件中的println!</p>
<h4 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"alloc"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> collections;</span><br></pre></td></tr></table></figure>
<p>暴露自己写的collections</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.hashbrown]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.14"</span></span><br><span class="line"><span class="attr">default-features</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>用了官方库的core版本</p>
<h2 id="二-内存管理与多任务基础"><a href="#二-内存管理与多任务基础" class="headerlink" title="二, 内存管理与多任务基础"></a><strong>二, 内存管理与多任务基础</strong></h2><h4 id="1-分页的两个阶段"><a href="#1-分页的两个阶段" class="headerlink" title="1. 分页的两个阶段"></a>1. 分页的两个阶段</h4><table>
<thead>
<tr>
<th>阶段</th>
<th>目标</th>
<th>实现方式</th>
<th>关键组件</th>
</tr>
</thead>
<tbody><tr>
<td>早期启用（必须）</td>
<td>快速建立基本映射，保证内核启动</td>
<td>1GB 恒等映射（虚拟地址 = 物理地址）</td>
<td>axhal 中的 BOOT_PT_SV39 页表</td>
</tr>
<tr>
<td>后期重映射（可选，需 paging feature）</td>
<td>扩展地址空间，支持设备 MMIO</td>
<td>细粒度权限控制（如只读、可执行）</td>
<td>axmm 中的 AddrSpace、PageTable</td>
</tr>
</tbody></table>
<h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h4><table>
<thead>
<tr>
<th>算法</th>
<th align="center">原理</th>
</tr>
</thead>
<tbody><tr>
<td>TLSF</td>
<td align="center">两级 Bitmap + 链表管理空闲块</td>
</tr>
<tr>
<td>Buddy</td>
<td align="center">基于 2 的幂次分裂 / 合并空闲块</td>
</tr>
<tr>
<td>Slab</td>
<td align="center">为特定大小对象创建缓存池</td>
</tr>
</tbody></table>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>全局分配器：通过 <code>#[global_allocator]</code> 声明，实现 <code>GlobalAlloc</code> trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg_attr(all(target_os = <span class="meta-string">"none"</span>, not(test)), global_allocator)]</span></span><br><span class="line"><span class="keyword">static</span> GLOBAL_ALLOCATOR: GlobalAllocator = GlobalAllocator::new();</span><br></pre></td></tr></table></figure>

<h4 id="任务数据结构-TaskInner"><a href="#任务数据结构-TaskInner" class="headerlink" title="任务数据结构 TaskInner"></a>任务数据结构 <code>TaskInner</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskInner</span></span> &#123;</span><br><span class="line">    id: TaskId,           <span class="comment">// 唯一标识</span></span><br><span class="line">    name: <span class="built_in">String</span>,         <span class="comment">// 任务名称（调试用）</span></span><br><span class="line">    state: AtomicU8,      <span class="comment">// 状态（Running/Ready/Blocked/Exited）</span></span><br><span class="line">    kstack: <span class="built_in">Option</span>&lt;TaskStack&gt;, <span class="comment">// 任务栈（类似线程栈）</span></span><br><span class="line">    ctx: UnsafeCell&lt;TaskContext&gt;, <span class="comment">// 上下文（保存寄存器状态）</span></span><br><span class="line">    <span class="comment">// 其他字段：调度相关（如时间片、优先级）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协作式调度"><a href="#协作式调度" class="headerlink" title="协作式调度"></a>协作式调度</h4><p>FIFO 队列：任务按 “先到先服务” 原则执行，当前任务需主动让出 CPU（调用 <code>yield_now()</code>）。</p>
<h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><table>
<thead>
<tr>
<th>组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>axsync</td>
<td>同步原语（自旋锁、互斥锁）</td>
</tr>
<tr>
<td>axtask</td>
<td>调度接口（spawn/yield_now 等）</td>
</tr>
</tbody></table>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>EarlyAllocator实现要求比较低</p>
<h5 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h5><ul>
<li><strong>alloc</strong><ul>
<li>注意每次分配内存时候的对齐</li>
<li>预分配，检查是否与p_pos重叠</li>
<li>为count++<ul>
<li>注意每次分配内存时候的对齐</li>
<li>预分配,检查是否与p_pos重叠</li>
<li>为count++</li>
</ul>
</li>
</ul>
</li>
<li>dealloc<ul>
<li>单纯的count–</li>
<li>count==0时,就可以重置b_pos了</li>
</ul>
</li>
</ul>
<h5 id="page"><a href="#page" class="headerlink" title="page"></a>page</h5><ul>
<li><strong>alloc</strong><ul>
<li>检查alignment是否有效</li>
<li>获取分配的size进行对齐，同时检查是否越界</li>
<li>更新数据<ul>
<li>检查alignment是否有效</li>
<li>获取分配的size进行对齐,同时检查是否越界</li>
<li>更新数据</li>
</ul>
</li>
</ul>
</li>
<li>dealloc<ul>
<li>不要求实现</li>
</ul>
</li>
</ul>
<h2 id="三、调度-块设备-文件系统"><a href="#三、调度-块设备-文件系统" class="headerlink" title="三、调度,块设备,文件系统"></a><strong>三、调度,块设备,文件系统</strong></h2><h3 id="时钟中断："><a href="#时钟中断：" class="headerlink" title="时钟中断："></a>时钟中断：</h3><h4 id="代码（Riscv64-中断初始化）"><a href="#代码（Riscv64-中断初始化）" class="headerlink" title="代码（Riscv64 中断初始化）"></a>代码（Riscv64 中断初始化）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axhal/src/platform/riscv64_qemu_virt/mod.rs</span></span><br><span class="line">axhal::irq::register_handler(TIMER_IRQ_NUM, || &#123;</span><br><span class="line">    update_timer(); <span class="comment">// 更新系统时间</span></span><br><span class="line">    axtask::on_timer_tick(); <span class="comment">// 触发调度器更新</span></span><br><span class="line">&#125;);</span><br><span class="line">axhal::arch::enable_irqs(); <span class="comment">// 开中断</span></span><br></pre></td></tr></table></figure>


<h3 id="块设备驱动："><a href="#块设备驱动：" class="headerlink" title="块设备驱动："></a>块设备驱动：</h3><h4 id="Trait：BlockDriverOps"><a href="#Trait：BlockDriverOps" class="headerlink" title="Trait：BlockDriverOps"></a>Trait：BlockDriverOps</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BlockDriverOps</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">num_blocks</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u64</span>; <span class="comment">// 磁盘总块数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">block_size</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span>; <span class="comment">// 块大小（512 字节）</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_id: <span class="built_in">u64</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; DevResult; <span class="comment">// 读块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="文件系统："><a href="#文件系统：" class="headerlink" title="文件系统："></a>文件系统：</h3><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>文件系统（FileSystem）：如 FAT32、EXT4。</p>
<p>目录（Dir）：存储文件 / 子目录元数据。</p>
<p>文件（File）：存储具体数据，支持读写操作。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">VfsOps</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">root_dir</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;DirNode; <span class="comment">// 获取根目录</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lookup</span></span>(&amp;<span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;FileNode&gt;; <span class="comment">// 解析路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h4><p>块设备读取：通过 VirtIO Blk 驱动读取磁盘前 512 字节（引导扇区）。</p>
<p>解析 BPB：获取 FAT 表起始地址、簇大小等参数。</p>
<p>挂载文件系统：将 FAT32 的根目录挂载到 VFS 的 / 节点。</p>
<h4 id="应用加载示例（U-8-实验）"><a href="#应用加载示例（U-8-实验）" class="headerlink" title="应用加载示例（U.8 实验）"></a>应用加载示例（U.8 实验）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 FAT32 文件系统加载应用程序</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">load_app</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> root = vfs.root_dir();</span><br><span class="line">    <span class="keyword">let</span> file = root.lookup(path).ok_or(<span class="string">"文件不存在"</span>)?;</span><br><span class="line">    file.read_to_end() <span class="comment">// 读取文件内容到内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h3><h4 id="寻找ing"><a href="#寻找ing" class="headerlink" title="寻找ing"></a>寻找ing</h4><p>在axfs_ramf中实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> VfsNodeOps <span class="keyword">for</span> DirNode&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>文件时通过封装的BTreeMap管理的, 替换相应键值对即可</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">rename</span></span>(&amp;<span class="keyword">self</span>, src_path: &amp;<span class="built_in">str</span>, dst_path: &amp;<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<p>src和dst_path路径层级不一样<br>我使用了split_path_to_end来获取最终的文件名</p>
<h2 id="四-地址空间管理"><a href="#四-地址空间管理" class="headerlink" title="四, 地址空间管理"></a><strong>四, 地址空间管理</strong></h2><h3 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键修改：init_user_stack的lazy参数设为false</span></span><br><span class="line"><span class="keyword">let</span> ustack_top = init_user_stack(&amp;<span class="keyword">mut</span> uspace, <span class="literal">false</span>).unwrap(); <span class="comment">// 延迟映射</span></span><br></pre></td></tr></table></figure>

<p><strong>缺页异常处理流程</strong></p>
<ul>
<li>异常触发：用户态访问未映射地址（如栈写入），CPU 陷入内核。</li>
<li>处理逻辑：<ol>
<li>通过handle_page_fault函数申请物理页帧（alloc_frame）</li>
<li>在页表中建立虚拟地址与物理页帧的映射（pt.remap）</li>
</ol>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_page_fault</span></span>(...) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> frame = alloc_frame(<span class="literal">true</span>); <span class="comment">// 申请物理页</span></span><br><span class="line">    pt.remap(vaddr, frame, orig_flags); <span class="comment">// 建立映射</span></span><br><span class="line">    tlb.flush(); <span class="comment">// 刷新TLB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ELF-格式解析"><a href="#ELF-格式解析" class="headerlink" title="ELF 格式解析"></a>ELF 格式解析</h3><p>关键段：<br>LOAD 段：包含代码段（R E标志）和数据段（RW标志）。<br>BSS 段：未初始化数据，ELF 文件不存储，内核需预留空间并清零。<br>加载逻辑：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> segment <span class="keyword">in</span> elf.segments &#123;</span><br><span class="line">    if segment.type == LOAD &#123;</span><br><span class="line">        <span class="keyword">let</span> vaddr = segment.virt_addr;</span><br><span class="line">        <span class="keyword">let</span> phys_frame = alloc_frame(segment.mem_siz);</span><br><span class="line">        map_virtual_to_physical(vaddr, phys_frame, segment.flags);</span><br><span class="line">        <span class="keyword">if</span> segment.has_data &#123;</span><br><span class="line">            copy_file_data(vaddr, segment.file_offset, segment.file_siz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zero_memory(vaddr, segment.mem_siz); <span class="comment">// BSS段清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验实现-1"><a href="#实验实现-1" class="headerlink" title="实验实现"></a>实验实现</h3><p>得到aspace-&gt;分配内存-&gt;将文件信息写入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAP_SHARED = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;    <span class="comment">// 共享映射，对映射区域的修改会反映到文件中</span></span><br><span class="line"><span class="keyword">const</span> MAP_PRIVATE = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;   <span class="comment">// 私有映射，对映射区域的修改不会反映到文件中</span></span><br><span class="line"><span class="keyword">const</span> MAP_FIXED = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;     <span class="comment">// 必须使用指定的映射地址</span></span><br><span class="line"><span class="keyword">const</span> MAP_ANONYMOUS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>; <span class="comment">// 匿名映射，不与文件关联</span></span><br><span class="line"><span class="keyword">const</span> MAP_NORESERVE = <span class="number">1</span> &lt;&lt; <span class="number">14</span>; <span class="comment">// 不保留交换空间</span></span><br><span class="line"><span class="keyword">const</span> MAP_STACK = <span class="number">0x20000</span>;    <span class="comment">// 用于栈分配</span></span><br></pre></td></tr></table></figure>

<p>这里只处理MAP_PRIVATE,<br>同时addr.is_null(),可通过aspace.find_free_area寻找内存</p>
<h2 id="五-Hypervisor"><a href="#五-Hypervisor" class="headerlink" title="五, Hypervisor"></a><strong>五, Hypervisor</strong></h2><h3 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>Hypervisor（虚拟机监控器）是运行在物理硬件与虚拟机之间的虚拟化层软件，允许多个虚拟机共享物理资源，每个虚拟机拥有独立的虚拟硬件环境（如vCPU、vMem、vDevice）。</p>
<h4 id="1-2-核心功能"><a href="#1-2-核心功能" class="headerlink" title="1.2 核心功能"></a>1.2 核心功能</h4><ul>
<li><strong>资源虚拟化</strong>：模拟CPU、内存、设备等硬件资源</li>
<li><strong>隔离与调度</strong>：确保虚拟机之间资源隔离，并高效调度物理资源</li>
<li><strong>模式切换</strong>：在Host（Hypervisor）与Guest（虚拟机）之间双向切换</li>
</ul>
<h4 id="1-3-与模拟器的区别"><a href="#1-3-与模拟器的区别" class="headerlink" title="1.3 与模拟器的区别"></a>1.3 与模拟器的区别</h4><table>
<thead>
<tr>
<th>维度</th>
<th>Hypervisor</th>
<th>模拟器(Emulator)</th>
</tr>
</thead>
<tbody><tr>
<td>ISA一致性</td>
<td>虚拟环境与物理环境ISA一致</td>
<td>可模拟不同ISA（如x86模拟ARM）</td>
</tr>
<tr>
<td>指令执行</td>
<td>大部分指令直接在物理CPU执行</td>
<td>全部指令需翻译/解释执行</td>
</tr>
<tr>
<td>性能目标</td>
<td>高效（虚拟化开销低）</td>
<td>侧重仿真效果，性能要求低</td>
</tr>
</tbody></table>
<h4 id="1-4-虚拟化类型"><a href="#1-4-虚拟化类型" class="headerlink" title="1.4 虚拟化类型"></a>1.4 虚拟化类型</h4><ol>
<li><strong>I型Hypervisor</strong>：直接运行在硬件上（如Xen、KVM），性能高</li>
<li><strong>II型Hypervisor</strong>：运行在宿主OS上（如VirtualBox），依赖宿主资源管理</li>
</ol>
<h3 id="二-Riscv64虚拟化扩展（H扩展）"><a href="#二-Riscv64虚拟化扩展（H扩展）" class="headerlink" title="二. Riscv64虚拟化扩展（H扩展）"></a>二. Riscv64虚拟化扩展（H扩展）</h3><h4 id="2-1-特权级扩展"><a href="#2-1-特权级扩展" class="headerlink" title="2.1 特权级扩展"></a>2.1 特权级扩展</h4><p>新增特权级：</p>
<ul>
<li><strong>HS</strong>(Hypervisor Supervisor)：Host域的管理级，负责虚拟化控制</li>
<li><strong>VS</strong>(Virtual Supervisor)：Guest域的内核级，运行Guest OS内核</li>
<li><strong>VU</strong>(Virtual User)：Guest域的用户级，运行Guest应用</li>
</ul>
<p>特权级关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">物理机：M（最高） &gt; HS &gt; U</span><br><span class="line">虚拟机：VS（Guest内核） &gt; VU（Guest用户）</span><br></pre></td></tr></table></figure>

<h4 id="2-2-关键寄存器"><a href="#2-2-关键寄存器" class="headerlink" title="2.2 关键寄存器"></a>2.2 关键寄存器</h4><ul>
<li><strong>hstatus</strong>：控制Host与Guest的模式切换<ul>
<li>SPV位：指示进入HS前的模式（0：非虚拟化模式；1：来自Guest的VS模式）</li>
<li>SPVP位：控制HS是否有权限操作Guest的地址空间</li>
</ul>
</li>
<li><strong>vs[xxx]/hs[xxx]</strong>：分别用于Guest和Host的上下文管理</li>
<li><strong>misa</strong>：标识是否支持H扩展（bit7=1表示支持）</li>
</ul>
<h3 id="3-模式切换机制"><a href="#3-模式切换机制" class="headerlink" title="3. 模式切换机制"></a>3. 模式切换机制</h3><h4 id="3-1-从Host到Guest（run-guest函数）"><a href="#3-1-从Host到Guest（run-guest函数）" class="headerlink" title="3.1 从Host到Guest（run_guest函数）"></a>3.1 从Host到Guest（run_guest函数）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存Host寄存器状态</span></span><br><span class="line">sd ra, (hyp_ra)(a0)  <span class="comment">// 保存返回地址</span></span><br><span class="line"><span class="comment">// 加载Guest寄存器状态</span></span><br><span class="line">ld sstatus, guest_sstatus(a0)</span><br><span class="line"><span class="comment">// 执行sret指令切换到VS模式</span></span><br><span class="line">sret</span><br></pre></td></tr></table></figure>
<p>可参考guest.s</p>
<ul>
<li>a0指向的guest_reg区域 与 当前reg的替换<h4 id="3-2-VM-Exit处理（以SBI调用为例）"><a href="#3-2-VM-Exit处理（以SBI调用为例）" class="headerlink" title="3.2 VM-Exit处理（以SBI调用为例）"></a>3.2 VM-Exit处理（以SBI调用为例）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">    Trap::Exception(Exception::VirtualSupervisorEnvCall) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> sbi_msg = SbiMessage::from_regs(ctx.guest_regs.gpr);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(SbiMessage::Reset(Shutdown)) = sbi_msg &#123;</span><br><span class="line">            ax_println!(<span class="string">"Shutdown vm normally!"</span>);</span><br><span class="line">            <span class="comment">// 清理Guest资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>根据结果硬编码,更改guest_reg的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/04/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-joeschmo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/04/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-joeschmo/" class="post-title-link" itemprop="url">2025 春夏季开源操作系统训练营阶段总结-joeschmo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-04 20:48:14" itemprop="dateCreated datePublished" datetime="2025-06-04T20:48:14+00:00">2025-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage 1"></a>Stage 1</h2><p>这个阶段主要是学习Rust语法，因为之前有报名过训练营，所以做起来比较顺手，把基础语法又复习了一遍。</p>
<h2 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage 2"></a>Stage 2</h2><p>这个阶段主要是阅读实验指导书和源码。实验指导书非常重要，如果没有看明白的话对做实验有很大影响，所以要细心耐心看。时间有限的话，看精简版指导书即可。<br>完成实验部分需要重点理解几个点：</p>
<ol>
<li>任务切换机制，保存切换前后程序上下文</li>
<li>地址空间，多级页表机制</li>
<li>文件系统，操作与管理</li>
</ol>
<h2 id="Stage-3"><a href="#Stage-3" class="headerlink" title="Stage 3"></a>Stage 3</h2><p>这个阶段主要是看视频和PPT，并通过做6个实验来熟悉ArceOS的设计思想。相对于上一个阶段的实验会简单一些。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前有报名过两次训练营，但都没有坚持下来。对于如何平衡学习、工作和自我提升之间的平衡，是一个我现在以及将来都需要仔细思考的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/03/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-vipectuSSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/06/03/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-vipectuSSS/" class="post-title-link" itemprop="url">2025春夏开源操作系统训练营三阶段总结报告--vipectuSSS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-03 14:06:08" itemprop="dateCreated datePublished" datetime="2025-06-03T14:06:08+00:00">2025-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>这样的总结应该从何开始？我是从<a href="https://www.bilibili.com/" target="_blank" rel="noopener">Bilibili</a>刷视频偶然了解到与训练营相关的信息的。使用Rust语言编写操作系统的实践，我太喜欢这个方向了。因为我正学过一点Rust，也经学校老师的推荐看过CSAPP并完成了大多数的实验。其中我最喜欢的便是<code>shlab</code>和<code>attacklab</code>────写一个shell！实在是有趣不过，如果再写一个操作系统呢？好吧，我应该没有与之匹配的实力，不过开源操作系统训练营就这样给了我一个类似的机会。报名人数破千！全程免费！还有什么好说的呢，杀😡。</p>
<h1 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage 1"></a>Stage 1</h1><p>110道Rustling编程题，并没有耗费我太多功夫，更多的是重新熟悉一下语法。我觉得，学习Rust不仅是学会如何使用一门编程语言，更是了解更多的编程范式。例如<code>trait</code>背后的组合大于继承；函数式编程对现代编程语言深刻的影响：默认不可变、闭包、HOFs、链式操作等；所有权与生命周期机制，这种RAII思想是C++首创的（但是opt-out）。Rust编译器就是你最好的老师，更别说还有满地走的各式AI（<del><em>本总结经AI辅助完成</em></del>），2025年的今天，学习Rust不应该再是一件难事🥳。</p>
<h1 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage 2"></a>Stage 2</h1><p>到了OS设计实现，主要是完成5道rCore操作系统大实验编程题。我是提前进入该阶段，所以全程并没有看过相关学习视频，而是跟随<a href="https://learningos.cn/rCore-Tutorial-Guide-2025S/" target="_blank" rel="noopener">rCore-Tutorial-Guide</a>文档完成的🤓。</p>
<p>这阶段最耗时的是lab2───地址空间和lab5───并发，这两个不管哪个太痛苦了😭。lab2是因为分页机制本身就相对复杂，层层抽象，读内核新增的代码就花了我很久时间（光论这一点文件系统其实不遑多让，不过到这里我的读代码能力已经得到显著锻炼了，所以带给我的痛苦远不及地址空间🥱）。而lab5，单纯是我因为技术路线的左右互博而无限拖缓了进度，我一直在对死锁检测资源的获取上究竟是现场构建还是跟随进程保存之间反复横跳。倒不如说，是因为我在实现这两个的时候遭遇多方掣肘，导致我不停怀疑我自己，不停的重构。使用Rust编程不就是戴着脚镣在跳舞吗？我现在水平还不够，只能写出不够优美的实现，但是我不会放弃的😡。</p>
<h1 id="Stage-3"><a href="#Stage-3" class="headerlink" title="Stage 3"></a>Stage 3</h1><p>组件化操作系统，这大概是最各显神通的阶段了。我对这阶段的印象其实是一点草台味🤯，遇到各方面奇怪的问题，测试脚本死活不通过，各种不同的资料，到底要实现在哪里，我要怎么修改一个crate依赖的代码？我是个不撞南墙不愿意问别人的人，所以我全部都闭门造车自己解决了所有问题（真的吗？至少测例说我通过了）。但实际上，在讨论群里大家都很乐意回答别人的提问，每个人都有自己的“奇技淫巧”，应该让大家全都热烈讨论遇到的问题，才能让训练营变得更好😈。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>写到这里我已经有点精疲力竭。我在参与前三个阶段的过程中收获颇多，不只是对整个组件化操作系统的认识。还有各种在学习过程中对工具的使用，<code>helix</code>、<code>Zellij</code>，这些工具，我很早就下载了，只是因为它是Rust重写的老工具。现在呢？我需要<code>helix</code>丰富的快捷键，我需要<code>Zellij</code>的分屏。我开始熟悉，正是我开始迈出一步，参加了这次，<a href="https://opencamp.cn/os2edu/camp/2025spring" target="_blank" rel="noopener">2025 春夏季开源操作系统训练营</a>。</p>
<p>完成了三阶段的任务，我也疲惫了，进入了一种拖延的状态。五月二十二号，新建文件夹，想要完成这篇总结报告。一直到今天，我终于又想重新出发了。希望到了第四阶段，我可以找到新的方向。</p>
<p>编程的乐趣：⭐️⭐️⭐️⭐️<br>挑战的难度：⭐️⭐️⭐️<br>开源训练营：⭐️⭐️⭐️⭐️⭐️</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/30/wwj%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/30/wwj%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">wwj三阶段学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-30 10:26:23" itemprop="dateCreated datePublished" datetime="2025-05-30T10:26:23+00:00">2025-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RUST学习总结"><a href="#RUST学习总结" class="headerlink" title="RUST学习总结"></a>RUST学习总结</h1><h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ul>
<li>函数名和变量名使用<a href="https://course.rs/practice/naming.html" target="_blank" rel="noopener">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; {}</code></li>
<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>
<li>每个函数参数都需要标注类型</li>
</ul>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>基础类型：不会转移所有权，属于复制变量的值</p>
<p>复合类型：会转移所有权，相当于重新绑定变量</p>
<p> （深拷贝：<code>复合类型变量名.clone()</code>，不转移所有权）</p>
<p><strong>引用</strong></p>
<ul>
<li>以<code>&amp;</code>表示引用，以<code>*</code>表示解引用</li>
<li>可变引用首先要求变量可变，引用时也要写成<code>&amp;mut 变量名</code>，否则是可变变量的不可变引用</li>
<li>一个变量的可变引用同时只能存在一个，可变与不可变引用不可同时存在</li>
<li>“同时”指引用的作用域，为引用”从创建开始，一直持续到它最后一次使用的地方“</li>
</ul>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>切片：对<code>string</code>类型中某一部分的引用，即<code>&amp;变量名[开始……终止]</code>，切片类型为<code>&amp;str</code></p>
<p><code>string</code>与<code>&amp;str</code>的转化：</p>
<p> <code>&amp;str</code>化成<code>string</code>: <code>String::from(&quot;字符串字面量&quot;)</code>/<code>&quot;字符串字面量&quot;.to_string()</code></p>
<p> <code>string</code>化成<code>&amp;str</code>: 取切片</p>
<p><strong>操作字符串</strong>（针对于<code>string</code>）</p>
<ul>
<li>追加：<code>push(字符)/push_str(字符串字面量（不能是string类型）)</code> 改变原有的字符串（不返回新值，必须<code>mut</code>可变）</li>
<li>插入：<code>insert()/insert_str()</code> 需要传入两个参数，第一个是插入位置索引，第二个是插入内容 改变原有字符串</li>
<li>替换：<code>replace(被替换的字符串，新的字符串)</code> 返回新的字符串（需要新变量接收）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let string_replace &#x3D; String::from(&quot;I like rust. Learning rust is my favorite!&quot;);</span><br><span class="line">let new_string_replace &#x3D; string_replace.replace(&quot;rust&quot;, &quot;RUST&quot;);</span><br></pre></td></tr></table></figure>

<p> <code>replacen(被替换的字符串，新的字符串，替换的个数)</code> 返回新的字符串</p>
<p> <code>replace_range(要替换的范围，新的字符串)</code> 改变原有的字符串</p>
<ul>
<li><p>删除：<code>pop()</code> 删除并返回最后一个字符 改变原有的字符串</p>
<p><code>remove(字符起始索引)</code> 删除并返回指定位置的字符 改变原有的字符串</p>
<p><code>truncate(字符起始索引)</code> 删除指定位置至结尾的所有字符 改变原有字符串</p>
<p><code>clear()</code> 清空字符串</p>
</li>
<li><p>连接：<code>+/+=</code> 相当于调用函数<code>add(self, s:&amp;str……)</code> 第一个参数是<code>string</code>,其所有权会被转移，后面的参数需要<code>&amp;str</code>类型 <code>&#39;+&#39;返回新的字符串</code></p>
<p> <code>format!(&quot;{}&quot;, s)</code> 用法与<code>println!</code>类似， 返回新的字符串</p>
</li>
</ul>
<p><strong>注：</strong>此处所有涉及索引的方法（包括切片），都是以字节为单位处理数据；对于<code>UTF-8</code>类型字符非常容易出错</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、&#x2F;&#x2F; 定义字段</span><br><span class="line">struct 结构体名称 &#123;</span><br><span class="line">    字段名称1： 类型 &#x2F;&#x2F;结构体字段</span><br><span class="line">&#125;</span><br><span class="line">gree</span><br><span class="line">2、&#x2F;&#x2F; 初始化：每个字段都要初始化，但顺序不一定一样</span><br><span class="line">let 变量名 &#x3D;  结构体名称 &#123;</span><br><span class="line">    字段名称1： 值 </span><br><span class="line">&#125;</span><br><span class="line">let 变量名 &#x3D;  结构体名称 &#123;</span><br><span class="line">    字段名称1： 值 </span><br><span class="line">    ..另一个同类型变量2名的名称	&#x2F;&#x2F;	剩余自动从另一变量中获取（该语句必须位于尾部）</span><br><span class="line">    				&#x2F;&#x2F;	同时变量2部分字段会发生所有权转移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、&#x2F;&#x2F; 访问字段</span><br><span class="line">变量名.字段名	</span><br><span class="line"></span><br><span class="line">4、&#x2F;&#x2F; 元组结构体、单元结构体</span><br><span class="line">let a : (i32, f64, u8) &#x3D; (500, 6.4, 1); &#x2F;&#x2F; (i32, f64, u8)是元组</span><br><span class="line">struct Color(i32, i32, i32); &#x2F;&#x2F; 元组结构体，适用于结构体有名称，字段没有的情况</span><br><span class="line">struct AlwaysEqual; &#x2F;&#x2F; 单元结构体，没有属性与字段</span><br><span class="line"></span><br><span class="line">5、 &#x2F;&#x2F; 结构体数据所有权：字段值最好不要基于引用，否则需要加上生命周期</span><br><span class="line"></span><br><span class="line">6、 &#x2F;&#x2F; 正常情况无法&#123;&#125;打印，需要在开头加上#[derive(Debug)]，使用&#123;:?&#125;或&#123;:#?&#125;来打印</span><br></pre></td></tr></table></figure>



<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 枚举变体携带数据</span><br><span class="line">enum PokerCard &#123;</span><br><span class="line">    Clubs(u8),</span><br><span class="line">    Spades(u8),</span><br><span class="line">    Diamonds(char),</span><br><span class="line">    Hearts(char),</span><br><span class="line">&#125; &#x2F;&#x2F; 任何类型的数据都可以放入枚举成员中，包括另一个枚举或者结构体</span><br><span class="line">let c1 &#x3D; PokerCard::Spades(5);</span><br></pre></td></tr></table></figure>



<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>分为静态的<code>array</code>和动态数组<code>vector</code>，先看<code>array</code></p>
<p><code>array</code>可以正常使用下标访问，可以使用<code>{:?}</code>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1, 2, 3, 4, 5]; &#x2F;&#x2F; 定义</span><br><span class="line">let a: [i32; 5] &#x3D; [1, 2, 3, 4, 5]; &#x2F;&#x2F; 需要声明类型时</span><br><span class="line">let a &#x3D; [3; 5]; &#x2F;&#x2F; 某个值重复出现</span><br><span class="line">let arrays: [[u8; 3]; 4]  &#x3D; [one, two, blank1, blank2]; &#x2F;&#x2F; 二维数组</span><br><span class="line"></span><br><span class="line">let slice: &amp;[i32] &#x3D; &amp;a[1..3]; &#x2F;&#x2F; 数组切片</span><br></pre></td></tr></table></figure>



<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>if:</strong> <code>if</code>语句块是表达式，可以有返回值</p>
<p><strong>for</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for 元素 in 集合&#x2F;0..集合.len() &#123; &#x2F;&#x2F; 注意，此处集合需要使用引用，否则所有权会被转移（如需更改加上mut）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 想要获取元素的索引</span><br><span class="line">let a &#x3D; [4, 3, 2, 1];</span><br><span class="line">for (i, v) in a.iter().enumerate() &#123;</span><br><span class="line">    println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;, i + 1, v); &#x2F;&#x2F; .iter()方法把 &#96;a&#96; 数组变成一个迭代器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只在意循环次数</span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>continue</code>与<code>break</code>依然存在</p>
<p><strong>while</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while 条件 &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>loop</strong></p>
<p>无条件循环，必须搭配<code>break</code></p>
<p>（<code>break</code>类似于<code>return</code>，可以单独使用也可以带回来一个返回值；</p>
<p> loop同样是表达式，可以返回一个值）</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><h4 id="match和if-let"><a href="#match和if-let" class="headerlink" title="match和if let"></a>match和if let</h4><p><strong>match:</strong> 非常类似于<code>switch</code>(但匹配后只会执行当前分支，而不会往下”贯穿“)</p>
<p><code>match</code>同样是表达式，可以有返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">match target &#123;</span><br><span class="line">    模式1 &#x3D;&gt; 表达式1, &#x2F;&#x2F; &#x3D;&gt;代替了:</span><br><span class="line">    模式2 | 模式3 &#x3D;&gt; &#123;	&#x2F;&#x2F; X|Y</span><br><span class="line">        语句1;</span><br><span class="line">        语句2;</span><br><span class="line">        表达式2 &#x2F;&#x2F; 注意，语句同样可以返回()</span><br><span class="line">    &#125;,</span><br><span class="line">    _ &#x3D;&gt; 表达式3 &#x2F;&#x2F; _代替了default，必须穷尽所有情况否则会报错</span><br><span class="line">    &#x2F;&#x2F;或者 任意无关变量名 &#x3D;&gt; 表达式3  &#x2F;&#x2F; 此时就可以对该变量操作，不操作记得使用_开头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式绑定（从匹配到的分支中取出绑定的值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState), &#x2F;&#x2F; 25美分硬币</span><br><span class="line">&#125;</span><br><span class="line">match coin &#123;</span><br><span class="line">        Coin::Penny &#x3D;&gt; 1,</span><br><span class="line">        Coin::Nickel &#x3D;&gt; 5,</span><br><span class="line">        Coin::Dime &#x3D;&gt; 10,</span><br><span class="line">        Coin::Quarter(state) &#x3D;&gt; &#123;</span><br><span class="line">            println!(&quot;State quarter from &#123;:?&#125;!&quot;, state); &#x2F;&#x2F; 可以取出绑定的具体state值</span><br><span class="line">            25</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>if let:</strong> 适用于只需要判断一个模式是否匹配的情况,比<code>if</code>更适用于匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let some_value &#x3D; Some(5);</span><br><span class="line">if let Some(v) &#x3D; some_value &#123;</span><br><span class="line">    println!(&quot;Value is: &#123;&#125;&quot;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>while let:</strong> while和let的总和，即如果满足条件就可循环，同样可以从模式匹配中拆出值</p>
<p><strong>注：</strong>match/if let/while let都会转移被匹配值的借用值的所有权，需要使用<code>ref</code>抵消（<code>ref</code>只在左侧生效）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let Some(ref x) &#x3D; value</span><br><span class="line">match opt &#123;</span><br><span class="line">    Some(ref s) &#x3D;&gt; println!(&quot;Got a reference to string: &#123;&#125;&quot;, s),</span><br></pre></td></tr></table></figure>



<h4 id="Option-lt-T-gt"><a href="#Option-lt-T-gt" class="headerlink" title="Option&lt;T&gt;"></a><code>Option&lt;T&gt;</code></h4><p>表示一个值是否存在的<strong>枚举</strong>(<code>Some&lt;T&gt;</code>与<code>T</code>不是同一类型)</p>
<p>对于<code>Some</code>和<code>None</code>可以不加<code>Option::</code>前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),  &#x2F;&#x2F; 表示有值</span><br><span class="line">    None,     &#x2F;&#x2F; 表示无值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储</span><br><span class="line">let x: Option&lt;i32&gt; &#x3D; Some(42);  &#x2F;&#x2F; Some(42) 代表 x 里面存了 42</span><br><span class="line">let y: Option&lt;i32&gt; &#x3D; None;      &#x2F;&#x2F; None 代表没有值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解构</span><br><span class="line">match x &#123;</span><br><span class="line">    Some(v) &#x3D;&gt; println!(&quot;Value is: &#123;&#125;&quot;, v),  &#x2F;&#x2F; 取出 v</span><br><span class="line">    None &#x3D;&gt; println!(&quot;No value&quot;),</span><br><span class="line">&#125;</span><br><span class="line">if let Some(v) &#x3D; x &#123;</span><br><span class="line">    println!(&quot;Value is: &#123;&#125;&quot;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>impl</code>中存储方法与<code>struct</code>中声明字段分开，同时一个结构体可以有多个<code>impl</code>块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; &amp;self代替了self:&amp;Self</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li><p><code>self</code> 表示 <code>Rectangle</code> 的所有权转移到该方法中，这种形式用的较少</p>
<p><code>&amp;self</code> 表示该方法对 <code>Rectangle</code> 的不可变借用</p>
<p><code>&amp;mut self</code> 表示可变借用</p>
</li>
<li><p>允许方法名和字段名相同</p>
</li>
<li><p>在调用方法时只有<code>.</code>没有<code>-&gt;</code></p>
</li>
<li><p>枚举同样可以定义方法</p>
</li>
</ul>
<p><strong>关联函数</strong></p>
<p>定义在结构体<code>impl</code>且没有<code>self</code>的函数</p>
<p>不能使用<code>变量.函数()</code>的方法调用，只能使用<code>结构体名称::函数名(参数)</code>来调用</p>
<p>比如<code>String::from()</code></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>为了抽象不同的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn 函数名&lt;T&gt;(变量名: T) -&gt; T &#123; &#x2F;&#x2F; 函数泛型</span><br><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125; &#x2F;&#x2F; 结构体泛型，多个类型也可以声明如struct Point&lt;T,U&gt;</span><br><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125; &#x2F;&#x2F; 枚举泛型，可以根据返回值的类型判断是否成功</span><br><span class="line">struct Point&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; </span><br><span class="line">    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: self.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 结构体泛型，impl处需要另外声明，impl中的方法可以拥有自己的泛型</span><br><span class="line">  &#x2F;&#x2F;对于结构体泛型，还可以为特定的泛型单独声明方法</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用<code>T</code>前需要先声明<code>&lt;T&gt;</code>，<code>T</code>的名字可以随便取</li>
<li>有时在调用泛型函数时需使用<code>函数名::&lt;具体类型&gt;()</code>来显式指定<code>T</code>的类型</li>
</ul>
<p><strong>const泛型</strong></p>
<p>允许常量值成为泛型变量，语法为<code>const N: usize</code>，表示const泛型N，它的值基于<code>usize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Buffer&lt;T, const N: usize&gt; &#123;</span><br><span class="line">    data: [T; N], &#x2F;&#x2F; N 作为数组大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const fn:</code> 在函数声明前加上<code>const</code>关键字</p>
<p><strong>注：</strong><code>const</code>泛型与<code>const fn</code>都需要在编译时确定，<code>const fn</code>就可以用于给<code>const</code>泛型赋值</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>定义了一组可以被共享的行为，只要实现了特征，你就能使用这组行为（类似于接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String; &#x2F;&#x2F; 只是一个抽象接口，而不具体实现</span><br><span class="line">&#125; &#x2F;&#x2F; 定义特征</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为每个需要的类单独实现特征</span><br><span class="line">impl Summary for Post &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;, self.title, self.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Summary for Weibo &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;, self.username, self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>孤儿规则：如果你想要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> <strong>或者</strong> <code>T</code> 至少有一个是在当前作用域中定义的（另一个可以在其他库中引入）</li>
<li>默认实现：可以在特征中定义具有默认实现的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法（默认实现允许调用特征中其他方法，哪怕这个方法没有默认实现）</li>
</ul>
<h4 id="特征约束"><a href="#特征约束" class="headerlink" title="特征约束"></a><strong>特征约束</strong></h4><p>特征作为函数参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify(item: &amp;impl Summary) &#123; &#x2F;&#x2F; 实现了Summary特征 的 item 参数</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 对于结构体方法</span><br><span class="line">impl&lt;T: Display&gt; ToString for T &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形如 <code>T: Summary</code> 被称为特征约束</p>
<p>多重约束:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 要求同时实现了两个特征的参数</span><br><span class="line">pub fn notify(item: &amp;(impl Summary + Display)) &#123;&#125;</span><br><span class="line">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>where</code>约束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 &#123;&#125;</span><br><span class="line">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32</span><br><span class="line">    where T: Display + Clone,</span><br><span class="line">          U: Clone + Debug</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>函数返回值：</p>
<p>通过 <code>impl Trait</code> 来说明一个函数返回了一个类型，该类型实现了某个特征</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn returns_summarizable() -&gt; impl Summary &#123; &#x2F;&#x2F; 返回一个实现了Summary特征的类型</span><br></pre></td></tr></table></figure>



<h4 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h4><table>
<thead>
<tr>
<th>特征约束</th>
<th>特征对象</th>
</tr>
</thead>
<tbody><tr>
<td><code>impl Trait</code></td>
<td><code>dyn Trait</code></td>
</tr>
<tr>
<td>接收所有实现了<code>Trait</code>的类型</td>
<td>接收所有实现了<code>Trait</code>的类型</td>
</tr>
<tr>
<td>认为是不一样的类型，不能一起存储</td>
<td>认为是相同的类型，可以一起存储</td>
</tr>
<tr>
<td>静态分发，编译时确定</td>
<td>动态分发，运行时确定</td>
</tr>
</tbody></table>
<p>允许你使用 不同类型 但 实现了相同特征 的对象，使它们可以在 同一个变量、参数或返回值 中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 语法</span><br><span class="line">&amp;dyn 特征名 &#x2F;&#x2F; 必须要使用指针，否则无法确定大小</span><br><span class="line">Box&lt;dyn 特征名&gt; &#x2F;&#x2F; 智能指针</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态数组</span><br><span class="line">Vec&lt;Box&lt;dyn 特征名&gt;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><h4 id="动态数组Vector"><a href="#动态数组Vector" class="headerlink" title="动态数组Vector"></a>动态数组<code>Vector</code></h4><p>使用<code>Vec&lt;T&gt;</code>表示，只能存储相同类型的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建数组</span><br><span class="line">let v: Vec&lt;i32&gt; &#x3D; Vec::new();</span><br><span class="line">let mut v &#x3D; Vec::new(); &#x2F;&#x2F; 在添加元素后会自动推导</span><br><span class="line">let mut v: Vec&lt;i32&gt; &#x3D; Vec::with_capacity(5); &#x2F;&#x2F; 预先分配空间</span><br><span class="line"></span><br><span class="line">let v &#x3D; vec![1, 2, 3]; &#x2F;&#x2F; 宏vec!可以给予初始值</span><br><span class="line">let v &#x3D; vec![0; 3];   &#x2F;&#x2F; 默认值为 0，初始长度为 3</span><br><span class="line">let v_from &#x3D; Vec::from([0, 0, 0]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新（需要为mut）</span><br><span class="line">v.push(n); &#x2F;&#x2F; 可变引用，不能与其他引用同时存在</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问元素</span><br><span class="line">v[下标] &#x2F;&#x2F;		越界不会检查</span><br><span class="line">v.get(下标) &#x2F;&#x2F; 返回Option&lt;T&gt;,需要match来解构出值		确保不会越界</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for i in &amp;(mut) v &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 常见方法</span><br><span class="line">v.is_empty()</span><br><span class="line">v.insert(pos, val) &#x2F;&#x2F; 在指定索引pos处插入数值val</span><br><span class="line">v.remove(pos) &#x2F;&#x2F; 删除在pos处的数并返回该数</span><br><span class="line">v.pop() &#x2F;&#x2F; 删除尾部的数并返回(返回的是Option&lt;T&gt;的枚举值)</span><br><span class="line">v.clear()</span><br><span class="line">v.append(&amp;mut v1) &#x2F;&#x2F; v1所有数据全部转入v，v1被清空</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排序</span><br><span class="line">sort&#x2F;sort_unstable() &#x2F;&#x2F; 默认按照升序类型，且要元素可比较</span><br><span class="line">sort_by&#x2F;sort_unstable_by(闭包实现) &#x2F;&#x2F; 可以自定义比较规则来实现多种类型的比较</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>可以通过使用枚举类型和特征对象来实现不同类型元素的存储</p>
<h4 id="KV存储HashMap"><a href="#KV存储HashMap" class="headerlink" title="KV存储HashMap"></a><code>KV</code>存储<code>HashMap</code></h4><p>需要使用<code>use std::collections::HashMap;</code>来引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建与插入</span><br><span class="line">let mut my_gems &#x3D; HashMap::new();</span><br><span class="line">my_gems.insert(&quot;红宝石&quot;, 1);</span><br><span class="line"></span><br><span class="line">HashMap::with_capacity(capacity)</span><br><span class="line"></span><br><span class="line">let teams_list &#x3D; vec![</span><br><span class="line">        (&quot;中国队&quot;.to_string(), 100),</span><br><span class="line">        (&quot;美国队&quot;.to_string(), 10),</span><br><span class="line">        (&quot;日本队&quot;.to_string(), 50),</span><br><span class="line">    ];</span><br><span class="line">let teams_map: HashMap&lt;_,_&gt; &#x3D; teams_list.into_iter().collect(); &#x2F;&#x2F; 从动态数组转化为hashmap</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在表中查询元素</span><br><span class="line">let score: Option&lt;&amp;value类型&gt; &#x3D; 表名.get(key的引用); &#x2F;&#x2F; 注意返回的是Option&lt;T&gt;类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for (key, value) in &amp;表名 &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新表中的值</span><br><span class="line">let old &#x3D; scores.insert(&quot;Blue&quot;, 20); &#x2F;&#x2F; 会直接覆盖旧值，返回Some(旧值)&#x2F;None</span><br><span class="line">let v &#x3D; scores.entry(&quot;Yellow&quot;).or_insert(5); &#x2F;&#x2F; 查询Yellow对应的值，若不存在则插入新值；返回存储值的可变引用</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<p><code>HashMap</code> 的所有权规则与其它 Rust 类型没有区别：</p>
<ul>
<li>若类型实现 <code>Copy</code> 特征，该类型会被复制进 <code>HashMap</code>，因此无所谓所有权</li>
<li>若没实现 <code>Copy</code> 特征，所有权将被转移给 <code>HashMap</code> 中（使用引用要确保其生命周期足够长）</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>变量的生命周期声明方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#39;a i32     &#x2F;&#x2F; 具有显式生命周期的引用</span><br><span class="line">&amp;&#39;a mut i32 &#x2F;&#x2F; 具有显式生命周期的可变引用</span><br></pre></td></tr></table></figure>

<h4 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h4><p>需要标注生命周期的情况如下：</p>
<ul>
<li>首先返回值必须是引用类型，可能会出现悬垂引用错误</li>
<li>存在多个参数时，如果编译器无法确定返回值需要跟随哪个参数的生命周期（哪怕这两个参数的生命周期是一样的），那么不标注就会报错</li>
<li>标注之后，编译时就会检查返回值使用会不会超出某个参数，如果发现超出就会报错（标注生命周期实际上<strong>不会更改任何返回值或者变量的真实生命周期</strong>，只是告诉编译器当返回值的生命周期不与较短的参数生命周期一致时，不予通过）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用&#39;a显式表示生命周期，此处的&#39;a表示两个参数中较短的生命周期，需要提前标注</span><br><span class="line">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特殊情况：返回值永远只和一个参数有关&#x2F;返回值与参数无关</span><br><span class="line">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;str) -&gt; &amp;&#39;a str &#123; &#x2F;&#x2F; 只与一个有关就只标注一个</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line">fn longest(_x: &amp;str, _y: &amp;str) -&gt; String &#123; &#x2F;&#x2F; 与新建变量有关尽量不返回引用</span><br><span class="line">    String::from(&quot;really long string&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h4><p>如果结构体的字段值类型为引用型，也需要标注生命周期<code>&#39;a</code>（<code>a</code>可以任意替换）</p>
<p>作用是避免编译器报错、同时(提醒编译器)在编译时就检查其是否不超过原变量的生命周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    part: &amp;&#39;a str,</span><br><span class="line">&#125; &#x2F;&#x2F; 只要在结构体每一个引用标注上生命周期即可，此处也需要提前声明&lt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期声明消除"><a href="#生命周期声明消除" class="headerlink" title="生命周期声明消除"></a>生命周期声明消除</h4><p>为何在只有一个参数时可以不标注生命周期？</p>
<p>存在以下三个步骤可以省略生命周期声明（函数中参数的生命周期是输入生命周期，返回值为输出）：</p>
<ol>
<li><p>每一个引用参数都会获得独自的生命周期（所以不声明则多个参数有各自的生命周期声明）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32) &#x2F;&#x2F; 所以不显式标出不知道跟随a还是b</span><br></pre></td></tr></table></figure>
</li>
<li><p>若只有一个输入生命周期（函数参数中只有一个引用类型），那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32 &#x2F;&#x2F; 所以单个参数可以省略</span><br></pre></td></tr></table></figure>
</li>
<li><p>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</p>
</li>
</ol>
<h4 id="方法中的生命周期"><a href="#方法中的生命周期" class="headerlink" title="方法中的生命周期"></a>方法中的生命周期</h4><ul>
<li>类似于泛型结构体</li>
<li>方法签名中一般不需要标注，因为有<code>&amp;self</code>参数（根据以上第三条规则）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    part: &amp;&#39;a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    fn level(&amp;self) -&gt; i32 &#123;</span><br><span class="line">        3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h4><p>拥有<code>&#39;static</code>生命周期声明的引用生命周期是整个程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s: &amp;&#39;static str &#x3D; &quot;我没啥优点，就是活得久，嘿嘿&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是一种元数据，用于修改编译器的行为、提供额外信息或影响代码生成方式</p>
<p>使用<code>#[]</code>语法</p>
<h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><p><strong><code>#[derive()]</code></strong> 自动派生特征</p>
<p>用于让编译器自动为结构体或枚举实现特定的 <strong>trait</strong>（特征），如 <code>Debug</code>、<code>Clone</code> 等</p>
<p>注意只针对结构体与枚举，同时在实现某特征时（比如<code>Copy</code>）结构体中不能够有<code>String</code>这种无法自动实现<code>Copy</code>的字段</p>
<p><strong><code>#[cfg(...)]</code></strong> 条件编译</p>
<p>用于根据特定 条件选择性地编译代码，例如目标平台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(target_os &#x3D; &quot;linux&quot;)]</span><br><span class="line">fn platform_specific() &#123;</span><br><span class="line">    println!(&quot;Running on Linux!&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 只在linux上面编译</span><br><span class="line"></span><br><span class="line">#[cfg(feature &#x3D; &quot;logging&quot;)]</span><br><span class="line">fn log_message() &#123;</span><br><span class="line">    println!(&quot;Logging is enabled&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 启用了feature特征才能编译（feature特征是cargo.toml中定义的）</span><br></pre></td></tr></table></figure>

<p><strong><code>#[test]</code></strong> Rust 测试函数</p>
<p>用于标记测试函数，让 <code>cargo test</code> 自动运行它</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="panic"><a href="#panic" class="headerlink" title="panic"></a><code>panic</code></h4><ul>
<li>标识不可恢复错误</li>
<li>有被动与主动触发两种情况</li>
</ul>
<p>主动触发：使用<code>panic!</code>宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    panic!(&quot;crash and burn&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序</span><br></pre></td></tr></table></figure>

<h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a><code>Result</code></h4><p>标识可恢复的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回了该枚举类型之后就可以使用<code>match</code>来匹配解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let f &#x3D; match f &#123;</span><br><span class="line">       Ok(file) &#x3D;&gt; file,</span><br><span class="line">       Err(error) &#x3D;&gt; match error.kind() &#123;</span><br><span class="line">           ErrorKind::NotFound &#x3D;&gt; match File::create(&quot;hello.txt&quot;) &#123;</span><br><span class="line">               Ok(fc) &#x3D;&gt; fc,</span><br><span class="line">               Err(e) &#x3D;&gt; panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, e),</span><br><span class="line">           &#125;,</span><br><span class="line">           other_error &#x3D;&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, other_error),</span><br><span class="line">       &#125;,</span><br><span class="line">   &#125;; &#x2F;&#x2F; 一个打开文件的返回处理</span><br></pre></td></tr></table></figure>

<p>如果不需要处理错误情况（即要么<code>Ok()</code>要么<code>panic()</code>，就使用<code>unwrap()</code>/<code>expect</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;).unwrap();</span><br><span class="line">&#x2F;&#x2F; 要么返回正确值要么直接panic</span><br><span class="line"></span><br><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);</span><br><span class="line">&#x2F;&#x2F; 与unwrap()一样，只不过会报出里面的信息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 改变错误类型：假设有f1(T)返回值T1类型，f2(F)返回值F2类型</span><br><span class="line">let n: u8 &#x3D; &quot;1&quot;.parse().map(f1).map_err(f2) &#x2F;&#x2F;原本返回T&#x2F;F,现在返回T1&#x2F;F1</span><br></pre></td></tr></table></figure>

<p><strong>传播错误</strong></p>
<p>如果需要上级来处理这个函数中出现的错误呢？</p>
<p>返回<code>Result&lt;, &gt;</code>类型</p>
<ul>
<li>使用<code>match</code>匹配，用分支来操作/返回</li>
<li>使用宏<code>?</code></li>
</ul>
<p><code>?</code>功能类似于match</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; match写法</span><br><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;);</span><br><span class="line">let mut f &#x3D; match f &#123;</span><br><span class="line">    Ok(file) &#x3D;&gt; file,</span><br><span class="line">    Err(e) &#x3D;&gt; return Err(e),</span><br><span class="line">&#125;;</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">match f.read_to_string(&amp;mut s) &#123;</span><br><span class="line">    Ok(_) &#x3D;&gt; Ok(s),</span><br><span class="line">    Err(e) &#x3D;&gt; Err(e),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ？写法：Err则该函数返回，Ok则语句返回正确值</span><br><span class="line">let mut f &#x3D; File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">f.read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br><span class="line">&#x2F;&#x2F; ？同时可以进行类型提升，把所有的错误类型都提升为std::error::Error</span><br><span class="line">&#x2F;&#x2F; 此时就是返回Result&lt;Ok值, Box&lt;dyn std::error::Error&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ？可以链式调用</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li><code>?</code>操作符一定需要一个变量来承接正确的值</li>
<li>函数一定要是<code>Result&lt;, &gt;</code>返回值</li>
</ul>
<h4 id="Option与Result的转换"><a href="#Option与Result的转换" class="headerlink" title="Option与Result的转换"></a><code>Option</code>与<code>Result</code>的转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Option&#96;转&#96;Result&#96;: 使用&#96;.ok_or()&#96;或&#96;.ok_or_else()</span><br><span class="line">&#x2F;&#x2F; Option&lt;T&gt;	Result&lt;T, E&gt;</span><br><span class="line">let res1: Result&lt;T, E&gt; &#x3D; Option类型值.ok_or(E类型值);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Result&#96;转&#96;Option&#96;: 丢弃错误使用&#96;ok()&#96;，丢弃成功值使用&#96;.err()</span><br><span class="line">&#x2F;&#x2F; Option&lt;T&gt;	Result&lt;T, E&gt;</span><br><span class="line">let opt1: Option&lt;T&gt; &#x3D; Result类型值.ok();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Option&lt;E&gt;	Result&lt;T, E&gt;</span><br><span class="line">let opt1: Option&lt;E&gt; &#x3D; Result类型值.err(); &#x2F;&#x2F; 如果Result类型值是ok()则丢弃</span><br></pre></td></tr></table></figure>

<h3 id="包与模块"><a href="#包与模块" class="headerlink" title="包与模块"></a>包与模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my_project&#x2F;</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src&#x2F;</span><br><span class="line">    ├── lib.rs         # library crate (名为 my_project)</span><br><span class="line">    ├── main.rs        # binary crate (名为 my_project)</span><br><span class="line">    └── bin&#x2F;</span><br><span class="line">        ├── tool1.rs   # binary crate (名为 tool1)</span><br><span class="line">        └── tool2.rs   # binary crate (名为 tool2)</span><br><span class="line">├── tests			   # 集成测试文件</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches			   # 基准性能测试文件</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples		   # 项目示例</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package&#96; &#x3D;&gt; &#96;Crate&#96; &#x3D;&gt; &#96;mod</span><br></pre></td></tr></table></figure>

<h4 id="Package-包"><a href="#Package-包" class="headerlink" title="Package(包)"></a><strong><code>Package(包)</code></strong></h4><p>一个<code>Package</code>就是一个项目，包含一个或多个<code>Crate</code>（最多一个）</p>
<p>每个 Package 必须包含一个 <code>Cargo.toml</code> 文件来描述包的元信息和依赖</p>
<h4 id="Crate-单元-箱"><a href="#Crate-单元-箱" class="headerlink" title="Crate(单元/箱)"></a><strong><code>Crate(单元/箱)</code></strong></h4><ul>
<li><code>crate</code> 是一个 Rust 项目或库的最小单元，即需要一起编译不可继续拆分</li>
<li>分为<code>lib</code>单元（入口文件一般为<code>src/lib.rs</code>；编译为库文件<code>.rlib</code>；不可单独执行，可以为其他项目提供依赖）和二进制单元（入口文件一般为<code>src/main.rs</code>或者在 <code>src/bin/</code> 目录下；编译为可执行文件）</li>
<li>一个<code>Package</code>最多可以包含一个库单元和多个二进制单元，也可以只包含一个库单元/一个或几个二进制单元</li>
<li>对于二进制单元，<code>src/main.rs</code>是默认的crate，其他的crate都在<code>src/bin/</code>（或其他）目录下，且文件可以单独编译（一个文件就是一个<code>crate</code>）</li>
</ul>
<p>考虑划分多个 crate 当：</p>
<ol>
<li>部分代码需要作为独立库被其他项目使用</li>
<li>项目包含多个独立可执行工具</li>
<li>某些功能需要单独编译和测试</li>
<li>需要减少编译时间（修改一个 crate 不会导致其他 crate 重新编译）</li>
</ol>
<h4 id="Mod-模块"><a href="#Mod-模块" class="headerlink" title="Mod(模块)"></a><strong><code>Mod(模块)</code></strong></h4><p>使用模块只是为了更好地组织代码，同时控制它们的可见性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义语法</span><br><span class="line">mod A &#123;</span><br><span class="line">	mod B &#123;fn B1()&#123;&#125;&#125; &#x2F;&#x2F;可以嵌套</span><br><span class="line">	mod C &#123;fn C1()&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路径引用</span><br><span class="line">fn D() &#123;</span><br><span class="line">    &#x2F;&#x2F; 绝对路径</span><br><span class="line">    crate::A::B::B1(); </span><br><span class="line">    &#x2F;&#x2F;相对路径：只能以super&#x2F;self&#x2F;模块名或Crate开头</span><br><span class="line">    A::B::B1(); &#x2F;&#x2F; 在同一个Crate根部的相对路径可以直接这么写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可见性设置</span><br><span class="line">pub mod hosting &#123; &#x2F;&#x2F; 模块写pub仅代表其可被访问，而其中的函数等还是对外界不可见</span><br><span class="line">    pub fn add_to_waitlist() &#123;&#125; &#x2F;&#x2F; 函数也需以pub开头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个<code>Crate</code>是一棵模块树，而<code>src/main.rs</code>及<code>src/lib.rs</code>就是该树的根</li>
<li>模块A包含模块B，则A是B的父模块，B是A的子模块</li>
<li>模块中可以定义各种<code>Rust</code>类型，如函数、结构体、枚举、特征等</li>
<li>在同一个<code>Crate</code>根下的模块，相互引用的相对路径可以直接以对方模块名称开头；在同一父模块下的两个子模块，若在同文件中实现则也可以以对方模块名称开头，否则需要通过<code>super::</code>来使用父模块中转</li>
<li>将结构体设置为 <code>pub</code>，但它的所有字段依然是私有的；将枚举设置为 <code>pub</code>，它的所有字段也将对外可见</li>
<li>可以把模块实现放入对应等级的<code>*.rs</code>文件中，<code>*</code>要等同于模块名（文件中便不必再写），模块的定义/声明还是在父文件/模块中</li>
</ul>
<h4 id="use"><a href="#use" class="headerlink" title="use"></a><code>use</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本引用方式：绝对或相对路径</span><br><span class="line">use crate::front_of_house::hosting; &#x2F;&#x2F; 引入模块</span><br><span class="line">use front_of_house::hosting::add_to_waitlist; &#x2F;&#x2F; 引入函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; as别名</span><br><span class="line">use std::fmt::Result;</span><br><span class="line">use std::io::Result as IoResult;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引入再导出</span><br><span class="line">pub use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简化引入</span><br><span class="line">use std::collections::&#123;HashMap,BTreeMap,HashSet&#125;;</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line">use std::io;</span><br><span class="line">use std::io::Write;</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br><span class="line"></span><br><span class="line">use std::collections::*; &#x2F;&#x2F; 引入模块下所有项</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>如果引入的函数存在同名的情况时，需使用<code>模块名::函数名</code>的方式或者<code>as</code>别名的方式来区分</li>
</ul>
<p><strong>限制可见性</strong></p>
<ul>
<li><code>pub</code> 意味着可见性无任何限制</li>
<li><code>pub(crate)</code> 表示在当前包可见</li>
<li><code>pub(self)</code> 在当前模块可见</li>
<li><code>pub(super)</code> 在父模块可见</li>
<li><code>pub(in &lt;path&gt;)</code> 表示在某个路径代表的模块中可见，其中 <code>path</code> 必须是父模块或者祖先模块</li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>简单来说，迭代器/高阶函数是“流水线模板”，提供规范流程（比如<code>map\filter</code>等等）；闭包是“可替换的工具”，即灵活调整传入的参数；而这两者都需要满足“不可变性”的安全要求</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是一种匿名函数，它<strong>可以赋值给变量也可以作为参数传递给其它函数</strong>，不同于函数的是，它<strong>允许捕获调用者作用域中的值</strong></p>
<p>闭包语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义闭包</span><br><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句1;</span><br><span class="line">    语句2;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125; </span><br><span class="line">|param1| 返回表达式 &#x2F;&#x2F; 只需要有一个表达式时</span><br><span class="line">|| &#123;&#125; &#x2F;&#x2F; 如果不需要参数时</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结构体中的闭包</span><br><span class="line">struct Cacher&lt;T&gt;</span><br><span class="line">where T: Fn(u32) -&gt; u32,</span><br><span class="line">&#123;</span><br><span class="line">    query: T,</span><br><span class="line">&#125;  &#x2F;&#x2F; 等价于struct Cacher&lt;T: Fn(u32) -&gt; u32&gt;，query字段同样也可以使用一个符合的函数作为值</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>闭包函数中是否标注类型皆可（如果未使用过则需要标注），同样可以以此省略返回值</li>
<li>闭包函数中的类型不可以是泛型，所以每次使用参数要求同类型</li>
</ul>
<p><strong>三种<code>Fn</code>特征</strong></p>
<p><code>FnOnce</code>: 强制需要闭包所捕获变量的所有权</p>
<p><code>FnMut</code>: 用于闭包函数内需要改变被捕获变量的值的情况，需要闭包和捕获变量都有<code>mut</code>声明</p>
<p><code>Fn</code>: 以不可变借用的方式捕获环境中的值(与<code>FnMut</code>不兼容，即不可改变捕获函数的值)</p>
<p><strong>注：</strong></p>
<ul>
<li><p>在<code>FnOnce</code>作为传入闭包的特征约束时，传入闭包和其捕获函数的所有权都会在第一次调用时被消耗；特殊情况：同时要求<code>FnOnce</code>与<code>Copy</code>（闭包会实现Copy，而其捕获的变量也会尽量实现Copy）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x &#x3D; vec![1, 2, 3];</span><br><span class="line">    fn_once(|z|&#123;z &#x3D;&#x3D; x.len()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fn_once&lt;F&gt;(func: F)</span><br><span class="line">where</span><br><span class="line">    F: FnOnce(usize) -&gt; bool,</span><br><span class="line">&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(3)); &#x2F;&#x2F; 捕获的Vec的所有权，闭包与变量一起消耗</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(4));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fn_once&lt;F&gt;(func: F)</span><br><span class="line">where</span><br><span class="line">    F: FnOnce(usize) -&gt; bool + Copy,&#x2F;&#x2F; 改动在这里</span><br><span class="line">&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(3)); &#x2F;&#x2F; 闭包实现Copy，不消耗；尽可能捕获可Copy的值如x.len()，没有则会在编译报错</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由上所知，闭包的捕获行为会根据上下文约束来调整</p>
</li>
<li><p>闭包自动实现<code>Copy</code>特征的规则是，只要闭包捕获的类型都实现了<code>Copy</code>特征的话，这个闭包就会默认实现<code>Copy</code>特征</p>
</li>
<li><p><code>FnOnce</code>会消耗闭包的所有权；但无论按值还是按引用传递，<code>Fn</code>/<code>FnMut</code>通常都不会消耗闭包的所有权。即在传入一个有<code>Fn(Mut)</code>特征约束的函数之后，一个闭包函数的变量还可以继续使用</p>
</li>
<li><p>所有的闭包都自动实现了 <code>FnOnce</code> 特征，因此任何一个闭包都至少可以被调用一次；没有移出所捕获变量的所有权的闭包自动实现了 <code>FnMut</code> 特征；不需要对捕获变量进行改变的闭包自动实现了 <code>Fn</code> 特征</p>
</li>
</ul>
<p><strong><code>move</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let update_string &#x3D;  move || println!(&quot;&#123;&#125;&quot;,s); &#x2F;&#x2F; move强制闭包获取变量所有权</span><br></pre></td></tr></table></figure>

<p>闭包作为函数返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fn factory() -&gt; Fn(i32) -&gt; i32 &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    |x| x + num</span><br><span class="line">&#125; &#x2F;&#x2F; 报错，特征不是类型，需要其他辅助声明</span><br><span class="line"></span><br><span class="line">fn factory(x:i32) -&gt; impl Fn(i32) -&gt; i32 &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    if x &gt; 1&#123;</span><br><span class="line">        move |x| x + num</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        move |x| x - num</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 报错，返回的内容要求是同一类型，此处虽然满足同一特征，但属于不同类型</span><br><span class="line"></span><br><span class="line">fn factory(x:i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    if x &gt; 1&#123;</span><br><span class="line">        Box::new(move |x| x + num)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Box::new(move |x| x - num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 正确，使用智能指针将其视为同一类型</span><br></pre></td></tr></table></figure>

<h4 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器<code>Iterator</code></h4><p>迭代器允许我们迭代一个连续的集合，例如数组、动态数组 <code>Vec</code>、<code>HashMap</code> 等，在此过程中，只需关心集合中的元素如何处理，而无需关心如何开始、如何结束、按照什么样的索引去访问</p>
<p>1、<code>.next</code>是迭代器中取下一个值的方式,返回<code>Option&lt;T&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</span><br><span class="line">    &#x2F;&#x2F; 省略其余有默认实现的方法</span><br><span class="line">&#125; &#x2F;&#x2F; 迭代器实现的特征Interator</span><br></pre></td></tr></table></figure>

<p>2、将数组转化为迭代器的三种方式(<code>Vec</code>动态数组实现的<code>IntoIterator</code>中的函数)：</p>
<ul>
<li><code>into_iter</code> 会夺走所有权</li>
<li><code>iter</code> 是借用</li>
<li><code>iter_mut</code> 是可变借用（<code>next</code>方法返回的<code>&amp;mut</code>）</li>
</ul>
<p>3、迭代器的消费者与适配器（都是迭代器特征中的方法）</p>
<ul>
<li><p>消费者：消费掉迭代器，返回一个值</p>
<p> 会拿走迭代器的所有权，即调用它之后迭代器无法再使用</p>
</li>
<li><p>适配器：返回一个新的迭代器，是链式调用的基础</p>
<p> 因此在链式调用末尾需要一个消费者来收尾用以返回一个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例1</span><br><span class="line">let v1: Vec&lt;i32&gt; &#x3D; vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">let v2: Vec&lt;_&gt; &#x3D; v1.iter().map(|x| x + 1).collect();</span><br><span class="line">&#x2F;&#x2F; collect():消费掉迭代器，把值收集成特定类型（需要显式注明）</span><br><span class="line">&#x2F;&#x2F; .map():对迭代器的每一个值操作，换为另一个新值</span><br><span class="line"></span><br><span class="line">assert_eq!(v2, vec![2, 3, 4]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例2</span><br><span class="line">let names &#x3D; [&quot;sunface&quot;, &quot;sunfei&quot;];</span><br><span class="line">let ages &#x3D; [18, 18];</span><br><span class="line">let folks: HashMap&lt;_, _&gt; &#x3D; names.into_iter().zip(ages.into_iter()).collect();</span><br><span class="line">&#x2F;&#x2F; .zip():将两个迭代器压缩在一起，形成Iterator&lt;Item&#x3D;(ValueFromA, ValueFromB)&gt; 这样的新的迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例3：闭包用作适配器参数</span><br><span class="line">fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.into_iter().filter(|s| s.size &#x3D;&#x3D; shoe_size).collect()</span><br><span class="line">&#125; &#x2F;&#x2F; filter():对迭代器每个值进行过滤，若满足则保留</span><br><span class="line">&#x2F;&#x2F; 此处闭包同样可以捕捉环境变量</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="深入类型"><a href="#深入类型" class="headerlink" title="深入类型"></a>深入类型</h3><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>as转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 3.1 as i8;</span><br><span class="line">let b &#x3D; 100_i8 as i32;</span><br><span class="line">let c &#x3D; &#39;a&#39; as u8; &#x2F;&#x2F; 将字符&#39;a&#39;转换为整数，97</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>转换不具有传递性：就算 <code>e as U1 as U2</code> 是合法的，也不能说明 <code>e as U2</code> 是合法的（<code>e</code> 不能直接转换成 <code>U2</code>）</p>
<p><strong><code>TryInto</code>转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: u8 &#x3D; 10;</span><br><span class="line">let b: u16 &#x3D; 1500;</span><br><span class="line">let b_: u8 &#x3D; b.try_into().unwrap(); &#x2F;&#x2F;尝试进行一次转换，并返回一个 Result</span><br></pre></td></tr></table></figure>

<p>注：<code>try_into</code> 转换会捕获大类型向小类型转换时导致的溢出错误</p>
<p><strong><code>From</code>和<code>Into</code>特征</strong></p>
<ul>
<li><strong><code>From&lt;T&gt;</code></strong>：定义如何从类型 <code>T</code> 转换到当前类型。</li>
<li><strong><code>Into&lt;T&gt;</code></strong>：自动为实现了 <code>From</code> 的类型生成反向转换。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">impl From&lt;i32&gt; for MyType &#123;</span><br><span class="line">    fn from(value: i32) -&gt; Self &#123;</span><br><span class="line">        MyType(value)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a &#x3D; MyType::from(42);  &#x2F;&#x2F; 显式调用</span><br><span class="line">let b: MyType &#x3D; 42.into(); &#x2F;&#x2F; 自动推导（需类型注解）</span><br></pre></td></tr></table></figure>

<h4 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a><code>newtype</code></h4><p>使用<a href="https://course.rs/basic/compound-type/struct.html#元组结构体tuple-struct" target="_blank" rel="noopener">元组结构体</a>的方式将已有的类型包裹起来：<code>struct Meters(u32);</code>，那么此处 <code>Meters</code> 就是一个 <code>newtype</code></p>
<ul>
<li>自定义类型可以让我们给出更有意义和可读性的类型名，例如与其使用 <code>u32</code> 作为距离的单位类型，我们可以使用 <code>Meters</code>，它的可读性要好得多</li>
<li>对于某些场景，只有 <code>newtype</code> 可以很好地解决</li>
<li>隐藏内部类型的细节</li>
</ul>
<p><strong>为外部类型实现外部特征</strong></p>
<p>孤儿规则：要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 必须至少有一个在当前的作用范围内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例：想为Vec实现Display特征，但这两个都在标准库中</span><br><span class="line">use std::fmt;</span><br><span class="line">struct Wrapper(Vec&lt;String&gt;);</span><br><span class="line">impl fmt::Display for Wrapper &#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f, &quot;[&#123;&#125;]&quot;, self.0.join(&quot;, &quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注：包裹一样类型的newtype是不同的类型,newtype与其内部包裹的类型同理</span><br></pre></td></tr></table></figure>



<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Meters &#x3D; u32</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>类型别名仅仅为了更好的可读性，与原类型没有任何区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 应用：减少代码模板的使用</span><br><span class="line">let f: Box&lt;dyn Fn() + Send + &#39;static&gt; &#x3D; Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line"></span><br><span class="line">type Thunk &#x3D; Box&lt;dyn Fn() + Send + &#39;static&gt;;</span><br><span class="line">let f: Thunk &#x3D; Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;常用于简化Result&lt;T, E&gt; 枚举中</span><br><span class="line">type Result&lt;T&gt; &#x3D; std::result::Result&lt;T, std::io::Error&gt;; &#x2F;&#x2F; 此处为std::io库中Error类型的简化</span><br></pre></td></tr></table></figure>



<h4 id="不定长类型DST"><a href="#不定长类型DST" class="headerlink" title="不定长类型DST"></a>不定长类型DST</h4><p>定长类型：基础类型、集合 <code>Vec</code>、<code>String</code> 和 <code>HashMap</code> 等(其在栈上拥有固定大小的指针)</p>
<p>不定长类型：<code>str</code>、特征对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn foobar_1(thing: &amp;dyn MyThing) &#123;&#125;     &#x2F;&#x2F; OK</span><br><span class="line">fn foobar_2(thing: Box&lt;dyn MyThing&gt;) &#123;&#125; &#x2F;&#x2F; OK</span><br><span class="line">fn foobar_3(thing: MyThing) &#123;&#125;          &#x2F;&#x2F; ERROR!</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>只能间接使用DST，通过引用或<code>Box</code>来使用</p>
<p><strong><code>Sized</code>特征</strong></p>
<p>怎么保证泛型参数是固定大小的类型？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T(: Sized)&gt;(t: T) &#123; &#x2F;&#x2F; 自动补全了Sized特征</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举与整数"><a href="#枚举与整数" class="headerlink" title="枚举与整数"></a>枚举与整数</h4><p>枚举到整数很容易，但反过来需要借助三方库来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">enum MyEnum &#123;</span><br><span class="line">    A &#x3D; 1,</span><br><span class="line">    B,</span><br><span class="line">    C,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将枚举转换成整数，顺利通过</span><br><span class="line">    let x &#x3D; MyEnum::C as i32;</span><br><span class="line">    &#x2F;&#x2F; 将整数转换为枚举，失败</span><br><span class="line">    match x &#123;</span><br><span class="line">        MyEnum::A &#x3D;&gt; &#123;&#125;</span><br><span class="line">        MyEnum::B &#x3D;&gt; &#123;&#125;</span><br><span class="line">        MyEnum::C &#x3D;&gt; &#123;&#125;</span><br><span class="line">        _ &#x3D;&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用num-traits&#x2F;num-derive库</span><br><span class="line">use num_derive::FromPrimitive;</span><br><span class="line">use num_traits::FromPrimitive;</span><br><span class="line"></span><br><span class="line">match FromPrimitive::from_i32(x) &#123;</span><br><span class="line">    Some(MyEnum::A) &#x3D;&gt; println!(&quot;Got A&quot;),</span><br><span class="line">    Some(MyEnum::B) &#x3D;&gt; println!(&quot;Got B&quot;),</span><br><span class="line">    Some(MyEnum::C) &#x3D;&gt; println!(&quot;Got C&quot;),</span><br><span class="line">    None            &#x3D;&gt; println!(&quot;Couldn&#39;t convert &#123;&#125;&quot;, x),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>引用（<code>&amp;T</code>/<code>&amp;mut T</code>）</strong></th>
<th><strong>智能指针（如 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所有权关系</strong></td>
<td>无所有权，仅是借用</td>
<td>通常拥有数据的所有权</td>
</tr>
<tr>
<td><strong>可变性控制</strong></td>
<td>分为共享引用（<code>&amp;T</code>）和可变引用（<code>&amp;mut T</code>）</td>
<td>通过内部可变性（如 <code>RefCell&lt;T&gt;</code>）或类型设计实现</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>必须显式或隐式标注生命周期</td>
<td>通常管理数据的整个生命周期（如 <code>Box</code> 负责释放）</td>
</tr>
<tr>
<td><strong>动态行为</strong></td>
<td>仅提供访问，无额外逻辑</td>
<td>可附加逻辑（如引用计数、自动释放、线程安全）</td>
</tr>
<tr>
<td><strong>常见类型</strong></td>
<td><code>&amp;T</code>, <code>&amp;mut T</code></td>
<td><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code></td>
</tr>
</tbody></table>
<p>智能指针与普通自定义结构体区别：实现了<code>Deref</code>和<code>Drop</code>特征</p>
<p>智能指针用于一些较引用更复杂的场景</p>
<h4 id="Box-lt-T-gt-堆对象分配"><a href="#Box-lt-T-gt-堆对象分配" class="headerlink" title="Box&lt;T&gt;堆对象分配"></a><code>Box&lt;T&gt;</code>堆对象分配</h4><p><code>Box</code> 简单的封装，用于将值存储在堆上</p>
<p>使用场景：</p>
<ul>
<li>特意的将数据分配在堆上</li>
<li>数据较大时，又不想在转移所有权时进行数据拷贝</li>
<li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时</li>
<li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将数据存储在堆上</span><br><span class="line">let a &#x3D; 3; &#x2F;&#x2F; a在栈上</span><br><span class="line">let a &#x3D; Box::new(3); &#x2F;&#x2F; 在堆上</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 避免栈上数据拷贝</span><br><span class="line">let arr &#x3D; [0;1000];</span><br><span class="line">let arr1 &#x3D; arr; &#x2F;&#x2F; 此时两份数据，是深拷贝</span><br><span class="line"></span><br><span class="line">let arr &#x3D; Box::new([0;1000]);</span><br><span class="line">let arr1 &#x3D; arr; &#x2F;&#x2F; 所有权顺利转移给 arr1，arr 不再拥有所有权</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提供固定大小</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, List), &#x2F;&#x2F; 递归类型：无法确定大小，因为DST报错</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, Box&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特征对象</span><br><span class="line">&#x2F;&#x2F; 想实现不同类型组成的数组只有两个办法：枚举和特征对象</span><br><span class="line">&#x2F;&#x2F; 特征对象其实就是把DST类型的特征转为固定大小</span><br></pre></td></tr></table></figure>

<p><strong>另：</strong><code>Box::leak</code>可以真正将一个运行期的值转化为<code>&#39;static</code>，如果只标注<code>&#39;static</code>可能无法成功</p>
<h4 id="Deref解引用"><a href="#Deref解引用" class="headerlink" title="Deref解引用"></a><code>Deref</code>解引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deref&#96; 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 &#96;*T</span><br></pre></td></tr></table></figure>

<p><strong><code>\*</code>:</strong> 对常规引用使用<code>*</code>操作符，即可以通过解引用的方式获取到内存地址对应的数据值</p>
<p><strong>智能指针解引用：</strong> 在使用给定的智能指针时，直接使用<code>*</code>解引用即可</p>
<p>在智能指针解引用时，实际上调用了<code>*(y.deref())</code>方法：<code>y.deref()</code>先返回了值的常规引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果要实现自己的智能指针同样要实现Deref特征</span><br><span class="line">use std::ops::Deref;</span><br><span class="line">impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;</span><br><span class="line">    type Target &#x3D; T;</span><br><span class="line">    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;</span><br><span class="line">        &amp;self.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 实现该特征后才能使用*解引用</span><br></pre></td></tr></table></figure>

<p><strong>函数/方法中的隐式<code>Deref</code>转换</strong></p>
<p>函数和方法的传参中有<code>Deref</code>的隐式转换。</p>
<p>若一个类型实现了 <code>Deref</code> 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 <code>Deref</code> 转换(<code>Deref</code>支持连续的隐式转换)</p>
<p><strong>总结</strong></p>
<ul>
<li>一个类型为 <code>T</code> 的对象 <code>foo</code>，如果 <code>T: Deref&lt;Target=U&gt;</code>，那么，相关 <code>foo</code> 的引用 <code>&amp;foo</code> 在应用的时候会自动转换为 <code>&amp;U</code></li>
<li>在解引用时自动把智能指针和 <code>&amp;&amp;&amp;&amp;v</code> 做引用归一化操作，转换成 <code>&amp;v</code> 形式，最终再对 <code>&amp;v</code> 进行解引用（即将智能指针脱壳为内部的引用类型即<code>&amp;v</code>， 把多级引用归一为一级<code>&amp;v</code>）</li>
</ul>
<h4 id="Drop释放资源"><a href="#Drop释放资源" class="headerlink" title="Drop释放资源"></a><code>Drop</code>释放资源</h4><p>指定在一个变量超出作用域时，执行一段特定的代码，最终编译器将帮你自动插入这段收尾代码（无需在每一个使用该变量的地方，都写一段代码来进行收尾工作和资源释放）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Drop for Foo &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123; &#x2F;&#x2F; 传入的是可变借用</span><br><span class="line">        println!(&quot;Dropping Foo!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Drop 的顺序</strong></p>
<ul>
<li>变量级别，按照逆序的方式（<code>_x</code> 在 <code>_foo</code> 之前创建，因此 <code>_x</code> 在 <code>_foo</code> 之后被 <code>drop</code>）</li>
<li>结构体内部，按照顺序的方式</li>
</ul>
<p><strong>注：</strong></p>
<ul>
<li>Rust 自动为几乎所有类型都实现了 <code>Drop</code> 特征（除了栈上的简单类型）</li>
<li>不允许显式地调用析构函数<code>变量名.drop()</code>，但可以调用函数<code>drop(变量名)</code>（<code>drop()</code>函数会拿走目标值的所有权）</li>
<li><code>Copy</code>和<code>Drop</code>互斥，不会在一种类型上面出现（为了防止重复释放内存）</li>
</ul>
<h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a><code>Rc</code></h4><p>通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者</p>
<p>实现机制就是 <code>Rc</code> 和 <code>Arc</code>，前者适用于单线程，后者适用于多线程</p>
<p><strong><code>Rc&lt;T&gt;</code></strong></p>
<p>引用计数：通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放</p>
<p>当我们希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用 <code>Rc</code> 成为数据值的所有者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; Rc::new(String::from(&quot;hello, world&quot;)); &#x2F;&#x2F; 创建时引用计数+1，此时Rc::strong_count(&amp;a) 返回的值是 1</span><br><span class="line">let b &#x3D; Rc::clone(&amp;a); &#x2F;&#x2F; clone 仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据；同样可以使用a.clone()</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>这几个智能指针都是相同的所以<code>Rc::strong_count(&amp;a/b/c)</code>皆可</li>
<li>当其中一个变量离开作用域被销毁后，计数<code>-1</code>，但只有当计数为0时，这个指针和指向的底层数据才会销毁</li>
<li><code>Rc&lt;T&gt;</code>指向的是底层数据的不可变应用(相当于有多个不可变引用)</li>
<li>实现了<code>Deref</code>特征，可以直接使用里面的数值</li>
</ul>
<p><strong><code>Arc</code></strong></p>
<ul>
<li>原子化的 <code>Rc&lt;T&gt;</code> 智能指针,保证我们的数据能够安全的在线程间共享</li>
<li>与<code>Rc</code>的API完全相同</li>
<li><code>Arc</code> 和 <code>Rc</code> 并没有定义在同一个模块，前者通过 <code>use std::sync::Arc</code> 来引入，后者通过 <code>use std::rc::Rc</code></li>
</ul>
<h4 id="Cell和RefCell"><a href="#Cell和RefCell" class="headerlink" title="Cell和RefCell"></a><code>Cell</code>和<code>RefCell</code></h4><p>解决问题（相较于引用）：</p>
<ul>
<li>可以通过不可变引用来修改数据</li>
<li>绕过编译期借用检查</li>
<li>实现了部分可变性（比如标定结构体某个字段为内部可变）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><code>Cell&lt;T&gt;</code></th>
<th><code>RefCell&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td>获取不可变访问</td>
<td><code>get()</code> → <code>T</code>（复制）</td>
<td><code>borrow()</code> → <code>Ref&lt;T&gt;</code></td>
</tr>
<tr>
<td>获取可变访问</td>
<td><code>set(new_value)</code></td>
<td><code>borrow_mut()</code> → <code>RefMut&lt;T&gt;</code></td>
</tr>
<tr>
<td>运行时检查</td>
<td>无</td>
<td>有（可能 panic）</td>
</tr>
<tr>
<td>适用类型</td>
<td><code>T: Copy</code>（如 <code>i32</code>）</td>
<td>任意 <code>T</code>（如 <code>String</code>）</td>
</tr>
</tbody></table>
<p><strong><code>Cell</code></strong></p>
<p><code>Cell</code> 和 <code>RefCell</code> 在功能上没有区别，区别在于 <code>Cell&lt;T&gt;</code> 适用于 <code>T</code> 实现 <code>Copy</code> 的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let c &#x3D; Cell::new(42);</span><br><span class="line">let val &#x3D; c.get(); &#x2F;&#x2F; 复制值（42）</span><br><span class="line">c.set(100); &#x2F;&#x2F; 替换新值，仍然拥有所有权不会报错</span><br><span class="line"></span><br><span class="line">let c &#x3D; Cell::new(String::from(&quot;asdf&quot;)); &#x2F;&#x2F; 这样会报错</span><br></pre></td></tr></table></figure>

<p><strong><code>RefCell</code></strong></p>
<ul>
<li>允许通过不可变引用 (<code>&amp;T</code>) 修改内部数据（内部可变性）。</li>
<li>在运行时（而非编译期）检查借用规则，违反规则时触发 <code>panic</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; RefCell::new(String::from(&quot;hello, world&quot;)); &#x2F;&#x2F; s为RefCell&lt;T&gt;类型</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>borrow()</code></td>
<td>获取不可变引用 (<code>Ref&lt;T&gt;</code>)，增加不可变借用计数。若已有可变借用，则 <code>panic</code>。</td>
</tr>
<tr>
<td><code>borrow_mut()</code></td>
<td>获取可变引用 (<code>RefMut&lt;T&gt;</code>)，标记独占借用。若已有任何借用，则 <code>panic</code>。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Logger &#123;</span><br><span class="line">    logs: RefCell&lt;Vec&lt;String&gt;&gt;, &#x2F;&#x2F; 内部可变</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Logger &#123;</span><br><span class="line">    fn log(&amp;self, message: &amp;str) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过不可变的 &amp;self 修改 logs！</span><br><span class="line">        self.logs.borrow_mut().push(message.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong><code>RefCell</code> 的核心机制是，将一个本应可变的数据（如 <code>String</code>）包裹在“壳子”（<code>RefCell</code>）里，然后通过这个壳子的不可变引用（<code>&amp;RefCell&lt;T&gt;</code>），在运行时安全地修改内部数据</p>
<h4 id="循环引用与自引用"><a href="#循环引用与自引用" class="headerlink" title="循环引用与自引用"></a>循环引用与自引用</h4><p>面临问题：当使用<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>时，可以a指向b，b再指向a，出现循环引用，最后<code>Rc</code>计数无法归0</p>
<p><strong><code>Weak</code></strong></p>
<p>仅保存一份指向数据的弱引用，不保证引用关系依然存在，无法阻止所引用的内存值被释放</p>
<table>
<thead>
<tr>
<th><code>Weak</code></th>
<th><code>Rc</code></th>
</tr>
</thead>
<tbody><tr>
<td>不计数</td>
<td>引用计数</td>
</tr>
<tr>
<td>不拥有所有权</td>
<td>拥有值的所有权</td>
</tr>
<tr>
<td>不阻止值被释放(drop)</td>
<td>所有权计数归零，才能 drop</td>
</tr>
<tr>
<td>引用的值存在返回 <code>Some</code>，不存在返回 <code>None</code></td>
<td>引用的值必定存在</td>
</tr>
<tr>
<td>通过 <code>upgrade</code> 取到 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，然后再取值</td>
<td>通过 <code>Deref</code> 自动解引用，取值无需任何操作</td>
</tr>
</tbody></table>
<p><code>Weak</code> 通过 <code>use std::rc::Weak</code> 来引入，它具有以下特点:</p>
<ul>
<li>可访问，但没有所有权，不增加引用计数，因此不会影响被引用值的释放回收</li>
<li>可由 <code>Rc&lt;T&gt;</code> 调用 <code>Rc::downgrade</code> 方法转换成 <code>Weak&lt;T&gt;</code></li>
<li><code>Weak&lt;T&gt;</code> 可使用 <code>upgrade</code> 方法转换成 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，如果资源已经被释放，则 <code>Option</code> 的值是 <code>None</code></li>
<li>常用于解决循环引用的问题</li>
</ul>
<h3 id="多线程并发编程"><a href="#多线程并发编程" class="headerlink" title="多线程并发编程"></a>多线程并发编程</h3><p>并发：同时存在多个动作</p>
<p>并行：可以同时执行多个动作</p>
<p>关系：并发程序可以由人编写，但只有有多个CPU内核时才可以并行执行；</p>
<p> 并行一定并发，但只有多核时并发才能够并行</p>
<h4 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h4><p><strong>风险</strong></p>
<p>由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：</p>
<ul>
<li>竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源</li>
<li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li>
<li>一些因为多线程导致的很隐晦的 BUG，难以复现和解决</li>
</ul>
<p><strong>创建线程：</strong><code>thread::spawn</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let handle &#x3D; </span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        for i in 1..10 &#123;</span><br><span class="line">            println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(1)); &#x2F;&#x2F; thread::sleep 会让当前线程休眠指定的时间，随后其它线程会被调度运行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); &#x2F;&#x2F; 线程内部的代码使用闭包来执行</span><br><span class="line">    </span><br><span class="line">    handle.join().unwrap(); &#x2F;&#x2F; 让当前线程阻塞，直到它等待的子线程的结束</span><br><span class="line">    </span><br><span class="line">    for i in 1..5 &#123;</span><br><span class="line">        println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; main 线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>线程的启动结束时间点都是不固定的</li>
<li>由上一条，为了保证子线程中的变量一直有效，在子线程的闭包中捕获了环境变量时，需要使用<code>move</code>来转移所有权</li>
<li>主线程（<code>main</code>）退出时，会强制终止所有子线程（无论它们是否在运行）；父线程（非主线程）退出时，不会影响它创建的子线程</li>
<li><code>thread::spawn</code> 的返回值是<strong><code>std::thread::JoinHandle</code></strong>类型，表示对线程的控制权，允许主线程通过 <code>join()</code> 等待子线程结束，同样可以使用数组收集</li>
</ul>
<p><strong>多线程的性能</strong></p>
<p>当任务是 CPU 密集型时，就算线程数超过了 CPU 核心数，也并不能帮你获得更好的性能</p>
<p>当你的任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量（典型就是网络 IO 操作）</p>
<p><strong>线程屏障<code>Barrier</code></strong></p>
<p>让多个线程都执行到某个点后，才继续一起往后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Barrier&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let barrier &#x3D; Arc::new(Barrier::new(3));</span><br><span class="line">    let mut handles &#x3D; vec![];</span><br><span class="line"></span><br><span class="line">    for i in 0..3 &#123;</span><br><span class="line">        let barrier &#x3D; barrier.clone();</span><br><span class="line">        handles.push(thread::spawn(move || &#123;</span><br><span class="line">            println!(&quot;线程 &#123;&#125;: 阶段1&quot;, i);</span><br><span class="line">            barrier.wait(); &#x2F;&#x2F; 等待所有线程完成阶段1</span><br><span class="line">            println!(&quot;线程 &#123;&#125;: 阶段2&quot;, i);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>需要<code>Arc</code>智能指针，作用是允许多个线程同时拥有同一数据（跨线程<code>Rc</code>）</li>
<li><code>Barrier::new(n)</code>中的<code>n</code>值一定要与实际调用<code>wait()</code>的线程数相等</li>
</ul>
<p><strong>多线程局部变量</strong></p>
<p>标准库<code>thread_local</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义</span><br><span class="line">thread_local! &#123;</span><br><span class="line">    static MY_TLS: 类型 &#x3D; 初始化值; &#x2F;&#x2F; 必须使用static声明为全局变量，一般使用RefCell&#x2F;Cell&#x2F;Mutex包裹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 语法：变量名.with(|绑定名| &#123; 操作 &#125;); 闭包传入参数即为局部变量</span><br><span class="line">thread::spawn(|| &#123;</span><br><span class="line">    &#x2F;&#x2F; 每个线程独立操作 COUNTER</span><br><span class="line">    COUNTER.with(|c| &#123;</span><br><span class="line">          *c.borrow_mut() +&#x3D; 1;</span><br><span class="line">          println!(&quot;Thread &#123;:?&#125;: &#123;&#125;&quot;, thread::current().id(), c.borrow());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>如果想使用多个局部变量的闭包函数，使用嵌套</p>
<p> 同样还有使用<code>use thread_local::ThreadLocal;</code>引用的三方库，这个库不仅仅使用了值的拷贝，而且还能自动把多个拷贝汇总到一个迭代器中，最后进行求和</p>
<p>条件控制线程的挂起和执行：<code>let pair = Arc::new((Mutex::new(false), Condvar::new()));</code></p>
<p>只会调用一次的函数：<code>static INIT: Once =Once::new();</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT.call_once(|| &#123;unsafe &#123;VAL &#x3D; 2;&#125;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a><strong>消息传递</strong></h5><p>线程通过发送和接收消息来通信，而非直接共享内存</p>
<p><strong>标准库工具<code>mpsc</code></strong>，允许多发送者，单接收者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个消息通道, 返回一个元组：(发送者，接收者)</span><br><span class="line">let (tx, rx) &#x3D; mpsc::channel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建线程，并发送消息</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    tx.send(1).unwrap(); &#x2F;&#x2F; 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span><br><span class="line">    &#x2F;&#x2F; tx.send(Some(1)).unwrap()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在主线程中接收子线程发送的消息并输出</span><br><span class="line">println!(&quot;receive &#123;&#125;&quot;, rx.recv().unwrap());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试接收一次消息，不会阻塞线程，当通道中没有消息时，它会立刻返回一个错误</span><br><span class="line">println!(&quot;receive &#123;:?&#125;&quot;, rx.try_recv());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 连续接收消息</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    let vals &#x3D; vec![</span><br><span class="line">        String::from(&quot;hi&quot;),</span><br><span class="line">        String::from(&quot;from&quot;),</span><br><span class="line">        String::from(&quot;the&quot;),</span><br><span class="line">        String::from(&quot;thread&quot;),</span><br><span class="line">    ];</span><br><span class="line">    for val in vals &#123;</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        thread::sleep(Duration::from_secs(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for received in rx &#123;</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用多发送者：克隆发送者，其余的线程拿走拷贝</span><br><span class="line">let tx1 &#x3D; tx.clone();</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    tx1.send(String::from(&quot;hi from cloned tx&quot;)).unwrap();</span><br><span class="line">&#125;); </span><br><span class="line">for received in rx &#123;</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;&#x2F;&#x2F; 需要所有的发送者都被drop掉后，接收者rx才会收到错误，进而跳出for循环，最终结束主线程；</span><br><span class="line">&#x2F;&#x2F; 两个子线程谁先创建完成是未知的，哪条消息先发送也是未知的</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步通道设置</span><br><span class="line">let (tx, rx)&#x3D; mpsc::sync_channel(n); &#x2F;&#x2F; n用来指定同步通道的消息缓存条数</span><br></pre></td></tr></table></figure>

<ul>
<li><code>tx</code>,<code>rx</code>对应发送者和接收者，它们的类型由编译器自动推导: <code>tx.send(1)</code>发送了整数，因此它们分别是<code>mpsc::Sender&lt;i32&gt;</code>和<code>mpsc::Receiver&lt;i32&gt;</code>类型，(一旦类型被推导确定，该通道就只能传递对应类型的值)</li>
<li>接收消息的操作<code>rx.recv()</code>会阻塞当前线程，直到读取到值，或者通道被关闭</li>
<li>需要使用<code>move</code>将<code>tx</code>的所有权转移到子线程的闭包中</li>
<li>使用通道来传输数据，一样要遵循 Rust 的所有权规则：<ul>
<li>若值的类型实现了<code>Copy</code>特征，则直接复制一份该值，然后传输过去，例如之前的<code>i32</code>类型</li>
<li>若值没有实现<code>Copy</code>（如<code>String</code>类型），则它的所有权会被转移给接收端，在发送端继续使用该值将报错</li>
</ul>
</li>
<li>异步中只有接收者会被阻塞，同步中发送者也会因为接收者接收不到消息被阻塞</li>
<li>所有发送者被<code>drop</code>或者所有接收者被<code>drop</code>后，通道会自动关闭</li>
</ul>
<h5 id="锁、Condvar"><a href="#锁、Condvar" class="headerlink" title="锁、Condvar"></a>锁、<code>Condvar</code></h5><p>使用共享内存来实现同步性</p>
<p>面临问题：多个线程同时修改同一数据时，结果不可预测；线程执行顺序影响最终结果</p>
<p><strong>互斥锁<code>Mutex</code></strong></p>
<p>同一时间，只允许一个线程<code>A</code>访问该值，其它线程需要等待<code>A</code>访问完成后才能继续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建实例：锁的容器</span><br><span class="line">let m &#x3D; Mutex::new(5);</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; lock返回的是Result</span><br><span class="line">    let mut num &#x3D; m.lock().unwrap(); &#x2F;&#x2F; .lock()向m申请锁的所有权（简称“锁”）：在获取锁之前会阻塞线程。同时只能有一个线程获得锁</span><br><span class="line">    &#x2F;&#x2F; 当拥有锁的线程panic，其他线程永远得不到这个锁</span><br><span class="line">    *num &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 锁自动被drop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多线程中使用锁</span><br><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">let counter &#x3D; Arc::new(Mutex::new(0));</span><br><span class="line">let mut handles &#x3D; vec![];</span><br><span class="line"></span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">    let counter &#x3D; Arc::clone(&amp;counter);</span><br><span class="line">    &#x2F;&#x2F; 创建子线程，并将&#96;Mutex&#96;的所有权拷贝传入到子线程中，子线程需要通过move拿走锁的所有权</span><br><span class="line">    let handle &#x3D; thread::spawn(move || &#123;</span><br><span class="line">        let mut num &#x3D; counter.lock().unwrap();</span><br><span class="line">		*num +&#x3D; 1;</span><br><span class="line">    &#125;);</span><br><span class="line">    handles.push(handle);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 等待所有子线程完成</span><br><span class="line">for handle in handles &#123;</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>m.lock()</code>返回一个智能指针<code>MutexGuard&lt;T&gt;</code>，拥有<code>Deref</code>特征（自动解引用获取引用类型）与<code>Drop</code>特征（超出作用域自动释放锁）</li>
<li><code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code>用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutex&lt;T&gt;</code>用于多线程内部可变性</li>
</ul>
<p><strong>死锁</strong></p>
<ul>
<li>在另一个锁还未被释放时去申请新的锁，就会触发</li>
<li>当我们拥有两个锁的容器，且两个线程各自使用了其中一个锁，然后试图去访问另一个锁时，就可能发生死锁</li>
<li><code>try_lock()</code>: 尝试去获取一次锁，如果无法获取会返回一个错误，因此不会发生阻塞</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let guard &#x3D; MUTEX2.lock().unwrap();</span><br><span class="line">let guard &#x3D; MUTEX2.try_lock(); &#x2F;&#x2F; 返回错误</span><br></pre></td></tr></table></figure>

<p><strong>读写锁<code>RwLock</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Mutex&#96;会对每次读写都进行加锁，但某些时候，我们需要大量的并发读，&#96;Mutex&#96;就无法满足需求了，此时就可以使用&#96;RwLock</span><br><span class="line">use std::sync::RwLock;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let lock &#x3D; RwLock::new(5);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同一时间允许多个读</span><br><span class="line">    &#123;</span><br><span class="line">        let r1 &#x3D; lock.read().unwrap();</span><br><span class="line">        let r2 &#x3D; lock.read().unwrap();</span><br><span class="line">        assert_eq!(*r1, 5);</span><br><span class="line">        assert_eq!(*r2, 5);</span><br><span class="line">    &#125; &#x2F;&#x2F; 读锁在此处被drop</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同一时间只允许一个写</span><br><span class="line">    &#123;</span><br><span class="line">        let mut w &#x3D; lock.write().unwrap();</span><br><span class="line">        *w +&#x3D; 1;</span><br><span class="line">        assert_eq!(*w, 6);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以下代码会阻塞发生死锁，因为读和写不允许同时存在</span><br><span class="line">        &#x2F;&#x2F; 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于&#96;w&#96;的作用域中</span><br><span class="line">        &#x2F;&#x2F; let r1 &#x3D; lock.read();</span><br><span class="line">        &#x2F;&#x2F; println!(&quot;&#123;:?&#125;&quot;,r1);</span><br><span class="line">    &#125;&#x2F;&#x2F; 写锁在此处被drop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>try_write</code>和<code>try_read</code>来尝试进行一次写/读，若失败则返回错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Err(&quot;WouldBlock&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>条件变量<code>Condvar</code>控制线程同步</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex, Condvar&#125;;</span><br><span class="line"></span><br><span class="line">let pair &#x3D; Arc::new((Mutex::new(false), Condvar::new()));</span><br><span class="line">let (lock, cvar) &#x3D; &amp;*pair;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消费者线程（等待条件成立）</span><br><span class="line">let consumer &#x3D; thread::spawn(move || &#123;</span><br><span class="line">    let mut condition &#x3D; lock.lock().unwrap();</span><br><span class="line">    while !*condition &#123;</span><br><span class="line">        condition &#x3D; cvar.wait(condition).unwrap(); &#x2F;&#x2F; 释放锁并等待</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;Condition is now true!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产者线程（修改条件并通知）</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    let mut condition &#x3D; lock.lock().unwrap();</span><br><span class="line">    *condition &#x3D; true;          &#x2F;&#x2F; 修改条件</span><br><span class="line">    cvar.notify_one();          &#x2F;&#x2F; 唤醒消费者</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">consumer.join().unwrap();</span><br></pre></td></tr></table></figure>

<p>消费者线程需等待条件成立才可执行：获取互斥锁检查条件是否成立 =&gt; 不成立则进入循环 =&gt; <code>cvar.wait(condition).unwrap()</code>执行时立即释放互斥锁（交由其他线程修改） =&gt; 其他线程修改后使用<code>cvar.notify_one()</code>唤醒该线程 =&gt; 返回条件重新检查</p>
<p>注：</p>
<ul>
<li><pre><code>notify_one()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">随机唤醒一个正在</span><br></pre></td></tr></table></figure>
wait()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  的线程（由操作系统调度决定）。</span><br><span class="line"></span><br><span class="line">  - 如果有多个线程在等待，不保证顺序（可能是最早等待的，也可能是随机的）。</span><br><span class="line">  - 如果没有线程在等待，这次通知会被丢弃（无效果）。</span><br><span class="line"></span><br><span class="line">- &#96;notify_all()&#96;： 唤醒所有正在 &#96;wait()&#96; 的线程，它们会竞争锁并依次检查条件。</span><br><span class="line"></span><br><span class="line">##### &#96;Atomic&#96;原子类型与内存顺序</span><br><span class="line"></span><br><span class="line">为解决锁的性能问题而生，通过 CPU 的原子指令实现无锁线程安全操作</span><br><span class="line"></span><br><span class="line">| 特性             | 说明                                                         |</span><br><span class="line">| ---------------- | ------------------------------------------------------------ |</span><br><span class="line">| **不可分割性**   | 操作一旦开始，不会被其他线程或 CPU 中断。                    |</span><br><span class="line">| **线程安全**     | 多线程同时执行同一原子指令时，结果依然正确                   |</span><br><span class="line">| **硬件直接支持** | 由 CPU 通过特定指令（如 &#96;LOCK&#96; 前缀）实现，而非软件模拟。    |</span><br><span class="line">| **内存顺序控制** | 通过 &#96;Ordering&#96; 参数指定操作前后的指令重排规则（如 &#96;SeqCst&#96;）。 |</span><br></pre></td></tr></table></figure>
use std::sync::atomic::AtomicUsize;
</code></pre></li>
</ul>
<p>let counter = AtomicUsize::new(0); // 常用场景是作为全局变量</p>
<p>counter.store(100, Ordering::Relaxed); // 存储值（写入）</p>
<p>let current = counter.load(Ordering::SeqCst);<br>println!(“Current value: {}”, current); // 加载值（读取）</p>
<p>let old = counter.fetch_add(10, Ordering::SeqCst); // 原子加法（返回旧值）旧值=100，新值=110</p>
<p>counter.fetch_sub(5, Ordering::Relaxed); // 原子减法 新值=105</p>
<p>counter.fetch_or(0b1, Ordering::Relaxed); // 原子位操作 按位或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**内存顺序**</span><br><span class="line"></span><br><span class="line">面临问题：编译器可能导致指令重排</span><br></pre></td></tr></table></figure>
<p>X = 1;<br>Y = 3;<br>X = 2; // 直接变成</p>
<p>X = 2;<br>Y = 3;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内存顺序指定</span><br><span class="line"></span><br><span class="line">| **Ordering** | 作用                                                         |</span><br><span class="line">| ------------ | ------------------------------------------------------------ |</span><br><span class="line">| &#96;Relaxed&#96;    | 仅保证原子性，不保证顺序（性能最高）                         |</span><br><span class="line">| &#96;Release&#96;    | 写入操作：确保之前的指令不会被重排到它之后，（在这条指令前写入的数据）对其他线程可见 |</span><br><span class="line">| &#96;Acquire&#96;    | 读取操作：确保之后的指令不会被重排到它之前，能读到其他线程的修改 |</span><br><span class="line">| &#96;SeqCst&#96;     | 严格顺序一致性（性能最低，但最安全）                         |</span><br></pre></td></tr></table></figure>
<p>use std::sync::atomic::{AtomicBool, Ordering};</p>
<p>let ready = AtomicBool::new(false);<br>let data = 42;</p>
<p>// 线程1：发布数据<br>thread::spawn(move || {<br>    data = 100;                        // 非原子写入<br>    ready.store(true, Ordering::Release); // 保证 data 写入对其他线程可见<br>});</p>
<p>// 线程2：读取数据<br>thread::spawn(move || {<br>    while !ready.load(Ordering::Acquire) {} // 等待并同步内存<br>    println!(“Data: {}”, data);        // 保证看到 data=100<br>});</p>
<p>// 多线程需要用到Arc与clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 全局变量</span><br><span class="line"></span><br><span class="line">全局变量的生命周期肯定是&#96;&#39;static&#96;，但是不代表它需要用&#96;static&#96;来声明</span><br><span class="line"></span><br><span class="line">- 编译期初始化的全局变量，&#96;const&#96;创建常量，&#96;static&#96;创建静态变量，&#96;Atomic&#96;创建原子类型</span><br><span class="line">- 运行期初始化的全局变量，&#96;lazy_static&#96;用于懒初始化，&#96;Box::leak&#96;利用内存泄漏将一个变量的生命周期变为&#96;&#39;static&#96;</span><br><span class="line"></span><br><span class="line">#### 编译期初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**静态常量**</span><br></pre></td></tr></table></figure>
<p>const MAX_ID: usize =  usize::MAX / 2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关键字是&#96;const&#96;而不是&#96;let&#96;</span><br><span class="line">- 定义常量必须指明类型（如 i32）不能省略</span><br><span class="line">- 定义常量时变量的命名规则一般是全部大写</span><br><span class="line">- 常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址</span><br><span class="line">- 常量的赋值只能是常量表达式&#x2F;数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式</span><br><span class="line">- 对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义</span><br><span class="line"></span><br><span class="line">**静态变量**</span><br></pre></td></tr></table></figure>
<p>static mut REQUEST_RECV: usize = 0;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 必须使用&#96;unsafe&#96;语句块才能访问和修改&#96;static&#96;变量</span><br><span class="line">- 定义静态变量的时候必须赋值为在编译期就可以计算出的值(常量表达式&#x2F;数学表达式)，不能是运行时才能计算出的值(如函数)</span><br><span class="line"></span><br><span class="line">**原子类型**</span><br><span class="line"></span><br><span class="line">想要全局计数器、状态控制等功能，又想要线程安全的实现</span><br></pre></td></tr></table></figure>
<p>use std::sync::atomic::{AtomicUsize, Ordering};<br>static REQUEST_RECV: AtomicUsize  = AtomicUsize::new(0);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 运行期初始化</span><br><span class="line"></span><br><span class="line">解决问题：无法用函数进行静态初始化</span><br><span class="line"></span><br><span class="line">**&#96;lazy_static&#96;**</span><br><span class="line"></span><br><span class="line">用于懒初始化（直到使用时才开始初始化）静态变量的宏，允许我们在运行期初始化静态变量</span><br></pre></td></tr></table></figure>
<p>use lazy_static::lazy_static;<br>lazy_static! {<br>    static ref NAMES: Mutex<String> = Mutex::new(String::from(“Sunface, Jack, Allen”));<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;lazy_static&#96;宏，匹配的是&#96;static ref&#96;，所以定义的静态变量都是不可变引用</span><br><span class="line"></span><br><span class="line">**&#96;Box::leak&#96;**</span><br><span class="line"></span><br><span class="line">将一个变量从内存中漏出来，变为&#96;&#39;static&#39;&#96;生命周期</span><br></pre></td></tr></table></figure>
<p>#[derive(Debug)]<br>struct Config {<br>    a: String,<br>    b: String<br>}<br>static mut CONFIG: Option&lt;&amp;mut Config&gt; = None;</p>
<p>fn main() {<br>    let c = Box::new(Config {<br>        a: “A”.to_string(),<br>        b: “B”.to_string(),<br>    });</p>
<pre><code>unsafe {
    // 将`c`从内存中泄漏，变成`&apos;static`生命周期(正常情况下，一个局部变量不可赋给全局变量)
    CONFIG = Some(Box::leak(c));
    println!(&quot;{:?}&quot;, CONFIG);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 错误处理</span><br><span class="line"></span><br><span class="line">#### 组合器</span><br><span class="line"></span><br><span class="line">**&#96;or()&#96;和&#96;and()&#96;**</span><br><span class="line"></span><br><span class="line">对两个表达式做逻辑组合，最终返回 &#96;Option&#96; &#x2F; &#96;Result&#96;</span><br><span class="line"></span><br><span class="line">- &#96;or()&#96;，表达式按照顺序求值，若任何一个表达式的结果是 &#96;Some&#96; 或 &#96;Ok&#96;，则该值会立刻返回</span><br><span class="line">- &#96;and()&#96;，若两个表达式的结果都是 &#96;Some&#96; 或 &#96;Ok&#96;，则第二个表达式中的值被返回。若任何一个的结果是 &#96;None&#96; 或 &#96;Err&#96; ，则立刻返回。</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“some1”);<br>let s2 = Some(“some2”);<br>let n: Option&lt;&amp;str&gt; = None;<br>assert_eq!(s1.or(s2), s1);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注：&#96;or&#x2F;and()&#96;的两个表达式要是同一类型，不能一边是&#96;Option&#96;一边是&#96;Result&#96;</span><br><span class="line"></span><br><span class="line">**&#96;or_else()和and_then()&#96;**</span><br><span class="line"></span><br><span class="line">跟 &#96;or()&#96; 和 &#96;and()&#96; 类似，但第二个表达式是一个闭包</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“some1”);<br>let fn_some = || Some(“some2”);<br>let fn_none = || None;<br>assert_eq!(s1.or_else(fn_some), s1);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;fliter&#96;**</span><br><span class="line"></span><br><span class="line">用于对 &#96;Option&#96; 进行过滤</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(3);<br>let n = None;<br>let fn_is_even = |x: &amp;i8| x % 2 == 0;<br>assert_eq!(s1.filter(fn_is_even), n);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;map()&#96;和&#96;map_err()&#96;**</span><br><span class="line"></span><br><span class="line">&#96;map&#96; 可以将 &#96;Some&#96; 或 &#96;Ok&#96; 中的值映射为另一个（转化容器内的值）</span><br><span class="line"></span><br><span class="line"> 如果&#96;a&#96;的值是&#96;Some(n)&#96;，&#96;a.map(f)&#96;将&#96;a&#96;的值变为&#96;Some(f(n))&#96;</span><br><span class="line"></span><br><span class="line">用 &#96;map_err&#96;将 &#96;Err&#96; 中的值进行改变（效果同上）</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“abcde”);<br>let s2 = Some(5);<br>let fn_character_count = |s: &amp;str| s.chars().count();<br>assert_eq!(s1.map(fn_character_count), s2);</p>
<p>let e1: Result&lt;&amp;str, &amp;str&gt; = Err(“404”);<br>let e2: Result&lt;&amp;str, isize&gt; = Err(404);<br>let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() };<br>assert_eq!(e1.map_err(fn_character_count), e2);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**&#96;map_or()&#96;和&#96;map_or_else()&#96;**</span><br><span class="line"></span><br><span class="line">&#96;map_or&#96; 在 &#96;map&#96; 的基础上提供了一个默认值</span><br><span class="line"></span><br><span class="line">&#96;map_or_else&#96; 与 &#96;map_or&#96; 类似，但是它是通过一个闭包来提供默认值</span><br></pre></td></tr></table></figure>
<p>const V_DEFAULT: u32 = 1; // 默认值<br>let s: Result&lt;u32, ()&gt; = Ok(10);<br>let fn_closure = |v: u32| v + 2;<br>assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);</p>
<p>let s = Some(10);<br>let fn_closure = |v: i8| v + 2;<br>let fn_default = || 1; // 默认值<br>assert_eq!(s.map_or_else(fn_default, fn_closure), 12);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;ok_or()&#96;和&#96;ok_or_else&#96;**</span><br><span class="line"></span><br><span class="line">可以将 &#96;Option&#96; 类型转换为 &#96;Result&#96; 类型</span><br><span class="line"></span><br><span class="line">&#96;ok_or&#96; 接收一个默认的 &#96;Err&#96; 参数，&#96;ok_or_else&#96; 接收一个闭包作为 &#96;Err&#96; 参数</span><br></pre></td></tr></table></figure>
<p>const ERR_DEFAULT: &amp;str = “error message”;<br>// let fn_err_message = || “error message”;</p>
<p>assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)<br>assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 自定义错误类型</span><br></pre></td></tr></table></figure>
<p>use std::fmt::{Debug, Display};</p>
<p>pub trait Error: Debug + Display {<br>    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + ‘static)&gt; { … }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当自定义类型实现该特征后，该类型就可以作为 &#96;Err&#96; 来使用，同时可以归一化为&#96;Box&lt;dyn std::error:Error&gt;&#96;</span><br><span class="line"></span><br><span class="line">**将其他错误类型转化为自定义错误类型**</span><br><span class="line"></span><br><span class="line">只要实现&#96;From&#96;特征，即可使用&#96;?&#96;强制把返回的错误类型转换（同时返回）</span><br></pre></td></tr></table></figure>
<p>// std::convert::From特征<br>pub trait From<T>: Sized {<br>  fn from(_: T) -&gt; Self;<br>} // T为原本的错误类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**归一化不同错误类型**</span><br><span class="line"></span><br><span class="line">面临问题：要在一个函数中返回不同的错误</span><br><span class="line"></span><br><span class="line">解决方案：将不同的错误类型归一化为一种</span><br><span class="line"></span><br><span class="line">- 使用特征对象 &#96;Box&lt;dyn Error&gt;&#96;：需要实现&#96;Debug + Display&#96; 特征（存在问题：一个没有&#96;Error&#96;特征的类型同样可以用作&#96;Result&lt;T, E&gt;&#96;中的&#96;E&#96;）</span><br><span class="line">- 自定义错误类型：需要实现&#96;Error&#96;特征才能被转换出来</span><br><span class="line">- 使用 &#96;thiserror&#96;（一种三方库函数）</span><br><span class="line"></span><br><span class="line">### &#96;UnSafe&#96;</span><br><span class="line"></span><br><span class="line">面临问题：</span><br><span class="line"></span><br><span class="line">- 编译器过强且保守</span><br><span class="line">- 特定功能如底层硬件操作本就不安全</span><br><span class="line"></span><br><span class="line">&#96;unsafe&#96;功能</span><br><span class="line"></span><br><span class="line">- 解引用裸指针</span><br><span class="line">- 调用一个 &#96;unsafe&#96; 或外部的函数</span><br><span class="line">- 访问或修改一个可变的静态变量</span><br><span class="line">- 实现一个 &#96;unsafe&#96; 特征</span><br><span class="line">- 访问 &#96;union&#96; 中的字段</span><br><span class="line"></span><br><span class="line">#### 功能解析</span><br><span class="line"></span><br><span class="line">##### 解引用裸指针</span><br><span class="line"></span><br><span class="line">裸指针在功能上跟引用类似，同时它也需要显式地注明可变性。</span><br><span class="line"></span><br><span class="line">&#96;*const T&#96; 和 &#96;*mut T&#96;分别代表了不可变和可变（&#96;*&#96; 是类型名称的一部分而非解引用）</span><br><span class="line"></span><br><span class="line">裸指针的功能（类似于C的指针）：</span><br><span class="line"></span><br><span class="line">- 可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</span><br><span class="line">- 并不能保证指向合法的内存</span><br><span class="line">- 可以是 &#96;null&#96;</span><br><span class="line">- 没有实现任何自动的回收 (drop)</span><br></pre></td></tr></table></figure>
<p>// 基于引用创建裸指针<br>let mut num = 5;<br>let r1 = &amp;num as *const i32;<br>let r2 = &amp;mut num as *mut i32;</p>
<p>// 使用*解引用<br>unsafe {<br>    println!(“{}”, *r1);<br>}</p>
<p>// 基于智能指针创建裸指针<br>let a: Box<i32> = Box::new(10);<br>let b: <em>const i32 = &amp;</em>a; // 需要先解引用a<br>let c: *const i32 = Box::into_raw(a); // 使用 into_raw 来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">- 创建裸指针是安全的行为，使用不是</span><br><span class="line">- 使用裸指针可以创建两个可变指针都指向同一个数据（需要自己处理数据竞争）</span><br><span class="line"></span><br><span class="line">##### 调用&#96;unsafe&#96;函数或方法</span><br></pre></td></tr></table></figure>
<p>// unsafe函数：外表唯一不同就是需要unsafe fn来定义，在调用时需要放在unsafe块<br>// 在unsafe函数中使用unsafe来注明块是多余的行为<br>unsafe fn dangerous() {}<br>fn main() {<br>    unsafe {<br>        dangerous();<br>    }<br>}</p>
<p>// 在函数中使用了unsafe声明块不代表函数要声明为unsafe fn:同样可以使用用安全的抽象包裹unsafr代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### &#96;FFI&#96;</span><br><span class="line"></span><br><span class="line">用来与其它语言进行交互</span><br><span class="line"></span><br><span class="line">面临问题：使用一个其他语言编写的库</span><br><span class="line"></span><br><span class="line">- 对该库进行重写或者移植</span><br><span class="line">- 使用 &#96;FFI&#96;</span><br></pre></td></tr></table></figure>
<p>// 调用C标准库中的abs函数<br>extern “C” { // C定义了外部函数所使用的应用二进制接口ABI<br>    fn abs(input: i32) -&gt; i32;<br>}<br>fn main() {<br>    unsafe { // 必须使用unsafe<br>        println!(“Absolute value of -3 according to C: {}”, abs(-3));<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 访问&#96;union&#96;中的字段</span><br><span class="line"></span><br><span class="line">&#96;union&#96;主要用于和&#96;C&#96;代码交互，访问其字段是不安全的</span><br></pre></td></tr></table></figure>
<p>#[repr(C)]<br>union MyUnion {<br>    f1: u32,<br>    f2: f32,<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &#96;Macro&#96;宏编程</span><br><span class="line"></span><br><span class="line">宏的参数可以使用 &#96;()&#96;、&#96;[]&#96; 以及 &#96;&#123;&#125;&#96;：虽然三种使用形式皆可，但是 Rust 内置的宏都有自己约定俗成的使用方式，例如 &#96;vec![...]&#96;、&#96;assert_eq!(...)&#96; 等</span><br><span class="line"></span><br><span class="line">宏分为两类：</span><br><span class="line"></span><br><span class="line">- 声明式宏</span><br><span class="line">- 三种过程宏</span><br><span class="line">  - &#96;#[derive]&#96;，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 &#96;Debug&#96; 特征</span><br><span class="line">  - 类属性宏(Attribute-like macro)，用于为目标添加自定义的属性</span><br><span class="line">  - 类函数宏(Function-like macro)，看上去就像是函数调用</span><br><span class="line"></span><br><span class="line">#### 宏与函数的区别</span><br><span class="line"></span><br><span class="line">元编程：通过一种代码来生成另一种代码，可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本</span><br><span class="line"></span><br><span class="line">可变参数：相比于&#96;Rust&#96;中函数参数个数的固定，宏的参数个数可变</span><br><span class="line"></span><br><span class="line">宏展开：宏展开过程是发生在编译器对代码进行解释之前，即编译期前；函数直到运行时才调用</span><br><span class="line"></span><br><span class="line">#### 声明式宏&#96;macro_rules&#96;</span><br><span class="line"></span><br><span class="line">声明式宏用来编写可以生成代码的代码，即可以编写自己的宏</span><br><span class="line"></span><br><span class="line">类似于&#96;match&#96;进行模式匹配，类似于函数可以传入参数</span><br></pre></td></tr></table></figure>
<p>// 基本形式<br>macro_rules! macro_name {<br>    (pattern) =&gt; { expansion };<br>    // 可以有多个匹配模式<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**模式匹配**的模式可以包括：字面量、元变量（以 &#96;$&#96; 开头的捕获，如 &#96;$x:expr&#96;）、重复（使用 &#96;$(...)*&#96; 或 &#96;$(...)+&#96; 等表示重复）</span><br><span class="line"></span><br><span class="line">**元变量类型**（类似于函数定义中形参的类型声明）</span><br><span class="line"></span><br><span class="line">- &#96;expr&#96;：表达式</span><br><span class="line">- &#96;ident&#96;：标识符（变量名、函数名等）</span><br><span class="line">- &#96;ty&#96;：类型</span><br><span class="line">- &#96;path&#96;：路径（如 &#96;std::collections::HashMap&#96;）</span><br><span class="line">- &#96;pat&#96;：模式</span><br><span class="line">- &#96;stmt&#96;：语句</span><br><span class="line">- &#96;block&#96;：代码块</span><br><span class="line">- &#96;item&#96;：项（函数、结构体、模块等）</span><br><span class="line">- &#96;meta&#96;：元项（&#96;#[...]&#96; 和 &#96;#![...]&#96; 属性内部的内容）</span><br><span class="line">- &#96;tt&#96;：标记树（单个标记或括号内的标记）</span><br><span class="line"></span><br><span class="line">**重复操作符**</span><br><span class="line"></span><br><span class="line">- &#96;*&#96;：0 次或多次</span><br><span class="line">- &#96;+&#96;：1 次或多次</span><br><span class="line">- &#96;?&#96;：0 次或 1 次</span><br></pre></td></tr></table></figure>
<p>#[macro_export] // 将宏进行了导出，其它的包就可以将该宏引入到当前作用域中<br>macro_rules! create_function { // 宏的名称是c_f，在调用时才需要加上！<br>    ($func_name:ident) =&gt; {<br>        fn $func_name() {<br>            println!(“You called {}”, stringify!($func_name));<br>        }<br>    };<br>}<br>// 使用<br>create_function!(foo); // 传入一个合法标识符，创建了一个函数<br>foo(); // 输出: You called foo</p>
<p>// 重复模式<br>#[macro_export]<br>macro_rules! vec {<br>    ( $( $x:expr ),* ) =&gt; {<br>        {<br>            let mut temp_vec = Vec::new();<br>            $(<br>                temp_vec.push($x);<br>            )* // 此处相当于一个循环<br>            temp_vec<br>        }<br>    };<br>}<br>// 使用<br>let v = vec!(“a”, “b”, “c”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 过程宏</span><br><span class="line"></span><br><span class="line">1. **派生宏（Derive Macros）** *&quot;自动为结构体&#x2F;枚举生成 trait 实现的代码扩展器。&quot;* → **用途**：如 &#96;#[derive(Serialize)]&#96; 为类型实现序列化逻辑。</span><br><span class="line">2. **属性宏（Attribute Macros）** *&quot;编译时代码加工器，能修改或增强被标记的项（如函数&#x2F;结构体）。&quot;* → **用途**：如 &#96;#[tokio::main]&#96; 将普通函数异步化。</span><br><span class="line">3. **函数式宏（Function-like Macros）** *&quot;将其他语法编译时转换为 Rust 代码的翻译器。&quot;* → **用途**：如 &#96;sql!(SELECT * FROM table)&#96; 生成类型安全的查询构建器。</span><br><span class="line"></span><br><span class="line">##### 自定义&#96;derive&#96;过程宏</span><br><span class="line"></span><br><span class="line">注：目前只能在单独的包中定义宏，包名以&#96;derive&#96;为后缀</span><br><span class="line"></span><br><span class="line">假设有一个特征 &#96;HelloMacro&#96;，现在有两种方式让用户使用它：</span><br><span class="line"></span><br><span class="line">- 为每个类型手动实现该特征，就像之前特征章节所做的</span><br><span class="line">- 使用过程宏来统一实现该特征，这样用户只需要对类型进行标记即可：&#96;#[derive(HelloMacro)]&#96;</span><br></pre></td></tr></table></figure>
<p>// hello_macro项目目录<br>hello_macro<br>├── Cargo.toml<br>├── src<br>│   ├── main.rs<br>│   └── lib.rs<br>└── hello_macro_derive // 此包中实现宏<br>    ├── Cargo.toml<br>    ├── src<br>        └── lib.rs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在项目的&#96;src&#x2F;main.rs&#96;中引用宏包中的内容：</span><br><span class="line"></span><br><span class="line">- 将 &#96;hello_macro_derive&#96; 发布到 &#96;crates.io&#96; 或 &#96;GitHub&#96; 中（类似于正常的依赖）</span><br><span class="line">- 使用相对路径引入的本地化方式</span><br></pre></td></tr></table></figure>
<p>// 修改 hello_macro/Cargo.toml 文件添加以下内容<br>[dependencies]<br>hello_macro_derive = { path = “../hello_macro/hello_macro_derive” }</p>
<h1 id="也可以使用下面的相对路径"><a href="#也可以使用下面的相对路径" class="headerlink" title="也可以使用下面的相对路径"></a>也可以使用下面的相对路径</h1><h1 id="hello-macro-derive-path-“-hello-macro-derive”"><a href="#hello-macro-derive-path-“-hello-macro-derive”" class="headerlink" title="hello_macro_derive = { path = “./hello_macro_derive” }"></a>hello_macro_derive = { path = “./hello_macro_derive” }</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">定义过程宏的过程</span><br></pre></td></tr></table></figure>
<p>// 1、在 hello_macro_derive/Cargo.toml 文件中添加<br>[lib]<br>proc-macro = true</p>
<p>[dependencies]<br>syn = “1.0”<br>quote = “1.0” // 这两个依赖包是定义中必须的</p>
<p>// 2、在 hello_macro_derive/src/lib.rs 中添加<br>extern crate proc_macro; // 过程宏核心库，提供 TokenStream 类型（表示宏的输入/输出）<br>use proc_macro::TokenStream;<br>use quote::quote;<br>use syn;<br>use syn::DeriveInput;</p>
<p>#[proc_macro_derive(HelloMacro)]<br>pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {<br>    // 基于 input 构建 AST 语法树<br>    let ast:DeriveInput = syn::parse(input).unwrap();</p>
<pre><code>// 构建特征实现代码
impl_hello_macro(&amp;ast)</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RCore学习记录</span><br><span class="line"></span><br><span class="line">顺序：&#96;bulid.rs&#96;文件会生成一个&#96;link_app.S&#96;（里面包含有各个程序标识起始地址的变量、名称和完整的ELF文件嵌入），这个文件由&#96;linker.S&#96;塞入内核镜像（编译链接后的程序文件），最后由&#96;load&#96;来执行</span><br><span class="line"></span><br><span class="line">任务切换的实质：切换任务上下文（即更改对应的寄存器为想执行的任务上下文中保存的数值）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 批处理系统</span><br><span class="line"></span><br><span class="line">**系统调用的基础函数：**</span><br><span class="line"></span><br><span class="line">&#96;syscall&#96; （用户文件中，标准库函数的基础） 和&#96;sbicall&#96; （系统文件中）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;rust</span><br><span class="line"> 3fn syscall(id: usize, args: [usize; 3]) -&gt; isize &#123;</span><br><span class="line"> 4   let mut ret: isize;</span><br><span class="line"> 5   unsafe &#123;</span><br><span class="line"> 6       core::arch::asm!(</span><br><span class="line"> 7           &quot;ecall&quot;,</span><br><span class="line"> 8           inlateout(&quot;x10&quot;) args[0] &#x3D;&gt; ret,</span><br><span class="line"> 9           in(&quot;x11&quot;) args[1],</span><br><span class="line">10           in(&quot;x12&quot;) args[2],</span><br><span class="line">11           in(&quot;x17&quot;) id</span><br><span class="line">12       );</span><br><span class="line">13   &#125;</span><br><span class="line">14   ret</span><br><span class="line">15&#125;</span><br></pre></td></tr></table></figure>



<p><strong>批处理系统的应用管理器：</strong></p>
<p>（从系统文件中一个记录了应用数量、各应用起始位置、最后一个应用结束位置的<code>link_app.S</code>中获取）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppManager</span></span> &#123;</span><br><span class="line">    num_app: <span class="built_in">usize</span>,</span><br><span class="line">    current_app: <span class="built_in">usize</span>,</span><br><span class="line">    app_start: [<span class="built_in">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法： <code>print_app_info/get_current_app/move_to_next_app</code> </p>
<p><code>load_app</code>将参数 <code>app_id</code> 对应的应用程序的二进制镜像加载到物理内存以 <code>0x80400000</code> 起始的位置</p>
<p><strong><code>batch</code>子模块暴露的接口</strong></p>
<ul>
<li><code>init</code> ：初始化 <code>APP_MANAGER</code> </li>
<li><code>run_next_app</code> ：加载并运行下一个应用程序</li>
</ul>
<p><strong>用户栈与内核栈</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">// os/src/batch.rs</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"> <span class="number">4</span><span class="keyword">struct</span> KernelStack &#123;</span><br><span class="line"> <span class="number">5</span>  data: [<span class="built_in">u8</span>; KERNEL_STACK_SIZE],</span><br><span class="line"> <span class="number">6</span>&#125;</span><br><span class="line"> <span class="number">7</span></span><br><span class="line"> <span class="number">8</span><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"> <span class="number">9</span><span class="keyword">struct</span> UserStack &#123;</span><br><span class="line"><span class="number">10</span>  data: [<span class="built_in">u8</span>; USER_STACK_SIZE],</span><br><span class="line"><span class="number">11</span>&#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span><span class="keyword">static</span> KERNEL_STACK: KernelStack = KernelStack &#123;</span><br><span class="line"><span class="number">14</span>  data: [<span class="number">0</span>; KERNEL_STACK_SIZE],</span><br><span class="line"><span class="number">15</span>&#125;;</span><br><span class="line"><span class="number">16</span><span class="keyword">static</span> USER_STACK: UserStack = UserStack &#123;</span><br><span class="line"><span class="number">17</span>  data: [<span class="number">0</span>; USER_STACK_SIZE],</span><br><span class="line"><span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>实现了 <code>get_sp</code> 方法来获取栈顶地址</p>
<p><strong>特权级切换</strong></p>
<table>
<thead>
<tr>
<th>CSR 名</th>
<th>该 CSR 与 Trap 相关的功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>sstatus</code></td>
<td><code>SPP</code> 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息</td>
</tr>
<tr>
<td><code>sepc</code></td>
<td>当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址</td>
</tr>
<tr>
<td><code>scause</code></td>
<td>描述 Trap 的原因</td>
</tr>
<tr>
<td><code>stval</code></td>
<td>给出 Trap 附加信息</td>
</tr>
<tr>
<td><code>stvec</code></td>
<td>控制 Trap 处理代码的入口地址</td>
</tr>
</tbody></table>
<p>硬件自动完成：</p>
<ul>
<li><code>sstatus</code> 的 <code>SPP</code> 字段会被修改为 CPU 当前的特权级（U/S）。</li>
<li><code>sepc</code> 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。</li>
<li><code>scause/stval</code> 分别会被修改成这次 Trap 的原因以及相关的附加信息。</li>
<li>CPU 会跳转到 <code>stvec</code> 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。</li>
</ul>
<p>处理完成后通过S特权级<code>sret</code>指令：</p>
<ul>
<li>CPU 会将当前的特权级按照 <code>sstatus</code> 的 <code>SPP</code> 字段设置为 U 或者 S ；</li>
<li>CPU 会跳转到 <code>sepc</code> 寄存器指向的那条指令，然后继续执行。</li>
</ul>
<p><strong><code>Trap</code>上下文</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="number">4</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line"><span class="number">6</span>    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line"><span class="number">7</span>    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line"><span class="number">8</span>&#125; <span class="comment">// 包含所有的通用寄存器 `x0~x31` ，还有 `sstatus` 和 `sepc`</span></span><br><span class="line"><span class="comment">// 从内存栈底分配34个空间保存</span></span><br></pre></td></tr></table></figure>

<p>实现 Trap 上下文保存和恢复的汇编代码<code>os/src/trap/trap.S</code>,用（汇编中的）外部符号 <code>__alltraps</code> 和 <code>__restore</code> 标记为函数</p>
<p>Trap 处理的总体流程如下：首先通过 <code>__alltraps</code> 将 Trap 上下文保存在内核栈上，然后跳转到使用 Rust 编写的 <code>trap_handler</code> 函数 完成 Trap 分发及处理。当 <code>trap_handler</code> 返回之后，使用 <code>__restore</code> 从保存在内核栈上的 Trap 上下文恢复寄存器。最后通过一条 <code>sret</code> 指令回到应用程序执行</p>
<p>使用<code>sp</code>表示当前的栈，<code>sscratch</code>代表另一个栈</p>
<p>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_sp</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="built_in">usize</span>) </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>(entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> </span><br><span class="line">    <span class="comment">// 修改其中的 sepc 寄存器为应用程序入口点 entry， sp 寄存器为我们设定的 一个栈指针，并将 sstatus 寄存器的 SPP 字段设置为 User</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="分时多任务"><a href="#分时多任务" class="headerlink" title="分时多任务"></a>分时多任务</h3><p><code>user/build.py</code>为每个应用定制各自的起始地址，.text 段的地址为 <code>0x80400000 + app_id * 0x20000</code></p>
<p><code>batch</code> 被拆分为 <code>loader</code> 和 <code>task</code> ， 前者负责启动时加载应用程序，后者负责切换和调度。</p>
<p><code>loader</code> 模块的 <code>load_apps</code> 函数负责将所有用户程序在内核初始化的时一并加载进内存</p>
<p><strong>任务切换</strong></p>
<p>当一个应用在内核态时，其 Trap 控制流可以调用一个特殊的 <code>__switch</code> 函数，函数调用时运行另一个任务，返回后运行原来的任务</p>
<p>在 <code>__switch</code> 中保存 CPU 的某些寄存器，它们就是任务上下文</p>
<p>函数拥有两个参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> __switch(</span><br><span class="line">    current_task_cx_ptr: *<span class="keyword">mut</span> TaskContext,</span><br><span class="line">    next_task_cx_ptr: *<span class="keyword">const</span> TaskContext</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>内核先把 <code>current_task_cx_ptr</code> 中包含的寄存器值逐个保存，再把 <code>next_task_cx_ptr</code> 中包含的寄存器值逐个恢复</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">// os/src/task/context.rs</span></span><br><span class="line"><span class="number">2</span><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="number">3</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span></span> &#123;</span><br><span class="line"><span class="number">4</span>    ra: <span class="built_in">usize</span>, <span class="comment">// 任务恢复后执行地址</span></span><br><span class="line"><span class="number">5</span>    sp: <span class="built_in">usize</span>, <span class="comment">// 该任务内核栈地址(当前是内核态)</span></span><br><span class="line"><span class="number">6</span>    s: [<span class="built_in">usize</span>; <span class="number">12</span>], <span class="comment">// 被调用者保存寄存器</span></span><br><span class="line"><span class="number">7</span>&#125; <span class="comment">// TaskContext 里包含的寄存器</span></span><br></pre></td></tr></table></figure>



<p><strong>管理多道程序</strong></p>
<ul>
<li>任务运行状态：未初始化、准备执行、正在执行、已退出</li>
<li>任务控制块：维护任务状态和任务上下文</li>
<li>任务相关系统调用：程序主动暂停 <code>sys_yield</code> 和主动退出 <code>sys_exit</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">TaskStatus</span></span> &#123; <span class="comment">// 任务状态</span></span><br><span class="line">    UnInit, <span class="comment">// 未初始化</span></span><br><span class="line">    Ready, <span class="comment">// 准备运行</span></span><br><span class="line">    Running, <span class="comment">// 正在运行</span></span><br><span class="line">    Exited, <span class="comment">// 已退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123; <span class="comment">// 任务控制块</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 任务状态</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 任务上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局的任务管理器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    num_app: <span class="built_in">usize</span>,</span><br><span class="line">    inner: UPSafeCell&lt;TaskManagerInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskManagerInner</span></span> &#123;</span><br><span class="line">    tasks: [TaskControlBlock; MAX_APP_NUM],</span><br><span class="line">    current_task: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TaskManager</code>方法：<code>mark_current_suspended</code>（暂停当前程序）/  <code>mark_current_exited</code> / <code>run_next_task</code> / <code>find_next_task</code>（找到下一个<code>Ready</code>状态的应用）</p>
<p><strong>时钟中断</strong></p>
<p>处理器维护时钟计数器 <code>mtime</code>，还有另外一个 CSR <code>mtimecmp</code> 。 一旦计数器 <code>mtime</code> 的值超过了 <code>mtimecmp</code>，就会触发一次时钟中断</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_time</span></span>() -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获得mtime值</span></span><br><span class="line">    time::read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_timer</span></span>(timer: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    sbi_call(SBI_SET_TIMER, timer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_next_trigger</span></span>() &#123; <span class="comment">// 设置时钟中断</span></span><br><span class="line">    set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>非叶节点（页目录表，非末级页表）的表项标志位含义和叶节点（页表，末级页表）相比有一些不同：</p>
<ul>
<li>当 <code>V</code> 为 0 的时候，代表当前指针是一个空指针，无法走向下一级节点，即该页表项对应的虚拟地址范围是无效的；</li>
<li>只有当 <code>V</code> 为1 且 <code>R/W/X</code> 均为 0 时，表示是一个合法的页目录表项，其包含的指针会指向下一级的页表；</li>
<li>注意: 当 <code>V</code> 为1 且 <code>R/W/X</code> 不全为 0 时，表示是一个合法的页表项，其包含了虚地址对应的物理页号。</li>
</ul>
<p><strong>物理地址与物理页号转换</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span><span class="keyword">impl</span> PhysAddr &#123;</span><br><span class="line"> <span class="number">4</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">page_offset</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="keyword">self</span>.<span class="number">0</span> &amp; (PAGE_SIZE - <span class="number">1</span>) &#125; <span class="comment">// 从自己的物理地址0x12345000得到偏移为0x000（末三位）</span></span><br><span class="line"> <span class="number">5</span>&#125;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span><span class="keyword">impl</span> <span class="built_in">From</span>&lt;PhysAddr&gt; <span class="keyword">for</span> PhysPageNum &#123;</span><br><span class="line"> <span class="number">8</span>    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(v: PhysAddr) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"> <span class="number">9</span>        <span class="built_in">assert_eq!</span>(v.page_offset(), <span class="number">0</span>);</span><br><span class="line"><span class="number">10</span>        v.floor()</span><br><span class="line"><span class="number">11</span>    &#125; <span class="comment">// 只有偏移为0（即对齐）才能从0x12345000得到物理页号0x12345</span></span><br><span class="line"><span class="number">12</span>&#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span><span class="keyword">impl</span> <span class="built_in">From</span>&lt;PhysPageNum&gt; <span class="keyword">for</span> PhysAddr &#123;</span><br><span class="line"><span class="number">15</span>    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(v: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123; <span class="keyword">Self</span>(v.<span class="number">0</span> &lt;&lt; PAGE_SIZE_BITS) &#125;</span><br><span class="line"><span class="number">16</span>&#125; <span class="comment">// 从物理页号0x12345还原回物理地址0x12345000</span></span><br></pre></td></tr></table></figure>

<p><strong>页表项的数据结构抽象与类型定义</strong></p>
<p>页表项共8个字节：</p>
<ul>
<li>V(0)    仅当 V(Valid) 位为 1 时，页表项才是合法的；</li>
<li>R(1)/W(2)/X(3)    R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；</li>
<li>U(4)    U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li>
<li>G(5)    G 我们不理会；</li>
<li>A(6)    A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li>
<li>D(7)    D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。</li>
<li>RSW(8-9)    </li>
<li>PPN[0] (10-18)    </li>
<li>PPN[1] (19-27)    </li>
<li>PPN[2] (28-53)    </li>
<li>Reserved(54-63)    </li>
</ul>
<p>前八位的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitflags!</span> &#123; <span class="comment">// 用来表示比特位的宏</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTEFlags</span></span>: <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> V = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> R = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> W = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> X = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> U = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">const</span> G = <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">const</span> A = <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">const</span> D = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的实现与方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"> <span class="number">4</span><span class="meta">#[repr(C)]</span></span><br><span class="line"> <span class="number">5</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTableEntry</span></span> &#123; <span class="comment">// 一个页表项</span></span><br><span class="line"> <span class="number">6</span>    <span class="keyword">pub</span> bits: <span class="built_in">usize</span>,</span><br><span class="line"> <span class="number">7</span>&#125;</span><br><span class="line"> <span class="number">8</span></span><br><span class="line"> <span class="number">9</span><span class="keyword">impl</span> PageTableEntry &#123;</span><br><span class="line"><span class="number">10</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum, flags: PTEFlags) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="number">11</span>        PageTableEntry &#123;</span><br><span class="line"><span class="number">12</span>            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line"><span class="number">13</span>        &#125;</span><br><span class="line"><span class="number">14</span>    &#125;</span><br><span class="line"><span class="number">15</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">empty</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="number">16</span>        PageTableEntry &#123;</span><br><span class="line"><span class="number">17</span>            bits: <span class="number">0</span>,</span><br><span class="line"><span class="number">18</span>        &#125;</span><br><span class="line"><span class="number">19</span>    &#125;</span><br><span class="line"><span class="number">20</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ppn</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123;</span><br><span class="line"><span class="number">22</span>    &#125;</span><br><span class="line"><span class="number">23</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">flags</span></span>(&amp;<span class="keyword">self</span>) -&gt; PTEFlags &#123;</span><br><span class="line"><span class="number">25</span>    &#125;</span><br><span class="line">     <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">26</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>页帧管理器</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackFrameAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,</span><br><span class="line">    end: <span class="built_in">usize</span>,</span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;PhysPageNum&gt; <span class="comment">// 分配物理页</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) <span class="comment">// 回收物理页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用以调用的接口</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">frame_alloc</span></span>() -&gt; <span class="built_in">Option</span>&lt;FrameTracker&gt;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">frame_dealloc</span></span>(ppn: PhysPageNum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表一个物理页帧</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameTracker</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> FrameTracker &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">		<span class="comment">// 将这个物理页帧上的所有字节清零</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        frame_dealloc(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>多级页表</strong></p>
<p>正常情况可以依靠MMU直接翻译，手动翻译是由于操作系统是不能直接靠MMU来访问用户地址程序的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个应用所有的页表</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTable</span></span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum, <span class="comment">// 某应用的根节点物理页号</span></span><br><span class="line">    frames: <span class="built_in">Vec</span>&lt;FrameTracker&gt;, <span class="comment">// 页表中所有节点（包括根）的物理页帧，不包括叶节点指向的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 新建时只需要分配一个根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表：维护虚拟物理地址的映射</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags);</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问特定物理页帧</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> PhysPageNum &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_pte_array</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [PageTableEntry] &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回的是一个页表项定长数组的可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_bytes_array</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &#125; <span class="comment">//  返回的是一个字节数组的可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取一个恰好放在一个物理页帧开头的类型为 T 的数据的可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立/拆除虚实地址映射</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> VirtPageNum &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">indexes</span></span>(&amp;<span class="keyword">self</span>) -&gt; [<span class="built_in">usize</span>; <span class="number">3</span>] &#123; <span class="comment">// 返回虚拟页号的三级索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fn</span> <span class="title">find_pte_create</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt;  <span class="comment">// 给定虚拟页号，找到/创建页表项及中间层页表</span></span><br><span class="line">&#125; <span class="comment">// 注意，这个只返回最后一级的页表项，所以还要通过map/unmap来判断或创建最后的物理地址</span></span><br></pre></td></tr></table></figure>

<p>只查询，不建立</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_token</span></span>(satp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 从satp寄存器中读此时的根页表地址</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_pte</span></span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;&amp;PageTableEntry&gt; &#123;&#125; <span class="comment">// 查找对应的页表是否存在（没有也不新建）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translate</span></span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;PageTableEntry&gt; &#123;&#125; <span class="comment">// 如果存放就返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户虚拟地址 =&gt; 可写物理内存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_byte_buffer</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>地址空间抽象</strong></p>
<p>逻辑段：虚拟地址连续，虚拟地址映射到物理地址的方式相同（物理页帧具有的属性相同而非物理地址连续）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑段结构体</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapArea</span></span> &#123;</span><br><span class="line">    vpn_range: VPNRange, <span class="comment">// 一段虚拟页号的连续区间，是一个迭代器</span></span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;, <span class="comment">// 绑定生命周期，到期自动回收</span></span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">MapType</span></span> &#123; <span class="comment">// 逻辑段内虚拟页面映射的方式</span></span><br><span class="line">    Identical, <span class="comment">// 恒等映射</span></span><br><span class="line">    Framed, <span class="comment">// 分配物理页帧（随机）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitflags!</span> &#123; <span class="comment">// 该逻辑段的访问方式</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapPermission</span></span>: <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> R = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> W = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> X = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> U = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> MapArea &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>( start_va: VirtAddr, end_va: VirtAddr, map_type: MapType, map_perm: MapPermission ) -&gt; <span class="keyword">Self</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map_one</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;&#125;; <span class="comment">// 在确定了虚拟页号之后，先在逻辑的页表管理MapArea里面加入虚拟页号和StackFrameAllocator分配的物理页帧，然后在pagetable里完善各级页表里面的指向路径</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap_one</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;&#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;&#125; <span class="comment">// 把当前结构体中的所有虚拟地址挨个map_one物理地址</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">copy_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;PageTable, data: &amp;[<span class="built_in">u8</span>]) &#123;&#125; <span class="comment">// 复制data到逻辑段开头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地址空间：一个进程能够访问的所有内存地址的集合，通常被组织为多个逻辑段</p>
<p><code>pagetable</code>    实际上查找虚拟/物理地址映射的方法（存储各级节点，可以手动搜索），供CPU/MMU使用</p>
<p><code>areas</code>    逻辑上管理的方法（管理虚拟内存、映射数组来直接寻找）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个地址空间的结构体</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemorySet</span></span> &#123; <span class="comment">// PageTable 下挂着所有多级页表的节点所在的物理页帧，而每个 MapArea 下则挂着对应逻辑段中的数据所在的物理页帧，这两部分合在一起构成了一个地址空间所需的所有物理页帧（绑定，自动回收）</span></span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="built_in">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_bare</span></span>() -&gt; <span class="keyword">Self</span> </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;) <span class="comment">// 插入新的逻辑段，还可以在物理页帧上写入data</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">insert_framed_area</span></span>( &amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start_va: VirtAddr, end_va: VirtAddr, permission: MapPermission )  <span class="comment">// 新建并插入一段Framed方式映射的逻辑段</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_kernel</span></span>() -&gt; <span class="keyword">Self</span>; <span class="comment">// 生成内核的地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_elf</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; (<span class="keyword">Self</span>, <span class="built_in">usize</span>, <span class="built_in">usize</span>); <span class="comment">// 分析应用的ELF文件(并且根据这个文件建立新的地址空间，返回栈顶和执行入口)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">activate</span></span>(&amp;<span class="keyword">self</span>) &#123;&#125; <span class="comment">// 第一次使用会开启分页，并且进入当前地址空间的页表</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map_trampoline</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;&#125; <span class="comment">// 直接插入一个空间地址中最高位置到跳板的键值对（注：所有地址空间中的跳板都是指向trap.S文件）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内核的地址空间排布</strong>    </p>
<p>跳板、各应用的内核栈（栈间有空洞区域防溢出）</p>
<p>四个逻辑段<code>.text/.rodata/.data/.bss</code>（恒等映射）、恒等映射（除之前内核已使用）所有物理页帧的页表 （即是内核页表）（注：后面两项都是恒等映射建立的三级页表<code>MapArea</code>）</p>
<p><strong>应用程序的地址空间排布</strong>    </p>
<p>跳板、<code>trap</code>上下文（用户不可访问）</p>
<p>用户栈、保护页<code>guard page</code>、各逻辑段</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批处理系统升级：加载应用进入内存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_num_app</span></span>() -&gt; <span class="built_in">usize</span> &#123;&#125; <span class="comment">// 获取程序数量</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_app_data</span></span>(app_id: <span class="built_in">usize</span>) -&gt; &amp;<span class="symbol">'static</span> [<span class="built_in">u8</span>] &#123;&#125; <span class="comment">// 获得某个应用的全部数据</span></span><br></pre></td></tr></table></figure>



<p><strong>基于空间地址的分时多任务</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; <span class="comment">// 内核地址全局实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123; <span class="comment">// trap上下文</span></span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="comment">// 以下为新增字段，在初始化时写入，便于保存完成寄存器后切换</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="built_in">usize</span>, <span class="comment">// 本来sp指向用户栈，sscratch指向内核栈，交换后在内核栈中保存上下文；但现在由于要更新页表寄存器不够，sscratch指向用户空间中trap上下文处保存，然后根据保存的内存栈顶直接更改sp</span></span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="number">3</span><span class="keyword">impl</span> TrapContext &#123;</span><br><span class="line"> <span class="number">4</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_sp</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="built_in">usize</span>) &#123; &#125;</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>( entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>, kernel_satp: <span class="built_in">usize</span>, kernel_sp: <span class="built_in">usize</span>, trap_handler: <span class="built_in">usize</span> ) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 从任务上下文中初始化trap上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>跳板就是执行<code>trap</code>时保存上下文的汇编代码<code>_alltraps</code>和<code>_restore</code>，由于其在内核与应用地址空间的位置相同，所以无论哪种页表都可以在同一位置访问</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务上下文</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet, <span class="comment">// 应用地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用trap上下文的实际物理页帧</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>, <span class="comment">// 应用地址空间大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>], app_id: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_trap_cx</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> TrapContext &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局应用管理器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskManagerInner</span></span> &#123;</span><br><span class="line">    tasks: <span class="built_in">Vec</span>&lt;TaskControlBlock&gt;,</span><br><span class="line">    current_task: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: TaskManager = &#123;&#125;; <span class="comment">// 初始化时根据loader提供的app数量和ELF文件来初始化所有任务上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>新增系统调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 功能：当前进程 fork 出来一个子进程。</span></span><br><span class="line"><span class="comment">/// 返回值：对于子进程返回 0，对于当前进程则返回子进程的 PID 。</span></span><br><span class="line"><span class="comment">/// syscall ID：220</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：当前进程等待一个子进程变为僵尸进程，回收其全部资源并收集其返回值。</span></span><br><span class="line"><span class="comment">/// 参数：pid 表示要等待的子进程的进程 ID，如果为 -1 的话表示等待任意一个子进程；</span></span><br><span class="line"><span class="comment">/// exit_code 表示保存子进程返回值的地址，如果这个地址为 0 的话表示不必保存。</span></span><br><span class="line"><span class="comment">/// 返回值：如果要等待的子进程不存在则返回 -1；否则如果要等待的子进程均未结束则返回 -2；</span></span><br><span class="line"><span class="comment">/// 否则返回结束的子进程的进程 ID。</span></span><br><span class="line"><span class="comment">/// syscall ID：260</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waitpid</span></span>(pid: <span class="built_in">isize</span>, exit_code: *<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：将当前进程的地址空间清空并加载一个特定的可执行文件，返回用户态后开始它的执行。</span></span><br><span class="line"><span class="comment">/// 参数：path 给出了要加载的可执行文件的名字；</span></span><br><span class="line"><span class="comment">/// 返回值：如果出错的话（如找不到名字相符的可执行文件）则返回 -1，否则不应该返回。</span></span><br><span class="line"><span class="comment">/// syscall ID：221</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：从文件中读取一段内容到缓冲区。</span></span><br><span class="line"><span class="comment">/// 参数：fd 是待读取文件的文件描述符，切片 buffer 则给出缓冲区。</span></span><br><span class="line"><span class="comment">/// 返回值：如果出现了错误则返回 -1，否则返回实际读到的字节数。</span></span><br><span class="line"><span class="comment">/// syscall ID：63</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buffer: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; <span class="built_in">isize</span>;</span><br></pre></td></tr></table></figure>

<p>在用户级中，在最最开始（即在<code>main</code>函数中）会初始化一个<code>initproc</code>用户初始进程，</p>
<p>其只会初始化一个<code>shell</code>进程，之后就持续循环+时间片轮转来回收进程（注：所有父进程被回收的进程都会变成其子进程）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于应用名的应用加载器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ref</span> APP_NAMES: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_app_data_by_name</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="symbol">'static</span> [<span class="built_in">u8</span>]&gt; <span class="comment">// 根据名字查找ELF数据</span></span><br></pre></td></tr></table></figure>



<p>进程标识符</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程标识符PID</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PidHandle</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> PidHandle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; <span class="comment">// 自动回收</span></span><br><span class="line">        PID_ALLOCATOR.exclusive_access().dealloc(<span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程分配器，类似于FrameAllocator</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PidAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>, <span class="comment">// 当前已分配到多少</span></span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PidAllocator &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// current为0，数组为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; PidHandle &#123; <span class="comment">// 分配一个新的PIDHandle(其他啥也没有)，优先从回收中选取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, pid: <span class="built_in">usize</span>) &#123; <span class="comment">// 在PID已分配、未回收的情况下丢进回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ref</span> PID_ALLOCATOR : UPSafeCell&lt;PidAllocator&gt; <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure>



<p>内核栈</p>
<p>原本每个程序一个，固定大小按程序顺序排列，中间穿插守护页防止溢出</p>
<p>现在将应用编号替换为进程标识符<code>PTD</code>，在内核栈中保存</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KernelStack</span></span> &#123;</span><br><span class="line">    pid: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> KernelStack &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(pid_handle: &amp;PidHandle) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 为一个已分配的进程标识符生成内核栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_on_top</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, value: T) -&gt; *<span class="keyword">mut</span> T <span class="keyword">where</span></span><br><span class="line">        T: <span class="built_in">Sized</span>, &#123; <span class="comment">// 将一个类型为 T 的变量压入内核栈顶并返回其裸指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_top</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获取当前内核栈顶在内核地址空间中的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> KernelStack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_stack_position</span></span>(app_id: <span class="built_in">usize</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line"> <span class="comment">// 得到pid进程内核栈的起始/终止虚拟地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进程控制块</strong></p>
<p>之前的<code>TaskControlBlock</code>分离为</p>
<p><code>Processor</code>处理器管理结构：管理CPU正在运行的任务</p>
<p><code>TaskManager</code>任务管理器：管理未在运行的所有任务</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123; <span class="comment">// 不可变</span></span><br><span class="line">    <span class="comment">// 不可变</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    <span class="keyword">pub</span> kernel_stack: KernelStack,</span><br><span class="line">    <span class="comment">// 可变</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">inner_exclusive_access</span></span>(&amp;<span class="keyword">self</span>) -&gt; RefMut&lt;<span class="symbol">'_</span>, TaskControlBlockInner&gt; &#123; <span class="comment">// 内层 TaskControlBlockInner 的可变引用</span></span><br><span class="line">        <span class="keyword">self</span>.inner.exclusive_access() </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">getpid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pid.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;...&#125; <span class="comment">// 仅用于内核中手动创建唯一一个初始进程 initproc</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;...&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;TaskControlBlock&gt;) -&gt; Arc&lt;TaskControlBlock&gt; &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用地址空间中的 Trap 上下文被放在的物理页帧的物理页号</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>, <span class="comment">// 应用数据仅有可能出现在应用地址空间低于 base_size 字节的区域中</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 暂停的任务的任务上下文</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 当前进程的执行状态</span></span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet, <span class="comment">// 应用地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="built_in">Option</span>&lt;Weak&lt;TaskControlBlock&gt;&gt;, <span class="comment">// Arc的非拥有引用，可访问但不拥有</span></span><br><span class="line">    <span class="keyword">pub</span> children: <span class="built_in">Vec</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 多个Arc拥有一个不可变值，计数为0时才释放</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlockInner &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_trap_cx</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">        <span class="keyword">self</span>.trap_cx_ppn.get_mut()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_user_token</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.memory_set.token()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_status</span></span>(&amp;<span class="keyword">self</span>) -&gt; TaskStatus &#123;</span><br><span class="line">        <span class="keyword">self</span>.task_status</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_zombie</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.get_status() == TaskStatus::Zombie</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务管理器与处理器管理器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 双端队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 新建一个空任务表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;) &#123; <span class="comment">// 在末尾新增一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123; <span class="comment">// 从开头拿取一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器管理结构</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Processor</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    idle_task_cx: TaskContext, <span class="comment">// 当前处理器上的 idle 控制流的任务上下文（调度器上下文）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Processor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 初始化为None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_current</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 取出当前正在执行的任务</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">current</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回当前执行的任务的一份拷贝，可以用于获得token/trap_cx等等</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_idle_task_cx_ptr</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; *<span class="keyword">mut</span> TaskContext &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取当前处理器上的 idle 控制流的任务上下文指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> PROCESSOR: UPSafeCell&lt;Processor&gt; <span class="comment">// 单核只创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程转换</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run_tasks</span></span>() &#123; <span class="comment">// 负责在taskManager中获取要执行的任务并执行</span></span><br><span class="line">&#125; <span class="comment">// 持续循环，只要进程让出CPU回到调度器中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">schedule</span></span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">&#125; <span class="comment">// 在进程交出控制权后，用于回到run_tasks()执行循环中的函数</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>将<code>Processer</code>的任务上下文分离并且单独存储，是为了把调度和存储分离开，并无其他意义</li>
<li><code>Processer</code>由内核中的结构体和上下文组成，相当于一个没有进程控制块的进程来用于调度</li>
</ul>
<p><strong>进程机制实现</strong></p>
<ul>
<li>创建初始进程：创建第一个用户态进程 <code>initproc</code>；</li>
<li>进程调度机制：当进程主动调用 <code>sys_yield</code> 交出 CPU 使用权或者内核把本轮分配的时间片用尽的进程换出且换入下一个进程；</li>
<li>进程生成机制：进程相关的两个重要系统调用 <code>sys_fork/sys_exec</code> 的实现；</li>
<li>进程资源回收机制：当进程调用 <code>sys_exit</code> 正常退出或者出错被内核终止之后如何保存其退出码，其父进程通过 <code>sys_waitpid</code> 系统调用收集该进程的信息并回收其资源。</li>
<li>字符输入机制：为了支持shell程序-user_shell获得字符输入，介绍 <code>sys_read</code> 系统调用的实现；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建初始进程</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> INITPROC: Arc&lt;TaskControlBlock&gt; <span class="comment">// 懒加载全局的initproc进程控制块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_initproc</span></span>() &#123; <span class="comment">// 在taskManager中加入initproc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程调度机制</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">suspend_current_and_run_next</span></span>() &#123;</span><br><span class="line">&#125; <span class="comment">// Process::取出当前执行的任务，修改状态为Ready后放入taskmanager末尾；然后schedule触发调度并切换任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程生成机制</span></span><br><span class="line"><span class="keyword">impl</span> MapArea &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_another</span></span>(another: &amp;MapArea) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 创建一模一样的结构体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_existed_user</span></span>(user_space: &amp;MemorySet) -&gt; MemorySet &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建一模一样的结构体，并且物理地址按页复制数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;TaskControlBlock&gt;) -&gt; Arc&lt;TaskControlBlock&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 与new类似，不过不是从ELF中获取信息而是从memory_set复制后获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 完全复制任务控制块，但是物理页帧不能直接复制，而且新的线程trap_cx中的a[0]（返回值寄存器）要改成0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;</span><br><span class="line">    &#125; <span class="comment">// 从一个ELF文件中获得Memory全部当前memory_set，然后更改控制块中信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_str</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 传递给调用的只有要执行的应用的名称字符串的起始地址，要以此在内存中查询得到整个字符串</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程退出机制</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exit</span></span>(exit_code: <span class="built_in">i32</span>) -&gt; ! &#123;</span><br><span class="line">&#125; <span class="comment">// 调用exit_current_and_run_next()</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exit_current_and_run_next</span></span>(exit_code: <span class="built_in">i32</span>) &#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waitpid</span></span>(pid: <span class="built_in">isize</span>, exit_code_ptr: *<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 等待某个子进程退出，返回它的 pid，并把它的退出码写到指定地址</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(exit_code: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 调用sys_waitpid，成功则返回退出码；失败（返回-2）则yield继续等待</span></span><br></pre></td></tr></table></figure>

<p>在执行<code>exit_current_and_run_next(exit_code: i32)</code>时</p>
<ul>
<li>修改当前进程控制块的状态为<code>TaskStatus::Zombie</code> 即僵尸进程</li>
<li>将退出码传入控制块等待父进程收集</li>
<li>将所有子进程挂载在<code>initproc</code>下面</li>
<li>对当前进程早期回收（回收<code>Memory_set</code>中的<code>areas</code>即数据页，不回收<code>pagetable</code>即页表页）</li>
</ul>
<p><strong>user_shell读入机制</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 仅支持从标准输入 FD_STDIN 即文件描述符 0 读入，且单次读入的长度限制为 1</span></span><br></pre></td></tr></table></figure>







<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><strong>文件与文件描述符</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件接口：只要实现了这个接口，就是文件</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">File</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户缓冲区：用户进程在系统调用的时候传给内核的地址空间（以内核为中转，用户缓冲区 &lt;=&gt; 文件）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_byte_buffer</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">UserBuffer</span></span> &#123; <span class="comment">// 将t_b_b中的切片进一步包装，即几页数据的数组</span></span><br><span class="line">    <span class="keyword">pub</span> buffers: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> UserBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(buffers: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 传入数据来新建缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">len</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获得总字节数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准输入/输出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stdin</span></span>;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Stdin &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区只能为一个字节大小，循环读取标准输入中的char，读取到则跳出循环写入缓冲区，未读取到则挂起继续循环，返回1 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, _user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123; </span><br><span class="line">    &#125; <span class="comment">// 直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stdout</span></span>;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Stdout &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, _user_buf: UserBuffer) -&gt; <span class="built_in">usize</span>&#123;</span><br><span class="line">    &#125; <span class="comment">// 直接panic</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区无大小限制，读出数据并print!,返回缓冲区字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件描述符：（文件描述符首先是一个非负整数）对于某一个进程，代表了其打开的一个文件对象，在要对文件进行操作时传入该整数即可（由内核来分配和记录，因为所有文件都在内核中）</p>
<p>文件描述符表：每个进程都有，记录所有其打开且可读写的文件集合（可以以表的下标作为描述符）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">	……</span><br><span class="line">    <span class="keyword">pub</span> fd_table: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 建立新的TCB时要创建三个fd_table: </span></span><br><span class="line">    <span class="comment">// vec！[Some(Arc::new(Stdin)),Some(Arc::new(Stdout)),Some(Arc::new(Stdout))] 0，1，2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的数据结构：</p>
<ul>
<li><p><code>Vec</code> 无需设置一个固定的文件描述符数量上限；</p>
</li>
<li><p><code>Option</code> 区分一个文件描述符当前是否空闲：当它是 <code>None</code> 的时候是空闲的，而 <code>Some</code> 则代表它已被占用；</p>
</li>
<li><p><code>Arc</code> 提供了共享引用能力：可能会有多个进程共享同一个文件对它进行读写；</p>
<pre><code>被它包裹的内容会被放到内核堆而不是栈上，不需要在编译期有确定的大小</code></pre></li>
<li><p><code>dyn</code> 关键字表明 <code>Arc</code> 里面的类型实现了 <code>File/Send/Sync</code> 三个 Trait ，</p>
<pre><code>编译期无法知道它具体是哪个类型需要等到运行时才能知道它的具体类型。</code></pre></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_write</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁使用write/read访问当前进程符表中标识符（下标）为fd的文件，返回值为w/r的返回值</span></span><br></pre></td></tr></table></figure>



<p><strong>文件系统接口</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开/读写的系统调用</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sys_openat</span></span>(dirfd: <span class="built_in">usize</span>, path: &amp;<span class="built_in">str</span>, flags: <span class="built_in">u32</span>, mode: <span class="built_in">u32</span>) -&gt; <span class="built_in">isize</span> </span><br><span class="line"><span class="comment">// 打开文件并返回描述符，否则返回-1；dirfd/mode无视；path为文件名；flags描述打开文件的标志</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpenFlags</span></span>: <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> RDONLY = <span class="number">0</span>; <span class="comment">// 只读</span></span><br><span class="line">        <span class="keyword">const</span> WRONLY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 只写</span></span><br><span class="line">        <span class="keyword">const</span> RDWR = <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// 可读写</span></span><br><span class="line">        <span class="keyword">const</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>; <span class="comment">// 在找不到时允许创建</span></span><br><span class="line">        <span class="keyword">const</span> TRUNC = <span class="number">1</span> &lt;&lt; <span class="number">10</span>; <span class="comment">// 打开时清空文件并将大小归零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>简易文件系统</strong></p>
<ul>
<li><code>easy-fs</code> 是简易文件系统的本体</li>
<li><code>easy-fs-fuse</code> 是能在开发环境（如 Ubuntu）中运行的应用程序，用于将应用打包为 easy-fs 格式的文件系统镜像，也可以用来对 <code>easy-fs</code> 进行测试</li>
</ul>
<p>文件系统层次化（共分为五层，上层可以调用下层的接口）：</p>
<p>1、磁盘块设备接口层：以块为单位对磁盘块设备进行读写的 trait 接口</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">BlockDevice</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> + Any &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]); <span class="comment">// 将编号为 block_id 的块从磁盘读入内存中的缓冲区 buf</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]); <span class="comment">// 将内存中的缓冲区 buf 中的数据写入磁盘编号为 block_id 的块</span></span><br><span class="line">&#125; <span class="comment">// 以实现了该特征的结构体为磁盘外设的模拟，在实现该特征时写入真正对硬件的操作</span></span><br></pre></td></tr></table></figure>

<p>2、块缓存层：在内存中缓存磁盘块的数据，避免频繁读写磁盘</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块缓存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> BLOCK_SZ: <span class="built_in">usize</span> = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ], <span class="comment">// 512字节数组，内存中的缓冲区</span></span><br><span class="line">    block_id: <span class="built_in">usize</span>, <span class="comment">// 这个块的编号</span></span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;, <span class="comment">// 块所属的底层设备</span></span><br><span class="line">    modified: <span class="built_in">bool</span>, <span class="comment">// 从磁盘进入内存后是否被修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(block_id: <span class="built_in">usize</span>, block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 新建时从某个磁盘中读入一个块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">addr_of_offset</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获得cache中偏移量offset的地址</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_ref</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; &amp;T <span class="keyword">where</span> T: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取缓冲区中偏移量为offset的一个T类型值的不可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut</span></span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; &amp;<span class="keyword">mut</span> T <span class="keyword">where</span> T: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>&lt;T, V&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;T) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125; <span class="comment">// 把闭包函数传入这个函数，在这个函数里面调用闭包直接返回其返回值，unsafe的T指针就不会给出去</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">modify</span></span>&lt;T, V&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset:<span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> T) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区被回收，由modified决定是否写回磁盘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块缓存全局管理器：一个磁盘拥有一个</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCacheManager</span></span> &#123;</span><br><span class="line">    queue: VecDeque&lt;(<span class="built_in">usize</span>, Arc&lt;Mutex&lt;BlockCache&gt;&gt;)&gt;, <span class="comment">// 共享引用&amp;互斥访问 磁盘块编号&amp;块缓存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCacheManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_cache</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,block_id: <span class="built_in">usize</span>,block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,) -&gt; Arc&lt;Mutex&lt;BlockCache&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果这里存储了block_id的块则返回其副本，没找到且队列未满则新建并插入返回，已满则丢出去未被使用（引用计数为1）的第一个块然后插入返回，否则panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、磁盘数据结构层：磁盘上的超级块、位图、索引节点、数据块、目录项等核心数据结构和相关处理</p>
<p>easy-fs 磁盘按照块编号从小到大顺序分成 5 个连续区域：</p>
<ul>
<li>第一个区域只包括一个块，它是超级块，用于定位其他连续区域的位置，检查文件系统合法性</li>
<li>第二个区域是一个索引节点位图，长度为若干个块：记录索引节点区域中有哪些索引节点已经被分配出去使用了(每个<code>bit</code>表示一个节点)</li>
<li>第三个区域是索引节点区域，长度为若干个块，其中的每个块都存储了若干个索引节点（每个节点描述一个“文件”/“目录”）</li>
<li>第四个区域是一个数据块位图，长度为若干个块：记录后面的数据块区域中有哪些已经被分配出去使用</li>
<li>最后的区域则是数据块区域：每个被分配出去的块保存了文件或目录的具体内容</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个区域：超级块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span></span> &#123;</span><br><span class="line">    magic: <span class="built_in">u32</span>, <span class="comment">// 魔数：验证有效性</span></span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="built_in">u32</span>, <span class="comment">// 文件系统总块数</span></span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="built_in">u32</span>, <span class="comment">// 索引节点位图块数</span></span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="built_in">u32</span>, <span class="comment">// 索引节点区域块数</span></span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="built_in">u32</span>, <span class="comment">// 数据块位图区域块数</span></span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="built_in">u32</span>, <span class="comment">// 数据库区域块数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> SuperBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">initialize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, total_blocks: <span class="built_in">u32</span>, inode_bitmap_blocks: <span class="built_in">u32</span>, inode_area_blocks: <span class="built_in">u32</span>, data_bitmap_blocks: <span class="built_in">u32</span>, data_area_blocks: <span class="built_in">u32</span> ); <span class="comment">// 更上层初始化</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="comment">// 根据魔数判断合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二/四个区域：位图-索引节点 / 位图-数据块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitmap</span></span> &#123; <span class="comment">// 位图区域管理器：区域起始编号+块数</span></span><br><span class="line">    start_block_id: <span class="built_in">usize</span>,</span><br><span class="line">    blocks: <span class="built_in">usize</span>,</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BitmapBlock</span></span> = [<span class="built_in">u64</span>; <span class="number">64</span>]; <span class="comment">// 一个块数据（划分方便操作）</span></span><br><span class="line"><span class="keyword">const</span> BLOCK_BITS: <span class="built_in">usize</span> = BLOCK_SZ * <span class="number">8</span>; <span class="comment">// 一个块中有多少个bit</span></span><br><span class="line"><span class="keyword">impl</span> Bitmap &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 遍历Bitmap中每个块，再遍历这个块中的每一个[u64]找到第一个为 0 的位置，该位置置1，返回该位的位置（在位图中的第n个比特位），以此作为分配的索引节点/数据块的编号；否则返回None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个区域：索引节点（包含文件/目录的元数据，以下仅写“文件”）</span></span><br><span class="line"><span class="keyword">const</span> INODE_DIRECT_COUNT: <span class="built_in">usize</span> = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>, <span class="comment">// 文件内容的字节数</span></span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT], <span class="comment">// 直接索引，数据块里是文件数据</span></span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>, <span class="comment">// 一级间接索引，该块上每一个u32指向一个文件数据块</span></span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>, <span class="comment">// 二级间接索引，该块上每一个指向一个一级间接索引</span></span><br><span class="line">    type_: DiskInodeType, <span class="comment">// 索引节点类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DiskInodeType</span></span> &#123;</span><br><span class="line">    File,</span><br><span class="line">    Directory,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> DiskInode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">initialize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, type_: DiskInodeType) &#123;</span><br><span class="line">    &#125; <span class="comment">// 一 / 二级索引全部置为0</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_dir</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_file</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="comment">// 确定文件类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_id</span></span>(&amp;<span class="keyword">self</span>, inner_id: <span class="built_in">u32</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 获得索引中的第inner_id数据块的block_id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">data_blocks</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 返回文件内容字节数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">_data_blocks</span></span>(size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 容纳size个字节需要多少数据块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">total_blocks</span></span>(size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 返回文件块+索引块数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">blocks_num_needed</span></span>(&amp;<span class="keyword">self</span>, new_size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 扩容到new_size个字节需要新增多少数据块</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">increase_size</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: <span class="built_in">u32</span>, new_blocks: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;);</span><br><span class="line">    <span class="comment">// 扩容函数，size为扩容后大小，blocks为扩容所需块编号（由上层分配）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clear_size</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;; <span class="comment">//清空文件并且回收数据块</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>], block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">usize</span> &#123; </span><br><span class="line">    &#125; <span class="comment">// 将文件内容从 offset 字节开始的部分读到内存中的缓冲区 buf 中，返回读到字节数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_at</span></span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目录项结构（文件项无结构）</span></span><br><span class="line"><span class="keyword">const</span> NAME_LENGTH_LIMIT: <span class="built_in">usize</span> = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DirEntry</span></span> &#123; <span class="comment">// 该结构保存在数据块中</span></span><br><span class="line">    name: [<span class="built_in">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>], <span class="comment">// 这一级目录/这个文件的名字</span></span><br><span class="line">    inode_number: <span class="built_in">u32</span>, <span class="comment">// 这一级目录/这个文件的索引序号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DIRENT_SZ: <span class="built_in">usize</span> = <span class="number">32</span>; <span class="comment">// 每个数据块可以存储16个</span></span><br><span class="line"><span class="keyword">impl</span> DirEntry &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">empty</span></span>() -&gt; <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="built_in">str</span>, inode_number: <span class="built_in">u32</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">name</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">inode_number</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_bytes</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;[<span class="built_in">u8</span>] &#123; <span class="comment">// 为了符合read/write_at接口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_bytes_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、磁盘块管理器层：合并了上述核心数据结构和磁盘布局所形成的磁盘文件系统数据结构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个文件系统对应一个磁盘（分区）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EasyFileSystem</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap: Bitmap, <span class="comment">// 索引节点位图</span></span><br><span class="line">    <span class="keyword">pub</span> data_bitmap: Bitmap, <span class="comment">// 数据块位图</span></span><br><span class="line">    inode_area_start_block: <span class="built_in">u32</span>, <span class="comment">// 索引区域起始块编号</span></span><br><span class="line">    data_area_start_block: <span class="built_in">u32</span>, <span class="comment">// 数据块区域起始块编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;, total_blocks: <span class="built_in">u32</span>, inode_bitmap_blocks: <span class="built_in">u32</span>,) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 传入 总共的块数量/索引位图的块数量 规划好整个磁盘，创建新文件系统并清理内存</span></span><br><span class="line">      <span class="comment">// 同时初始化内存中的超级块、创建根目录</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open</span></span>(block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 从一个写入了easy-fs镜像（即按照该格式排布的数据块集合）的块设备block_device上打开文件系统</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_disk_inode_pos</span></span>(&amp;<span class="keyword">self</span>, inode_id: <span class="built_in">u32</span>) -&gt; (<span class="built_in">u32</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 根据索引的编号，返回它所在磁盘块编号block_id和块内偏移</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_data_block_id</span></span>(&amp;<span class="keyword">self</span>, data_block_id: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 得到某数据块的磁盘块编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_inode</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 分配一个索引返回其编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 分配一个数据块返回其磁盘块编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_id: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：只要知道了数据所在的具体磁盘块号和块内偏移，可以以任意结构体方式操作这一段数据<code>get_block_cache(block_id, device).lock().modify(offset, |变量名: &amp;mut 结构体| {})</code></p>
<p>5、索引节点层：管理索引节点，实现了文件创建/文件打开/文件读写等成员函数</p>
<p>便于直接看到目录树结构中逻辑上的文件和目录</p>
<ul>
<li><code>DiskInode</code> 放在磁盘块中比较固定的位置</li>
<li><code>Inode</code> 是放在内存中的记录文件索引节点信息的数据结构</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_offset: <span class="built_in">usize</span>, <span class="comment">// 前两个用于记录具体位置</span></span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;, <span class="comment">// 便于操作传参</span></span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化 get_block_cache.lock.read/modify 流程</span></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125; <span class="comment">// 读取数据并且用闭包f处理</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">modify_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> DiskInode) -&gt; V) -&gt; V &#123; <span class="comment">// 读取可修改数据并且用闭包f处理（都是更改索引节点 DiskInode 的值）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">root_inode</span></span>(efs: &amp;Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt;) -&gt; Inode &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取根目录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(block_id: <span class="built_in">u32</span>, block_offset: <span class="built_in">usize</span>, fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;, block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建</span></span><br><span class="line">    <span class="comment">// 文件索引（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">find</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回本索引指向的目录下名称为name的文件的索引的新建Inode</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_inode_id</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>, disk_inode: &amp;DiskInode) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; &#123; <span class="comment">// 找到传入的索引节点指向的目录下名称为name的文件的索引序号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件列举（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ls</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回该目录下所有文件的文件名的数组</span></span><br><span class="line">    <span class="comment">// 文件创建（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建新的文件并返回其Inode，若存在则返回None</span></span><br><span class="line">    <span class="comment">// 文件清空</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clear</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 以某些方式打开时需要先传入文件Inode清空</span></span><br><span class="line">    <span class="comment">// 文件读写</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 从offset偏移处开始读</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 注意：在写之前需要先扩容为offset+buf.len()容量</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">increase_size</span></span>(&amp;<span class="keyword">self</span>, new_size: <span class="built_in">u32</span>, disk_inode: &amp;<span class="keyword">mut</span> DiskInode, fs: &amp;<span class="keyword">mut</span> MutexGuard&lt;EasyFileSystem&gt;) &#123;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内核中的easy-fs</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内核块设备实例</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BlockDeviceImpl</span></span> = virtio_blk::VirtIOBlock; <span class="comment">// 一个实现了BlockDevice类特征的结构体</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> BLOCK_DEVICE: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt; = Arc::new(BlockDeviceImpl::new());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核索引节点层</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInode</span></span> &#123; <span class="comment">// 表示进程中一个被打开的常规文件或目录</span></span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    inner: UPSafeCell&lt;OSInodeInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInodeInner</span></span> &#123;</span><br><span class="line">    offset: <span class="built_in">usize</span>, <span class="comment">// 读写过程中的偏移量</span></span><br><span class="line">    inode: Arc&lt;Inode&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> OSInode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="keyword">self</span>.readable &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="keyword">self</span>.writable &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 直接使用inode的read/write_at</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核文件系统实现</span></span><br><span class="line"><span class="comment">// 文件系统初始化</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">    &#125;; <span class="comment">// 打开efs并且获取根目录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpenFlags</span></span>: <span class="built_in">u32</span> &#123; <span class="comment">// 打开文件的方式</span></span><br><span class="line">        <span class="keyword">const</span> RDONLY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> WRONLY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> RDWR = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">const</span> TRUNC = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> OpenFlags &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_write</span></span>(&amp;<span class="keyword">self</span>) -&gt; (<span class="built_in">bool</span>, <span class="built_in">bool</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回（可读，可写）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open_file</span></span>(name: &amp;<span class="built_in">str</span>, flags: OpenFlags) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;OSInode&gt;&gt; &#123;</span><br><span class="line">&#125; <span class="comment">// 根据flags的要求打开文件并且返回inode</span></span><br></pre></td></tr></table></figure>



<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><strong>管道</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用：为当前进程打开一个管道（包含一个只读、一个只写文件）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_pipe</span></span>(pipe: *<span class="keyword">mut</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>;<span class="comment">// pipe:应用地址空间中一个长度为2的usize数组的起始地址，内核负责讲管道读端、写端的文件描述符写入</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_close</span></span>(fd: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>; <span class="comment">// 关闭一个文件</span></span><br></pre></td></tr></table></figure>

<p>基于文件的管道</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道的一端（读/写）：会实现File特征，作为文件访问</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span></span> &#123;</span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Pipe &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_end_with_buffer</span></span>(buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;) -&gt; <span class="keyword">Self</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_end_with_buffer</span></span>(buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 根据一个已有的管道创建其读端和写端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Pipe &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 从文件中最多读取应用缓冲区大小那么多字符：如果文件中没有字符且没有写端则返回，否则任务挂起</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RingBufferStatus</span></span> &#123; FULL, EMPTY, NORMAL &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PipeRingBuffer</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">u8</span>; RING_BUFFER_SIZE],</span><br><span class="line">    head: <span class="built_in">usize</span>,</span><br><span class="line">    tail: <span class="built_in">usize</span>, <span class="comment">// 维护循环队列</span></span><br><span class="line">    status: RingBufferStatus, <span class="comment">// 缓冲区状态</span></span><br><span class="line">    write_end: <span class="built_in">Option</span>&lt;Weak&lt;Pipe&gt;&gt;, <span class="comment">// 写端的弱引用计数，来确认是否还有写端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 全部置为0，写端置为None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_write_end</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, write_end: &amp;Arc&lt;Pipe&gt;) &#123; </span><br><span class="line">    &#125; <span class="comment">// 保留其写端的弱引用计数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_byte</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 读取管道中的一个字节，并且更新队头（如果与队尾重合则改为empty）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">available_read</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 计算管道中还有多少个字节可以读取</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">all_write_ends_closed</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 判断管道的所有写端是不是都被关闭了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">make_pipe</span></span>() -&gt; (Arc&lt;Pipe&gt;, Arc&lt;Pipe&gt;) &#123; <span class="comment">// 创建一个管道并返回其读写端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlockInner &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_fd</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 在进程控制块中分配一个最小的空闲文件描述符来访问新打开的文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>命令行参数与标准I/O重定向</strong></p>
<p>命令行参数</p>
<p>在user_shell中读取一行后，根据空格分隔成<code>Vec&lt;String&gt;</code>，然后手动在每个字符串后面加上<code>\0</code>，在最后加上<code>0 as *const u8</code>，将字符串数组的起始地址传入<code>sys_exec()</code>内核调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用更新</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>, <span class="keyword">mut</span> args: *<span class="keyword">const</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 依次转换地址并取出参数，在调用TCB::exec时传入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">     <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>], args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) &#123;</span><br><span class="line">    &#125; <span class="comment">// 在从ELF文件创建进程后把参数压入用户栈（此时用户栈为空）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据TCB创建时从ELF中读出来的内容，所有进程第一次进入用户态都是从<code>_start</code>进入：这个函数会依次取出命令行参数并且放入一个数组中</p>
<p>标准输入输出重定向</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用：将进程中一个已经打开的文件复制一份并分配到一个新的文件描述符中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_dup</span></span>(fd: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>; <span class="comment">//（在符表中分配一个新的描述符指向一个复制）</span></span><br></pre></td></tr></table></figure>

<p>在用户态的<code>user_shell</code>程序中，要检查是否存在通过<code>&lt;</code>/<code>&gt;</code>进行输入输出重定向：</p>
<p>存在则移除，并记录输入/输出的文件名并打开；</p>
<p>这时候关掉<code>0/1</code>的文件描述符，给打开的文件<code>dup</code>一个新的，由于<code>alloc_fd()</code>一定会分配最小的可用文件描述符（先扫描符表中有无可用的，再push一个），所以这个文件就可以顶替掉<code>0/1</code></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li>存在线程前：进程是程序的基本执行实体，是程序关于某数据集合上的一次运行活动，是            系统进行资源（处理器、 地址空间和文件等）分配和调度的基本单位。</li>
<li>存在线程后：进程是线程的资源容器， 线程成为了程序的基本执行实体。</li>
</ul>
<p><strong>并发相关术语</strong></p>
<ul>
<li>共享资源（shared resource）：不同的线程/进程都能访问的变量或数据结构。</li>
<li>临界区（critical section）：访问共享资源的一段代码。</li>
<li>竞态条件（race condition）：多个线程/进程都进入临界区时，都试图更新共享的数据结构，导致产生了不期望的结果。</li>
<li>不确定性（indeterminate）： 多个线程/进程在执行过程中出现了竞态条件，导致执行结果取决于哪些线程在何时运行， 即执行结果不确定，而开发者期望得到的是确定的结果。</li>
<li>互斥（mutual exclusion）：一种操作原语，能保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的执行结果。</li>
<li>原子性（atomic）：一系列操作要么全部完成，要么一个都没执行，不会看到中间状态。在数据库领域， 具有原子性的一系列操作称为事务（transaction）。</li>
<li>同步（synchronization）：多个并发执行的进程/线程在一些关键点上需要互相等待，这种相互制约的等待称为进程/线程同步。</li>
<li>死锁（dead lock）：一个线程/进程集合里面的每个线程/进程都在等待只能由这个集合中的其他一个线程/进程 （包括他自身）才能引发的事件，这种情况就是死锁。</li>
<li>饥饿（hungry）：指一个可运行的线程/进程尽管能继续执行，但由于操作系统的调度而被无限期地忽视，导致不能执行的情况。</li>
</ul>
<p><strong>线程</strong>（一个进程在一个时刻有多个执行点）</p>
<ul>
<li>程序计数器寄存器来记录当前的执行位置</li>
<li>一组通用寄存器记录当前的指令的操作数据</li>
<li>一个栈来保存线程执行过程的函数调用栈和局部变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_thread_create</span></span>(entry: <span class="built_in">usize</span>, arg: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> </span><br><span class="line"><span class="comment">// 创建新的线程（entry:入口函数地址， arg:参数）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waittid</span></span>(tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line"><span class="comment">// 等待线程结束：进程/主线程回收资源（tid:线程id，由主线程调用）</span></span><br></pre></td></tr></table></figure>

<p>线程管理由进程而来</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="keyword">pub</span> kernel_stack: KernelStack,</span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;, <span class="comment">// 可变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用地址空间中线程的 Trap 上下文被放在的物理页帧的物理页号</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 暂停线程的线程上下文，用于线程切换</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 当前线程的执行状态</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;, <span class="comment">// 线程退出码</span></span><br><span class="line">    <span class="keyword">pub</span> res: <span class="built_in">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskUserRes</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> tid: <span class="built_in">usize</span>, <span class="comment">// 线程标识符</span></span><br><span class="line">    <span class="keyword">pub</span> ustack_base: <span class="built_in">usize</span>, <span class="comment">// 线程栈顶</span></span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;, <span class="comment">// 所属进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>进程控制块</code></pre><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> tasks: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> task_res_allocator: RecycleAllocator,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>锁</strong></p>
<p>相关数据结构：使用锁来包裹共享资源</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> mutex_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt;&gt;, <span class="comment">// 进程可能存在多个互斥资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Mutex</span></span>: <span class="built_in">Sync</span> + <span class="built_in">Send</span> &#123; <span class="comment">// 互斥锁特征</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MutexBlocking</span></span> &#123; <span class="comment">// 实现互斥锁特征的结构</span></span><br><span class="line">    inner: UPSafeCell&lt;MutexBlockingInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MutexBlockingInner</span></span> &#123;</span><br><span class="line">    locked: <span class="built_in">bool</span>, <span class="comment">// 是否上锁</span></span><br><span class="line">    wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 上锁的等待队列 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关系统调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_create</span></span>(blocking: <span class="built_in">bool</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 创建一个新的锁：当前mutex_list是否有空位/锁的类型来创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_lock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 只负责调用当前线程的第id个锁的lock()方法</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果已经上锁则加入等待队列，否则上锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_unlock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;<span class="comment">// 只负责调用当前线程的第id个锁的unlock()方法</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果有等待的线程则唤醒，否则释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>信号量</strong>：适用于一个共享资源可以被有限个线程同时访问的情况（互斥锁即为N=1）</p>
<p>P操作：尝试进入，失败则阻塞</p>
<p>V操作：信号量的值+1，如果有线程等待则唤醒</p>
<p>（注意，以上两个操作都应该有原子性）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> semaphore_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Semaphore&gt;&gt;&gt;, <span class="comment">// 进程可能有多个信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Semaphore</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;SemaphoreInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SemaphoreInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> count: <span class="built_in">isize</span>, <span class="comment">// 信号量值（count &lt;= 0时代表有线程在等待）</span></span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 等待序列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Semaphore &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(res_count: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建新的信号量，置放初始信号值</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">up</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// V操作：count++, count &lt;= 0时从等待队列中取队头唤醒</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">down</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// P操作：count--, count &lt; 0时进入等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>条件变量</strong></p>
<p>线程在检查满足某一条件后才会执行（条件变量时一个线程等待队列）</p>
<p><code>wait</code>操作：释放锁 =&gt; 挂起自己 =&gt; 被唤醒后获取锁</p>
<p><code>signal</code>操作：找到挂在条件变量上面的线程并唤醒</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> condvar_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Condvar&gt;&gt;&gt;, <span class="comment">// 进程中的条件变量列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Condvar</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;CondvarInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CondvarInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 条件变量：等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Condvar &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建空的等待队列</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">signal</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 唤醒条件变量的等待队列的队头</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(&amp;<span class="keyword">self</span>, mutex:Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">    &#125; <span class="comment">// 释放互斥锁（线程在进入前获取），挂起当前进程，恢复后获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="ArceOS学习记录"><a href="#ArceOS学习记录" class="headerlink" title="ArceOS学习记录"></a>ArceOS学习记录</h1><p>第三阶段时间比较紧张，就只能写写测试写不了挑战题了</p>
<p><strong>第一部分<code>UniKernel</code></strong></p>
<p><code>print_with_color</code></p>
<p>在输出println宏的实现处加上标识颜色的<code>ASCⅡ</code>码即可，需要注意（本人踩过坑）的是如果不想引入<code>format!</code>来直接把颜色字符拼接进入要打印字符中而是分别打印，需要注意字符打印导致的换行问题，这个会导致后边测试脚本在读取数据时检测不通过的问题</p>
<p><code>support_hashmap</code></p>
<p>这个去网上查了一下资料，还以为有什么高级实现的方法</p>
<p>结果最后还是使用了最朴实无华的取模插入</p>
<p>果然所有的数据结构都很难想</p>
<p><code>alt_alloc</code></p>
<p>在怎么实现上还是纠结了挺久的，是存储字符数转化成页还是存储页转化成字符、如果有新加入的内存怎么在其中表示……后面不得不去找了一下，发现原来可以不支持新加入内存（）</p>
<p>其实还是学到了很多的，在上操作系统理论课的时候根本没有想过这些内存是由一个统一初始化的内存管理器来进行管理，就只是单纯的知道了一下页表是什么</p>
<p><strong>第二部分宏内核</strong></p>
<p><code>sys_mmap</code></p>
<p>难度还可以，好像在这里没有花很久时间</p>
<p><code>ramfs_rename</code></p>
<p>因为没有什么大项目的经验导致对依赖很不敏感，在实现了之后一直进入不了我想用的DirNode的trait里面</p>
<p>后面不断调试才终于在偶然中发现如果不在根目录的<code>cargo.toml</code>中使用patch的话需要改两个cargo.toml</p>
<p><strong>第三部分<code>Hypervisor</code></strong></p>
<p><code>simple_hv</code></p>
<p>这个其实挺简单的，但是卡了我很久很久。遇到的问题是我在一开始就触发不了<code>panic</code>程序会直接卡死，然后依然是不断通过打印去定位错误，竟然发现卡死在了<code>_run_guest</code>的汇编代码里面，就硬着头皮去看汇编。还是一直发现不了卡死的原因……</p>
<p>总之就是试了很久，分析<code>qemu</code>的日志才发现是<code>store_page_fault</code>和时钟错误交替出现，拷打了一下AI之后才发现是没有</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/29/Lfan-ke%EF%BC%9AArceOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/29/Lfan-ke%EF%BC%9AArceOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">穿越操作系统的迷雾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-29 10:38:44" itemprop="dateCreated datePublished" datetime="2025-05-29T10:38:44+00:00">2025-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/" itemprop="url" rel="index"><span itemprop="name">ArceOS</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E4%B8%89/" itemprop="url" rel="index"><span itemprop="name">阶段三</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E4%B8%89/2025S/" itemprop="url" rel="index"><span itemprop="name">2025S</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ArceOS/%E9%98%B6%E6%AE%B5%E4%B8%89/2025S/%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">补完计划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lfan-ke：第三阶段总结报告"><a href="#Lfan-ke：第三阶段总结报告" class="headerlink" title="Lfan-ke：第三阶段总结报告"></a>Lfan-ke：第三阶段总结报告</h1><p>about-me: <a href="https://gitee.com/heke1228" target="_blank" rel="noopener">heke1228@gitee</a>, <a href="https://atomgit.com/heke1228" target="_blank" rel="noopener">heke1228@atom</a>, <a href="https://github.com/Lfan-ke" target="_blank" rel="noopener">Lfan-ke@github</a>, <a href="https://codeberg.org/heke1228" target="_blank" rel="noopener">heke1228@codeberg</a></p>
<h2 id="内核发展史"><a href="#内核发展史" class="headerlink" title="内核发展史"></a>内核发展史</h2><blockquote>
<p>很早很早以前~，并不区分应用与操作系统。所有功能都绑定在一起，负责开发的也是同一批人。某些底层功能被频繁复用，慢慢的常用功能形成了特定的模块，通过接口与其他模块交互。比如：储存模块就是一个大数组。那么，为什么不能把系统作为一个库呢？</p>
</blockquote>
<p>多道操作系统通过分时复用的方式在一台计算机上同时运行多个应用程序。但是出现了安全问题：如果每个应用都可以控制全局资源，如何保证不同应用之间的隔离？不会出现A想格式化，B想重启……所以必须限制应用不允许直接改变全局的系统状态。所以应用与系统分离，至少需要两种权限。</p>
<p>低权限的不允许改变全局系统状态，用来运行应用，高权限的集中运行能改变全局系统状态的操作（特权操作），分化出操作系统内核。</p>


<p>CPU对软件提供的接口：ISA - Instruction Set Architecture - 指令集架构 ：：： RV64、x86、mips、<a href="https://www.loongson.cn/system/loongarch" target="_blank" rel="noopener">LoongArch</a>等等。软硬件的分界线以及交互规范标准。</p>
<p><a href="https://riscv.org/" target="_blank" rel="noopener">RISC-V</a>指令集 = 基础指令集 + 标准扩展指令集 + 用户自定义扩展指令集，比如RV32IM就是RV32的拥有整数以及乘除法指令的配置。RV64GC的G是一个省略书写，实际GC = IMAFD + C。RV32E是一个16个寄存器的嵌入式精简指令集。在gcc编译时使用<a href="https://gcc.gnu.org/onlinedocs/gcc/RISC-V-Options.html" target="_blank" rel="noopener">march</a>指定。使用mabi指定应用程序二进制接口对应类型的字长，比如ilp指的是int/long/usize_t(void*ptr)为32位，lp64f指的是int32位，long/usize_t为64位，支持单精度浮点采用浮点寄存器传递，但是双精度浮点仍然采用栈传递（即硬件指令集得支持F/D扩展，不然你硬件只有整数寄存器，没有对应精度的浮点寄存器）。在未支持的扩展，比如RV64I中书写乘法，则会以软件替代的形式出现，比如使用循环和移位的函数<a href="https://gcc.gnu.org/onlinedocs/gcc-3.4.0/gccint/Integer-library-routines.html" target="_blank" rel="noopener">__mulsi3</a>来替代（当然，如果target=RVxIM但是运行在RVxI，M系指令也会通过trap的形式硬件兜底执行，但是效率低，其他扩展类似）。2020年，RISC-V发展的优先级从体系结构驱动切换为<a href="https://open-src-soc.org/2022-05/media/slides/RISC-V-International-Day-2022-05-05-11h05-Calista-Redmond.pdf" target="_blank" rel="noopener">软件</a>驱动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -o program.elf program.c</span><br><span class="line">riscv64-unknown-elf-g++ -march=rv64gc -mabi=lp64 -o program.elf program.cpp</span><br><span class="line">rustc --target=riscv32imac-unknown-none-elf -C target-feature=+m,+a,+c program.rs</span><br><span class="line">GOOS=linux GOARCH=riscv64 go build -o program program.go</span><br><span class="line">tinygo build -target=riscv32-unknown-elf -o program.elf program.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> cargo.toml：</span></span><br><span class="line">[build]</span><br><span class="line">target="riscv64gc-unknown-none-elf"</span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    "-C", "link-arg=-Tlink.x",              # 可选：自定义链接脚本</span><br><span class="line">    "-C", "target-feature=+m,+a,+f,+d,+c",  # 显式启用扩展</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>ISA包含：指令、寄存器等软件可见可操作的接口，从上到下切换的过程通常被称为陷入(trap)，比如S-sbicall-&gt;M/U-syscall-&gt;S/V&lt;-syscall-&gt;H都是ecall和trap。其中trap是由硬件监测的，比如检测到某些错误就陷入M-Mode：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> trap_detector (</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        clk,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        rst,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] current_pc,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] instruction,</span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        page_fault,         <span class="comment">// 页错误</span></span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        illegal_instr,      <span class="comment">// 非法指令</span></span><br><span class="line">    <span class="keyword">input</span>  <span class="keyword">logic</span>        timer_interrupt,    <span class="comment">// 定时器中断</span></span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]  trap_cause          <span class="comment">// 陷阱原因（scause 编码）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        trap_triggered = <span class="number">0</span>;</span><br><span class="line">        trap_cause     = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步异常检测 - 异常 - Exception</span></span><br><span class="line">        <span class="keyword">if</span> (xxx异常) <span class="keyword">begin</span></span><br><span class="line">            trap_triggered = <span class="number">1</span>;</span><br><span class="line">            trap_cause     = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步中断检测 - 中断 - Interrupt</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (计时器等等) <span class="keyword">begin</span></span><br><span class="line">            trap_triggered = <span class="number">1</span>;</span><br><span class="line">            trap_cause     = &#123;<span class="number">1'b1</span>, timer_interrupt ? <span class="number">3'd5</span> : <span class="number">3'd9</span>&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测到之后trap_handler触发硬件(trap)特权级切换，但是像跳板页是软件(ecall)特权级切换</span></span><br><span class="line"><span class="comment">// 补充：trap - riscv将ECF(异常控制流(Exceptional Control Flow))统称为trap</span></span><br><span class="line"><span class="comment">// 补充：无论是ecall还是trap，都是增删改部分csr与pc，处理结束后通常会逆增删改回到原位/+4</span></span><br><span class="line"><span class="comment">// 补充：ecall-U-&gt;S -&gt; crud: scause/sepc等等   ecall-S-&gt;M -&gt; crud: mcause/mepc等等   trap -&gt; crud: mcause/mepc等等</span></span><br><span class="line"><span class="comment">// 可以是硬件处理，也可以是软件处理，比如编写中断处理函数并将地址刷入中断向量表</span></span><br><span class="line"><span class="comment">// 主打一个硬件可以做的软件也可以做，软件可以做的硬件也可以做，软慢成本低，硬快成本高……</span></span><br></pre></td></tr></table></figure>

<p>操作系统在启动前需要先对部分寄存器赋予初值（初始化），以及传递设备等等硬件信息，这部分工作由SBI来完成。OS若需要M支持需要调用sbicall（比如操作定时器、关闭中断等等）。</p>
<p>定义底层固件与OS的接口：SBI - Supervisor Binary Interface - 监管层二进制接口 ：：： x86-UEFI/BIOS-Grub、RV-opensbi/rustsbi等等。</p>
<p>在SBI初始化结束，PC会被安置到OS的执行入口，开始操作系统初始化，比如开启页表、虚拟空间映射、启动第一个进程等等。比如RISC-V架构通常被放置在<code>0x8020_0000</code>。</p>
<p>操作系统：OS - 用来管理硬件资源并向上层应用提供统一的服务。除了最基础的存储、运行外，还有诸多如：网络、设备、显示等等扩展，以及：运行时环境、集成开发环境、基础库、编译工具链、编程语言、调试工具等等基础设施。</p>
<p>操作系统启动之后，如RISC-V架构，通常为三个特权级：MSU（虚拟化有五个，新增：VS VU，原S-&gt;HS）。用户程序运行在最上层。用户程序若需要S特权级支持需要调用syscall。基于操作系统的标准库，如GNUlibC，通常封装好了一部分syscall的便捷的调用方式，比如fork、printf -&gt; write -&gt; sys_write等等。</p>
<p>操作系统进行了内外两种演化：</p>
<ul>
<li>外部接口：POSIX接口演化、系统调用的增删改、分布式软总线（鸿蒙）等等</li>
<li>内部架构：宏、微、外、多，以及在扩展性安全性性能等等方面的改进</li>
</ul>


<p>宏内核：整个系统分为内核和应用两层，常见比如Linux的主体是宏内核。用户进程通过系统调用使用内核的各项功能。但是系统过于庞大。大量共享状态位于内核态。</p>
<p>微内核：最小化内核功能，将操作系统功能迁移到用户态，称之为”服务“，用户模块之间使用消息传递机制通信。常见比如：WinNT。WinNT实际上是混合内核，但其大部分功能采用微内核实现。共享数据状态部分在内核态，部分在用户态。</p>
<p>混内核：比如上述的WinNT以及MacOS/iOS，将需要性能的模块（线程调度、虚拟内存、IPC-进程间通信、图形子系统）放在内核态，扩展功能（文件系统、网络协议栈）放于用户态。</p>
<p>外核库：Exokernel不管理资源，只管理应用（计算资源、隔离等等），库OS则对硬件的抽象以库的形式提供，不通应用可以使用不通的LibOS。将管理与保护分离。</p>


<p>单内核：Unikernel（单/联内核），使用组件扩展操作系统的功能，在编译时确定系统组件。可看作虚拟化环境下的LibOS。应用与内核位于同一特权级。通过扩展，联内核可扩展为宏内核以及支持虚拟化。常见比如：ArceOS、Rumprun、Drawbridge、OSv等等。以及一个可以将Linux作为联内核的项目：<a href="[https://github.com/lkl](https://github.com/lkl)">LKL</a>。</p>
<p>多内核：又称：复内核。OS整体是一个分布式系统，应用程序仍然运行在OS之上。默认的状态是划分而非共享，显式的核间通信机制。支持设备（比如NPU/GPU等等）上的异构CPU。常见的如：Barrelfish、Popcorn Linux。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/05/29/Lfan-ke%EF%BC%9AArceOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/26/2025summercamp-%E5%AD%99%E5%AE%87%E8%88%AA-%E4%BA%8C%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/26/2025summercamp-%E5%AD%99%E5%AE%87%E8%88%AA-%E4%BA%8C%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2025summercamp 孙宇航-二三阶段总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-26 20:20:15" itemprop="dateCreated datePublished" datetime="2025-05-26T20:20:15+00:00">2025-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h1><p>这个阶段给我最大的感受是学习，因为很多函数都被事先书写好了，这几个实验基本都是在已有的框架上进行相关的函数调用即可，在明白每个函数的实现逻辑以及每个lab实验要实现的功能即可完成实验。同时这个阶段给我的感受是有许多深层次的知识仍需要学习，有许多一知半解的知识需要实践，看到学习群里面大家对于实验的讨论的诸多见解，受益匪浅，完完全全的拓宽了我的眼界，许多从未听过的名词出现在我的面前，只感到纸上得来终觉浅，绝知此事要躬行。可惜时间所迫，没办法对于每个lab实验进行进一步的深究。<br>第二阶段我重点理会到了操作系统的一步步发展以及实现的功能，在进行每个实验的时候，感受到学校里面的讲解十分片面，并且浅薄（也是我没有认真学习的缘故，学校里面的课检验的只有期末突击而已）。<br>非常重要的一点是这次的理论和实践一起进行，让我极大的认识到了抽象和具体之间的联系，有时候理论上很复杂并且难以理解的东西，转化到实践上面竟然可能只是一个数组，一个函数栈而已，这让欠缺实践的我大开眼界。<br>非常期待第三阶段带来的挑战，也非常希望可以通过第三阶段（哈哈哈）。</p>
<h1 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h1><p>这个阶段我做的十分仓促，并且没有详细做挑战题的内容，arceos组件化的设计思路让我受益匪浅，项目的设计理念和一些细节都要比rcore要好很多，也复杂很多。四阶段项目阶段我没有什么了解，只能希望自己可以投入进去，获得一些成果吧。<br>临近毕业，对于未来仍然十分迷茫，写下三阶段总结时，我刚刚完成我的本科毕业设计，对未来没有一个清晰的规划，没想到这么快就要毕业了。原计划我准备这个训练营和毕业一起做完，可惜并没有达成我原先的目标，最后一个月的时间，希望可以再接再厉吧，这可能也是我仅剩的校园时光了…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/26/%E5%90%84%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-yuanyiboyyb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/26/%E5%90%84%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-yuanyiboyyb/" class="post-title-link" itemprop="url">各阶段总结_yuanyiboyyb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-26 00:36:06" itemprop="dateCreated datePublished" datetime="2025-05-26T00:36:06+00:00">2025-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-02 11:52:05" itemprop="dateModified" datetime="2025-11-02T11:52:05+00:00">2025-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="各阶段总结"><a href="#各阶段总结" class="headerlink" title="各阶段总结"></a>各阶段总结</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>rust的基本学习，挺多有用的函数记不住，还需要多写代码</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><ul>
<li>Chapter 1: 应用程序与基本执行环境</li>
</ul>
<p>删除了标准库，适应一下内核级别的编程，不过其实core库很多都是直接引用std库的哈哈哈</p>
<ul>
<li>Chapter 2: 批处理系统</li>
</ul>
<p>操作系统必须负责保存所有的通用寄存器以及一系列关键的控制状态寄存器（CSRs），例如sstatus（记录CPU当前的特权级别）、sepc（记录发生trap时的指令地址，即trap返回后应继续执行的地址）、scause/stval（分别记录trap发生的原因及相关的附加信息）。这些CSRs对于用户态程序而言通常是透明的。出于安全性的考量，操作系统必须为内核态的执行维护一个独立的内核栈，而非在用户栈的基础上进行扩展。RISC-V架构为此提供了sscratch寄存器，可用于保存内核栈的地址。当陷入（trap）发生时，操作系统可以从sscratch寄存器中获取内核栈的起始地址，并切换至内核栈上开始后续处理。另外，在此阶段，所有的内存操作均基于物理地址进行，尚未实现内核态与用户态之间的内存隔离。理论上，应用程序能够访问包括内核栈在内的所有物理内存区域，这具有极大的潜在风险。此内存隔离问题将在后续实现虚拟内存机制时得到解决。</p>
<ul>
<li>Chapter 3: 多道程序与分时多任务</li>
</ul>
<p>当初学操作系统时对中断说实话没什么概念，原来真的是中中又断断啊，真的中断触发时直接跳转到中断处理程序。当然中断处理程序的地址由一个专门的寄存器来储存</p>
<ul>
<li>Chapter 4: 地址空间</li>
</ul>
<p>由于内核与应用程序的地址空间通常是不同的（或者说，它们各自拥有不同部分的内存映射），在从用户态陷入内核态之前，往往需要借助一个位于固定虚拟地址的“跳板页”（trampoline page）来实现上下文的平滑、安全切换。是的，也会有一个寄存器用来存储根页表的地址，将根页表的地址放到寄存器里之后，mmu会接管地址访问，也就是说，之后的地址转换由硬件完成，而不是软件。</p>
<ul>
<li>Chapter 5: 进程</li>
</ul>
<p>我原以为最为复杂的进程与shell机制，原来如次简单。</p>
<ul>
<li>Chapter 6: 文件系统</li>
</ul>
<p>其实文件系统的底层还是客户操作系统的read write系统调用，只不过封装成block的形式，真实操作系统里应该会依赖与硬件特性以及驱动的实现</p>
<ul>
<li>Chapter 7: 进程间通信</li>
</ul>
<p>这一章虽然没有题，但是我还是建议好好看看代码，解答了过往我的很多疑惑</p>
<ul>
<li>Chapter 8: 并发</li>
</ul>
<p>“纸上得来终觉浅，绝知此事要躬行”，当初操作系统课上我觉得银行家算法是一个没有实际应用价值的东西，通过实验的一点点试错尝试，我还是最终推导出了银行家算法，其解决的不是所有死锁问题，只是解决死锁中的a进程获得a锁，b进程获得了b锁，然后a想获得b锁，b想获得a锁这种问题，受益匪浅啊</p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>这一块的由于杂事颇多还需好好研究一下代码以及项目组织架构，几道题中有意思的是Hipervisor，其通过一个循环不多进入虚拟机状态，如果虚拟机有解决不了或权限不足无法执行的指令，就通过陷入由陷入处理函数来帮助虚拟机执行，然后在进入虚拟机模式，挺有意思，需要好好研究一下之后的东西。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/blog/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/73/">73</a><a class="extend next" rel="next" href="/blog/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
