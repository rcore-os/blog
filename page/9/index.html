<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/9/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/9/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">684</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">590</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/25/2025OS%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95-%E5%88%98%E7%A7%91%E8%BF%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/25/2025OS%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95-%E5%88%98%E7%A7%91%E8%BF%AA/" class="post-title-link" itemprop="url">2025OS训练营三阶段记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-25 17:21:55" itemprop="dateCreated datePublished" datetime="2025-04-25T17:21:55+00:00">2025-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:25" itemprop="dateModified" datetime="2025-05-18T05:10:25+00:00">2025-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/catogory/" itemprop="url" rel="index"><span itemprop="name"><catogory></span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025OS训练营三阶段记录"><a href="#2025OS训练营三阶段记录" class="headerlink" title="2025OS训练营三阶段记录"></a>2025OS训练营三阶段记录</h1><h2 id="4-7-4-8"><a href="#4-7-4-8" class="headerlink" title="4.7-4.8"></a>4.7-4.8</h2><p>这两天看了石磊老师的unikernel讲解视频，完成了彩色print和hashmap的任务。</p>
<p>unikernel我是第一次听说，用组件化的方式来实现操作系统，可以对应用定制轻量化的运行环境，相当于操作系统与应用一体，比较适合嵌入式和轻量虚拟化场景。arceos就不像rcore那样是面向教学的了，而是更偏向于实际应用，我查看了toml，操作系统的组件几乎都是依赖导入，刚开始有些搞不清楚这些包的具体用途。</p>
<p>彩色print的实现很简单，在格式化前加入蓝色字符标注即可实现。</p>
<p>hashmap的实现我一开始考虑的是nostd环境是否还需要我来实现对内存分配器，但是后来仔细看过arceos里有实现默认的对内存分配。我的实现内存分配依赖的vec，用vec作为hashmap的底层数据结构，实现起来相对容易，对于通过测例来说还是足够的。</p>
<h2 id="4-9-4-12"><a href="#4-9-4-12" class="headerlink" title="4.9-4.12"></a>4.9-4.12</h2><p>这几天在琢磨lab1的挑战题，不愧是挑战题，花了目前最久的时间。题目规范很好，只需要实现规定的部分就可以。内容是要实现一个字节内存分配器来让这个测试达到最大迭代次数。这个测试用例是重点，他是循环分配32+i到2的14次方+i的内存，这个i就是迭代次数，每次迭代会把每一轮偶数次数的分配空间给释放掉，所以每次都有一部分内存不会被释放，即这个挑战有理论最大值。用例的分配用的是vec，vec根据rust的实现每次分配在空间不够时都是要扩容当前一倍的空间的。挑战的分数是i的次数要大于170，因为170是算法tlsf的结果。我对tlsf、buddy算法的实现都手动实现测试了一遍，逐步理清了我的实现思路。</p>
<p>每次分配的偶数情况都会被释放，那直接对偶数情况的内存分配给固定的内存池，比如32 index为0，那分配32+Max的内存池，这个max就是最大i值，中修改max来得到i最大值。对于奇数的情况我使用了最简单的线性分配方法，应为当时想的是每次技术分配的都不会释放，所以不会有间隙，其实不是。这个探索的过程我发现分配的大小没有按照我的想法分配到对应的位置，于是我就打印了每次分配的内存的大小，我发现有几个固定值96，192，386这些数字不符合每次请求的内存大小，猜测应该是对其的要求分配的。所以对这个情况进行处理，直接计数进行跳过。但是效果到64又出现问题，分析发现32涨到96，与固定值96的分配打乱了奇偶计数的顺序，所以对全局分配96的大小进行计数，同样跳过一个固定位次的96分配。同理128在涨到192时也会触发，32在涨到192又会触发。对这些情况都做处理，得到了189的分数，折腾了三天，也总算有个结果，即便我知道这不是最佳答案。</p>
<p>其实问题在于我认为奇数的分配是没有空隙的，其实vec的分配策略，扩容的空间都是浪费了，如果要提升，就要在奇数合并块时，通过某种策略找出未使用的扩容区域，就可以真做到最大限度利用空间，达到无空隙。</p>
<p>这个题目刚开始觉得是个算法题，但其实也让我对内存分配的理解更加的深入。</p>
<h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><p>今天实现的是bump内存分配策略，同时兼顾页分配和字节分配，通过上次挑战题的考验，这道题相当简单了。而且题目要求也很低，我的实现就是对分配器维护一个左右标签记录已经分配的区域，左为字节分配器的使用位置，右为页面分配器的使用位置。字节分配采用线性分配，每次分配查看左标签内还有没有空余，没有就移动左标签扩容。释放只处理与左标签邻近的地址，将左标签剪去分配的内存大小。右标签则是每次分配页面大小，维护是扩容则减，释放则加。</p>
<p>其实对与这道题的测试用例很松，维护好左右分配标签就可以过。</p>
<h2 id="4-14"><a href="#4-14" class="headerlink" title="4.14"></a>4.14</h2><p>今天实现了rename，其实有个最简单的方法就是拷贝删除用来重新创建该文件。</p>
<p>正规做法需要先改下依赖的路径为本地，再将rename实现，arceos的文件系统依赖于虚拟文件系统，根据它的结构找到mata文件即可修改文件名。</p>
<h2 id="4-15"><a href="#4-15" class="headerlink" title="4.15"></a>4.15</h2><p>mmap操作需要先理解静态分配，其实很简单，我们平时用到的动态分配就是请求了就立即分配内存空间给用户，静态则是在请求时返回成功，再用到时访问内存会触发pagefault，这个时候再分配内存。mmap需要做到文件映射，本来文件读入内存需要先经过内核空间再到用户空间，mmap在静态分配地址后，手动映射到用户空间，再将文件直接读取到这个物理地址，实现了无拷贝操作。</p>
<p>实现时检查参数有效性，转换传进来的flags格式，获取当前任务的地址空间即可转换给定的虚拟地址为物理地址，使用mapalloc对内存大小完成映射，注意flag要加上USER，因为是要映射到用户空间。通过fd找到文件节点后直接读入到得到的物理内存处，完成映射。</p>
<h2 id="4-16"><a href="#4-16" class="headerlink" title="4.16"></a>4.16</h2><p>虚拟化这个题，看过了视频后，有了老师给的提示还是非常容易的。虚拟机在执行到某个位置触发了系统异常，那肯定要在traphandler里找，返汇编后，看到有非该特权级的指令执行出发了异常指令，那就将pc指针步进继续执行，然后代替处理复制操作，后面的错误访问内存也一样，代替执行赋值后设置pc继续执行内核。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三阶段做的这些题远远不够理解arceos，所以在做完后我确定在虚拟化上下功夫，仔细研究这一块的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/25/2025OS%E8%AE%AD%E7%BB%83%E8%90%A5%E4%BA%8C%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95-%E5%88%98%E7%A7%91%E8%BF%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/25/2025OS%E8%AE%AD%E7%BB%83%E8%90%A5%E4%BA%8C%E9%98%B6%E6%AE%B5%E8%AE%B0%E5%BD%95-%E5%88%98%E7%A7%91%E8%BF%AA/" class="post-title-link" itemprop="url">2025OS训练营二阶段记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-25 17:21:55" itemprop="dateCreated datePublished" datetime="2025-04-25T17:21:55+00:00">2025-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:25" itemprop="dateModified" datetime="2025-05-18T05:10:25+00:00">2025-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/catogory/" itemprop="url" rel="index"><span itemprop="name"><catogory></span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025OS训练营二阶段记录"><a href="#2025OS训练营二阶段记录" class="headerlink" title="2025OS训练营二阶段记录"></a>2025OS训练营二阶段记录</h1><h2 id="3-18-3-21"><a href="#3-18-3-21" class="headerlink" title="3.18-3.21"></a>3.18-3.21</h2><p>这段时间是在开营前，我在用rcorebook学习，这几天完成了ch1-ch3的学习。</p>
<h3 id="ch1"><a href="#ch1" class="headerlink" title="ch1"></a>ch1</h3><p><strong>环境配置</strong>：我用的是ubuntu20.04，按照教程来配置还是相当容易的，没有碰到什么问题。</p>
<p><strong>个人基础</strong>：我是在寒假接触自制操作系统的，看的一本书叫做《操作系统真象还原》，这本书用c语言和汇编实现了一个x86的32的操作系统。书的内容很多，对于基础盲区也讲解很全，作者从MBR到Bios、bootloader再到用显存来实现print，操作系统的必要组件。所以我学起来还没那么吃力。</p>
<p>riscv我没有接触过，有一些x86的汇编先不系统学习还是可以看得懂的，毕竟rcore没有涉及太多汇编内容。</p>
<p>rust的编译工具安装、编译方便在开始都让我非常惊喜。内核的第一条指令涉及到一个linker.ld，这个文件就是链接脚本，通过分析内容可以很容易理解程序的内存分布，首先是固定的内存入口，其次是 .data .bss .rodata等段的排布很清晰。</p>
<p>简单学习了下gdb调试和远程连接，反编译反汇编工具。</p>
<p>第一次接触rust的外部链接extern “C”，使用声明函数的方式来找到链接脚本确定的内存区域起始符号。</p>
<p>rustsbi这个东西真的很方便，当然也是riscv架构的标准。像打印字符这种函数都实现在里面，要不然需要用汇编来自己实现。对sbi进行封装后很容易就能实现write函数和print宏。</p>
<h3 id="ch2"><a href="#ch2" class="headerlink" title="ch2"></a>ch2</h3><p>这一章是写一个批处理系统，系统在运行前就明确了所有要运行的app，这些app都按顺序执行直到最后一道，然后系统panic结束。应用的内存地址都是在运行前要手动计算确定的。riscv架构从大到小分为0，1，2，3四个特权级，还提供了ecall，eret用来切换特权级。这个批处理系统分成了用户态和内核态，ecall就是用来从用户态进入内核态，eret用来返回用户态。ecall属于riscv规定的一种异常，而操作系统属于在riscv的s模式特权级，在用户态ecall就会触发陷入机制进入s模式特权级，用sret来返回u特权级。进入s模式后会调用二进制接口，也称为系统调用。</p>
<p>系统调用的意义在于很多操作交给用户来做非常不安全，系统稳定性难以保证，所以需要划分出内核态用户态，内核根据需求做出安全的系统调用操作。</p>
<p>程序的入口准确来说是_start就是linker里的start符号位置，这里我们不能使用原生架构编译工具，而是使用交叉工具链，所以rust std内容都用不了，main函数也不能完成作为程序入口的作用。在rust声明外部链接符号就要在link操作的宏。</p>
<p>创建系统调用的触发接口，使用内敛汇编调用ecall传入系统调用号和参数，在操作系统就会捕捉异常，判断类型为ecall后根据对应系统调用号即可处理系统调用，完成系统调用后返回用户态。</p>
<p>这里的测试没有实现具体的系统调用，而是用了linux相同的系统调用好在linux环境进行测试，测试正常。</p>
<p>rcore写了build.rs用来构建linker.ld链接脚本，app需要使用路径方式进行导入，每个app的入口地址和执行顺序挂钩。使用的测试用例是在linux系统调用环境下编译的，编译的结果是elf的，需要使用工具来将elf转换成bin二进制文件。在设计上rcore创建了UnSafeCell用来在单核上可以安全使用全局可变借用。</p>
<p>load_app根据固定的标号入口地址来从内存里找到app的代码段，加载到APP_BASE_ADDR，这个地址是个固定值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">批处理操作系统为了建立好应用程序的执行环境，需要在执行应用程序之前进行一些初始化工作，并监控应用程序的执行，具体体现在：</span><br><span class="line">当启动应用程序的时候，需要初始化应用程序的用户态上下文，并能切换到用户态执行应用程序；</span><br><span class="line">当应用程序发起系统调用（即发出 Trap）之后，需要到批处理操作系统中进行处理；</span><br><span class="line">当应用程序执行出错的时候，需要到批处理操作系统中杀死该应用并加载运行下一个应用；</span><br><span class="line">当应用程序执行结束的时候，需要到批处理操作系统中加载运行下一个应用（实际上也是通过系统调用 sys_exit 来实现的）。</span><br><span class="line">这些处理都涉及到特权级切换，因此需要应用程序、操作系统和硬件一起协同，完成特权级切换机制。</span><br></pre></td></tr></table></figure>

<p>系统调用和异常都涉及到了切换特权级，特权级的切换最重要的就是保存上下文。因为不管是trap还是异常都是停止执行当前的程序，转去执行系统调用或者异常处理，这时候就需要保存当前应用的寄存器环境，这个就是上下文，将这些寄存器按固定顺序保存到用户栈，在ret时再逆顺序恢复寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sstatus 的 SPP 字段会被修改为 CPU 当前的特权级（U&#x2F;S）。</span><br><span class="line">sepc 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。</span><br><span class="line">scause&#x2F;stval 分别会被修改成这次 Trap 的原因以及相关的附加信息。</span><br><span class="line">CPU 会跳转到 stvec 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。</span><br></pre></td></tr></table></figure>

<p>这些是riscv用到的硬件辅助寄存器。</p>
<p>rcore使用汇编实现了alltrap和restore，用来保存和恢复寄存器，需要注意sp寄存器，sp寄存器的值用到sscratch，这个寄存器用来交换内核栈sp值，还要注意处理当前执行的位置。</p>
<p>traphandler中根据scause的结果，对不同的异常进行处理，包括ecall，runnext等操作。</p>
<h3 id="ch3"><a href="#ch3" class="headerlink" title="ch3"></a>ch3</h3><p>这一章要创建一个多道程序处理系统，需要实现分时调用就必须要将应用都加载到内存，这也意味着也要为当前每个应用都分配独立栈空间。所以不能像上节一样都加载到base地址，需要确保应用占用的空间不会重叠。切换任务必然也要保存上下文，与系统调用不同的是，任务切换的操作保存寄存器恢复寄存器都是在用户态。rcore根据sbi实现了gettime，设定计时器后，计时器到时触发异常，traphandler捕捉到后执行任务切换操作。</p>
<p>任务切换最重要的是switch操作，在执行之前已经将下个任务的栈顶地址保存起来，保存当前寄存器环境后，导入下个任务的寄存器环境。yeild操作为计时器中断触发切换任务的系统调用。</p>
<h2 id="3-24-3-25"><a href="#3-24-3-25" class="headerlink" title="3.24-3.25"></a>3.24-3.25</h2><p>关于trace的系统调用实现,需要判断request来实现不同功能. 在request为0时:需要将id转换成<em>const u8 再解引用,再转换为isize返回;在request为1时:要将id转换成</em>mut u8,再将data转换成u8,复制给id转换后指针的解引用,返回0;</p>
<p>当request为2时: 想要获取每个任务的某个系统调用次数,并且考虑到批处理系统会进行任务切换,所以在切换到其他任务时也要保存着其他刮起的人物的调用次数,所以我就在syscall/mod.rs中实现了个全局变量SYSCALL_COUNT,类型为Mutex&lt;BTreeMap&lt;usize, BTreeMap&lt;usize, usize&gt;&gt;&gt;,Mutex包裹是因为他是全局变量(rust的要求? 按理说批处理单进程用不到锁,但是我编译没过就加上了.),外层BTree key为app_id,value为内层BTree,内层BTree为(sys_id, count).这样就可以通过app_id来得到所有系统调用的次数.syscall_count方法在syscall里用来计数,insert_syscall_count为当前任务初始化记录,已有记录则返回,delete_syscall_count在进程退出时删除记录,get_syscall_count就用来在sys_trace里获取当前任务的系统调用次数.</p>
<h2 id="3-25-3-26"><a href="#3-25-3-26" class="headerlink" title="3.25-3.26"></a>3.25-3.26</h2><p>在sys_get_time和sys_trace实现最主要的是将虚拟地址转换成物理地址,因为内核不能访问应用的虚拟地址.sys_get_time首先获取应用虚拟页表,将ts转换成虚拟地址,记录偏移,通过页表转换后可以得到对应的物理页表项,将表项加上偏移就得到了对应ts的物理地址,然后转换成mut指针,将获取的timeval复制给该地址.判断跨页是要在ts地址上加上timeval长度得到截至地址,与start%Pagesize后判断是否相等,不相等则要处理跨页,还是计算出物理地址分别在对应部分拷贝该部分的数据.</p>
<p> sys_trace相比上次只需要处理0,1的情况,要想办法通过虚拟地址读取或写入,同样转换为物理地址就可以将其转换成指针.在获取物理页表项时要注意判断页表项的有效性 可读性 可写性.</p>
<p> mmap就是要为应用程序申请一块动态区域,这个就要在memset上处理,本来我是准备将内存加入areas的,但是在写unmap时判断vpn来删除有些困难,就考虑重新为mmap的内存重新建立映射结构.处理时就是要几个点注意,1:判断port是否全0或者无效位有非0, 2:判断start是否页表对齐,没有对齐就返回, 3:PTEFlags不仅要加上port的标志,还需要有效位V和用户位U, 4:计算虚拟页表起始地址,然后对每个页循环遍历, 5: 判断虚拟页表有效性,有效则返回(mapped), 6: 申请物理页建立映射.</p>
<p> unmap要判断虚拟页表无效性,然后循环遍历每个vpn在虚拟页表中被unmap,并移除mmap_set对应项.</p>
<h2 id="3-26-3-28"><a href="#3-26-3-28" class="headerlink" title="3.26-3.28"></a>3.26-3.28</h2><p>关于spawn,相比fork就是不要复制父进程的内存布局,将传进来的字符串指针转换成string,通过这个名字获取应用elf_data,后面就对TCB进行初始化,和TCB::new一样,注意三点,父进程设置为当前进程;将该进程加入父进程的child列表;将该进程加入运行队列.</p>
<p> 关于stride,我定义了两个常量BASE_STRIDE=91,BIG_STRIDE=99991.在TCBinner里加入两个量:pass=0,prio=1,封装updatepass:</p>
<p>pass += (BASE_STRIDE / prio) % BIG_STRIDE</p>
<p>留出相关接口.再到run_task调用updatepass, 在fatch里对ready_queue取出最小pass的TCB.</p>
<h2 id="3-28-3-30"><a href="#3-28-3-30" class="headerlink" title="3.28-3.30"></a>3.28-3.30</h2><p> 关于link，与linux的ln命令类似，对文件创建链接相当于在操作系统层面增加个INode，但是磁盘里共用统一片块，那相当于拥有相同的inode编号，我们先通过原文件名称获取编号，已知所有文件都在根目录。找到编号后就可以得到块位置id和offset，在创建inode时需要。接下来修改目录项，需要先扩展目录项的存储区域，后写入目录项。返回一个新的inode。</p>
<p> 关于unlink，通过name找到根节点后计算目录项数目，循环读取根节点每个文件对比名称，找到index后，把末尾的目录项换到index处，减小目录大小。</p>
<p> stat就连两个项需要获取，ino就是blockid，nlink需要通过块位置来对目录里所有文件的块位置进行比较，相同计数加1.在返回时我和gettime的处理一样，将虚拟地址转换成物理地址后再转换成可变指针，将stat结构体指针放进去。</p>
<h2 id="3-30-4-3"><a href="#3-30-4-3" class="headerlink" title="3.30-4.3"></a>3.30-4.3</h2><p>这节还挺费劲的。刚开始看了很久没发现是银行家算法，不知道如何来抽象这些资源。</p>
<p>首先就是清楚是要以每个进程为单位来进行资源管理，所以在pcb inner里添加了死锁检测模块。模块数据一维为线程tid，二维为资源rid，模块需要实现几个功能，isunsafe就是银行家算法用来查看当前状态是否安全，tryallocate在检查unsafe同时通过tid和rid处理减小available和need，增加allocation；setneed需要在设置资源前调用，在分配失败时会保留，在分配成功会减小。release在up时增加available和减小allocation；检测开关只需要设置enabled。在创建线程和创建资源时需要更新数据结构，在添加一个线程时会为二维结构添加资源数的全为0的向量，在添加mutex时avail则push 1，sem则push 初始化值。在down时首先判断是否打开了检测，打开了就首先setneed，然后判断unsafe如果不安全则直接返回dead，安全则尝试分配（会失败），然后调用down；up时判断检测打开之后就调用release，release判断了当前分配数是否为0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/25/2025%E5%B9%B4%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-mingzi47/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/25/2025%E5%B9%B4%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-mingzi47/" class="post-title-link" itemprop="url">2025春夏季开源操作系统训练营前三阶段总结-mingzi47</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-25 14:40:28" itemprop="dateCreated datePublished" datetime="2025-04-25T14:40:28+00:00">2025-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:25" itemprop="dateModified" datetime="2025-05-18T05:10:25+00:00">2025-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h3 id="3-28"><a href="#3-28" class="headerlink" title="3.28"></a>3.28</h3><p>完成 Rust 语言练习</p>
<h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><h3 id="4-7"><a href="#4-7" class="headerlink" title="4.7"></a>4.7</h3><p>risc-v知识欠缺，花费大量时间浏览 risc-v 手册。</p>
<p>完成 Lab1</p>
<p>学习 第四章 Rust 中的动态内存分配，地址空间， SV39 多级页面管理机制（上）。</p>
<p>成果：</p>
<p>初步了解risc-v多级分页机制。</p>
<h3 id="4-10"><a href="#4-10" class="headerlink" title="4.10"></a>4.10</h3><p>完成 Lab2, 选做了 Lazy 分配策略。</p>
<p>大部分时间花在了 Lazy 策略初始化不分配内存上，通过查看多个函数的调试输出，完善了mmap申请的虚拟页表和物理页表映射结构上的设计。</p>
<h3 id="4-11"><a href="#4-11" class="headerlink" title="4.11"></a>4.11</h3><p>开始 Lab3：spawn, 迁移 Lab2 中的工作。</p>
<p>spawn 功能非常简单，记得最后要添加到 manager 中。</p>
<h3 id="4-15-总结"><a href="#4-15-总结" class="headerlink" title="4.15 总结"></a>4.15 总结</h3><p>rcore 的文档很详细，通过读文档已经能对 rcore 很清晰的了解了，之后做实验也不存在太大的困难。选做题只做了 mmap lazy 策略。</p>
<h2 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h2><h3 id="4-17"><a href="#4-17" class="headerlink" title="4.17"></a>4.17</h3><p>做完第二个小测验，发现没有安装 riscv-linux-musl-gcc， ArchLinux 中这个包在 AUR 中可以找到，<a href="https://aur.archlinux.org/packages/riscv64-gnu-toolchain-musl-bin" target="_blank" rel="noopener">riscv64-gnu-toolchain-musl-bin^AUR^</a>, 也可以在 github 上找到相应的二进制文件 <a href="https://github.com/riscv-collab/riscv-gnu-toolchain/releases" target="_blank" rel="noopener">riscv-gnu-toolchain/releases</a></p>
<h3 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h3><p>完成 Lab3, 选做题花费的时间多了些，主要是卡在了最后一个点上，费了一番功夫才完成了。现在回想起来感觉是因为是在晚上3，4点脑子不清醒，今天下午就顺利很多。<br>题目难度本身不大，第三阶段需要对项目的结构有一定的了解，不然会不知道要找的模块在哪里。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/24/oscamp-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/24/oscamp-summary/" class="post-title-link" itemprop="url">oscamp_summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-24 21:23:15" itemprop="dateCreated datePublished" datetime="2025-04-24T21:23:15+00:00">2025-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:26" itemprop="dateModified" datetime="2025-05-18T05:10:26+00:00">2025-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="rustling"><a href="#rustling" class="headerlink" title="rustling"></a>rustling</h4><p>大部分练习没什么印象，都是很基础的练习。</p>
<p>唯一印象深刻的是对<code>#[cfg(feature)]</code>的考察，cargo在编译时会根据feature来选择编译字段、函数、源代码，私认为这是个很有用的特性。在编译大型项目时，就可以塞入很多功能，让用户能够选择feature来控制项目的编译。</p>
<h4 id="rcore"><a href="#rcore" class="headerlink" title="rcore"></a>rcore</h4><p>之前做过<code>mit 6.1810</code> 操作系统实验课，是基于<code>riscv</code>的用<code>c</code>编写的操作系统。这次写<code>rcore</code>主要是体验两者在实验流程的设计差异，以及<code>c</code>和<code>rust</code>在编写内核上的特性与差异。</p>
<p>我个人觉得<code>rcore</code>内容上更丰厚更复杂，但是实验设计上有点太简单了，或者说为学生实现了太多。我觉得可以丰富实验内容，让学生体会到内核的调用流程，以及<code>rust</code>语言实现内核的优点。</p>
<ol>
<li><p>在<code>syscall</code>实验中，可以增加几个系统调用函数，并让学生完成从用户态增加函数，到内核态具体实现</p>
</li>
<li><p>在<code>syscall</code>实验中，内核接收<code>syscall_id</code>，通过match分发到对应的函数。我个人觉得这里应该提供两个数组引导学生去填写新增的系统调用函数：</p>
<ol>
<li><code>index -&gt; syscall_id</code>: <code>SYSCALL_MAP = [SYS_GETTIME, SYS_READ, SYS_WRITE, .. ]</code></li>
<li><code>index -&gt; syscall_func</code>: <code>SYSCALL_FUNC = [sys_gettime, sys_read, sys_write, ..]</code></li>
</ol>
<p>这样，很自然的就能想到<code>trace</code>系统调用应该怎么实现。我觉得<code>syscall_id</code>设置成<code>64,93,124,...</code>应该有<code>rcore</code>设计上的考量，教学项目是不是可以设置从0开始的连续自然数呢？</p>
</li>
<li><p>在<code>virtual memory</code>中，实验设计书上没有仔细讲从虚拟地址的39位怎么映射到物理地址的，而代码更是直接帮学生实现好了地址转换、地址映射、地址查找。我个人觉得这里可以划分几个实验让学生实现</p>
</li>
<li><p>在<code>virtual memory</code>中，增加一个中断实验，内核处理<code>page_fault</code>，进而进一步考察<code>copy on write</code>页表缺页的实验</p>
</li>
<li><p>接上一条，增加<code>trap</code>的处理实验</p>
</li>
<li><p>增加考察汇编代码的简单编写，比如在代码中插入汇编代码、在<code>.S</code>中编写汇编代码。并让学生体会为什么这么做：手动控制寄存器。在这个过程中，自然的就了解了编写的函数本质就是汇编代码中的符号，再通过汇编链接到一起</p>
</li>
<li><p>测试可以更丰富，有些测试过于简单了</p>
</li>
<li><p>用户端的<code>shell</code>代码应该捕获<code>ctrl z, ctrl d, ctrl c</code>之类的字符或者添加<code>exit, quit</code>来让用户退出</p>
</li>
</ol>
<p>在这次实验中，我深刻体会到了<code>rust</code>在<code>trait</code>抽象的强大之处，在<code>virtual memory</code>实验中，<code>VirtAddr</code>和<code>PhyAddr</code>的<code>struct</code>对相关<code>trait</code>的实现可以很方便让用户操作地址还不会混淆。</p>
<h4 id="arceos"><a href="#arceos" class="headerlink" title="arceos"></a>arceos</h4><p>非常的复杂，内容也非常的多。我一直认为大型项目的价值在于项目的架构以及各个api的语义设计。</p>
<p>通过查看调用链了解到了是<code>user -&gt; axstd -&gt; api -&gt; modules/xxx</code>。我觉得这个项目最有意思的地方在于组件化操作系统，通过<code>feature</code>来选择编译<code>Unikernel</code>、宏内核、虚拟机。如果组件化内核编译出的各种类型内核性能与原生内核差距不大的话，感觉会是很方便的内核开发方式。<br>郑友捷老师讲的组件化内核让我收益很多，我准备后续学习一下cargo的功能来了解这个项目是怎么组织不同功能的组件的。<br>我自己一直有个疑惑，编写内核的时候要不要用alloc::collections中的数据结构，以及为了内核稳定性是不是应该只用官方库和自己编写的库而少用第三方库。</p>
<p>这个项目也让我逐渐意识到一个事实：编译器提供c语言库，其他高级语言通过调用c语言库(汇编)来与硬件/操作系统交互。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/24/2025%E6%98%A5%E5%A4%8F%E5%89%8D%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-NoahNieh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/24/2025%E6%98%A5%E5%A4%8F%E5%89%8D%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-NoahNieh/" class="post-title-link" itemprop="url">2025春夏前三阶段总结-NoahNieh</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-24 11:23:32" itemprop="dateCreated datePublished" datetime="2025-04-24T11:23:32+00:00">2025-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:25" itemprop="dateModified" datetime="2025-05-18T05:10:25+00:00">2025-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><p>在原版的<code>rustlings</code>基础上加入了一些针对训练营需要的<code>unsafe</code>相关的知识和构建过程中<code>build.rs</code>的应用。属于比较基础的内容，跟着评测机一道道做过去就可以了。</p>
<h2 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h2><p>这个阶段主要是通过基于<code>rust</code>编写操作系统内核<code>rcore</code>完成几个实验，借助实验理解一个具有进程/线程管理、内存管理、文件系统、进程间通信和提供了一定同步机制的内核是如何构成并运作起来的。</p>
<p>比较印象深刻的有这么几个知识点：</p>
<ul>
<li>链接脚本与全局符号的使用</li>
<li><code>Rust</code>的汇编嵌入</li>
<li>第四章中，在使用分离内核空间的时候。通过设计跳板页来解决切换页表后指令执行的问题。<a href="#跳板">跳板页</a></li>
<li>第六章了解了文件系统，了解了块设备的概念，对文件系统的各个抽象层有了一定的了解。</li>
<li>第七、八章了解了操作系统是如何为应用提供同步原语的</li>
</ul>
<h3 id="跳板"><a href="#跳板" class="headerlink" title="跳板"></a>跳板</h3><p>由于<code>rcore</code>使用了分离内核空间的设计，所以在<code>Trap</code>的时候需要切换页表。但在切换页表之后，<code>pc</code>寄存器还是忠实的在其原来的位置自加到下一条指令，如果<code>内核内存空间</code>和<code>程序内存空间</code>对这段代码的映射不是在同一个位置的话，则会表现出来程序跳转到了别的地方执行的效果。因此需要设计一个跳板页，在虚存中将其映射到所有内存空间的最高页，确保在切换之后，也能正确运行下一条指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># trap.S</span><br><span class="line">...</span><br><span class="line">    .section .text.trampoline</span><br><span class="line">    .globl __alltraps</span><br><span class="line">    .globl __restore</span><br><span class="line">    .align 2</span><br><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># linker.ld</span><br><span class="line">...</span><br><span class="line">    stext &#x3D; .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        . &#x3D; ALIGN(4K);</span><br><span class="line">        strampoline &#x3D; .;</span><br><span class="line">        *(.text.trampoline);</span><br><span class="line">        . &#x3D; ALIGN(4K);</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在上面的汇编可以看到，我们给<code>trap.S</code>分配到了<code>.text.trampoline</code>段，并在链接脚本中定义了一个<code>strampline</code>符号来标记他的位置，这样我们可以在<code>Rust</code>中找到这个跳板页，映射到我们期望的位置。</p>
<p>但将跳板也映射到别的地方带来了新的问题，原来<code>__alltraps</code>中最后跳转到<code>trap_handler</code>使用的是<code>call trap_handler</code>。我们可以通过<code>obj-dump</code>看看编译得到的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># obj-dump -Dx ...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">80201056: 73 90 02 18   csrw    satp, t0</span><br><span class="line">8020105a: 73 00 00 12   sfence.vma</span><br><span class="line">8020105e: 97 80 00 00   auipc   ra, 0x8</span><br><span class="line">80201062: e7 80 e0 0b   jalr    0xbe(ra) &lt;trap_handler&gt; # pc+0x80be</span><br><span class="line">...</span><br><span class="line">000000008020911c g     F .text  00000000000003b2 trap_handler</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，这里用的是pc相对寻址，也就是基于当前指令的偏移找到<code>trap_handler</code>所在的位置。但是现在<code>__alltraps</code>已经在虚拟内存中被我们映射到最高页去了，也就是说我们实际运行代码的时候是在下面这一段内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># gdb</span><br><span class="line">&gt;&gt;&gt; x &#x2F;20i $pc-10</span><br><span class="line">   0xfffffffffffff054:  ld      sp,280(sp)</span><br><span class="line">   0xfffffffffffff056:  csrw    satp,t0</span><br><span class="line">   0xfffffffffffff05a:  sfence.vma</span><br><span class="line">&#x3D;&gt; 0xfffffffffffff05e:  jr      t1 </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; p &#x2F;x $t1</span><br><span class="line">$9 &#x3D; 0x8020911c</span><br></pre></td></tr></table></figure>

<p>很明显如果这里跳转到$pc+offset$的话，并不是跳到位于正常代码段的<code>trap_handler</code>。所以我们要将这里换成寄存器跳转，将<code>trap_handler</code>的地址放到寄存器<code>t1</code>中，这样才能顺利地调用到<code>trap_handler</code>。</p>
<p>也就是<a href="https://learningos.cn/rCore-Tutorial-Guide-2025S/chapter4/6multitasking-based-on-as.html?#term-trampoline" target="_blank" rel="noopener">指导书</a>中所说的</p>
<blockquote>
<p>跳转指令实际被执行时的虚拟地址和在编译器/汇编器/链接器进行后端代码生成和链接形成最终机器码时设置此指令的地址是不同的。</p>
</blockquote>
<h2 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h2><p>这个阶段正式接触到组件化操作系统<code>arceos</code>。</p>
<h3 id="print-with-color"><a href="#print-with-color" class="headerlink" title="print_with_color"></a>print_with_color</h3><p>在调用路径上任意一个地方加入颜色代码就可以了，本身并不复杂，主要是了解arceos的结构。</p>
<h3 id="support-hashmap"><a href="#support-hashmap" class="headerlink" title="support_hashmap"></a>support_hashmap</h3><p>考虑实现一个hashmap比较麻烦，直接引入<code>hashbrown</code>，将里面HashMap包到<code>collections</code>里面也可以通过。</p>
<blockquote>
<p>但是hashbrown默认依赖的hashfold库在no_std下所提供的RandomState是基于内存布局的，而非每次都随机<br>可能会带来一些安全性问题</p>
</blockquote>
<h3 id="alt-alloc"><a href="#alt-alloc" class="headerlink" title="alt_alloc"></a>alt_alloc</h3><p>实验要求实现一个<code>bump alloctor</code>，是一个比较简单的分配器，在给定的接口下实现就可以了</p>
<h3 id="ramfs-rename"><a href="#ramfs-rename" class="headerlink" title="ramfs_rename"></a>ramfs_rename</h3><p>要求在给定的文件系统中实现rename的功能。看了测例中的注释仅要求在同级下重命名，不涉及移动。</p>
<p>搞清楚了<code>VfsOps</code>和<code>VfsNodeOps</code>两个trait之后，在路径上把目录项的名字改掉就好了。</p>
<h3 id="sys-map"><a href="#sys-map" class="headerlink" title="sys_map"></a>sys_map</h3><p>要求实现系统调用<code>mmap</code>。</p>
<p>利用<code>task_ext</code>的<code>aspace</code>提供的接口就可以完成。通过<code>find_free_area</code>找到空闲的区域并通过<code>map_alloc</code>分配，然后将给定fd的数据读进来就可以通过了。需要注意一些接口有检查传入参数是否有对齐。</p>
<h3 id="simple-hv"><a href="#simple-hv" class="headerlink" title="simple_hv"></a>simple_hv</h3><p>按照提示将<code>a0``a1</code>寄存器设置好，并将pc寄存器偏移以跳过当前指令即可。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>阶段三的任务总体来说比阶段二的时候来得要更简单，感觉主要还是了解<code>arceos</code>的架构以及<code>Unikernel</code>、<code>Monolithic Kernel</code>、<code>Hypervisor</code>的不同。并体会在不同的内核需求中，<code>arceos</code>是如何将不同的组件组合起来以达成需求的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/24/451846939-rcore-2025-reports/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/24/451846939-rcore-2025-reports/" class="post-title-link" itemprop="url">451846939-rcore-2025-reports</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-24 11:15:18" itemprop="dateCreated datePublished" datetime="2025-04-24T11:15:18+00:00">2025-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:25" itemprop="dateModified" datetime="2025-05-18T05:10:25+00:00">2025-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h2><p>用rust其实也有快5年了所以一阶段不是什么特别难的事，因为23年已经做过一次，这次增加了一些数据结构的实现，其实不是特别难，整体数据结构实现对于之前刷过leetcode的人都会比较熟，所以轻松就过了。</p>
<h2 id="二阶段"><a href="#二阶段" class="headerlink" title="二阶段"></a>二阶段</h2><p>其实23年最早刷过一遍所以这个比较简单，沿用23年的一些总结，这次lab1和23年的lab1有一些不同，不过核心是不变的</p>
<ol>
<li><p>lab1</p>
<p>其实是一个很简单的lab，系统调用的次数统计<br>问答题是很好的问题，也帮助我回忆和加深了risc-v的寄存器的作用，包括trap的流程，这个很重要，直接以代码展现出来，没学rcore的时候平时听到系统调用，其实是很抽象的，并不知道系统调用是怎么从用户态切换到内核态的，而rcore非常精彩的给我解答了这个问题，并且以代码展现，不再抽象。只能说感谢开源！</p>
</li>
<li><p>lab2</p>
<p>mmap 和 munmap 匿名映射，对我来说其实也不难，不过反而是问答题让我再次加深了SV39的结构，页表，页表项等等这些其实理解很抽象，包括用户态是怎么用到MMU的，MMU和操作系统存储的页表这些是怎么结合的，在这一张再结合linux的一些代码就理解了。其实是riscv 使用 SATP 寄存器来保存 MMU 映射表的根地址</p>
</li>
<li><p>lab3</p>
<p>spawn和stride 调度算法，这个其实也不算特别复杂，在给予fork和exec代码中只需要理解    spawn和他们的区别，就很容易写出来，而stride调度算法用一个小顶堆实现即可。因为之前看了linux的task_struct的实现，所以比较轻松就能理解。</p>
</li>
<li><p>lab4</p>
<p>这个要求实现<strong>linkat</strong>和<strong>unlinkat</strong> 这个加深了我对硬连接的理解，并且文件系统的这章让我对linux的vfs也更加理解。整体来说明显会感受到磁盘读取和内存有异曲同工之妙。</p>
</li>
<li><p>lab5</p>
<p>死锁检测，这个就非常考察细心了，主要就是资源的分配、分出、释放，需要格外注意，否则都无法通过，顺带这里也有一个坑，就是检测用了sleep，sleep用的是get_time，所以要实现这个api不然程序就会卡在那</p>
</li>
</ol>
<h2 id="三阶段"><a href="#三阶段" class="headerlink" title="三阶段"></a>三阶段</h2><p>这次是新增的一个阶段，主要是为了让大家先熟悉arceos，在熟悉rcore以后其实再看arceos是比较轻松的，组件化操作系统的思想是一个很好的思想，同时也比较考验抽象能力如果做到高性能高抽象的同时又可以随意的扩展操作系统的个个组件，使用一个create引入开箱即用，个人认为是一个未来需要的方向。随着整体社会需求的发展大家对底层性能的要求越来越苛刻定制化需求也越来越多，对于操作系统也是百花齐放，同时在写一个新的操作系统的时候也总是需要重复造轮子，这个工作量其实也不算小，所以个人认为组件化操作系统在当前是一个很好的想法，高质量的组件化操作系统可以帮助个人和初创企业降低开发操作系统的难度还可以获得定制操作系统的优势来满足一些特殊的场景需要。</p>
<ol>
<li><p>print_color<br>这个其实很简单，因为不想修改println的宏所以这里新增了一个print_color的宏来实现对颜色的打印，并再用log来包装print_color宏实现不同等级打印不同颜色的日志</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print_color &#123;</span><br><span class="line">    ($color:expr, $($arg:tt)*) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">use</span> axstd::io::Write;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> out = $crate::io::stdout().lock();</span><br><span class="line">        <span class="keyword">let</span> _ = <span class="built_in">write!</span>(out, <span class="string">"\x1B[&#123;&#125;m"</span>, $color); </span><br><span class="line">        <span class="keyword">let</span> _ = <span class="built_in">write!</span>(out, $($arg)*);           </span><br><span class="line">        <span class="keyword">let</span> _ = <span class="built_in">write!</span>(out, <span class="string">"\x1B[0m"</span>);          </span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">LogLevel</span></span> &#123;</span><br><span class="line">    Error,</span><br><span class="line">    Warn,</span><br><span class="line">    Info,</span><br><span class="line">    <span class="built_in">Debug</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> log &#123;</span><br><span class="line">    (error, $($arg:tt)*) =&gt; &#123;</span><br><span class="line">        $crate::print_color!(<span class="string">"31"</span>, <span class="built_in">concat!</span>(<span class="string">"[error] "</span>, $($arg)*, <span class="string">"\n"</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    (warn, $($arg:tt)*) =&gt; &#123;</span><br><span class="line">        $crate::print_color!(<span class="string">"33"</span>, <span class="built_in">concat!</span>(<span class="string">"[warn] "</span>, $($arg)*, <span class="string">"\n"</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    (info, $($arg:tt)*) =&gt; &#123;</span><br><span class="line">        $crate::print_color!(<span class="string">"32"</span>, <span class="built_in">concat!</span>(<span class="string">"[info] "</span>, $($arg)*, <span class="string">"\n"</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    (debug, $($arg:tt)*) =&gt; &#123;</span><br><span class="line">        $crate::print_color!(<span class="string">"34"</span>, <span class="built_in">concat!</span>(<span class="string">"[debug] "</span>, $($arg)*, <span class="string">"\n"</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p>hashmap<br>这个其实可以参考rust的std的rust实现，然后改一下就可以了，当然也可以从0自己实现一个最后别忘了这样才能使用std::map</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> map;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"alloc"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> collections &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> crate::map::HashMap;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> alloc::collections::*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p>bump_alloc<br>这个主要需要了解什么是bump算法，在实现ByteAllocator和PageAllocator的时候需要注意b_pos和p_pos的验证，还有要注意对齐,还要理解一下align_pow2</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, layout: Layout) -&gt; AllocResult&lt;NonNull&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> align = layout.align();</span><br><span class="line">    <span class="keyword">let</span> size = layout.size();</span><br><span class="line">    <span class="keyword">let</span> aligned = (<span class="keyword">self</span>.b_pos + align - <span class="number">1</span>) &amp; !(align - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> new_b_pos = aligned + size;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> new_b_pos &gt; <span class="keyword">self</span>.p_pos &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Err</span>(AllocError::NoMemory);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">self</span>.b_pos = new_b_pos;</span><br><span class="line">    <span class="keyword">self</span>.byte_alloc_count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span>.byte_alloc_total += size;</span><br><span class="line">    <span class="literal">Ok</span>(NonNull::new(aligned <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>).unwrap())</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, layout: Layout) -&gt; AllocResult&lt;NonNull&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> align = layout.align();</span><br><span class="line">    <span class="keyword">let</span> size = layout.size();</span><br><span class="line">    <span class="keyword">let</span> aligned = (<span class="keyword">self</span>.b_pos + align - <span class="number">1</span>) &amp; !(align - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> new_b_pos = aligned + size;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> new_b_pos &gt; <span class="keyword">self</span>.p_pos &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Err</span>(AllocError::NoMemory);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">self</span>.b_pos = new_b_pos;</span><br><span class="line">    <span class="keyword">self</span>.byte_alloc_count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span>.byte_alloc_total += size;</span><br><span class="line">    <span class="literal">Ok</span>(NonNull::new(aligned <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>).unwrap())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p>rename<br>这个需要修改一下axfs_ramfs组件大致思路是 获取当前节点（即当前目录)-&gt; 查找要重命名的原始节点 old_node-&gt;拆解 new 路径，获得新文件名新父目录路径-&gt;获取根节点，并从中查找新父目录-&gt;从原目录中移除旧路径-&gt;将 old_node 插入新父目录，使用新文件名</p>
</li>
<li><p>mmap file<br>这个修改较多，在Backend新增了一个FileBacked</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// File-backed mapping backend (lazy load).</span></span><br><span class="line">FileBacked &#123;</span><br><span class="line">    reader: ::alloc::sync::Arc&lt;<span class="keyword">dyn</span> crate::MmapReadFn&gt;,</span><br><span class="line">    file_offset: <span class="built_in">usize</span>,</span><br><span class="line">    area_start: VirtAddr,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在page_fault的时候进行实际内存申请</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Self::FileBacked &#123;</span><br><span class="line">                reader,</span><br><span class="line">                file_offset,</span><br><span class="line">                area_start,</span><br><span class="line">            &#125; =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> va = vaddr.align_down(PAGE_SIZE_4K);</span><br><span class="line">                <span class="keyword">let</span> offset = file_offset + (va.as_usize() - area_start.as_usize());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> vaddr = <span class="keyword">match</span> global_allocator().alloc_pages(<span class="number">1</span>, PAGE_SIZE_4K) &#123;</span><br><span class="line">                    <span class="literal">Ok</span>(vaddr) =&gt; vaddr,</span><br><span class="line">                    <span class="literal">Err</span>(_) =&gt; <span class="keyword">return</span> <span class="literal">false</span>,</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> paddr = virt_to_phys(VirtAddr::from(vaddr));</span><br><span class="line">                <span class="keyword">let</span> buf = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                    core::slice::from_raw_parts_mut(axhal::mem::phys_to_virt(paddr).as_mut_ptr(), PAGE_SIZE_4K)</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">if</span> !(reader)(offset, buf) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                page_table</span><br><span class="line">                    .map_region(</span><br><span class="line">                        va,</span><br><span class="line">                        |_| paddr,</span><br><span class="line">                        PAGE_SIZE_4K,</span><br><span class="line">                        orig_flags,</span><br><span class="line">                        <span class="literal">false</span>,</span><br><span class="line">                        <span class="literal">false</span>,</span><br><span class="line">                    )</span><br><span class="line">                    .map(|tlb| tlb.ignore())</span><br><span class="line">                    .is_ok()</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>mmap</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sys_mmap</span></span>(</span><br><span class="line">    addr: *<span class="keyword">mut</span> <span class="built_in">usize</span>,</span><br><span class="line">    length: <span class="built_in">usize</span>,</span><br><span class="line">    prot: <span class="built_in">i32</span>,</span><br><span class="line">    flags: <span class="built_in">i32</span>,</span><br><span class="line">    fd: <span class="built_in">i32</span>,</span><br><span class="line">    offset: <span class="built_in">isize</span>,</span><br><span class="line">) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> binding = current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> aspace = binding.task_ext().aspace.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vaddr = <span class="keyword">match</span> aspace.find_free_area(</span><br><span class="line">        VirtAddr::from(addr <span class="keyword">as</span> <span class="built_in">usize</span>),</span><br><span class="line">        length,</span><br><span class="line">        VirtAddrRange::from_start_size(aspace.base(), aspace.size()),</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="literal">Some</span>(base) =&gt; base,</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span> -<span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prot_flags = MmapProt::from_bits_truncate(prot);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map_flags = MappingFlags::USER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> prot_flags.contains(MmapProt::PROT_READ) &#123;</span><br><span class="line">        map_flags |= MappingFlags::READ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> prot_flags.contains(MmapProt::PROT_WRITE) &#123;</span><br><span class="line">        map_flags |= MappingFlags::WRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> prot_flags.contains(MmapProt::PROT_EXEC) &#123;</span><br><span class="line">        map_flags |= MappingFlags::EXECUTE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> aligned_len = (length + PAGE_SIZE_4K - <span class="number">1</span>) &amp; !(PAGE_SIZE_4K - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> hint = <span class="keyword">if</span> addr.is_null() &#123;</span><br><span class="line">        aspace.base()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        VirtAddr::from(addr <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> file_obj = <span class="keyword">match</span> get_file_like(fd) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(f) =&gt; f,</span><br><span class="line">        <span class="literal">Err</span>(_) =&gt; <span class="keyword">return</span> -<span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> reader = alloc::sync::Arc::new(<span class="keyword">move</span> |_offset: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]| &#123;</span><br><span class="line">        file_obj.read(buf).is_ok()</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = aspace.mmap_file(vaddr, aligned_len, map_flags, offset <span class="keyword">as</span> <span class="built_in">usize</span>, reader) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vaddr.as_usize() <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>simple_hv<br>这个其实蛮有意思的可以体验到guest操作自己没有权限的指令时候的一个流程以及体验的到page_fault的流程，第一个需要自己在VM中模拟 CSR 访问</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.guest_regs.gprs.set_reg(A1, <span class="number">0x1234</span>);</span><br><span class="line">ctx.guest_regs.sepc += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>第二个可以直接写成成对应的值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.guest_regs.gprs.set_reg(A0, <span class="number">0x6688</span>);</span><br><span class="line">ctx.guest_regs.sepc += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>这个是对Hypervisor很好的一个体验也有了一个初步的认识，包括整个项目中的实验设计是非常好的，每一个新的功能都有一个简单的实验来上手体验，而且正是因为有了arceos也免去了很多最开始操作系统要处理的事情，直接进入体验Hypervisor代码量非常少，实验在risc-v指令集下，整个Hypervisor的体验很丝滑，代码结构很好，可以立马就对VM_ENTRY和VM_EXIT这个有点抽象的概念进行了具象</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>新增的三阶段arceos是非常棒的，整体实验设计也很不错，在有了rcore的基础以后再看arceos是不困难的，一步一步的迈向抽象度更高的操作系统，大家在arceos里已经做了非常多的事情了，使得我们可以如此简单的启动一个os，并且体验到最小化的一个Hypervisor以及宏内核，也再次加深了对操作系统的理解，以及发现软硬协同的重要性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/23/ArceOS-Learning-Record-Anekoqie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/23/ArceOS-Learning-Record-Anekoqie/" class="post-title-link" itemprop="url">ArceOS Learning Record-Anekoqie</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-23 17:13:44" itemprop="dateCreated datePublished" datetime="2025-04-23T17:13:44+00:00">2025-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:25" itemprop="dateModified" datetime="2025-05-18T05:10:25+00:00">2025-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ArceOS-Record"><a href="#ArceOS-Record" class="headerlink" title="ArceOS Record"></a>ArceOS Record</h1><p>ArceOS 的设计可以说优雅而不失健壮性，利用rust优秀的包管理机制和crates的特性组件化地搭建OS，将复杂的OS设计解耦，各个模块功能清晰、层次鲜明，</p>
<p>tutorial出于教学的目的，在modules引入了dependence crates；而在主线arceos中，将解耦做到了极致，形成了清晰的Unikernel层次：dependence crates -&gt; kernel modules -&gt; api -&gt; ulib -&gt; app,下为上提供功能，上到下形成层次鲜明的抽象，这种抽象又为异构内核的实现提供支持，以宏内核为例，其既可以使用api提供的功能，又可以复用kernel modules支持更多的功能，这种自由的复用和组织可以为定制化操作系统提供极大的便利和支持，方便基于需求实现特定OS</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/2025/04/23/ArceOS-Learning-Record-Anekoqie/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/22/zhouyuhan-stage2-and-stage-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/22/zhouyuhan-stage2-and-stage-3/" class="post-title-link" itemprop="url">zhouyuhan-stage2 and stage 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-22 17:14:37" itemprop="dateCreated datePublished" datetime="2025-04-22T17:14:37+00:00">2025-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:26" itemprop="dateModified" datetime="2025-05-18T05:10:26+00:00">2025-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="训练营学习记录"><a href="#训练营学习记录" class="headerlink" title="训练营学习记录"></a>训练营学习记录</h2><p>这篇文章用来记录我在2025春夏季开源操作系统训练营的学习过程，之所以会参加本次训练营，是因为我想进一步学习操作系统以及学习操作系统以及通过完成rcore包括通过完成组件化操作系统进行进一步磨练自己。</p>
<h2 id="训练营二阶段关于rcore实验完成记录"><a href="#训练营二阶段关于rcore实验完成记录" class="headerlink" title="训练营二阶段关于rcore实验完成记录"></a>训练营二阶段关于rcore实验完成记录</h2><p>在第二阶段的学习过程中，我收获颇丰，深入理解了 Rust 语言和操作系统的核心概念。在学习 Rust 语言时，我全面掌握了其独特的所有权、借用和生命周期规则，这些特性为 Rust 提供了强大的内存安全保障。而在操作系统方面，我不再停留在浅显的层面，而是深入探讨了内核架构，从系统启动到各个模块的交互过程有了清晰的认知。特别是在进程管理方面，我了解了进程的创建、销毁及状态转换的原理，并深入分析了不同调度算法对 CPU 资源分配的影响。</p>
<p>在内存管理方面，我深入研究了物理内存分配与虚拟内存映射的机制，了解了页表机制在其中扮演的关键角色，惊叹于内存管理的复杂性与精巧性。在我的个人项目中，我将 Rust 和操作系统的知识结合，参与了从设计、实现到调试的全过程，解决了许多技术难题，这一过程让我不断成长和提升。</p>
<p>这一阶段的学习为我打开了全新的视野，未来我将继续深入探索，将所学的知识更好地应用于实践。</p>
<h2 id="训练营三阶段关于arceos实验以及挑战实验"><a href="#训练营三阶段关于arceos实验以及挑战实验" class="headerlink" title="训练营三阶段关于arceos实验以及挑战实验"></a>训练营三阶段关于arceos实验以及挑战实验</h2><p>print_with_color<br>通过使用 ASCII 字符，实现了简单的控制台颜色输出。</p>
<p>support_hashmap<br>为了快速实现功能，引入了一个现成的库来处理哈希映射。</p>
<p>alt_alloc<br>由于测试用例较为简单，实现难度较低。严格按照要求实现后，我对是否完全正确也并没有特别的把握。</p>
<p>shell<br>在原有的 Shell 实现中，已经有了 rename 功能。为了简化，我直接调用了现有库来处理 rename，同时利用文件创建、复制文件内容和删除原文件的方式，模拟了 mv 命令的功能。</p>
<p>sys_map<br>通过使用 find_free_area 来找到合适的内存区域并进行数据读取，尽管 find_free_area 找到的内存地址并不完全符合 man mmap 的描述，但依旧能够实现所需的功能。</p>
<p>page_fault<br>难度适中，相比于原先的实现，这部分内容更多是基于 rcore 的基础进行了延伸与补充。</p>
<p>simple_hv<br>通过修改 guest 的 sepc 寄存器值，并设置 a0、a1 的值，成功实现了一个基础的 Hypervisor 操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/22/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A53%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-Shao-ZW/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/22/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A53%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-Shao-ZW/" class="post-title-link" itemprop="url">2025春夏开源操作系统训练营3阶段总结-Shao-ZW</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-22 17:00:11" itemprop="dateCreated datePublished" datetime="2025-04-22T17:00:11+00:00">2025-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:25" itemprop="dateModified" datetime="2025-05-18T05:10:25+00:00">2025-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过第三阶段的学习，我理解了组件化操作系统内核的设计理念。相较于2阶段的rcore，这种组件化内核更像是可以随意拼接的积木，可以极大程度的根据自己的需求适配或灵活的扩展内核。开始时，我学习Unikernel这种内核结构，并阅读了如axhal、axruntime、axalloc等关键部分的代码，初步掌握acreos的运行逻辑和代码架构；尝试将arceos扩展为宏内核，也让我进一步体验到组件化内核的奇妙；同时根据PPT初步了解了虚拟化的原理和技术。Arceos的模块化内核很好的结合rust模块的特性，也让我思考模块化内核和微内核是否能够结合起来呢，这或许也是一个扩展方向吧。我第四阶段打算做rust异步运行时，希望能做成一个比较完备的项目！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/21/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-hxingjie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/21/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-hxingjie/" class="post-title-link" itemprop="url">2025春夏季开源操作系统训练营第三阶段总结报告-hxingjie</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-21 19:20:32" itemprop="dateCreated datePublished" datetime="2025-04-21T19:20:32+00:00">2025-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-18 05:10:25" itemprop="dateModified" datetime="2025-05-18T05:10:25+00:00">2025-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/summary-report/" itemprop="url" rel="index"><span itemprop="name">summary report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在过去两周，我学习了Unikernel, Monolithic Kernel, Hypervisor三种内核架构。经过学习，我对组件化操作系统有了初步的认识和掌握。以下是我对这两周学习过程的总结。</p>
<h2 id="二、学习内容"><a href="#二、学习内容" class="headerlink" title="二、学习内容"></a>二、学习内容</h2><ol>
<li>Unikernel</li>
</ol>
<p>学习了Unikernel的基础与框架，包括如何从汇编代码进入到rust代码再进入到内核，并通过axhal -&gt; axruntime -&gt; arceos_api -&gt; axstd 实现控制台的打印输出。</p>
<p>接下来引入了动态内存分配组件，以支持Rust Collections类型。通过引入axalloc模块，实现对内存的管理，并学习了动态内存分配的相关算法。通过这部分的学习，让我理解了rCore中为什么到后面的章节就可以使用Vec等集合类型。</p>
<p>之后引入任务数据结构并构建了通用调度框架，实现了抢占式调度。并实现了文件系统的初始化和文件操作。</p>
<p>实践作业：</p>
<p>实现带颜色的打印输出，理清控制台的打印输出的调用链即可， 可以在不同层次的组件上修改。</p>
<p>手写HashMap，我使用拉链法实现哈希表，并通过引入axhal提供的随机数增强鲁棒性。</p>
<p>实现bump分配算法，根据代码框架，实现EarlyAllocator的初始化和分配函数。</p>
<p>实现rename，首先是需要追踪是如何使用axfs_ramfa的，通过调试，可以发现底层实现是在DirNode，并且源数据结构其实就是btreemap，具体操作并不复杂。</p>
<p>2.Monolithic Kernel</p>
<p>在unikernel的基础上，引入用户态、系统调用等即可完成到宏内核的跨越，这一部分的学习让我更深刻的理解了组件化的优势，扩展task属性实现宏内核的进程管理以及分离调度属性和资源属性的策略更是让我眼前一亮。</p>
<p>实践作业：</p>
<p>实现sys_mmap系统调用，先使用fd读取源文件的内容，分配所需的内存空间，再查找用户态的页表得到相应的物理地址，将源文件内容写入即可。</p>
<p>3.Hypervisor</p>
<p>引入RISC-V H扩展，使原来的S态增强为HS态，并加入了VS态和VU态，通过对特权寄存器的修改，即可跨越到Hypervisor。</p>
<p>主要学习了VM-EXIT，由于Guest不存在M态，所以超出当前特权态的处理能力时会经历 VU -&gt; VS -&gt; (H)S -&gt; M 的过程，本部分的作业也是和 VM-EXIT相关的，通过修改 vmexit_handler 函数以完成作业的要求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/blog/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/69/">69</a><a class="extend next" rel="next" href="/blog/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
