<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/11/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/11/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">718</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">629</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap4/" class="post-title-link" itemprop="url">rcore-handnote-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We don’t want a fixed physical addr for allocation, rather, we want a unified abstract interface for dynamic memory layout for app storage. We call it <strong>Virtual Address</strong></p>
<p>Safety: Every app will be allocated in its own virtual memory space, so each can’t interfere others.</p>
<p>Efficiency: Every app can coexist in same time without demand of reading outer peripherals to switch app.(With development of memory size)</p>
<p>We need <strong>MMU</strong>(Memory Management Unit) to achieve <strong>Address Translation</strong> for interview from virtual to physical.</p>
<p>Different designs occur.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h3 id="Segment-Design"><a href="#Segment-Design" class="headerlink" title="Segment Design"></a>Segment Design</h3><p><img src="/blog/.io//assets/Lab4-1.png" alt="alt text"></p>
<p>Each app exist in one fixed slot for one segment as $[0,bound)$, with a linear map by <strong>MMU</strong>.</p>
<p>Problem: Wasteful and inflexible</p>
<p>We may want a different linear map for each app， for example, its allocation for heap, data, code etc… So we can dispatch memory in more finer style, but it can’t resolve the problem because now even slot is dynamically allocated, it may still exist some free memory too small to reuse, cause the <strong>External Fragment</strong> rather than <strong>Internal Fragment</strong> which is the problem due to fixed slot.</p>
<h3 id="Paging-Design"><a href="#Paging-Design" class="headerlink" title="Paging Design"></a>Paging Design</h3><p><img src="/blog/.io//assets/Lab4-2.png" alt="alt text"><br>We could set a <strong>Protection bit</strong> as <code>r</code> for read, <code>w</code> for write, <code>x</code> for execution.</p>
<p>Another way is to inverse our mind, rather take a slot on memory, we take slot on <strong>MMU</strong>, it can map its slot(now we call it <strong>Page</strong>) for real physical memory layout. To adjust, we can take slice for <strong>Page</strong> to form <strong>Frame</strong> which is a smaller unit to suit physical memory layout, each app can take many <strong>Page Number</strong> for a <strong>Page Table</strong>, record the map.</p>
<h2 id="Page-Design"><a href="#Page-Design" class="headerlink" title="Page Design"></a>Page Design</h2><p><img src="/blog/.io//assets/Lab4-3.png" alt="alt text"></p>
<p><strong>SV39</strong> only use lower 39 bits rather whole 64 bits in design even bit width is 64 bits(it’s a fairly large amount!)</p>
<p>In a address, $[11:0]$ called <strong>Page Offset</strong>, and $[38:12]$ is the <strong>VPN</strong> which will be used for location of page and use offset to direct in one page(with 4KiB in one page).</p>
<p>We should modify <code>satp</code> to open Paging for S and U-level memory.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PAGE_SIZE: <span class="built_in">usize</span> = <span class="number">4096</span></span><br><span class="line"><span class="keyword">const</span> PAGE_SIZE_BIT: <span class="built_in">usize</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>Page Size and offset to slice physical addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/address.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PhysAddr &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">floor</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123; PhysPageNum(<span class="keyword">self</span>.<span class="number">0</span> / PAGE_SIZE) &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ceil</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123; PhysPageNum((<span class="keyword">self</span>.<span class="number">0</span> + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Page Entry to bundle permission and physical page.</p>
<p><img src="/blog/.io//assets/Lab4-4.png" alt></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ppn</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123;</span><br><span class="line">	(<span class="keyword">self</span>.bits &gt;&gt; <span class="number">10</span> &amp; ((<span class="number">1usize</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>)).into()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">flags</span></span>(&amp;<span class="keyword">self</span>) -&gt; PTEFlags &#123;</span><br><span class="line">	PTEFlags::from_bits(<span class="keyword">self</span>.bits <span class="keyword">as</span> <span class="built_in">u8</span>).unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, a simple design for page manager would be a linear map from base addr and follow up. But actually it will take a huge amount of memory due to the storage of offset by base addr for each app.</p>
<p>A finer design is from <strong>Trie</strong>. We will take index slice for each 8 bits(it will fit in to 4KB just right!), it means for each slice has 512 states, and link those state up, form a tree. Usually with 3-level for <strong>Page Index</strong>. Total 27 bits.</p>
<p>Virtual Page will reserve 27 bits for the index slice and 12 bits for offset for certain page. Total 39 bits.</p>
<p>When we transform a virtual addr to physical one, we will do the following exposition reversely.</p>
<h2 id="Page-Management-Design"><a href="#Page-Management-Design" class="headerlink" title="Page Management Design"></a>Page Management Design</h2><p>A simple allocation for page(rather management!) is stack style.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackFrameAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,  <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    end: <span class="built_in">usize</span>,      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on Allocation, we can design <strong>Page Table</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/frame_allocator.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameTracker</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> FrameTracker &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// page cleaning</span></span><br><span class="line">        <span class="keyword">let</span> bytes_array = ppn.get_bytes_array();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bytes_array &#123;</span><br><span class="line">            *i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ppn &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTable</span></span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="built_in">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It means for one physical page, we will record each allocation by vector of FrameTracker as a representation of real <strong>Frame</strong> after the root.</p>
<p>We should design transformation from virtual addr to physical addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each idxs represent index slices of virtual addr.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> pte = &amp;<span class="keyword">mut</span> ppn.get_pte_array()[idxs[i]];</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">		result = <span class="literal">Some</span>(pte);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !pte.is_valid() &#123;</span><br><span class="line">		<span class="keyword">let</span> frame = frame_alloc().unwrap();</span><br><span class="line">		<span class="comment">// create or return None</span></span><br><span class="line">		*pte = PageTableEntry::new(frame.ppn, PTEFlags::V);</span><br><span class="line">		<span class="keyword">self</span>.frames.push(frame);</span><br><span class="line">	&#125;</span><br><span class="line">	ppn = pte.ppn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Page-Map-Design"><a href="#Page-Map-Design" class="headerlink" title="Page Map Design"></a>Page Map Design</h2><p>Based on our abstraction, we need a design for <code>MapArea</code> to given a map from continuous virtual address(no matter their corresponding page!) to physical address.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapArea</span></span> &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on continuous virtual address map, we can define discontinuous map for one app.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemorySet</span></span> &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="built_in">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// impl MemorySet</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;) &#123;</span><br><span class="line">	<span class="comment">// map range of virtual addr in allocation in page_table</span></span><br><span class="line">	map_area.map(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table);</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(data) = data &#123;</span><br><span class="line">		map_area.copy_data(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.page_table, data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">self</span>.areas.push(map_area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In Each <code>MapArea</code> allocated for some key-value for virtual-physical addr, it will allocate the same for <code>PageTable</code> for <strong>Frame</strong>.</p>
<hr>
<h2 id="Allocation-Space"><a href="#Allocation-Space" class="headerlink" title="Allocation Space"></a>Allocation Space</h2><p>To open SV39, we should write instruction for <code>satp</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/mm/page_table.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">token</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="number">8usize</span> &lt;&lt; <span class="number">60</span> | <span class="keyword">self</span>.root_ppn.<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">activate</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> satp = <span class="keyword">self</span>.page_table.token();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            satp::write(satp);</span><br><span class="line">            asm!(<span class="string">"sfence.vma"</span> :::: <span class="string">"volatile"</span>);</span><br><span class="line">			<span class="comment">// sfence.vma is a special instruction to clear `Translaton Lookaside Buffer` which is used for quick search for memory addr to reduce performance expenses.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Therefore, it will fill current root of physical page number as activation.</p>
<p>Notice that we should make instruction contigeous for <code>SV39</code> open in physical address to amend the gap of transformation of address before and after open.</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>Initiation for Kernel memory layout.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> memory_set = Self::new_bare();</span><br><span class="line"><span class="comment">// map trampoline</span></span><br><span class="line">memory_set.map_trampoline();</span><br><span class="line">memory_set.push(MapArea::new(</span><br><span class="line">	(stext <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">	(etext <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">	MapType::Identical,</span><br><span class="line">	MapPermission::R | MapPermission::X,</span><br><span class="line">), <span class="literal">None</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"mapping .rodata section"</span>);</span><br><span class="line"><span class="comment">// other layout ...</span></span><br></pre></td></tr></table></figure>

<p>Initiation for App memory layout.</p>
<p>Previously, we will cut off <code>elf</code> part of binary of apps, now we load it and extract useful infos, s.t. Permissions.</p>
<p><code>MemorySet</code> should allocate storage of execution code with its permissions, allocate user stack and trap context at top of the memory layout.</p>
<p>Output <code>MemorySet</code>, user stack top, entry point addr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> max_end_vpn = VirtPageNum(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> max_end_va: VirtAddr = max_end_vpn.into();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user_stack_bottom: <span class="built_in">usize</span> = max_end_va.into();</span><br><span class="line"><span class="comment">// guard page</span></span><br><span class="line">user_stack_bottom += PAGE_SIZE;</span><br><span class="line"><span class="keyword">let</span> user_stack_top = user_stack_bottom + USER_STACK_SIZE;</span><br><span class="line">memory_set.push(MapArea::new(</span><br><span class="line">	TRAP_CONTEXT.into(),</span><br><span class="line">	TRAMPOLINE.into(),</span><br><span class="line">	MapType::Framed,</span><br><span class="line">	MapPermission::R | MapPermission::W,</span><br><span class="line">), <span class="literal">None</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="App"><a href="#App" class="headerlink" title="App"></a>App</h3><p>A problem is that separation of Kernel and App will also isolate <strong>Trap</strong>, the process need info from App to Kernel but App can’t see it. Therefore, we need a transfer operation. We achieve this by storing related info in <code>TrapContext</code>.</p>
<p>(Because there’s no more register to store these without breaking state like <code>sscratch</code> designed for kernel stack.)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line">	<span class="comment">// new:</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="built_in">usize</span>, </span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that we also need to modify below to trigger <code>satp</code> and specify corresponding(U-level, S-level <code>satp</code>) physical page number to change state.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># __alltraps:</span><br><span class="line"></span><br><span class="line"># load kernel_satp into t0</span><br><span class="line">ld t0, 34*8(sp)</span><br><span class="line"># load trap_handler into t1</span><br><span class="line">ld t1, 36*8(sp)</span><br><span class="line"># move to kernel_sp</span><br><span class="line">ld sp, 35*8(sp)</span><br><span class="line"># switch to kernel space</span><br><span class="line">csrw satp, t0</span><br><span class="line">sfence.vma</span><br><span class="line"># jump to trap_handler</span><br><span class="line">jr t1</span><br><span class="line"></span><br><span class="line"># __restore:</span><br><span class="line"># a0: *TrapContext in user space(Constant); a1: user space token</span><br><span class="line"># switch to user space</span><br><span class="line">csrw satp, a1</span><br><span class="line">sfence.vma</span><br><span class="line">csrw sscratch, a0</span><br></pre></td></tr></table></figure>

<p>To amend the problem of contigeous instructions after switch, we need to adjust memory layout for <code>trampoline</code> which is in the same location in U-level and S-level(<strong>unified for all app to trap!</strong>). It will be placed at highest virtual page.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># os&#x2F;src&#x2F;linker.ld</span><br><span class="line"></span><br><span class="line">    stext &#x3D; .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">+        . &#x3D; ALIGN(4K);</span><br><span class="line">+        strampoline &#x3D; .;</span><br><span class="line">+        *(.text.trampoline);</span><br><span class="line">+        . &#x3D; ALIGN(4K);</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>We modify rather raw handler and restore, due to virtual address, we need to adjust it for <code>trampoline</code> rather the address we had code!(<strong>it’s virtual!</strong>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_handler</span></span>() -&gt; ! &#123;</span><br><span class="line">    set_kernel_trap_entry();</span><br><span class="line">    <span class="keyword">let</span> cx = current_trap_cx();</span><br><span class="line">    <span class="keyword">let</span> scause = scause::read();</span><br><span class="line">    <span class="keyword">let</span> stval = stval::read();</span><br><span class="line">    <span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    trap_return();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">trap_return</span></span>() -&gt; ! &#123;</span><br><span class="line">    set_user_trap_entry();</span><br><span class="line">    <span class="keyword">let</span> trap_cx_ptr = TRAP_CONTEXT;</span><br><span class="line">    <span class="keyword">let</span> user_satp = current_user_token();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__alltraps</span></span>();</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">__restore</span></span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> restore_va = __restore <span class="keyword">as</span> <span class="built_in">usize</span> - __alltraps <span class="keyword">as</span> <span class="built_in">usize</span> + TRAMPOLINE;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">"fence.i"</span>,</span><br><span class="line">            <span class="string">"jr &#123;restore_va&#125;"</span>,</span><br><span class="line">            restore_va = <span class="keyword">in</span>(reg) restore_va,</span><br><span class="line">            <span class="keyword">in</span>(<span class="string">"a0"</span>) trap_cx_ptr,</span><br><span class="line">            <span class="keyword">in</span>(<span class="string">"a1"</span>) user_satp,</span><br><span class="line">            options(noreturn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Unreachable in back_to_user!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then map the virtual address for it up to the physical address for unifying.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> TRAMPOLINE: <span class="built_in">usize</span> = <span class="built_in">usize</span>::MAX - PAGE_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/mm/memory_set.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="comment">/// Mention that trampoline is not collected by areas.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map_trampoline</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.page_table.map(</span><br><span class="line">            VirtAddr::from(TRAMPOLINE).into(),</span><br><span class="line">            PhysAddr::from(strampoline <span class="keyword">as</span> <span class="built_in">usize</span>).into(),</span><br><span class="line">            PTEFlags::R | PTEFlags::X,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We should adjust <code>TaskControlBlock</code> for the same reason, record each <code>Trap</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It will read data getting from elf, get trap contexr ppn, its kernel stack bottom and top, and then initiate trap context.</p>
<p>Here the part of task control initiation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskContext &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">goto_trap_return</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            ra: trap_return <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">            s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn new(elf_data: &amp;[u8], app_id: usize) -&gt; Self </span></span><br><span class="line"><span class="keyword">let</span> task_control_block = <span class="keyword">Self</span> &#123;</span><br><span class="line">	task_status,</span><br><span class="line">	task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><br><span class="line">	memory_set,</span><br><span class="line">	trap_cx_ppn,</span><br><span class="line">	base_size: user_sp,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// prepare TrapContext in user space</span></span><br><span class="line"><span class="keyword">let</span> trap_cx = task_control_block.get_trap_cx();</span><br><span class="line">*trap_cx = TrapContext::app_init_context(</span><br><span class="line">	entry_point,</span><br><span class="line">	user_sp,</span><br><span class="line">	KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">	kernel_stack_top,</span><br><span class="line">	trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">);</span><br><span class="line">task_control_block</span><br></pre></td></tr></table></figure>









      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap5/" class="post-title-link" itemprop="url">rcore-handnote-5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>After the demand of code execution one by one, we want to introduce <strong>Process</strong> which will be a full space-time description of execution process of binary file in OS. It means for one process, it should hold independent resources to be executed.</p>
<p>After <strong>Process</strong>, <strong>Thread</strong> and <strong>Coroutine</strong> are also developed in growth of OS. They are different in resources taken up, usually, <strong>Thread</strong> will be in one process and hold their own independent stack and workflow; <strong>Coroutine</strong> will be in one <strong>Thread</strong> and hold their own independent workflow.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>Every process need independent memory layout, can be dispatch by cpu. It’s the functionality based on <strong>Task</strong>, after that, each process can <strong>Fork</strong> their own children processes, so there’s a workflow in time discrepancy. Its resource can’t be recycled in time due to children processes, we need to mark it as <strong>Zombie Process</strong>.</p>
<p>To clarify which is children, which is parent, and each isolated process, we mark each with <strong>PID-Process Identifier</strong>. Notice if we fork a process, it will be same as parent only <code>a0</code> which is the register called for return will be different, parent process return new PID of child process, child process return 0 as none of fork.</p>
<ul>
<li>fork: copy a process state(like <code>sp</code> etc…) as its child process.</li>
<li>waitpid: wait a child become zombie and recycle all resources.</li>
<li>exec: clear a process state and load a execution file.</li>
</ul>
<hr>
<h3 id="Data-Constructon"><a href="#Data-Constructon" class="headerlink" title="Data Constructon"></a>Data Constructon</h3><p>We will recycle all presumed pid by <code>PidAllocator</code>, No need to worry about previous pid used.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PidHandle</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PidAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,</span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl PidAllocator</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; PidHandle &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(pid) = <span class="keyword">self</span>.recycled.pop() &#123;</span><br><span class="line">		PidHandle(pid)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">		PidHandle(<span class="keyword">self</span>.current - <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Therefore, if one pid recycled, it deallocated memory can be reused, we will define its <code>KernelStack</code> addr by pid.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/pid.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KernelStack</span></span> &#123;</span><br><span class="line">    pid: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_stack_position</span></span>(app_id: <span class="built_in">usize</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = TRAMPOLINE - app_id * (KERNEL_STACK_SIZE + PAGE_SIZE);</span><br><span class="line">    <span class="keyword">let</span> bottom = top - KERNEL_STACK_SIZE;</span><br><span class="line">    (bottom, top)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl KernelStack</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_on_top</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, value: T) -&gt; *<span class="keyword">mut</span> T <span class="keyword">where</span></span><br><span class="line">	T: <span class="built_in">Sized</span>, &#123;</span><br><span class="line">	<span class="keyword">let</span> kernel_stack_top = <span class="keyword">self</span>.get_top();</span><br><span class="line">	<span class="keyword">let</span> ptr_mut = (kernel_stack_top - core::mem::size_of::&lt;T&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> T;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123; *ptr_mut = value; &#125;</span><br><span class="line">	ptr_mut</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_top</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> (_, kernel_stack_top) = kernel_stack_position(<span class="keyword">self</span>.pid);</span><br><span class="line">	kernel_stack_top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> KernelStack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> (kernel_stack_bottom, _) = kernel_stack_position(<span class="keyword">self</span>.pid);</span><br><span class="line">        <span class="keyword">let</span> kernel_stack_bottom_va: VirtAddr = kernel_stack_bottom.into();</span><br><span class="line">        KERNEL_SPACE</span><br><span class="line">            .exclusive_access()</span><br><span class="line">            .remove_area_with_start_vpn(kernel_stack_bottom_va.into());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We need to construct <code>TaskControlBlock</code> for parent and children process.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// new:</span></span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="built_in">Option</span>&lt;Weak&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> children: <span class="built_in">Vec</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl TaskControlBlockInner</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_zombie</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.get_status() == TaskStatus::Zombie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TaskManager</code> manage all tasks and cpu dispatch, we will separate only tasks management for <code>TaskManager</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/manager.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: UPSafeCell&lt;TaskManager&gt; = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        UPSafeCell::new(TaskManager::new())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_task</span></span>(task: Arc&lt;TaskControlBlock&gt;) &#123;</span><br><span class="line">    TASK_MANAGER.exclusive_access().add(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_task</span></span>() -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    TASK_MANAGER.exclusive_access().fetch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And cpu dispatch for newly introduced <strong>Processor</strong>.<br>We introduce a <strong>idle process</strong> that used to call other process.</p>
<ul>
<li>Why not direct call next by previous one? rather use idle process?</li>
<li>Separate idle process for <strong>start</strong> and others for its own, then dispatch data won’t occur in other process and make the dispatch process invisible for <strong>Trap</strong> for each process.</li>
</ul>
<p>The whole workflow would be:</p>
<ul>
<li>idle process fetch task and switch</li>
<li>task run out of its time or finish</li>
<li>task switch to idle process</li>
<li>repeat…</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Processor</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">	<span class="comment">// idle process of current cpu</span></span><br><span class="line">    idle_task_cx: TaskContext,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> PROCESSOR: UPSafeCell&lt;Processor&gt; = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        UPSafeCell::new(Processor::new())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run_tasks() </span></span><br><span class="line"><span class="comment">// loop to fetch task and switch possible task</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = fetch_task() &#123;</span><br><span class="line">    <span class="keyword">let</span> idle_task_cx_ptr = processor.get_idle_task_cx_ptr();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> next_task_cx_ptr = &amp;task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">    task_inner.task_status = TaskStatus::Running;</span><br><span class="line">    <span class="built_in">drop</span>(task_inner);</span><br><span class="line">    processor.current = <span class="literal">Some</span>(task);</span><br><span class="line">    <span class="built_in">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(</span><br><span class="line">            idle_task_cx_ptr,</span><br><span class="line">            next_task_cx_ptr,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch to idle process if one task run out of its time.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">schedule</span></span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> processor = PROCESSOR.exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> idle_task_cx_ptr = processor.get_idle_task_cx_ptr();</span><br><span class="line">    <span class="built_in">drop</span>(processor);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(</span><br><span class="line">            switched_task_cx_ptr,</span><br><span class="line">            idle_task_cx_ptr,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Dispatch-Construction"><a href="#Dispatch-Construction" class="headerlink" title="Dispatch Construction"></a>Dispatch Construction</h3><p>Previously, we use <code>suspend_current_and_run_next</code> to pause task and switch to next, now we need to adapt it to process design.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">suspend_current_and_run_next</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> task = take_current_task().unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- access current TCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> task_cx_ptr = &amp;<span class="keyword">mut</span> task_inner.task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">    task_inner.task_status = TaskStatus::Ready;</span><br><span class="line">    <span class="built_in">drop</span>(task_inner);</span><br><span class="line">    <span class="comment">// ---- stop exclusively accessing current PCB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to task deque</span></span><br><span class="line">    add_task(task);</span><br><span class="line">    <span class="comment">// change current to idle process</span></span><br><span class="line">    schedule(task_cx_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In previous case, task won’t be created by its parent task, but process will. So, if its <code>TrapContext</code> has been recycled, we need to refactor our <code>trap_handler</code> for such case.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn trap_handler() -&gt; !</span></span><br><span class="line">Trap::Exception(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">    <span class="comment">// jump to next instruction anyway</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cx = current_trap_cx();</span><br><span class="line">    cx.sepc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// syscall may create new process and change trap context.</span></span><br><span class="line">    <span class="keyword">let</span> result = syscall(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]);</span><br><span class="line">    <span class="comment">// wether cx is changed or not, we will refetch it.</span></span><br><span class="line">    cx = current_trap_cx();</span><br><span class="line">    cx.x[<span class="number">10</span>] = result <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Now we will construct <code>fork</code>, <code>exec</code>, <code>waitpid</code>,<code>exit</code>.</p>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><p>We need to copy all memory layout and its task state. Then reallocate new kernel stack for it.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl MemorySet</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_existed_user</span></span>(user_space: &amp;MemorySet) -&gt; MemorySet &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> memory_set = Self::new_bare();</span><br><span class="line">    <span class="comment">// map trampoline</span></span><br><span class="line">    memory_set.map_trampoline();</span><br><span class="line">    <span class="comment">// copy data sections/trap_context/user_stack</span></span><br><span class="line">    <span class="keyword">for</span> area <span class="keyword">in</span> user_space.areas.iter() &#123;</span><br><span class="line">        <span class="keyword">let</span> new_area = MapArea::from_another(area);</span><br><span class="line">        memory_set.push(new_area, <span class="literal">None</span>);</span><br><span class="line">        <span class="comment">// copy data from another space</span></span><br><span class="line">        <span class="keyword">for</span> vpn <span class="keyword">in</span> area.vpn_range &#123;</span><br><span class="line">            <span class="keyword">let</span> src_ppn = user_space.translate(vpn).unwrap().ppn();</span><br><span class="line">            <span class="keyword">let</span> dst_ppn = memory_set.translate(vpn).unwrap().ppn();</span><br><span class="line">            dst_ppn.get_bytes_array().copy_from_slice(src_ppn.get_bytes_array());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl TaskControlBlock</span></span><br><span class="line"><span class="comment">// fn fork</span></span><br><span class="line"><span class="keyword">let</span> trap_cx_ppn = memory_set</span><br><span class="line">    .translate(VirtAddr::from(TRAP_CONTEXT).into())</span><br><span class="line">    .unwrap()</span><br><span class="line">    .ppn();</span><br><span class="line"><span class="comment">// alloc a pid and a kernel stack in kernel space</span></span><br><span class="line"><span class="keyword">let</span> pid_handle = pid_alloc();</span><br><span class="line"><span class="keyword">let</span> kernel_stack = KernelStack::new(&amp;pid_handle);</span><br><span class="line"><span class="keyword">let</span> kernel_stack_top = kernel_stack.get_top();</span><br><span class="line"><span class="keyword">let</span> task_control_block = Arc::new(TaskControlBlock &#123;</span><br><span class="line">    pid: pid_handle,</span><br><span class="line">    kernel_stack,</span><br><span class="line">    inner: <span class="keyword">unsafe</span> &#123; UPSafeCell::new(TaskControlBlockInner &#123;</span><br><span class="line">        trap_cx_ppn,</span><br><span class="line">        base_size: parent_inner.base_size,</span><br><span class="line">        task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><br><span class="line">        task_status: TaskStatus::Ready,</span><br><span class="line">        memory_set,</span><br><span class="line">        parent: <span class="literal">Some</span>(Arc::downgrade(<span class="keyword">self</span>)),</span><br><span class="line">        children: <span class="built_in">Vec</span>::new(),</span><br><span class="line">        exit_code: <span class="number">0</span>,</span><br><span class="line">    &#125;)&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// add child</span></span><br><span class="line">parent_inner.children.push(task_control_block.clone());</span><br><span class="line"><span class="comment">// modify kernel_sp in trap_cx</span></span><br><span class="line"><span class="comment">// **** access children PCB exclusively</span></span><br><span class="line"><span class="keyword">let</span> trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><br><span class="line">trap_cx.kernel_sp = kernel_stack_top;</span><br></pre></td></tr></table></figure>

<p>Finally, implement <code>sys_fork</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current_task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> new_task = current_task.fork();</span><br><span class="line">    <span class="keyword">let</span> new_pid = new_task.pid.<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> trap_cx = new_task.inner_exclusive_access().get_trap_cx();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for child process, fork returns 0</span></span><br><span class="line">    trap_cx.x[<span class="number">10</span>] = <span class="number">0</span>;  <span class="comment">//x[10] is a0 reg</span></span><br><span class="line"></span><br><span class="line">    add_task(new_task);</span><br><span class="line">    new_pid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that if <code>trap_handler</code> call <code>sys_fork</code>, parent process <code>x[10]</code> would be <code>new_pid</code> as return value.</p>
<h4 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h4><p>If we want to execute a task by its name, we need to first load string in app load.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/build.rs</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">writeln!</span>(f, r#<span class="string">"</span></span><br><span class="line"><span class="string">.global _app_names</span></span><br><span class="line"><span class="string">_app_names:"</span>#)?;</span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> apps.iter() &#123;</span><br><span class="line">    <span class="built_in">writeln!</span>(f, <span class="string">r#"    .string "&#123;&#125;""#</span>, app)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># link_app.S</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">_app_names:</span><br><span class="line">    .string &quot;exit&quot;</span><br><span class="line">    .string &quot;fantastic_text&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Construct <code>APP_NAMES</code> as global state in OS.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/loader.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// APP_NAMES: Vec&lt;&amp;'static str&gt; &#123;...</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..num_app &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> end = start;</span><br><span class="line">    <span class="keyword">while</span> end.read_volatile() != <span class="string">'\0'</span> <span class="keyword">as</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">        end = end.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slice = core::slice::from_raw_parts(start, end <span class="keyword">as</span> <span class="built_in">usize</span> - start <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">str</span> = core::<span class="built_in">str</span>::from_utf8(slice).unwrap();</span><br><span class="line">    v.push(<span class="built_in">str</span>);</span><br><span class="line">    start = end.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When execute a new binary file, we need to read it and extract all state to replace original one.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><br><span class="line">        <span class="keyword">let</span> trap_cx_ppn = memory_set</span><br><span class="line">            .translate(VirtAddr::from(TRAP_CONTEXT).into())</span><br><span class="line">            .unwrap()</span><br><span class="line">            .ppn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **** access inner exclusively</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner_exclusive_access();</span><br><span class="line">        inner.memory_set = memory_set;</span><br><span class="line">        inner.trap_cx_ppn = trap_cx_ppn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> trap_cx = inner.get_trap_cx();</span><br><span class="line">        *trap_cx = TrapContext::app_init_context(</span><br><span class="line">            entry_point,</span><br><span class="line">            user_sp,</span><br><span class="line">            KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">            <span class="keyword">self</span>.kernel_stack.get_top(),</span><br><span class="line">            trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// **** stop exclusively accessing inner automatically</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will read input <code>str</code> as a ptr and replace current task state.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(data) = get_app_data_by_name(path.as_str()) &#123;</span><br><span class="line">        <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">        task.exec(data);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exit"><a href="#Exit" class="headerlink" title="Exit"></a>Exit</h4><p>When a task exit, it will return a <strong>exit code</strong> assigned by app if successfully or kernel if anomaly.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn exit_current_and_run_next(exit_code:i32)</span></span><br><span class="line">    inner.task_status = TaskStatus::Zombie;</span><br><span class="line">    inner.exit_code = exit_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move all its children to the initial process</span></span><br><span class="line">    <span class="comment">// ++++++ access initproc TCB exclusively</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> initproc_inner = INITPROC.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> inner.children.iter() &#123;</span><br><span class="line">            child.inner_exclusive_access().parent = <span class="literal">Some</span>(Arc::downgrade(&amp;INITPROC));</span><br><span class="line">            initproc_inner.children.push(child.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ++++++ stop exclusively accessing parent PCB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear all memory.</span></span><br><span class="line">    inner.children.clear();</span><br><span class="line">    inner.memory_set.recycle_data_pages();</span><br><span class="line">    <span class="built_in">drop</span>(inner);</span><br><span class="line">    <span class="comment">// **** stop exclusively accessing current PCB</span></span><br><span class="line">    <span class="comment">// drop task manually to maintain rc correctly</span></span><br><span class="line">    <span class="built_in">drop</span>(task);</span><br><span class="line">    <span class="comment">// use _unused replace original context, which will be recycled by rust.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> _unused = TaskContext::zero_init();</span><br><span class="line">    schedule(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> _);</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exit</span></span>(exit_code: <span class="built_in">i32</span>) -&gt; ! &#123;</span><br><span class="line">    exit_current_and_run_next(exit_code);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Unreachable in sys_exit!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WaitPid"><a href="#WaitPid" class="headerlink" title="WaitPid"></a>WaitPid</h4><p>WaitPid will return <code>-1</code> if there’s no specified pid process exist, if it’s running, return <code>-2</code>, finally, if it finished, recycle it and return <code>0</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sys_waitpid(pid:uisze, exit_code_ptr:*mut i32) -&gt; isize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 case</span></span><br><span class="line"><span class="comment">// search task manager and find (task_block)</span></span><br><span class="line">|p| &#123;pid == -<span class="number">1</span> || pid <span class="keyword">as</span> <span class="built_in">usize</span> == p.getpid()&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pair = <span class="comment">// search task managers and find (idx,task_block)</span></span><br><span class="line">p.inner_exclusive_access().is_zombie() &amp;&amp; (pid == -<span class="number">1</span> || pid <span class="keyword">as</span> <span class="built_in">usize</span> == p.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((idx,_)) = pair &#123;</span><br><span class="line">    <span class="keyword">let</span> child = inner.children.remove(idx);</span><br><span class="line">    <span class="comment">// confirm that child will be deallocated after removing from children list</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(Arc::strong_count(&amp;child), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> found_pid = child.getpid();</span><br><span class="line">    <span class="comment">// ++++ temporarily access child TCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> exit_code = child.inner_exclusive_access().exit_code;</span><br><span class="line">    <span class="comment">// ++++ stop exclusively accessing child PCB</span></span><br><span class="line">    *translated_refmut(inner.memory_set.token(), exit_code_ptr) = exit_code;</span><br><span class="line">    found_pid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// pid process is running</span></span><br><span class="line">    -<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(exit_code: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> sys_waitpid(-<span class="number">1</span>, exit_code <span class="keyword">as</span> *<span class="keyword">mut</span> _) &#123;</span><br><span class="line">            -<span class="number">2</span> =&gt; &#123; yield_(); &#125;</span><br><span class="line">            <span class="comment">// -1 or a real pid</span></span><br><span class="line">            exit_pid =&gt; <span class="keyword">return</span> exit_pid,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap6-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap6-1/" class="post-title-link" itemprop="url">rcore-handnote-6-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-6-1"><a href="#Chapter-6-1" class="headerlink" title="Chapter 6-1"></a>Chapter 6-1</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The demand of persistent storage is with growth of computer. Currently we can only store things on our map memory, but it’s only exist in running time, which is <strong>Internal Storage</strong>, now we want to store it to <strong>External Storage</strong>.</p>
<h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><h4 id="Regular-File"><a href="#Regular-File" class="headerlink" title="Regular File"></a>Regular File</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> os/src/</span><br><span class="line"><span class="built_in">stat</span> main.rs</span><br><span class="line"></span><br><span class="line">File: main.rs</span><br><span class="line">Size: 940           Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049d  Inode: 4975        Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/   oslab)   Gid: ( 1000/   oslab)</span><br><span class="line">Access: 2021-02-28 23:32:50.289925450 +0800</span><br><span class="line">Modify: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Change: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure>

<p>Beside usual info, if one file is not <code>regular</code>, it’s usually a block device file or character device file, whose major/minor ID will be shown.</p>
<ul>
<li>Links: alias name for one file</li>
<li>Inode: the underneath id used to route</li>
<li>Uid: the file belonged user id.</li>
<li>Gid: the file begloned group id.</li>
<li>Blocks: take amount of blocks(in linux, it’s 4096KB).</li>
</ul>
<h4 id="Dir"><a href="#Dir" class="headerlink" title="Dir"></a>Dir</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> os</span><br><span class="line">File: os</span><br><span class="line">Size: 4096          Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: 801h/2049d  Inode: 4982        Links: 5</span><br><span class="line">Access: (0755/drwxr-xr-x)  Uid: ( 1000/   oslab)   Gid: ( 1000/   oslab)</span><br><span class="line">Access: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Modify: 2021-02-28 23:32:50.129927180 +0800</span><br><span class="line">Change: 2021-02-28 23:32:50.129927180 +0800</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure>

<ul>
<li>Access:<ul>
<li>d: dir</li>
<li>r: allowed to read files and subdir</li>
<li>w: allowed to create and delete files and subdir</li>
<li>x: allowed to “pass” this dir.</li>
</ul>
</li>
</ul>
<h4 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h4><p>Play the role of mapping the given dir tree structure to persistent storage. For example: windows-FAT/NTPS; linux-Ext3/Ext4/Btrfs. Therefore, construct a <strong>VFS-Virtual File System</strong> is necessary to restrict unified interface.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h4><ul>
<li>flatten: only root dir <code>/</code></li>
<li>permission: only user and no restriction on file access</li>
<li>no timestamp</li>
<li>no soft/hard link</li>
<li>many…</li>
</ul>
<p><img src="/blog/.io//assets/Lab6-1.png" alt></p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>For a persistent external storage, it will separate file in basic storage unit. Which is called <strong>sector</strong>(usually 512 bytes, 4KB), rather, file system will set its own storage unit which is called <strong>block</strong>, usually different from sector, but in this implementation, we set it as 512 bytes, same as sector.</p>
<p>A basic interface from device is:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/block_dev.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">BlockDevice</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> + Any &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File will not read and write directly often which will slow down speed, we will construct <strong>Block Cache</strong> to store read data. Then we unify all block cache in to a manager with limit size and used for allocation and deallocation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> BLOCK_SZ: <span class="built_in">usize</span> = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/block_cache.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ],</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    modified: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>&lt;T, V&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;T) -&gt; V) -&gt; V &#123;</span><br><span class="line">        f(<span class="keyword">self</span>.get_ref(offset))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">modify</span></span>&lt;T, V&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset:<span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> T) -&gt; V) -&gt; V &#123;</span><br><span class="line">        f(<span class="keyword">self</span>.get_mut(offset))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/block_cache.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BLOCK_CACHE_SIZE: <span class="built_in">usize</span> = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> alloc::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCacheManager</span></span> &#123;</span><br><span class="line">    queue: VecDeque&lt;(<span class="built_in">usize</span>, Arc&lt;Mutex&lt;BlockCache&gt;&gt;)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BlockCacheManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; queue: VecDeque::new() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl BlockCacheManager</span></span><br><span class="line"><span class="comment">// fn get_block_cache(&amp;mut self, block_id:usize, block_device: Arc&lt;dyn BlockDevice&gt;)</span></span><br><span class="line"><span class="comment">// if reach limit size:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.queue.len() == BLOCK_CACHE_SIZE &#123;</span><br><span class="line">    <span class="comment">// from front to tail</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((idx, _)) = <span class="keyword">self</span>.queue</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .find(|(_, pair)| Arc::strong_count(&amp;pair.<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.queue.drain(idx..=idx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">"Run out of BlockCache!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// load block into mem and push back</span></span><br><span class="line"><span class="keyword">let</span> block_cache = Arc::new(Mutex::new(</span><br><span class="line">    BlockCache::new(block_id, Arc::clone(&amp;block_device))</span><br><span class="line">));</span><br><span class="line"><span class="keyword">self</span>.queue.push_back((block_id, Arc::clone(&amp;block_cache)));</span><br><span class="line">block_cache</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Block-Layout"><a href="#Block-Layout" class="headerlink" title="Block Layout"></a>Block Layout</h4><p><img src="/blog/.io//assets/Lab6-2.png" alt="alt text"></p>
<p>We will design a whole map structure to control block caches.</p>
<p>First is <strong>Super Block</strong> which is a head to control everything, notice <code>magic</code> is magic number in mathematics to check the integrity of structure.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span></span> &#123;</span><br><span class="line">    magic: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.magic == EFS_MAGIC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bit Map</strong> is a nice structure to handle mapping operations, we set each block as 512 bytes(4KB), each bits represent a state of allocation(<code>1/0</code> for allocated/deallocated).</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/bitmap.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// notice it only store the id of start block and the len of blocks in its range.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitmap</span></span> &#123;</span><br><span class="line">    start_block_id: <span class="built_in">usize</span>,</span><br><span class="line">    blocks: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the true structure to map</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BitmapBlock</span></span> = [<span class="built_in">u64</span>; <span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// equal: 4096 bits</span></span><br><span class="line"><span class="keyword">const</span> BLOCK_BITS: <span class="built_in">usize</span> = BLOCK_SZ * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Bitmap &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> block_id <span class="keyword">in</span> <span class="number">0</span>..<span class="keyword">self</span>.blocks &#123;</span><br><span class="line">            <span class="keyword">let</span> pos = get_block_cache(</span><br><span class="line">                block_id + <span class="keyword">self</span>.start_block_id <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device),</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .modify(<span class="number">0</span>, |bitmap_block: &amp;<span class="keyword">mut</span> BitmapBlock| &#123;</span><br><span class="line">                <span class="comment">// core!</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((bits64_pos, inner_pos)) = bitmap_block</span><br><span class="line">                    .iter()</span><br><span class="line">                    .enumerate()</span><br><span class="line">                    .find(|(_, bits64)| **bits64 != <span class="built_in">u64</span>::MAX)</span><br><span class="line">                    .map(|(bits64_pos, bits64)| &#123;</span><br><span class="line">                        (bits64_pos, bits64.trailing_ones() <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">                    &#125;) &#123;</span><br><span class="line">                    <span class="comment">// modify cache</span></span><br><span class="line">                    bitmap_block[bits64_pos] |= <span class="number">1u64</span> &lt;&lt; inner_pos;</span><br><span class="line">                    <span class="literal">Some</span>(block_id * BLOCK_BITS + bits64_pos * <span class="number">64</span> + inner_pos <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="literal">None</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> pos.is_some() &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on such structure, we could exposit what is <strong>Inode</strong> and <strong>Data</strong> Block, not all block will store real data because some of them need to be used as guidance. However, we also need to know where and how these route blocks be allocated. That’s the reason of <strong>Bit Map</strong>! Now we delve into <strong>Inode</strong>.</p>
<p>To make one inode control many data blocks, we will design layer of route for it. Beside direct index, it also store the index of layer 1 and layer 2 to route other index block(which is considered same as data block), and route to real data block. Notice one block contains 512 bytes, which is 512 u8, so it contains 512/4 = 128 u32, so one index block can route 128 * 512 bytes = 128 * 0.5 KB = 64 KB in one layer. In second layer, it can route as much as 128 * 64 KB = 64 MB.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INODE_DIRECT_COUNT: <span class="built_in">usize</span> = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// 128</span></span><br><span class="line"><span class="keyword">const</span> INODE_INDIRECT1_COUNT: <span class="built_in">usize</span> = BLOCK_SZ / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DiskInodeType</span></span> &#123;</span><br><span class="line">    File,</span><br><span class="line">    Directory,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Such <strong>Inode</strong> take 128 bytes, so in one block, it could contains 4 inodes. We should make a data structure could be fit exactly into a block size. Now we design route method.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 28 + 128</span></span><br><span class="line"><span class="keyword">const</span> INDIRECT1_BOUND: <span class="built_in">usize</span> = DIRECT_BOUND + INODE_INDIRECT1_COUNT;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">IndirectBlock</span></span> = [<span class="built_in">u32</span>; BLOCK_SZ / <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> DiskInode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_id</span></span>(&amp;<span class="keyword">self</span>, inner_id: <span class="built_in">u32</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> inner_id = inner_id <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        <span class="keyword">if</span> inner_id &lt; INODE_DIRECT_COUNT &#123;</span><br><span class="line">            <span class="keyword">self</span>.direct[inner_id]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> inner_id &lt; INDIRECT1_BOUND &#123;</span><br><span class="line">            get_block_cache(<span class="keyword">self</span>.indirect1 <span class="keyword">as</span> <span class="built_in">usize</span>, Arc::clone(block_device))</span><br><span class="line">                .lock()</span><br><span class="line">                .read(<span class="number">0</span>, |indirect_block: &amp;IndirectBlock| &#123;</span><br><span class="line">                    indirect_block[inner_id - INODE_DIRECT_COUNT]</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> last = inner_id - INDIRECT1_BOUND;</span><br><span class="line">            <span class="keyword">let</span> indirect1 = get_block_cache(</span><br><span class="line">                <span class="keyword">self</span>.indirect2 <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device)</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .read(<span class="number">0</span>, |indirect2: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect2[last / INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;);</span><br><span class="line">            get_block_cache(</span><br><span class="line">                indirect1 <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device)</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .read(<span class="number">0</span>, |indirect1: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect1[last % INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we design <strong>Data</strong> block, which is simple. Because for file system, any data are just bytes.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BLOCK_SZ = 512</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">DataBlock</span></span> = [<span class="built_in">u8</span>; BLOCK_SZ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl DiskInode</span></span><br><span class="line">    <span class="comment">// pub fn read_at(</span></span><br><span class="line">    <span class="comment">//     &amp;self,</span></span><br><span class="line">    <span class="comment">//     offset: usize,</span></span><br><span class="line">    <span class="comment">//     buf: &amp;mut [u8],</span></span><br><span class="line">    <span class="comment">//     block_device: &amp;Arc&lt;dyn BlockDevice&gt;,</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// calculate end of current block</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> end_current_block = (start / BLOCK_SZ + <span class="number">1</span>) * BLOCK_SZ;</span><br><span class="line">    end_current_block = end_current_block.min(end);</span><br><span class="line">    <span class="comment">// read and update read size</span></span><br><span class="line">    <span class="keyword">let</span> block_read_size = end_current_block - start;</span><br><span class="line">    <span class="keyword">let</span> dst = &amp;<span class="keyword">mut</span> buf[read_size..read_size + block_read_size];</span><br><span class="line">    get_block_cache(</span><br><span class="line">        <span class="keyword">self</span>.get_block_id(start_block <span class="keyword">as</span> <span class="built_in">u32</span>, block_device) <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        Arc::clone(block_device),</span><br><span class="line">    )</span><br><span class="line">    .lock()</span><br><span class="line">    .read(<span class="number">0</span>, |data_block: &amp;DataBlock| &#123;</span><br><span class="line">        <span class="keyword">let</span> src = &amp;data_block[start % BLOCK_SZ..start % BLOCK_SZ + block_read_size];</span><br><span class="line">        dst.copy_from_slice(src);</span><br><span class="line">    &#125;);</span><br><span class="line">    read_size += block_read_size;</span><br><span class="line">    <span class="comment">// move to next block</span></span><br><span class="line">    <span class="keyword">if</span> end_current_block == end &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    start_block += <span class="number">1</span>;</span><br><span class="line">    start = end_current_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="File-System-1"><a href="#File-System-1" class="headerlink" title="File System"></a>File System</h4><p>Due to our consecutive layout, we will store bitmap and start block, then initiate a unified system to control allocation and route. We call it <strong>File System</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EasyFileSystem</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap: Bitmap,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap: Bitmap,</span><br><span class="line">    inode_area_start_block: <span class="built_in">u32</span>,</span><br><span class="line">    data_area_start_block: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(</span><br><span class="line">        block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">        total_blocks: <span class="built_in">u32</span>,</span><br><span class="line">        inode_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    ) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// calculate block size of areas &amp; create bitmaps</span></span><br><span class="line">        <span class="keyword">let</span> inode_bitmap = Bitmap::new(<span class="number">1</span>, inode_bitmap_blocks <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">        <span class="keyword">let</span> inode_num = inode_bitmap.maximum();</span><br><span class="line">        <span class="keyword">let</span> inode_area_blocks =</span><br><span class="line">            ((inode_num * core::mem::size_of::&lt;DiskInode&gt;() + BLOCK_SZ - <span class="number">1</span>) / BLOCK_SZ) <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">        <span class="keyword">let</span> inode_total_blocks = inode_bitmap_blocks + inode_area_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_total_blocks = total_blocks - <span class="number">1</span> - inode_total_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_bitmap_blocks = (data_total_blocks + <span class="number">4096</span>) / <span class="number">4097</span>;</span><br><span class="line">        <span class="keyword">let</span> data_area_blocks = data_total_blocks - data_bitmap_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_bitmap = Bitmap::new(</span><br><span class="line">            (<span class="number">1</span> + inode_bitmap_blocks + inode_area_blocks) <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">            data_bitmap_blocks <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Use <strong>Bit Map</strong>, we finally know which is <strong>Inode</strong> and <strong>Data</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_disk_inode_pos</span></span>(&amp;<span class="keyword">self</span>, inode_id: <span class="built_in">u32</span>) -&gt; (<span class="built_in">u32</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> inode_size = core::mem::size_of::&lt;DiskInode&gt;();</span><br><span class="line">        <span class="keyword">let</span> inodes_per_block = (BLOCK_SZ / inode_size) <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">        <span class="keyword">let</span> block_id = <span class="keyword">self</span>.inode_area_start_block + inode_id / inodes_per_block;</span><br><span class="line">        (block_id, (inode_id % inodes_per_block) <span class="keyword">as</span> <span class="built_in">usize</span> * inode_size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_data_block_id</span></span>(&amp;<span class="keyword">self</span>, data_block_id: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.data_area_start_block + data_block_id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our <strong>Disk Inode</strong> is aims for underneath system, not for user, so we need a real <strong>Inode</strong> as a interface for <strong>Disk Inode</strong> to route, which store its id and offset.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_offset: <span class="built_in">usize</span>,</span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">        get_block_cache(</span><br><span class="line">            <span class="keyword">self</span>.block_id,</span><br><span class="line">            Arc::clone(&amp;<span class="keyword">self</span>.block_device)</span><br><span class="line">        ).lock().read(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">modify_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">        get_block_cache(</span><br><span class="line">            <span class="keyword">self</span>.block_id,</span><br><span class="line">            Arc::clone(&amp;<span class="keyword">self</span>.block_device)</span><br><span class="line">        ).lock().modify(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All methods exposed to user will be root inode.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">root_inode</span></span>(efs: &amp;Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt;) -&gt; Inode &#123;</span><br><span class="line">        <span class="keyword">let</span> block_device = Arc::clone(&amp;efs.lock().block_device);</span><br><span class="line">        <span class="comment">// acquire efs lock temporarily</span></span><br><span class="line">        <span class="keyword">let</span> (block_id, block_offset) = efs.lock().get_disk_inode_pos(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// release efs lock</span></span><br><span class="line">        Inode::new(</span><br><span class="line">            block_id,</span><br><span class="line">            block_offset,</span><br><span class="line">            Arc::clone(efs),</span><br><span class="line">            block_device,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, we still need one special data block which is <strong>DirEntry</strong>, as directory which store <code>inode_number</code> to route inode, <strong>DirEntry</strong> takes 32 bytes, so each block can store 4 <strong>DirEntry</strong>. Thus we can route to inode by <code>&amp;str</code>.</p>
<p>Notice disk_inode contains type for dir and file. So some of inodes will store dir data and some of inodes will store file data, we can get inode of data by inode of dir.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NAME_LENGTH_LIMIT: <span class="built_in">usize</span> = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DirEntry</span></span> &#123;</span><br><span class="line">    name: [<span class="built_in">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>],</span><br><span class="line">    inode_number: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DIRENT_SZ: <span class="built_in">usize</span> = <span class="number">32</span>;</span><br></pre></td></tr></table></figure>

<p>First, we will </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">find</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> fs = <span class="keyword">self</span>.fs.lock();</span><br><span class="line">        <span class="keyword">self</span>.read_disk_inode(|disk_inode| &#123;</span><br><span class="line">            <span class="keyword">self</span>.find_inode_id(name, disk_inode)</span><br><span class="line">            .map(|inode_id| &#123;</span><br><span class="line">                <span class="keyword">let</span> (block_id, block_offset) = fs.get_disk_inode_pos(inode_id);</span><br><span class="line">                Arc::new(Self::new(</span><br><span class="line">                    block_id,</span><br><span class="line">                    block_offset,</span><br><span class="line">                    <span class="keyword">self</span>.fs.clone(),</span><br><span class="line">                    <span class="keyword">self</span>.block_device.clone(),</span><br><span class="line">                ))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_inode_id</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        name: &amp;<span class="built_in">str</span>,</span><br><span class="line">        disk_inode: &amp;DiskInode,</span><br><span class="line">    ) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// assert it is a directory</span></span><br><span class="line">        <span class="built_in">assert!</span>(disk_inode.is_dir());</span><br><span class="line">        <span class="keyword">let</span> file_count = (disk_inode.size <span class="keyword">as</span> <span class="built_in">usize</span>) / DIRENT_SZ;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dirent = DirEntry::empty();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..file_count &#123;</span><br><span class="line">            <span class="comment">// note assert_eq! has side effect: read data to dirent.</span></span><br><span class="line">            <span class="built_in">assert_eq!</span>(</span><br><span class="line">                disk_inode.read_at(</span><br><span class="line">                    DIRENT_SZ * i,</span><br><span class="line">                    dirent.as_bytes_mut(),</span><br><span class="line">                    &amp;<span class="keyword">self</span>.block_device,</span><br><span class="line">                ),</span><br><span class="line">                DIRENT_SZ,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> dirent.name() == name &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Some</span>(dirent.inode_number() <span class="keyword">as</span> <span class="built_in">u32</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, the workflow of create or delete, read or write would be:</p>
<ul>
<li>read/write<ul>
<li>get root inode which is dir type</li>
<li>read/write closure of disk inode through root inode</li>
<li>resize specified inode</li>
</ul>
</li>
<li>create/clear<ul>
<li>allocation/deallocation: alloc/dealloc inode by bitmap and get its index</li>
<li>initialization/clear by get its block cache by its index</li>
<li>resize root inode</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap6-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap6-2/" class="post-title-link" itemprop="url">rcore-handnote-6-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-6-2"><a href="#Chapter-6-2" class="headerlink" title="Chapter 6-2"></a>Chapter 6-2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We gonna load our <code>easy-fs</code> to kernel. First, we need to know our device interface. Second, our <strong>Inode</strong> should be wrapped in OS as <strong>OSInode</strong> for extended functionality. Then we implement <code>sys_read/write</code> for it.</p>
<h3 id="MMIO-Memory-Mapped-I-O"><a href="#MMIO-Memory-Mapped-I-O" class="headerlink" title="MMIO-Memory-Mapped I/O"></a>MMIO-Memory-Mapped I/O</h3><p>The device registers of peripherals can be accessed through specific physical memory addresses, <strong>VirtIO</strong> MMIO physical address range for the peripheral bus is 4KiB starting at 0X10001000. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"board_qemu"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MMIO: &amp;[(<span class="built_in">usize</span>, <span class="built_in">usize</span>)] = &amp;[</span><br><span class="line">    (<span class="number">0x10001000</span>, <span class="number">0x1000</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="OS-Inode"><a href="#OS-Inode" class="headerlink" title="OS Inode"></a>OS Inode</h3><p>We only take restriction on our operations with <code>readable</code> and <code>writable</code> by <code>OpenFlags</code>. <code>offset</code> and <code>Arc</code> is a way to tackle simple situation of multi processes.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpenFlags</span></span>: <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> RDONLY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> WRONLY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> RDWR = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">const</span> TRUNC = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> OpenFlags &#123;</span><br><span class="line">    <span class="comment">/// Do not check validity for simplicity</span></span><br><span class="line">    <span class="comment">/// Return (readable, writable)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_write</span></span>(&amp;<span class="keyword">self</span>) -&gt; (<span class="built_in">bool</span>, <span class="built_in">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            (<span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.contains(Self::WRONLY) &#123;</span><br><span class="line">            (<span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (<span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInode</span></span> &#123;</span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    inner: Mutex&lt;OSInodeInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInodeInner</span></span> &#123;</span><br><span class="line">    offset: <span class="built_in">usize</span>,</span><br><span class="line">    inode: Arc&lt;Inode&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> OSInode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(</span><br><span class="line">        readable: <span class="built_in">bool</span>,</span><br><span class="line">        writable: <span class="built_in">bool</span>,</span><br><span class="line">        inode: Arc&lt;Inode&gt;,</span><br><span class="line">    ) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            readable,</span><br><span class="line">            writable,</span><br><span class="line">            inner: Mutex::new(OSInodeInner &#123;</span><br><span class="line">                offset: <span class="number">0</span>,</span><br><span class="line">                inode,</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File-Descriptor-Table"><a href="#File-Descriptor-Table" class="headerlink" title="File Descriptor Table"></a>File Descriptor Table</h4><p>Now we need to connect file operations with process, each process need a descriptors table(which manage many files!) to indicate file record infos. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">pub</span> fd_table: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Remember our previous root inode? We load it directly for easy manipulation. So our workflow would be for current process, push a descriptor of allocation, and return the ptr of this allocation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/inode.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> efs = EasyFileSystem::open(BLOCK_DEVICE.clone());</span><br><span class="line">        Arc::new(EasyFileSystem::root_inode(&amp;efs))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open_file</span></span>(name: &amp;<span class="built_in">str</span>, flags: OpenFlags) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;OSInode&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (readable, writable) = flags.read_write();</span><br><span class="line">    <span class="keyword">if</span> flags.contains(OpenFlags::CREATE) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inode) = ROOT_INODE.find(name) &#123;</span><br><span class="line">            <span class="comment">// clear size</span></span><br><span class="line">            inode.clear();</span><br><span class="line">            <span class="literal">Some</span>(Arc::new(OSInode::new(</span><br><span class="line">                readable,</span><br><span class="line">                writable,</span><br><span class="line">                inode,</span><br><span class="line">            )))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// create file</span></span><br><span class="line">            ROOT_INODE.create(name)</span><br><span class="line">                .map(|inode| &#123;</span><br><span class="line">                    Arc::new(OSInode::new(</span><br><span class="line">                        readable,</span><br><span class="line">                        writable,</span><br><span class="line">                        inode,</span><br><span class="line">                    ))</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ROOT_INODE.find(name)</span><br><span class="line">            .map(|inode| &#123;</span><br><span class="line">                <span class="keyword">if</span> flags.contains(OpenFlags::TRUNC) &#123;</span><br><span class="line">                    inode.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                Arc::new(OSInode::new(</span><br><span class="line">                    readable,</span><br><span class="line">                    writable,</span><br><span class="line">                    inode</span><br><span class="line">                ))</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/fs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_open</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>, flags: <span class="built_in">u32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(inode) = open_file(</span><br><span class="line">        path.as_str(),</span><br><span class="line">        OpenFlags::from_bits(flags).unwrap()</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.acquire_inner_lock();</span><br><span class="line">        <span class="keyword">let</span> fd = inner.alloc_fd();</span><br><span class="line">        inner.fd_table[fd] = <span class="literal">Some</span>(inode);</span><br><span class="line">        fd <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/syscall/fs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_close</span></span>(fd: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> fd &gt;= inner.fd_table.len() &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> inner.fd_table[fd].is_none() &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inner.fd_table[fd].take();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The implementation is same for <code>sys_read/write</code>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap7-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap7-1/" class="post-title-link" itemprop="url">rcore-handnote-7-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-7-1"><a href="#Chapter-7-1" class="headerlink" title="Chapter 7-1"></a>Chapter 7-1</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We gonna abstract <code>Stdin</code> and <code>Stdout</code> by file, and insert into file descriptor. Therefore support <strong>Pipe</strong> operation and <strong>IO Redirection</strong> across each process.</p>
<h3 id="Everything-Is-a-File"><a href="#Everything-Is-a-File" class="headerlink" title="Everything Is a File"></a>Everything Is a File</h3><p>The design philosophy of <strong>Everything is a file</strong> will generalize everything to file based on IO operations while omit concrete content semantics.</p>
<p>Abstraction of IO hardware:</p>
<ul>
<li>read-only: s.t. keyboard</li>
<li>write-only: s.t. screen</li>
<li>read-write: s.t. serial device</li>
</ul>
<p>Abstraction of IO operations(based on file descriptor):</p>
<ul>
<li>open: open file while possessing it by certain process.</li>
<li>close: close file while discarding it by certain process.</li>
<li>read: read file into memory.</li>
<li>write: write file from memory.</li>
</ul>
<p>When a process is created, it owns three file as operation abstraction:</p>
<ul>
<li>0: Stdin</li>
<li>1: Stdout</li>
<li>2: Stderr(which we will merge with Stdout)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> task_control_block = <span class="keyword">Self</span> &#123;</span><br><span class="line">            pid: pid_handle,</span><br><span class="line">            kernel_stack,</span><br><span class="line">            inner: Mutex::new(TaskControlBlockInner &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">                fd_table: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="comment">// 0 -&gt; stdin</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdin)),</span><br><span class="line">                    <span class="comment">// 1 -&gt; stdout</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdout)),</span><br><span class="line">                    <span class="comment">// 2 -&gt; stderr</span></span><br><span class="line">                    <span class="literal">Some</span>(Arc::new(Stdout)),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>In usual shell, <code>|</code> is the symbolic of pipe. Manage input from left and output to right. If we abstract everything to file, s.t. <code>Stdin</code> or <code>Stdout</code>, so does <strong>Pipe</strong>, it has <code>read</code> and <code>write</code> ends, user could read thing from this end and write thing(often in child process) to other end, transfer those underneath thing.</p>
<p>We already has file descriptor as the indication of file, we will implement same operation for pipe.</p>
<p><code>sys_pipe</code> get the ptr of a array with <code>len = 2</code>, output the write and the read ends of descriptors of pipe in the ptr.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_PIPE: <span class="built_in">usize</span> = <span class="number">59</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_pipe</span></span>(pipe: &amp;<span class="keyword">mut</span> [<span class="built_in">usize</span>]) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    syscall(SYSCALL_PIPE, [pipe.as_mut_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>So What’s the basic design of pipe?</p>
<p>It should has write and read ends which means ends share the same data, and record read and write informations on this data. We will construct <code>RingBuffer</code> to achieve this. <code>Pipe</code> owns a buffer control read and write, buffer will record data from head to tail index. Why we can’t just use two piece of data or <code>Queue</code>?</p>
<p>Because there’s no copy and suitable for our restriction! We will read data from head and move forward and push data to end in a fixed array rather allocation for <code>Queue</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/pipe.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span></span> &#123;</span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RING_BUFFER_SIZE: <span class="built_in">usize</span> = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RingBufferStatus</span></span> &#123;</span><br><span class="line">    FULL,</span><br><span class="line">    EMPTY,</span><br><span class="line">    NORMAL,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PipeRingBuffer</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">u8</span>; RING_BUFFER_SIZE],</span><br><span class="line">    head: <span class="built_in">usize</span>, <span class="comment">// head index of ring buffer</span></span><br><span class="line">    tail: <span class="built_in">usize</span>, <span class="comment">// tail index of ring buffer</span></span><br><span class="line">    status: RingBufferStatus,</span><br><span class="line">    write_end: <span class="built_in">Option</span>&lt;Weak&lt;Pipe&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_write_end</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, write_end: &amp;Arc&lt;Pipe&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.write_end = <span class="literal">Some</span>(Arc::downgrade(write_end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Return (read_end, write_end)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">make_pipe</span></span>() -&gt; (Arc&lt;Pipe&gt;, Arc&lt;Pipe&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> buffer = Arc::new(Mutex::new(PipeRingBuffer::new()));</span><br><span class="line">    <span class="keyword">let</span> read_end = Arc::new(</span><br><span class="line">        Pipe::read_end_with_buffer(buffer.clone())</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> write_end = Arc::new(</span><br><span class="line">        Pipe::write_end_with_buffer(buffer.clone())</span><br><span class="line">    );</span><br><span class="line">    buffer.lock().set_write_end(&amp;write_end);</span><br><span class="line">    (read_end, write_end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_byte</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.status = RingBufferStatus::NORMAL;</span><br><span class="line">        <span class="keyword">let</span> c = <span class="keyword">self</span>.arr[<span class="keyword">self</span>.head];</span><br><span class="line">		<span class="comment">// move forward</span></span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="number">1</span>) % RING_BUFFER_SIZE;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.head == <span class="keyword">self</span>.tail &#123;</span><br><span class="line">            <span class="keyword">self</span>.status = RingBufferStatus::EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">available_read</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.status == RingBufferStatus::EMPTY &#123;</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// data from head to tail!</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.tail &gt; <span class="keyword">self</span>.head &#123;</span><br><span class="line">                <span class="keyword">self</span>.tail - <span class="keyword">self</span>.head</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.tail + RING_BUFFER_SIZE - <span class="keyword">self</span>.head</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">all_write_ends_closed</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.write_end.as_ref().unwrap().upgrade().is_none()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In one process, there’s a possible that can’t read all thing in once, if so, we will pause and run other thing until the write end is finished.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/fs/pipe.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Pipe &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(<span class="keyword">self</span>.readable());</span><br><span class="line">        <span class="keyword">let</span> want_to_read = buf.len();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> buf_iter = buf.into_iter();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> already_read = <span class="number">0usize</span>;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> ring_buffer = <span class="keyword">self</span>.buffer.exclusive_access();</span><br><span class="line">            <span class="keyword">let</span> loop_read = ring_buffer.available_read();</span><br><span class="line">            <span class="keyword">if</span> loop_read == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ring_buffer.all_write_ends_closed() &#123;</span><br><span class="line">                    <span class="keyword">return</span> already_read;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">drop</span>(ring_buffer);</span><br><span class="line">                suspend_current_and_run_next();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..loop_read &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(byte_ref) = buf_iter.next() &#123;</span><br><span class="line">                    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                        *byte_ref = ring_buffer.read_byte();</span><br><span class="line">                    &#125;</span><br><span class="line">                    already_read += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> already_read == want_to_read &#123;</span><br><span class="line">                        <span class="keyword">return</span> want_to_read;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> already_read;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h3><p>We will combine our pipe with our shell.</p>
<p>First, parse our arguments and push <code>0</code> to end to indicated end.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/bin/user_shell.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;_&gt; = line.as_str().split(<span class="string">' '</span>).collect();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> args_addr: <span class="built_in">Vec</span>&lt;*<span class="keyword">const</span> <span class="built_in">u8</span>&gt; = args</span><br><span class="line">	.iter()</span><br><span class="line">	.map(|&amp;arg| &#123;</span><br><span class="line">		<span class="keyword">let</span> s = arg.to_string();</span><br><span class="line">		s.push(<span class="string">'\0'</span>);</span><br><span class="line">		s.as_ptr()</span><br><span class="line">	&#125;)</span><br><span class="line">	.collect();</span><br><span class="line">args_addr.push(<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>)</span><br></pre></td></tr></table></figure>

<p>Now task will accept a series of args rather than solely one string. So make <code>sys_exec</code> to:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>, <span class="keyword">mut</span> args: *<span class="keyword">const</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> path = translated_str(token, path);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> args_vec: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">	<span class="comment">// args would be a ptr of array contains ptr of string.</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arg_str_ptr = *translated_ref(token, args);</span><br><span class="line">        <span class="keyword">if</span> arg_str_ptr == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        args_vec.push(translated_str(token, arg_str_ptr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>));</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; args = args.add(<span class="number">1</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(app_inode) = open_file(path.as_str(), OpenFlags::RDONLY) &#123;</span><br><span class="line">        <span class="keyword">let</span> all_data = app_inode.read_all();</span><br><span class="line">        <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">        <span class="keyword">let</span> argc = args_vec.len();</span><br><span class="line">        task.exec(all_data.as_slice(), args_vec);</span><br><span class="line">        <span class="comment">// return argc because cx.x[10] will be covered with it later</span></span><br><span class="line">        argc <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we really gonna use user stack to store these args!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">	<span class="comment">// notice exec will allocate a new memory set!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>], args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// first allocate memory for ptr of strings.</span></span><br><span class="line">        user_sp -= (args.len() + <span class="number">1</span>) * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;();</span><br><span class="line">        <span class="keyword">let</span> argv_base = user_sp;</span><br><span class="line">		<span class="comment">// allocate new memory in user stack addr as a vector of strings </span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> argv: <span class="built_in">Vec</span>&lt;_&gt; = (<span class="number">0</span>..=args.len())</span><br><span class="line">            .map(|arg| &#123;</span><br><span class="line">                translated_refmut(</span><br><span class="line">                    memory_set.token(),</span><br><span class="line">                    (argv_base + arg * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">usize</span></span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect();</span><br><span class="line">        *argv[args.len()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..args.len() &#123;</span><br><span class="line">			<span class="comment">// allocate for strings themselves.</span></span><br><span class="line">            user_sp -= args[i].len() + <span class="number">1</span>;</span><br><span class="line">            *argv[i] = user_sp;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> p = user_sp;</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> args[i].as_bytes() &#123;</span><br><span class="line">                *translated_refmut(memory_set.token(), p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>) = *c;</span><br><span class="line">                p += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *translated_refmut(memory_set.token(), p <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// make the user_sp aligned to 8B for k210 platform</span></span><br><span class="line">        user_sp -= user_sp % core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **** hold current PCB lock</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.acquire_inner_lock();</span><br><span class="line">        <span class="comment">// substitute memory_set</span></span><br><span class="line">        inner.memory_set = memory_set;</span><br><span class="line">        <span class="comment">// update trap_cx ppn</span></span><br><span class="line">        inner.trap_cx_ppn = trap_cx_ppn;</span><br><span class="line">        <span class="comment">// initialize trap_cx</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> trap_cx = TrapContext::app_init_context(</span><br><span class="line">            entry_point,</span><br><span class="line">            user_sp,</span><br><span class="line">            KERNEL_SPACE.lock().token(),</span><br><span class="line">            <span class="keyword">self</span>.kernel_stack.get_top(),</span><br><span class="line">            trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">		<span class="comment">// a[0] be args len</span></span><br><span class="line">        trap_cx.x[<span class="number">10</span>] = args.len();</span><br><span class="line">		<span class="comment">// a[1] be args base addr</span></span><br><span class="line">        trap_cx.x[<span class="number">11</span>] = argv_base;</span><br><span class="line">        *inner.get_trap_cx() = trap_cx;</span><br><span class="line">        <span class="comment">// **** release current PCB lock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we provide receive operation in <code>_start</code>, in which <code>main</code> could use it at first time S-level reading data and passing to U-level:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="meta-string">".text.entry"</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>(argc: <span class="built_in">usize</span>, argv: <span class="built_in">usize</span>) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP.lock()</span><br><span class="line">            .init(HEAP_SPACE.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>, USER_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..argc &#123;</span><br><span class="line">        <span class="keyword">let</span> str_start = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            ((argv + i * core::mem::size_of::&lt;<span class="built_in">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">usize</span>).read_volatile()</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> len = (<span class="number">0usize</span>..).find(|i| <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            ((str_start + *i) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>).read_volatile() == <span class="number">0</span></span><br><span class="line">        &#125;).unwrap();</span><br><span class="line">        v.push(</span><br><span class="line">            core::<span class="built_in">str</span>::from_utf8(<span class="keyword">unsafe</span> &#123;</span><br><span class="line">                core::slice::from_raw_parts(str_start <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u8</span>, len)</span><br><span class="line">            &#125;).unwrap()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    exit(main(argc, v.as_slice()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h3><p>Redirection usually represent using <code>&gt;</code> and <code>&lt;</code> for output and input.</p>
<p>If we really want to redirect IO, we will combine <code>user_shell</code> and <code>sys_dup</code>.</p>
<p>First, <code>sys_dup</code> will duplicate a new file descriptor already opened in this process.</p>
<p>Then we parse user arguments, if there exist <code>&gt;</code> or <code>&lt;</code>, fork a new child process, open the file and close our corresponding <code>Stdin</code> and <code>Stdout</code> descriptor, using <code>dup</code> to hold the place of it by <code>file</code> itself! Then <code>exec</code> by original parsed arguments, and receive results in parent process.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap7-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap7-2/" class="post-title-link" itemprop="url">rcore-handnote-7-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-7-2"><a href="#Chapter-7-2" class="headerlink" title="Chapter 7-2"></a>Chapter 7-2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>If a process want to notify other process with event semantics, such one-side mechanism called <strong>Signal</strong>, one process received specific event will pause and implement corresponding operation to handle the notification.</p>
<p>For example, a program could receive the stop event sended by <code>Ctrl+C</code>, and stop itself.</p>
<p>The abstraction of handling of signal:</p>
<ul>
<li>ignore: do own thing and ignore signal</li>
<li>trap: call corresponding operation of the received signal</li>
<li>stop: stop itself</li>
</ul>
<p>Now, beside this raw idea, we want to classify such abstraction with specified data.</p>
<hr>
<h3 id="Signal-Data"><a href="#Signal-Data" class="headerlink" title="Signal Data"></a>Signal Data</h3><p>First, we define raw info for each possible event.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGDEF: <span class="built_in">i32</span> = <span class="number">0</span>; <span class="comment">// Default signal handling</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGHUP: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGINT: <span class="built_in">i32</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGQUIT: <span class="built_in">i32</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGILL: <span class="built_in">i32</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGTRAP: <span class="built_in">i32</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGABRT: <span class="built_in">i32</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGBUS: <span class="built_in">i32</span> = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGFPE: <span class="built_in">i32</span> = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> SIGKILL: <span class="built_in">i32</span> = <span class="number">9</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>So, what if a process want to omit the signal, what should this process do? We will introduce <strong>Mask</strong> in bit design, which means higher number contains lower number, indicating higher priority.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SignalFlags</span></span>: <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> SIGDEF = <span class="number">1</span>; <span class="comment">// Default signal handling</span></span><br><span class="line">        <span class="keyword">const</span> SIGHUP = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> SIGINT = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> SIGQUIT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> SIGILL = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">const</span> SIGTRAP = <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">const</span> SIGSYS = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In a task block, it should record its current mask and current signal priority and each action corresponding to each flags, so we need a fixed array contains ptrs and its priority. After that, we need to record current flag it should implement.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Action for a signal</span></span><br><span class="line"><span class="meta">#[repr(C, align(16))]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Copy)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SignalAction</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> handler: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> mask: SignalFlags,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/signal.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> MAX_SIG: <span class="built_in">usize</span> = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/action.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SignalActions</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> table: [SignalAction; MAX_SIG + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">pub</span> handling_sig: <span class="built_in">isize</span>,</span><br><span class="line">	<span class="comment">// priority allowed</span></span><br><span class="line">	<span class="keyword">pub</span> signals: SignalFlags,</span><br><span class="line">	<span class="comment">// priority forbidden</span></span><br><span class="line">    <span class="keyword">pub</span> signal_mask: SignalFlags,</span><br><span class="line">    <span class="keyword">pub</span> signal_actions: SignalActions,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then our task know which signal should be implemented, which should be omitted.</p>
<hr>
<h3 id="Signal-Handle"><a href="#Signal-Handle" class="headerlink" title="Signal Handle"></a>Signal Handle</h3><p>Recall that, each process should receive signal and trap into possible level, some may be in S-level, some may be in U-level. And some of them may be illegal or atrocious that we should <code>stop</code> or <code>frozen</code> to wait. If so, we should backup our <code>trap_ctx</code>, because handler contains different environement.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">pub</span> killed: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> frozen: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> handling_sig: <span class="built_in">isize</span>,</span><br><span class="line">    <span class="keyword">pub</span> trap_ctx_backup: <span class="built_in">Option</span>&lt;TrapContext&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some signals are severe and handled by kernel.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">call_kernel_signal_handler</span></span>(signal: SignalFlags) &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">match</span> signal &#123;</span><br><span class="line">        SignalFlags::SIGSTOP =&gt; &#123;</span><br><span class="line">            task_inner.frozen = <span class="literal">true</span>;</span><br><span class="line">            task_inner.signals ^= SignalFlags::SIGSTOP;</span><br><span class="line">        &#125;</span><br><span class="line">        SignalFlags::SIGCONT =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> task_inner.signals.contains(SignalFlags::SIGCONT) &#123;</span><br><span class="line">                task_inner.signals ^= SignalFlags::SIGCONT;</span><br><span class="line">                task_inner.frozen = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// println!(</span></span><br><span class="line">            <span class="comment">//     "[K] call_kernel_signal_handler:: current task sigflag &#123;:?&#125;",</span></span><br><span class="line">            <span class="comment">//     task_inner.signals</span></span><br><span class="line">            <span class="comment">// );</span></span><br><span class="line">            task_inner.killed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some signals are normal and handled by user.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">call_user_signal_handler</span></span>(sig: <span class="built_in">usize</span>, signal: SignalFlags) &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handler = task_inner.signal_actions.table[sig].handler;</span><br><span class="line">    <span class="keyword">if</span> handler != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// register signal into task</span></span><br><span class="line">        task_inner.handling_sig = sig <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line">        task_inner.signals ^= signal;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// backup</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> trap_ctx = task_inner.get_trap_cx();</span><br><span class="line">        task_inner.trap_ctx_backup = <span class="literal">Some</span>(*trap_ctx);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// modify current trap for our event handler</span></span><br><span class="line">        trap_ctx.sepc = handler;</span><br><span class="line">        trap_ctx.x[<span class="number">10</span>] = sig;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// default action</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"[K] task/call_user_signal_handler: default action: ignore it or kill process"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on this, we could check our pending signal based on priority of <code>signals</code>, <code>signal_mask</code> of task and <code>signal_mask</code> of signal itself of table.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_pending_signals</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> sig <span class="keyword">in</span> <span class="number">0</span>..(MAX_SIG + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">        <span class="keyword">let</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">let</span> signal = SignalFlags::from_bits(<span class="number">1</span> &lt;&lt; sig).unwrap();</span><br><span class="line">        <span class="keyword">if</span> task_inner.signals.contains(signal) &amp;&amp; (!task_inner.signal_mask.contains(signal)) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> masked = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">let</span> handling_sig = task_inner.handling_sig;</span><br><span class="line">            <span class="keyword">if</span> handling_sig == -<span class="number">1</span> &#123;</span><br><span class="line">                masked = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> handling_sig = handling_sig <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">                <span class="keyword">if</span> !task_inner.signal_actions.table[handling_sig]</span><br><span class="line">                    .mask</span><br><span class="line">                    .contains(signal)</span><br><span class="line">                &#123;</span><br><span class="line">                    masked = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !masked &#123;</span><br><span class="line">                <span class="built_in">drop</span>(task_inner);</span><br><span class="line">                <span class="built_in">drop</span>(task);</span><br><span class="line">                <span class="keyword">if</span> signal == SignalFlags::SIGKILL</span><br><span class="line">                    || signal == SignalFlags::SIGSTOP</span><br><span class="line">                    || signal == SignalFlags::SIGCONT</span><br><span class="line">                    || signal == SignalFlags::SIGDEF</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// signal is a kernel signal</span></span><br><span class="line">                    call_kernel_signal_handler(signal);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// signal is a user signal</span></span><br><span class="line">                    call_user_signal_handler(sig, signal);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then record a loop function to handle repeatedly while changing the state of task.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">handle_signals</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        check_pending_signals();</span><br><span class="line">        <span class="keyword">let</span> (frozen, killed) = &#123;</span><br><span class="line">            <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">            <span class="keyword">let</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">            (task_inner.frozen, task_inner.killed)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> !frozen || killed &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        suspend_current_and_run_next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="System-Operation"><a href="#System-Operation" class="headerlink" title="System Operation"></a>System Operation</h3><p>Finally, we will design <code>sys</code> operations to construct interface.</p>
<ul>
<li>procmask: set mask of current process</li>
<li>sigaction: set handler of a signal of current process and move original handler to our input <code>old_action</code> ptr.</li>
<li>kill: current process send signal to the other</li>
<li>sigreturn: clear current signal and back to original trap state</li>
</ul>
<p>We will construct it one by one.</p>
<p><code>procmask</code> is simple, we just set it directly and return original one.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_sigprocmask</span></span>(mask: <span class="built_in">u32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = current_task() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">        <span class="keyword">let</span> old_mask = inner.signal_mask;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(flag) = SignalFlags::from_bits(mask) &#123;</span><br><span class="line">            inner.signal_mask = flag;</span><br><span class="line">            old_mask.bits() <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sigaction</code> is a bit harder but still easy, however, notice that the ptr may be null.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_sigaction_error</span></span>(signal: SignalFlags, action: <span class="built_in">usize</span>, old_action: <span class="built_in">usize</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> action == <span class="number">0</span></span><br><span class="line">        || old_action == <span class="number">0</span></span><br><span class="line">        || signal == SignalFlags::SIGKILL</span><br><span class="line">        || signal == SignalFlags::SIGSTOP</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_sigaction</span></span>(</span><br><span class="line">    signum: <span class="built_in">i32</span>,</span><br><span class="line">    action: *<span class="keyword">const</span> SignalAction,</span><br><span class="line">    old_action: *<span class="keyword">mut</span> SignalAction,</span><br><span class="line">) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> signum <span class="keyword">as</span> <span class="built_in">usize</span> &gt; MAX_SIG &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(flag) = SignalFlags::from_bits(<span class="number">1</span> &lt;&lt; signum) &#123;</span><br><span class="line">        <span class="keyword">if</span> check_sigaction_error(flag, action <span class="keyword">as</span> <span class="built_in">usize</span>, old_action <span class="keyword">as</span> <span class="built_in">usize</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> prev_action = inner.signal_actions.table[signum <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">        *translated_refmut(token, old_action) = prev_action;</span><br><span class="line">        inner.signal_actions.table[signum <span class="keyword">as</span> <span class="built_in">usize</span>] = *translated_ref(token, action);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kill</code> is simple, we will extract the task from <code>pid</code>, and insert flag to it if there’s no flag has been set.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_sigaction_error</span></span>(signal: SignalFlags, action: <span class="built_in">usize</span>, old_action: <span class="built_in">usize</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> action == <span class="number">0</span></span><br><span class="line">        || old_action == <span class="number">0</span></span><br><span class="line">        || signal == SignalFlags::SIGKILL</span><br><span class="line">        || signal == SignalFlags::SIGSTOP</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_sigaction</span></span>(</span><br><span class="line">    signum: <span class="built_in">i32</span>,</span><br><span class="line">    action: *<span class="keyword">const</span> SignalAction,</span><br><span class="line">    old_action: *<span class="keyword">mut</span> SignalAction,</span><br><span class="line">) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = current_user_token();</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> signum <span class="keyword">as</span> <span class="built_in">usize</span> &gt; MAX_SIG &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(flag) = SignalFlags::from_bits(<span class="number">1</span> &lt;&lt; signum) &#123;</span><br><span class="line">        <span class="keyword">if</span> check_sigaction_error(flag, action <span class="keyword">as</span> <span class="built_in">usize</span>, old_action <span class="keyword">as</span> <span class="built_in">usize</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> prev_action = inner.signal_actions.table[signum <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">        *translated_refmut(token, old_action) = prev_action;</span><br><span class="line">        inner.signal_actions.table[signum <span class="keyword">as</span> <span class="built_in">usize</span>] = *translated_ref(token, action);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sigreturn</code> is simple, because we only need to restore our backup one.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_sigreturn</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = current_task() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = task.inner_exclusive_access();</span><br><span class="line">        inner.handling_sig = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// restore the trap context</span></span><br><span class="line">        <span class="keyword">let</span> trap_ctx = inner.get_trap_cx();</span><br><span class="line">        *trap_ctx = inner.trap_ctx_backup.unwrap();</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phew! We finish our <strong>Signal</strong> mechanism!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap8-1/" class="post-title-link" itemprop="url">rcore-handnote-8-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-8-1"><a href="#Chapter-8-1" class="headerlink" title="Chapter 8-1"></a>Chapter 8-1</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>As the growth of OS, dispatch resource could be divided to smaller piece for more efficient operations. Now, process can’t satisfied our demand, we want some programs could be implemented in parallel. Then, we introduce <strong>Thread</strong>.</p>
<p>Therefore, process will be the container of threads, each threads contain its <code>id</code>, <code>state</code>, current instruction ptr, registers, stack. However, it will share data(which means same memory and addr) in the same process. So, we will develop a accompany exclusion mechanism for parallel operations by each threads.</p>
<h3 id="Design-Data"><a href="#Design-Data" class="headerlink" title="Design Data"></a>Design Data</h3><p>Now, clarify our resource dispatch for one thread:</p>
<p>Immutable:</p>
<ul>
<li>kernel stack</li>
</ul>
<p>Mutable:</p>
<ul>
<li>thread id</li>
<li>user stack</li>
<li>trap context</li>
<li>trap status</li>
<li>exit code</li>
</ul>
<p>Every tasks is a thread unit and contained in one process, so now, process is really a process rather a task, it can owns many tasks.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    <span class="comment">// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">pub</span> task_res_allocator: RecycleAllocator,</span><br><span class="line">    <span class="keyword">pub</span> tasks: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice, we should separate user stack and kernel stack, we shouldn’t allocate user stack and kernel stack by same logic. Kernel stack is immutable, we only need its top place for trap context.</p>
<p><img src="/blog/.io//assets/Lab8-1.png" alt></p>
<p>Because every thread use the same memory set, so each user stack and its trampoline would be allocated by its thread id. We encapsulate these to <code>TaskUserRes</code> data.</p>
<p>We can see many structure need a id allocation, we could design a general id allocator.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/id.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">RecycleAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,</span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> RecycleAllocator &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        RecycleAllocator &#123;</span><br><span class="line">            current: <span class="number">0</span>,</span><br><span class="line">            recycled: <span class="built_in">Vec</span>::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(id) = <span class="keyword">self</span>.recycled.pop() &#123;</span><br><span class="line">            id</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.current += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">self</span>.current - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, id: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(id &lt; <span class="keyword">self</span>.current);</span><br><span class="line">        <span class="built_in">assert!</span>(</span><br><span class="line">            !<span class="keyword">self</span>.recycled.iter().any(|i| *i == id),</span><br><span class="line">            <span class="string">"id &#123;&#125; has been deallocated!"</span>,</span><br><span class="line">            id</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">self</span>.recycled.push(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Kernel-Stack-Allocation"><a href="#Kernel-Stack-Allocation" class="headerlink" title="Kernel Stack Allocation"></a>Kernel Stack Allocation</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/id.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> KSTACK_ALLOCATOR: UPSafeCell&lt;RecycleAllocator&gt; =</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; UPSafeCell::new(RecycleAllocator::new()) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KernelStack</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Return (bottom, top) of a kernel stack in kernel space.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_stack_position</span></span>(kstack_id: <span class="built_in">usize</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = TRAMPOLINE - kstack_id * (KERNEL_STACK_SIZE + PAGE_SIZE);</span><br><span class="line">    <span class="keyword">let</span> bottom = top - KERNEL_STACK_SIZE;</span><br><span class="line">    (bottom, top)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kstack_alloc</span></span>() -&gt; KernelStack &#123;</span><br><span class="line">    <span class="keyword">let</span> kstack_id = KSTACK_ALLOCATOR.exclusive_access().alloc();</span><br><span class="line">    <span class="keyword">let</span> (kstack_bottom, kstack_top) = kernel_stack_position(kstack_id);</span><br><span class="line">    KERNEL_SPACE.exclusive_access().insert_framed_area(</span><br><span class="line">        kstack_bottom.into(),</span><br><span class="line">        kstack_top.into(),</span><br><span class="line">        MapPermission::R | MapPermission::W,</span><br><span class="line">    );</span><br><span class="line">    KernelStack(kstack_id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> KernelStack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> (kernel_stack_bottom, _) = kernel_stack_position(<span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> kernel_stack_bottom_va: VirtAddr = kernel_stack_bottom.into();</span><br><span class="line">        KERNEL_SPACE</span><br><span class="line">            .exclusive_access()</span><br><span class="line">            .remove_area_with_start_vpn(kernel_stack_bottom_va.into());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will do the same for user stack:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/config.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> TRAMPOLINE: <span class="built_in">usize</span> = <span class="built_in">usize</span>::MAX - PAGE_SIZE + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> TRAP_CONTEXT_BASE: <span class="built_in">usize</span> = TRAMPOLINE - PAGE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/task/id.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">trap_cx_bottom_from_tid</span></span>(tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    TRAP_CONTEXT_BASE - tid * PAGE_SIZE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ustack_bottom_from_tid</span></span>(ustack_base: <span class="built_in">usize</span>, tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    ustack_base + tid * (PAGE_SIZE + USER_STACK_SIZE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then, <code>TaskUserRes</code> could be allocated with trap and user stack.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impl TaskUserRes</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_user_res</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> process = <span class="keyword">self</span>.process.upgrade().unwrap();</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">	<span class="comment">// alloc user stack</span></span><br><span class="line">	<span class="keyword">let</span> ustack_bottom = ustack_bottom_from_tid(<span class="keyword">self</span>.ustack_base, <span class="keyword">self</span>.tid);</span><br><span class="line">	<span class="keyword">let</span> ustack_top = ustack_bottom + USER_STACK_SIZE;</span><br><span class="line">	process_inner.memory_set.insert_framed_area(</span><br><span class="line">		ustack_bottom.into(),</span><br><span class="line">		ustack_top.into(),</span><br><span class="line">		MapPermission::R | MapPermission::W | MapPermission::U,</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">// alloc trap_cx</span></span><br><span class="line">	<span class="keyword">let</span> trap_cx_bottom = trap_cx_bottom_from_tid(<span class="keyword">self</span>.tid);</span><br><span class="line">	<span class="keyword">let</span> trap_cx_top = trap_cx_bottom + PAGE_SIZE;</span><br><span class="line">	process_inner.memory_set.insert_framed_area(</span><br><span class="line">		trap_cx_bottom.into(),</span><br><span class="line">		trap_cx_top.into(),</span><br><span class="line">		MapPermission::R | MapPermission::W,</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, combine all things together:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/task.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="keyword">pub</span> kstack: KernelStack,</span><br><span class="line">    <span class="comment">// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> res: <span class="built_in">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Design-Data-Operation"><a href="#Design-Data-Operation" class="headerlink" title="Design Data Operation"></a>Design Data Operation</h3><p>We still get one task in operation rather process, because it’s the smallest instance unit. However, we need some interface to control process id.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_task</span></span>(task: Arc&lt;TaskControlBlock&gt;);</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_task</span></span>(task: Arc&lt;TaskControlBlock&gt;);</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_task</span></span>() -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pid2process</span></span>(pid: <span class="built_in">usize</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;ProcessControlBlock&gt;&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">insert_into_pid2process</span></span>(pid: <span class="built_in">usize</span>, process: Arc&lt;ProcessControlBlock&gt;);</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_from_pid2process</span></span>(pid: <span class="built_in">usize</span>);</span><br></pre></td></tr></table></figure>

<p>Actually, many thing is same, for example:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/task/process.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ProcessControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> pid_handle = pid_alloc();</span><br><span class="line">        <span class="keyword">let</span> process = ...;</span><br><span class="line">        <span class="keyword">let</span> task = Arc::new(TaskControlBlock::new(</span><br><span class="line">            Arc::clone(&amp;process),</span><br><span class="line">            ustack_base,</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">        ));</span><br><span class="line">		<span class="comment">// initiation of task...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">        process_inner.tasks.push(<span class="literal">Some</span>(Arc::clone(&amp;task)));</span><br><span class="line">        <span class="built_in">drop</span>(process_inner);</span><br><span class="line">        insert_into_pid2process(process.getpid(), Arc::clone(&amp;process));</span><br><span class="line">        <span class="comment">// add main thread to scheduler</span></span><br><span class="line">        add_task(task);</span><br><span class="line">        process</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we <code>fork</code> a process, we only extract the first task which is itself, so no others will be copied.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) -&gt; Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> child = ...;</span><br><span class="line">	parent.children.push(Arc::clone(&amp;child));</span><br><span class="line">	<span class="keyword">let</span> task = Arc::new(TaskControlBlock::new(</span><br><span class="line">		Arc::clone(&amp;child),</span><br><span class="line">		parent</span><br><span class="line">			.get_task(<span class="number">0</span>)</span><br><span class="line">			.inner_exclusive_access()</span><br><span class="line">			.res</span><br><span class="line">			.as_ref()</span><br><span class="line">			.unwrap()</span><br><span class="line">			.ustack_base(),</span><br><span class="line">		<span class="comment">// here we do not allocate trap_cx or ustack again</span></span><br><span class="line">		<span class="comment">// but mention that we allocate a new kstack here</span></span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">	));</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> child_inner = child.inner_exclusive_access();</span><br><span class="line">	child_inner.tasks.push(<span class="literal">Some</span>(Arc::clone(&amp;task)));</span><br><span class="line">	<span class="built_in">drop</span>(child_inner);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Design-System-Operation"><a href="#Design-System-Operation" class="headerlink" title="Design System Operation"></a>Design System Operation</h3><p>If we want to create a thread, as a naive designer, we only need the function entry addr, and arguments, yes! That’s it!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/thread.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_thread_create</span></span>(entry: <span class="built_in">usize</span>, arg: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> process = task.process.upgrade().unwrap();</span><br><span class="line">    <span class="comment">// create a new thread</span></span><br><span class="line">    <span class="keyword">let</span> new_task = Arc::new(TaskControlBlock::new(</span><br><span class="line">        Arc::clone(&amp;process),</span><br><span class="line">        task.inner_exclusive_access().res.as_ref().unwrap().ustack_base,</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">    ));</span><br><span class="line">    <span class="comment">// add new task to scheduler</span></span><br><span class="line">    add_task(Arc::clone(&amp;new_task));</span><br><span class="line">    <span class="keyword">let</span> new_task_inner = new_task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> new_task_res = new_task_inner.res.as_ref().unwrap();</span><br><span class="line">    <span class="keyword">let</span> new_task_tid = new_task_res.tid;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="comment">// add new thread to current process</span></span><br><span class="line">    <span class="keyword">let</span> tasks = &amp;<span class="keyword">mut</span> process_inner.tasks;</span><br><span class="line">    <span class="keyword">while</span> tasks.len() &lt; new_task_tid + <span class="number">1</span> &#123;</span><br><span class="line">        tasks.push(<span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tasks[new_task_tid] = <span class="literal">Some</span>(Arc::clone(&amp;new_task));</span><br><span class="line">    <span class="keyword">let</span> new_task_trap_cx = new_task_inner.get_trap_cx();</span><br><span class="line">    *new_task_trap_cx = TrapContext::app_init_context(</span><br><span class="line">        entry,</span><br><span class="line">        new_task_res.ustack_top(),</span><br><span class="line">        kernel_token(),</span><br><span class="line">        new_task.kstack.get_top(),</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    (*new_task_trap_cx).x[<span class="number">10</span>] = arg;</span><br><span class="line">    new_task_tid <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, <code>sys_exit</code> will receive a <code>exit_code</code> and recycle its resource. Notice, if <code>tid == 0</code>, the thread of process itself will make other sub threads moved to <code>init</code> process.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pub fn exit_current_and_run_next(exit_code: i32) &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> initproc_inner = INITPROC.inner_exclusive_access();</span><br><span class="line">	<span class="keyword">for</span> child <span class="keyword">in</span> process_inner.children.iter() &#123;</span><br><span class="line">		child.inner_exclusive_access().parent = <span class="literal">Some</span>(Arc::downgrade(&amp;INITPROC));</span><br><span class="line">		initproc_inner.children.push(child.clone());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> recycle_res = <span class="built_in">Vec</span>::&lt;TaskUserRes&gt;::new();</span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> process_inner.tasks.iter().filter(|t| t.is_some()) &#123;</span><br><span class="line">	<span class="keyword">let</span> task = task.as_ref().unwrap();</span><br><span class="line">	remove_inactive_task(Arc::clone(&amp;task));</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(res) = task_inner.res.take() &#123;</span><br><span class="line">		recycle_res.push(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sys_waittid</code> will check thread state and recycle if could, return <code>-2</code> if it has not exited. Why need it? Because <code>sys_exit</code> can’t recycle itself unless the thread of process, other thread can call <code>waittid</code> to remove it from tasks queue, then it will be cleared by rust!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/thread.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// thread does not exist, return -1</span></span><br><span class="line"><span class="comment">/// thread has not exited yet, return -2</span></span><br><span class="line"><span class="comment">/// otherwise, return thread's exit code</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waittid</span></span>(tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> task = current_task().unwrap();</span><br><span class="line">    <span class="keyword">let</span> process = task.process.upgrade().unwrap();</span><br><span class="line">    <span class="keyword">let</span> task_inner = task.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="comment">// a thread cannot wait for itself</span></span><br><span class="line">    <span class="keyword">if</span> task_inner.res.as_ref().unwrap().tid == tid &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> exit_code: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> waited_task = process_inner.tasks[tid].as_ref();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(waited_task) = waited_task &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(waited_exit_code) = waited_task.inner_exclusive_access().exit_code &#123;</span><br><span class="line">            exit_code = <span class="literal">Some</span>(waited_exit_code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// waited thread does not exist</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(exit_code) = exit_code &#123;</span><br><span class="line">        <span class="comment">// dealloc the exited thread</span></span><br><span class="line">        process_inner.tasks[tid] = <span class="literal">None</span>;</span><br><span class="line">        exit_code</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// waited thread has not exited</span></span><br><span class="line">        -<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap8-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/Chap8-2/" class="post-title-link" itemprop="url">rcore-handnote-8-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-8-2"><a href="#Chapter-8-2" class="headerlink" title="Chapter 8-2"></a>Chapter 8-2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We will develop exclusion mechanism previously mentioned.</p>
<p>Beside construction, we need to abstract possible situation of data sharing. A usual native thought is a thread want to modify one thing but due to thread switch, the data is already modified and we get wrong result. So based on this, we want a operation to be <strong>Atomic</strong>, which means the operation excluding others. Now we can alleviate this restriction and generalize this.</p>
<h3 id><a href="#" class="headerlink" title></a></h3><p>Generalization:</p>
<ul>
<li>Allow multiple but finite thread can join one atomic operation.</li>
<li>Allow condition of atomic operation.</li>
</ul>
<p>Before such generalization, we want a way to represent atomic operation. We call the content of this operation <strong>Critical Section</strong>, and multiple threads operations in indeterminate time sequence <strong>Race Condition</strong>. So the basic problem of data sharing push us to identify multiple different operations by different threads, we can’t restrict data because the problem is on modification by threads, we need to <strong>Lock</strong> operations!</p>
<p>So, it there’s a lock sharing by threads, each threads can declare <strong>Lock it!</strong>, and no other threads can access this thread again.</p>
<p>Now, back to our generalization. If this lock has a bound of access number, many can access until reaching a bound. That’s also a reasonable design, we call this <strong>Semaphore</strong>; If this lock has a signal which one thread can send it to others to allow others to access it, That’s also a reasonable design, we call this <strong>Condition Variable</strong>.</p>
<p>If the real minimal sharing thing is <strong>Lock</strong> rather than data, we can discard so called data problem, and focus on lock itself, each threads can do anything in this lock and excluding others.</p>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>No matter which kinds of lock, this is shared among threads.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    <span class="comment">// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> lock_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Lock&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;LockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LockInner</span></span> &#123;</span><br><span class="line">	<span class="keyword">pub</span> data: ...</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In such design, one lock can push one thread to  <code>wait_queue</code> to stop it, and pop front to start it. <code>data</code> is a generalization for various locks.</p>
<p>Then, in one process, it owns many locks used in various conditions, one can easily take it as a generalization of many data(actually nothing related to real data) we want to share.</p>
<h3 id="Basic-Lock"><a href="#Basic-Lock" class="headerlink" title="Basic Lock"></a>Basic Lock</h3><p>Now, we want to construct a basic lock allowing simple <code>lock</code>, <code>unlock</code> operation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Mutex</span></span>: <span class="built_in">Sync</span> + <span class="built_in">Send</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, there’s U-level, M-level, S-level implementation. First, we gonna try first one easily, knowing the heuristic design of M-level, and extend basic thought to S-level.</p>
<hr>
<h4 id="U-level"><a href="#U-level" class="headerlink" title="U-level"></a>U-level</h4><p>A naive approach is to declare a global boolean indicating block state. <code>lock</code> will wait if the boolean is true and try to set it to true, and <code>unlock</code> will set it to false to release.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> mutex :<span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(mutex: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (mutex);</span><br><span class="line">    mutex = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(mutex: <span class="built_in">i32</span>)&#123;</span><br><span class="line">    mutex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, that’s wrong! We can’t construct lock by things we want to lock! Threads can jump in any instructions and break it! That’s means we can’t do it in U-level? We should ponder further in real situation, imagine two threads modify one thing in nearly same time, if we could set two global state in a operation that excluding each other(for example, one state set to 1 and another state set to 0), then only one operation can really be implemented and we can check this condition, allow it to get the lock.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> flag : [<span class="built_in">i32</span>;<span class="number">2</span>] = [<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">// 哪个线程想拿到锁？</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> turn : <span class="built_in">i32</span> = <span class="number">0</span>;         <span class="comment">// 排号：轮到哪个线程? (线程 0 or 1?)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>() &#123;</span><br><span class="line">    flag[<span class="keyword">self</span>] = <span class="number">1</span>;             <span class="comment">// 设置自己想取锁 self: 线程 ID</span></span><br><span class="line">    turn = <span class="number">1</span> - <span class="keyword">self</span>;            <span class="comment">// 设置另外一个线程先排号</span></span><br><span class="line">    <span class="keyword">while</span> ((flag[<span class="number">1</span>-<span class="keyword">self</span>] == <span class="number">1</span>) &amp;&amp; (turn == <span class="number">1</span> - <span class="keyword">self</span>)); <span class="comment">// 忙等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>() &#123;</span><br><span class="line">    flag[<span class="keyword">self</span>] = <span class="number">0</span>;             <span class="comment">// 设置自己放弃锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now analyze the code, we find that no matter which flag is 1, or both 1, indicating certain thread want to get lock, <code>turn</code> will be a excluding state to <code>flag</code>, which means if another thread modify <code>turn</code> in same time, the turn can only be in one of the state and only one thread can get the lock.</p>
<hr>
<h4 id="M-level"><a href="#M-level" class="headerlink" title="M-level"></a>M-level</h4><p>Is there any predefined operation in instructions that is atomic? Then we can use it as a lock. The answer is <strong>Yes</strong>, in RISC-V, it’s:</p>
<ul>
<li>AMO: Atomic memory operation</li>
<li>LR/SC: Load Reserved/Store Conditional</li>
</ul>
<p><strong>AMO</strong>: will read the value in memory and write new value, then store the old value to target register(s.t. <code>amoadd.w rd, rs2, (rs1)</code>). </p>
<p><strong>LR/SC</strong>: <strong>LR</strong> will read memory and store in target register, and leave the addr of this memory, then <strong>SC</strong> could check the addr and write data to this addr, output a condition(0/1) to target register.(s.t. <code>lr.w rd, (rs1)</code>, <code>sc.w rd, rs2, (rs1)</code>)</p>
<p>We can use it to implement a atomic function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># RISC-V sequence for implementing a TAS  at (s1)</span><br><span class="line">li t2, 1                 # t2 &lt;-- 1</span><br><span class="line">Try: lr  t1, s1          # t1 &lt;-- mem[s1]  (load reserved)</span><br><span class="line">        bne t1, x0, Try     # if t1 !&#x3D; 0, goto Try:</span><br><span class="line">        sc  t0, s1, t2      # mem[s1] &lt;-- t2  (store conditional)</span><br><span class="line">        bne t0, x0, Try     # if t0 !&#x3D;0 (&#39;sc&#39; Instr failed), goto Try:</span><br><span class="line">Locked:</span><br><span class="line">        ...                 # critical section</span><br><span class="line">Unlock:</span><br><span class="line">        sw x0,0(s1)         # mem[s1] &lt;-- 0</span><br></pre></td></tr></table></figure>

<p>Here the logic of <code>Try</code> is <code>mem[s1]</code> would be zero if it’s unlocked, and would be non-zero if it’s locked. So, <code>Try</code> will compare <code>t1</code> and <code>x0</code>, actually <code>mem[s1]</code> and <code>0</code>, if equal to zero, then try to store <code>t2</code> into <code>s1</code>, if succeed, it will compare it again for the output signal <code>t0</code> and <code>x0</code>, actually the output signal and <code>0</code>, if succeed, it will jump out otherwise repeat.In this process, if the write operation failed, <code>t0</code> would be non-zero, and repeat in <code>Try</code>.</p>
<p>If we want to <code>Unlock</code>, we write <code>x0</code> to <code>s1</code> to set <code>mem[s1]</code> to zero. Which is the unlocked state.</p>
<h4 id="S-level"><a href="#S-level" class="headerlink" title="S-level"></a>S-level</h4><p>Then we could take the function to rust and package it. A simple refactor is when we in repetition loop, we <code>yield</code>, and give CPU to others.</p>
<hr>
<p>Now, for any kinds of locks, we could apply it to our structure.</p>
<p>First, when we create a lock, we create and push it to list or set in empty element.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_create</span></span>(blocking: <span class="built_in">bool</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> mutex: <span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt; = <span class="keyword">if</span> !blocking &#123;</span><br><span class="line">        <span class="literal">Some</span>(Arc::new(MutexSpin::new()))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Some</span>(Arc::new(MutexBlocking::new()))</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(id) = process_inner</span><br><span class="line">        .mutex_list</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .find(|(_, item)| item.is_none())</span><br><span class="line">        .map(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.mutex_list[id] = mutex;</span><br><span class="line">        id <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner.mutex_list.push(mutex);</span><br><span class="line">        process_inner.mutex_list.len() <span class="keyword">as</span> <span class="built_in">isize</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When we call <code>lock</code>, we should provide corresponding id of the lock, if it’s already locked, we push to <code>wait_queue</code>, else we lock it and goes on.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_lock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(process_inner);</span><br><span class="line">    <span class="built_in">drop</span>(process);</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// os/src/sync/mutex.rs</span></span><br><span class="line"><span class="keyword">impl</span> Lock <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> mutex_inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">        <span class="keyword">if</span> ... &#123;</span><br><span class="line">            mutex_inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">			<span class="comment">// ... other operations</span></span><br><span class="line">            <span class="built_in">drop</span>(mutex_inner);</span><br><span class="line">            block_current_and_run_next();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// ... other operations</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Same reverse operation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_unlock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(process_inner);</span><br><span class="line">    <span class="built_in">drop</span>(process);</span><br><span class="line">    mutex.unlock();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// os/src/sync/mutex.rs</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> mutex_inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">		<span class="comment">// ... other operation</span></span><br><span class="line">		<span class="keyword">if</span> ... &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(waking_task) = mutex_inner.wait_queue.pop_front() &#123;</span><br><span class="line">				add_task(waking_task);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>It’s simple, we only need to switch boolean to number and check the bound. So, the initiated count is the bound, if one thread access, it will minus one, and release, add one. We only need to check positive or negative.</p>
<p>Apply our structure:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">up</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = inner.wait_queue.pop_front() &#123;</span><br><span class="line">            add_task(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">down</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt; <span class="number">0</span> &#123;</span><br><span class="line">        inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">        <span class="built_in">drop</span>(inner);</span><br><span class="line">        block_current_and_run_next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the initiated count equal to <code>1</code>, we back to <code>mutex</code>!, which indicates sole thread access!</p>
<p>Actually, we could use it for <strong>synchronization</strong> operation, we set count to <code>0</code>, if one thread access, it will be blocked, and another thread will could release and add one to count, then the original thread finally could access. Then the second thread will always be advanced to first one.</p>
<p>Here, the first is always advanced to second.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SEM_SYNC: <span class="built_in">usize</span> = <span class="number">0</span>; <span class="comment">//信号量ID</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">first</span></span>() -&gt; ! &#123;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"First work and wakeup Second"</span>);</span><br><span class="line">    semaphore_up(SEM_SYNC); <span class="comment">//信号量V操作</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">second</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second want to continue,but need to wait first"</span>);</span><br><span class="line">    semaphore_down(SEM_SYNC); <span class="comment">//信号量P操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second can work now"</span>);</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Conditional-Variable"><a href="#Conditional-Variable" class="headerlink" title="Conditional Variable"></a>Conditional Variable</h3><p>If we want one thread owns the ability of release lock for others, we need the <code>CondVar</code>. We have to dispatch operation in <code>wait_queue</code>, if one thread <code>signal</code> others, it will pop out a thread, which means trigger it <strong>You are free!</strong>. And if one thread <code>wait</code>, it will push itself to queue to <strong>wait</strong>, The unlock and lock is important because in wait operation, it allow other thread to modify <strong>condition</strong>, but it should be after of the push operation, in case that the signal is before the push, then we can never receive the signal again! We won’t encapsulate condition check to <code>CondVar</code> because it should leave to user to design it, we only leave out interface for user.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">signal</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = inner.wait_queue.pop_front() &#123;</span><br><span class="line">		add_task(task);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(&amp;<span class="keyword">self</span>, mutex: Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(inner);</span><br><span class="line">    mutex.unlock();                 </span><br><span class="line">    block_current_and_run_next();</span><br><span class="line">    mutex.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, if condition check is leave out to user, we can’t ensure the condition be violated due to data sharing, so usually we need to append <code>mutex</code> lock for this section.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> A: <span class="built_in">usize</span> = <span class="number">0</span>;   <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONDVAR_ID: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> MUTEX_ID: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">first</span></span>() -&gt; ! &#123;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"First work, Change A --&gt; 1 and wakeup Second"</span>);</span><br><span class="line">    mutex_lock(MUTEX_ID);</span><br><span class="line">    A=<span class="number">1</span>;</span><br><span class="line">    condvar_signal(CONDVAR_ID);</span><br><span class="line">    mutex_unlock(MUTEX_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">second</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second want to continue,but need to wait A=1"</span>);</span><br><span class="line">    mutex_lock(MUTEX_ID);</span><br><span class="line">    <span class="keyword">while</span> A==<span class="number">0</span> &#123;</span><br><span class="line">        condvar_wait(CONDVAR_ID, MUTEX_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(MUTEX_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that if <code>A=1</code>, second won’t <code>wait</code> repeatly, and goes out.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/day-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/day-1/" class="post-title-link" itemprop="url">arceos-handnote-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day-1"></a>Day-1</h2><h2 id="Component-Kernel"><a href="#Component-Kernel" class="headerlink" title="Component Kernel"></a>Component Kernel</h2><p>Based on experiment, we will construct kernel in increment by demand.</p>
<ul>
<li><strong>UniKernel</strong>: Single S-Level, App is within kernel.</li>
</ul>
<p>Each kernel instance can be considered as a construction based on unikernel.</p>
<ul>
<li><strong>MacroKernel</strong>: Manage U-Level with support on multiple apps, process management etc…</li>
<li><strong>Hypervisor</strong>: Virtual state with restricted communication between U-level and S-level.</li>
</ul>
<h2 id="Aceros-Design"><a href="#Aceros-Design" class="headerlink" title="Aceros Design"></a>Aceros Design</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    App &lt;--&gt; Runtime</span><br><span class="line">    Runtime &lt;--&gt; HAL</span><br></pre></td></tr></table></figure>
<p>The design of Aceros is simple, first <strong>HAL</strong>(<code>axhal</code>) is the abstraction of hardware to initiation trap, stack, MMU, registers based on various architectures. Then <strong>Runtime</strong>(<code>ax*</code>) will be classified as many components to support various environments, like net, task, fs etc…</p>
<p>Each arrow is reversible, in boot, it will be from bottom to top to initiate App. Then when App call something, it will be from top to bottom to evoke functionality.</p>
<p>In real situation, we choose thing based on <em>features</em>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">	App --&gt; axstd</span><br><span class="line">	axstd --&gt; |axfeat| aceros_api</span><br><span class="line">	aceros_api --&gt; axruntime</span><br><span class="line">	axruntime --&gt;|alloc| axalloc</span><br><span class="line">	axruntime --&gt; axhal</span><br><span class="line">	axruntime --&gt;|irq| irq</span><br><span class="line">	axruntime --&gt;|multitask| axtask</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/day-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/04/27/day-2/" class="post-title-link" itemprop="url">arceos-handnote-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 06:13:38" itemprop="dateModified" datetime="2025-06-20T06:13:38+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day-2"></a>Day-2</h2><h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>We delve into paging.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Physical address for pflash#1</span></span><br><span class="line"><span class="keyword">const</span> PFLASH_START: <span class="built_in">usize</span> = <span class="number">0x2200_0000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg_attr(feature = <span class="meta-string">"axstd"</span>, no_mangle)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Makesure that we can access pflash region.</span></span><br><span class="line">    <span class="keyword">let</span> va = phys_to_virt(PFLASH_START.into()).as_usize();</span><br><span class="line">    <span class="keyword">let</span> ptr = va <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Try to access dev region [&#123;:#X&#125;], got &#123;:#X&#125;"</span>, va, *ptr);</span><br><span class="line">        <span class="keyword">let</span> magic = mem::transmute::&lt;<span class="built_in">u32</span>, [<span class="built_in">u8</span>; <span class="number">4</span>]&gt;(*ptr);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got pflash magic: &#123;&#125;"</span>, <span class="built_in">str</span>::from_utf8(&amp;magic).unwrap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PFlash</strong> is the simulation of flash memory of qemu. When qemu boot, it will automatically load file to fixed <strong>MMIO</strong>, and can be directly accessed.</p>
<p><strong>Paging</strong>: <code>feature = [&quot;paging&quot;]</code> is the way to evoke virtual memory management tu support <code>MMIO</code>. Located in <code>axruntime</code>.</p>
<p>The workflow would be:</p>
<ul>
<li>qemu fdt: from <code>0x0c00_0000</code> to <code>0x3000_0000</code>. Construct the space of device.</li>
<li>SBI: from <code>0x8000_0000</code> to <code>0x8020_0000</code>. RISC-V <strong>Supervisor Binary Interface</strong>, it construct a interface for programming language to manipulate device level things.</li>
<li>Kernel Image: from <code>0x8020_0000</code>. <code>_skernel</code> contains S-level things like static data, code etc… <code>_ekernel</code> is user thing.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[link_section = <span class="meta-string">".data.boot_page_table"</span>]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> BOOT_PT_SV39: [<span class="built_in">u64</span>; <span class="number">512</span>] = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_boot_page_table</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 0x8000_0000..0xc000_0000, VRWX_GAD, 1G block</span></span><br><span class="line">    BOOT_PT_SV39[<span class="number">2</span>] = (<span class="number">0x80000</span> &lt;&lt; <span class="number">10</span>) | <span class="number">0xef</span>;</span><br><span class="line">    <span class="comment">// 0xffff_ffc0_8000_0000..0xffff_ffc0_c000_0000, VRWX_GAD, 1G block</span></span><br><span class="line">	<span class="comment">// shift 10 bits to store flags</span></span><br><span class="line">    BOOT_PT_SV39[<span class="number">0x102</span>] = (<span class="number">0x80000</span> &lt;&lt; <span class="number">10</span>) | <span class="number">0xef</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_mmu</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> page_table_root = BOOT_PT_SV39.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">    satp::set(satp::Mode::Sv39, <span class="number">0</span>, page_table_root &gt;&gt; <span class="number">12</span>);</span><br><span class="line">    riscv::asm::sfence_vma_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each entry of page table will map 1G(<code>0x4000_0000</code>) memory. From <code>0x8000_0000</code> to <code>0xc0000_0000</code> at <code>pgd_idx = 2</code> to <code>0xffff_ffc0_8000_0000</code> to <code>0xffff_ffc0_c000_0000</code> at <code>pgd_idx = 102</code>. This will map to a bigger range.</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"Spawned-thread ..."</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Makesure that we can access pflash region.</span></span><br><span class="line">	<span class="keyword">let</span> va = phys_to_virt(PFLASH_START.into()).as_usize();</span><br><span class="line">	<span class="keyword">let</span> ptr = va <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u32</span>;</span><br><span class="line">	<span class="keyword">let</span> magic = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">		mem::transmute::&lt;<span class="built_in">u32</span>, [<span class="built_in">u8</span>; <span class="number">4</span>]&gt;(*ptr)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(s) = <span class="built_in">str</span>::from_utf8(&amp;magic) &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">"Got pflash magic: &#123;s&#125;"</span>);</span><br><span class="line">		<span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		-<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Each task will be in concurrency and dispatched by strategy. If it’s blocked, it will be moved to <code>wait_queue</code> to wait. If it’s ready, it will be moved to <code>run_queue</code> which is scheduler to be dispatched.</p>
<h3 id="Message-Communication"><a href="#Message-Communication" class="headerlink" title="Message Communication"></a>Message Communication</h3><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q1 = Arc::new(SpinNoIrq::new(VecDeque::new()));</span><br><span class="line"><span class="keyword">let</span> q2 = q1.clone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> worker1 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"worker1 ..."</span>);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..=LOOP_NUM &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"worker1 [&#123;i&#125;]"</span>);</span><br><span class="line">        q1.lock().push_back(i);</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> If worker1 doesn't yield, others have</span></span><br><span class="line">        <span class="comment">// no chance to run until it exits!</span></span><br><span class="line">        thread::yield_now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"worker1 ok!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> worker2 = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"worker2 ..."</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(num) = q2.lock().pop_front() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"worker2 [&#123;num&#125;]"</span>);</span><br><span class="line">            <span class="keyword">if</span> num == LOOP_NUM &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"worker2: nothing to do!"</span>);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> it should sleep and wait for notify!</span></span><br><span class="line">            thread::yield_now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"worker2 ok!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Cooperative Scheduling</strong>: Each tasks kindly yield themselves or exit otherwise it will block everyone because the power of CPU occupation is ownned by each tasks.</p>
<p><strong>Preemptive Scheduling</strong>: Each tasks will be automatically suspended by external condition: No lock, no device access; inner condition: run out of current time slice. We can use a <code>disable_count</code> to record this, even for multiple condition restriction, we can sum them up.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axhal::irq::register_handler(TIMER_IRQ_NUM, || &#123;</span><br><span class="line">    update_timer();</span><br><span class="line">    <span class="meta">#[cfg(feature = <span class="meta-string">"multitask"</span>)]</span></span><br><span class="line">    axtask::on_timer_tick();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable IRQs before starting app</span></span><br><span class="line">axhal::arch::enable_irqs()</span><br></pre></td></tr></table></figure>

<p><code>on_timer_tick</code> will be trigger in time slice. When time ticker ticks, <code>run_queue</code> will check and suspend task if possible.</p>
<p>We can make it more dynamic. Which means each task has priority and during the implementation of cpu, each task has a <code>vruntime</code> to be dynamically adjusted by <code>init_vruntime + (delta/weight(nice))</code> where <code>delta</code> and <code>nice</code> are dynamic adjustment number. <code>delta</code> will be incremented by <code>timer</code>, <code>weight(nice)</code> is actually the priority of the task. We ensure that task with lowest <code>vruntime</code> will be placed at top.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/blog/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/72/">72</a><a class="extend next" rel="next" href="/blog/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
