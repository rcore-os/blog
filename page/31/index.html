<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/31/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/31/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">698</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">608</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/06/29/2024-%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5-%E8%8B%A6%E7%93%9C%E5%B0%8F%E4%BB%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/06/29/2024-%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5-%E8%8B%A6%E7%93%9C%E5%B0%8F%E4%BB%94/" class="post-title-link" itemprop="url">2024 春季开源操作系统训练营总结报告 - 第三阶段 - 周积萍 (苦瓜小仔)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-29 22:00:00" itemprop="dateCreated datePublished" datetime="2024-06-29T22:00:00+00:00">2024-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>继我的训练营<a href="https://rcore-os.cn/blog/2024/04/23/2024-%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A1-%E8%8B%A6%E7%93%9C%E5%B0%8F%E4%BB%94/" target="_blank" rel="noopener">第 1-2 阶段总结</a>之后，终于结束了第 3 阶段。</p>
<p>这里的内容与我的幻灯片《<a href="https://docs.qq.com/slide/DTG1vc2FKR2xsYmpL" target="_blank" rel="noopener">阶段 3 学习总结 + 实现 rCore 异步定时器驱动</a>》基本一致。</p>
<p>参加训练营以来的所有笔记，都在 <a href="https://zjp-cn.github.io/os-notes" target="_blank" rel="noopener">https://zjp-cn.github.io/os-notes</a>。</p>
<h1 id="每周任务（均完成）"><a href="#每周任务（均完成）" class="headerlink" title="每周任务（均完成）"></a>每周任务（均完成）</h1><ul>
<li>第 2 周：<a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=404a64695ff36c37b18e4e3d92f849d1" target="_blank" rel="noopener">用户态协程（爬虫）</a></li>
<li>第 3 周：向 embassy 提交修复 Waker unsoundness 的 PR（已合并）<ul>
<li><a href="https://github.com/embassy-rs/embassy/pull/3059" target="_blank" rel="noopener">embassy#3059: use nightly waker_getters APIs</a></li>
<li><a href="https://github.com/embassy-rs/embassy/pull/3069" target="_blank" rel="noopener">embassy#3069: minimize cfg code in task_from_waker</a></li>
</ul>
</li>
<li>第 4-6 周：将 embassy 应用于 rCore 定时器驱动<ul>
<li>仓库地址：<a href="https://gitee.com/ZIP97/rCore-tutorial-code-2024S-embassy" target="_blank" rel="noopener">rCore-tutorial-code-2024S-embassy</a></li>
<li>文档：仓库 README 或者 <a href="https://zjp-cn.github.io/os-notes/rCore-embassy-timer.html" target="_blank" rel="noopener">os-notes/rCore-embassy-timer</a></li>
</ul>
</li>
</ul>
<h1 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h1><ul>
<li><a href="https://zjp-cn.github.io/os-notes/async-os-dev-log_rCore-N.html" target="_blank" rel="noopener">rCore-N (共享调度器 fork) 搭建和踩坑</a></li>
<li><a href="https://zjp-cn.github.io/os-notes/cortex-m-quickstart.html" target="_blank" rel="noopener">cortex-m-quickstart 的 qemu 模拟记录</a></li>
<li><a href="https://zjp-cn.github.io/os-notes/embassy-usage.html" target="_blank" rel="noopener">embassy-usage</a>（学习 embassy 时，自己编写的<a href="https://gitee.com/ZIP97/embassy-usage" target="_blank" rel="noopener">示例仓库</a>）</li>
<li><a href="https://zjp-cn.github.io/os-notes/embassy.html" target="_blank" rel="noopener">研究 embassy 库的经验之谈</a> （RA 配置、条件编译、check-cfg）</li>
<li><a href="https://zjp-cn.github.io/os-notes/green-thread.html" target="_blank" rel="noopener">green-thread</a>（整合绿色线程代码到单独的<a href="https://gitee.com/ZIP97/green-thread" target="_blank" rel="noopener">仓库</a>）</li>
</ul>
<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><ul>
<li><a href="https://zjp-cn.github.io/os-notes/embassy-task.html" target="_blank" rel="noopener">embassy: TaskStorage</a></li>
<li><a href="https://zjp-cn.github.io/os-notes/embassy-timer.html" target="_blank" rel="noopener">embassy: embassy_time_driver::Driver</a></li>
<li><a href="https://zjp-cn.github.io/os-notes/embassy-sync.html" target="_blank" rel="noopener">embassy: sync</a>：zerocopy_channel (SPSC) 和 MPMC Channel</li>
<li><a href="https://zjp-cn.github.io/os-notes/embassy-integrated-timers.html" target="_blank" rel="noopener">embassy: integrated-timers 和任务机制</a>：任务类别、任务调度与执行、任务的状态与改变、添加和删除任务、任务与 Future</li>
</ul>
<h1 id="其他工作"><a href="#其他工作" class="headerlink" title="其他工作"></a>其他工作</h1><ul>
<li>学习 rCore-N 共享调度器项目代码</li>
<li>学习 embassy std 例子时，使用 Miri 碰到 UB 和 ICE<ul>
<li>报告 ICE 给 Miri：<a href="https://github.com/rust-lang/miri/issues/3647" target="_blank" rel="noopener">ICE due to overflow when using a large timeout with futexes</a></li>
<li>在造成 UB 的 critical-section 仓库下留言，提供更多信息：<a href="https://github.com/rust-embedded/critical-section/pull/46" target="_blank" rel="noopener">Mitigate Miri violation</a></li>
</ul>
</li>
<li>每周线上讨论时准备的 PPT<ul>
<li><a href="https://docs.qq.com/slide/DTE5Ta2FXZ1NjSldN" target="_blank" rel="noopener">第 1 周</a></li>
<li><a href="https://docs.qq.com/slide/DTFNkQ0hwaHp2TkxW" target="_blank" rel="noopener">第 2 周</a></li>
<li><a href="https://docs.qq.com/slide/DTHpYQ05HdGZwWUZv" target="_blank" rel="noopener">第 3 周</a></li>
</ul>
</li>
<li>补充基础知识：反复观看讨论的视频回放，把里面提及的新知识全部查一遍<ul>
<li>【笔记】<a href="https://zjp-cn.github.io/os-notes/terminology.html" target="_blank" rel="noopener">专业名词集锦</a></li>
<li>【笔记】<a href="https://zjp-cn.github.io/os-notes/terminology2.html" target="_blank" rel="noopener">专业名词集锦 2</a></li>
<li>【笔记】<a href="https://zjp-cn.github.io/os-notes/terminology3.html" target="_blank" rel="noopener">专业名词集锦 3</a></li>
</ul>
</li>
</ul>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>向老师是我遇见的最好的老师！感谢向老师在这 6 周时间里倾囊相授，尤其对我充满了耐心、热情和鼓励。与您所交流的一切，远远大于我在训练营里学习的所有知识，也是我所得到的最具价值的收获。</p>
<p>在最后一周，我其实在笔记本里，用笔写了很多很多页想告诉向老师的话，但最终没有开口。</p>
<p>我是一个很容易受到鼓励而逐渐喜欢一个知识领域的人。十四年前，我向英语老师请教的第一个问题，打开了我对英语的兴趣大门，在之后的八年直到人生再无英语课堂，我一直是英语课堂上最跃跃欲试的学生，也常常从第一节晚自习缠着英语老师请教各种问题，直到晚自习放学而不知疲惫。七年前，我发现自己能够自学编程，随后在参加各种数学建模比赛中，负责编程，在收获名次的喜悦中，发展起对编程的爱好，而编程这个兴趣持续到现在。我只是凭借自己的努力而缓慢地学习着，所以，当向老师您每周热情地给予我宝贵的学习机会，我内心充满了感激。我甚至在第三阶段的前几周里，就不止一次地梦见您成为了我的老师，当梦醒来，我就已经知足了。但即便我有时非常希望请教您，我依然不得不拒绝这些机会：我不想麻烦任何人，尤其不想浪费向老师的时间和精力 —— 费心去教一个操作系统领域之外的人，是不值得的事情；此外，我害怕因为向老师而发展起对这个领域的兴趣，维持现有的兴趣已经让我支付了巨大的机会成本和沉没成本。</p>
<hr>
<p>感谢陶要仲同学将异步运行时放置到时间中断处理函数里面，这是完成向老师所提的第二个步骤的最重要的一环；也谢谢你在最后一周、连续三个晚上倾听我喋喋不休，最终我们愉快地合作成功。</p>
<hr>
<p>感谢操作系统训练营里的每位老师！感谢第三阶段杨杰老师、赵方亮老师对我的帮助。感谢 rCore 教程的作者陈渝老师、吴一凡老师（如果我了解错误或者仍有遗漏，请告诉我 ta 的名字）。rCore 教程是我阅读操作系统领域的第一本书，它带我领略到操作系统环环相扣的精巧设计，是我能够完成第二、三阶段非常重要的基础。</p>
<hr>
<p>感谢全球的、开放的、包容的 Rust 社区！我所有的 Rust 知识来自 Rust 社区，来自我所阅读的每一篇文档、每一个博客、每一条帖子、每一则帮助、每一处讨论……是社区的力量，让我发现了新的兴趣，培养了新的习惯。没有积累充分的 Rust 知识储备，我不可能参加这个训练营，也不可能轻松阅读每一行 rCore、embassy 里的 Rust 代码，更不可能在训练营里与各位结识，最终走到现在。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/06/29/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%AD%8F%E9%9D%96%E8%BD%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/06/29/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%AD%8F%E9%9D%96%E8%BD%A9/" class="post-title-link" itemprop="url">2024春季开源操作系统训练营第二阶段总结报告-魏靖轩</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-29 21:10:58" itemprop="dateCreated datePublished" datetime="2024-06-29T21:10:58+00:00">2024-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三阶段总结"><a href="#第三阶段总结" class="headerlink" title="第三阶段总结"></a>第三阶段总结</h1><p>第三阶段我参加的是向勇老师的项目6：异步操作系统的实现。</p>
<p>总的来说，6周的项目实训过程中，读了很多代码和文档，做了很多事情，学到了很多的东西。</p>
<p>在参加训练营之前，我对异步的了解其实也就是局限于说我们IO要异步，让出控制权，仅此而已。</p>
<p>但是在训练营中，我真正的接触到了何谓真正的异步，以及如何去实现它，受益匪浅。</p>
<p>同时我也将ArceOS的宏内核版本，将其进行了异步化，使整个内核都使用rust的async和await异步编程实现。</p>
<p>同时它也是无栈协程的切换方式，且对协程采用多栈复用的抢占。</p>
<h1 id="第三阶段成果"><a href="#第三阶段成果" class="headerlink" title="第三阶段成果"></a>第三阶段成果</h1><p>在成果上，实现了对ArceOS家族系的Starry的异步化改造，使用async和await等rust提供的异步编程编写内核，已实现核心主体框架；同时对通用操作系统内核下协程的不合理性做调整，实现内核栈池，通过少量堆栈的复用实现对诸如键盘输入等高优先协程处理的抢占机制。</p>
<p>为后来者留下的东西，首先是代码产出：有充足的代码仓库参考，我将各个小步骤的代码都保存了下来。从原始版本 -&gt; task实现 -&gt; 同步无栈协程与显式执行流 -&gt; 异步无栈协程 -&gt; 多栈复用版本。</p>
<p>同时留下了若干个人的文档心得：考虑到训练营很多同学对从同步到异步的过程一头雾水，其实我本人最开始也是这样的，我个人认为更好的办法是看别人的代码，看看别人是怎么实现了，跟着别人学，先模仿，再谈能不能超越，因此留下文档如下：</p>
<ol>
<li>我个人参考的两个内核的阅读和解析心得（去年OS内核唯二的异步内核）。链接：<a href="https://www.jensei.cn/?p=217" target="_blank" rel="noopener">https://www.jensei.cn/?p=217</a></li>
<li>以Starry为基准的，整个改造过程是如何实现的，包含了从一个ArceOS宏内核（或者说rCore）如何一步步改为无栈异步内核。链接：<a href="https://www.jensenwei.cn/?p=221" target="_blank" rel="noopener">https://www.jensenwei.cn/?p=221</a></li>
<li>我个人对其中一些机制的理解，比如async+await，poll等。链接：<a href="https://www.jensenwei.cn/?p=220" target="_blank" rel="noopener">https://www.jensenwei.cn/?p=220</a></li>
</ol>
<p>当然，更多的中间过程结果在项目六，向老师的文档中有所记录，这里不再列出。</p>
<h1 id="第三阶段感受和体会"><a href="#第三阶段感受和体会" class="headerlink" title="第三阶段感受和体会"></a>第三阶段感受和体会</h1><p>总的来说，第三阶段也算有一定的产出，这么长时间也算没白干，身为一个寄算机人，一切都要落实到代码产出上，光写文档吹牛逼不是一个合格的程序猿。</p>
<p>对我这个异步小白来说，理解和实现异步，再到利用异步的过程，是比较复杂且困难的，而且所面对的是如此大的一个内核，其藕断丝连的耦合性会对改造造成相当大的麻烦。尤其是我们对整个调度和进程管理的部分进行一次彻底的重构，这种挑战相当之大。</p>
<p>但是挑战之大，也是挺过来了，在改造整体框架下，大概前前后后推倒重来了十多次，这也是为什么我那么注重保存每一个小步骤的代码。</p>
<p>总的来说，训练营中我给自己列了一个很高的挑战，也尽力的去完成它了，最后的结果我个人是非常满意的，达到了自己对自己的要求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/06/29/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%99%B6%E8%A6%81%E4%BB%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/06/29/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%99%B6%E8%A6%81%E4%BB%B2/" class="post-title-link" itemprop="url">2024开源操作系统训练营第三阶段总结-tyz-own</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-29 19:16:19" itemprop="dateCreated datePublished" datetime="2024-06-29T19:16:19+00:00">2024-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三阶段总结报告"><a href="#第三阶段总结报告" class="headerlink" title="第三阶段总结报告"></a>第三阶段总结报告</h1><h2 id="相关进度"><a href="#相关进度" class="headerlink" title="相关进度"></a>相关进度</h2><h3 id="前期学习"><a href="#前期学习" class="headerlink" title="前期学习"></a>前期学习</h3><ul>
<li>阅读<a href="https://course.rs/advance/async/future-excuting.html" target="_blank" rel="noopener">《底层探秘: Future 执行与任务调度》</a></li>
<li>阅读<a href="https://stevenbai.top/rust/futures_explained_in_200_lines_of_rust/#%E4%B8%89-rust%E4%B8%AD%E7%9A%84futures" target="_blank" rel="noopener">《200行代码讲透Rust Futures 》</a></li>
<li><a href="https://www.yuque.com/xyong-9fuoz/hg8kgr/xd49izet7xd38gdy" target="_blank" rel="noopener">异步操作系统学术报告</a></li>
<li>编写  <a href="https://github.com/tyz-own/blog/blob/main/%E5%BC%82%E6%AD%A5os/resource/crawler.rs" target="_blank" rel="noopener">用户态异步爬虫</a></li>
<li>阅读<a href="https://embassy.dev/book/" target="_blank" rel="noopener">《Embassy Book》</a></li>
<li>阅读代码<a href="https://github.com/embassy-rs/embassy" target="_blank" rel="noopener">《embassy源码》</a></li>
<li>仓库搭建embassy+rcore并尝试使用<a href="https://github.com/tyz-own/rcore-embassy" target="_blank" rel="noopener">tyz-own/rcore-embassy</a></li>
</ul>
<h3 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h3><ul>
<li>在 <code>rcore</code> 中整合 <code>embassy</code>, 首先遇到的问题就是在 <code>executor</code> 代码中里调试程序出错，后来发现了是因为在 <code>poll</code> 之后的一致性锁服务中加入了M态不是S态，将配置文件中的riscv加上一个<code>s-mode</code>的特征属性就好了。</li>
<li>最后一学期在整合 <code>embassy</code> 提供的时钟中断服务时，因为没有找到关于 <code>Driver trait</code> 的具体实现，加上自身实力不济，并未能成功实现相关功能，是周积萍同学帮忙写的，然后我们测试了在单任务，多任务下的时钟中断服务，发现了各种各样的bug，例如任务的阻塞、无限嵌套时钟中断、忽然打出满屏的<code>#</code>号等等（按理来说地址越界是有相应的处理的，不知道这个为什么会直接不处理，可能不是地址越界造成的问题），有些是 <code>embassy</code>循环时的机制问题，有些则还未能解决，但并不妨碍我们去重构timer.rs中的相关定时器代码。</li>
<li>最后在将代码放入 <code>timer.rs</code> 的定时器中并加以重构之后，我们测试了相关用例，发现符合我们的需求，并且能够正常运行。</li>
</ul>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li>很感谢周积萍同学帮忙讲解 <code>embassy</code> 相关的运行机制，以及帮我解决 <code>embassy</code> 中的相关问题。</li>
<li>也很感谢向老师每周周会时提出的建议，让我对之后的学习有了更加明确的方向。</li>
<li>感谢夏令营的各位老师和助教们的帮助和支持，同时还提供了一个这么好的平台供我们学习成长。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/06/29/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%83%91%E6%98%B1%E5%8F%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/06/29/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E9%83%91%E6%98%B1%E5%8F%AF/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营第三阶段总结报告_郑昱可</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-29 15:33:10" itemprop="dateCreated datePublished" datetime="2024-06-29T15:33:10+00:00">2024-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>三阶段的项目我选择了Rust for Linux驱动开发方向。</p>
<p>具体内容是用Rust重写PL011串口驱动,并能通过跨内核驱动框架，使驱动在arceos和linux运行</p>
<p>这次的项目基于Raspi4b or Raspi3b in Qemu进行开发。</p>
<p>我使用的开发的仓库地址是(R4L_DRV)[<a href="https://github.com/Oveln/R4L_DRV]" target="_blank" rel="noopener">https://github.com/Oveln/R4L_DRV]</a></p>
<h1 id="练习部分"><a href="#练习部分" class="headerlink" title="练习部分"></a>练习部分</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>练习部分分三个</p>
<ul>
<li>用Rust for Linux写一个简单的杂项设备驱动，能做到输入和输出</li>
<li>用跨内核驱动框架，实现一个设备驱动，能控制Raspi4b上的某个引脚，从而控制LED的亮灭</li>
</ul>
<h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h2><p>此前我完全没有接触过驱动的编写，对硬件的原理知之甚少。经过很长一段时间的RTFM，以及了解硬件编程相关的知识。</p>
<p>同时对Linux设备驱动相关的内容也进行了比较充足的了解。</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>练习部分的收获主要是</p>
<ul>
<li>第一次接触了Linux的设备驱动，对文件树中的/dev/xxx的设备文件有了认知</li>
<li>更加明白了什么叫Every thing is File</li>
<li>稍微看的懂电路原理图了x</li>
<li>对很长的文档的恐惧逐渐消退</li>
</ul>
<h1 id="实战部分-使用Rust重写PL011驱动"><a href="#实战部分-使用Rust重写PL011驱动" class="headerlink" title="实战部分:使用Rust重写PL011驱动"></a>实战部分:使用Rust重写PL011驱动</h1><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>串口驱动的内容相较于简单的GPIO繁琐且复杂，需要我进一步的了解Linux的串口子系统tty-uart_driver-uart_port相关的注册关系。</p>
<p>在经过一些努力</p>
<ul>
<li>RTFS</li>
<li>找网上的资料学习（特别感谢野火的文档教程</li>
</ul>
<p>这个问题逐渐的被解决了</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>Rust for Linux经过数年的发展，在某些方面有了完备的抽象。但这次项目所涉及的uart_driver、uart_port、console等结构体没有被支持。</p>
<p>这个问题没什么简单的办法，在Rust for Linux社区中也没有找到好的实现。只能自己做。</p>
<h3 id="如何抽象函数指针"><a href="#如何抽象函数指针" class="headerlink" title="如何抽象函数指针"></a>如何抽象函数指针</h3><p>比如，在uart_port中有很多void*类型的函数指针，如何对这些函数指针进行良好的Rust抽象就成了一大问题。</p>
<p>我在R4L的代码中找到的解决方案是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ops</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">print_int</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span>* <span class="title">print_char</span><span class="params">(<span class="keyword">char</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码可以通过Rust进行如下封装</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OperationsVtable</span></span>&lt;T&gt;(marker::PhantomData&lt;T&gt;);</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Ops</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">print_int</span></span>(x: <span class="built_in">i32</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">print_char</span></span>(x: <span class="built_in">char</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: Ops&gt; OperationsVtable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">print_int</span></span>(x: c_int) &#123;</span><br><span class="line">        T::print_int(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">print_char</span></span>(x: c_char) &#123;</span><br><span class="line">        T::print_char(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> VTABLE: bindings::ops = bindings::ops &#123;</span><br><span class="line">        print_int: <span class="literal">Some</span>(Self::print_int),</span><br><span class="line">        print_char: <span class="literal">Some</span>(Self::print_char)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">build</span></span>() -&gt; *<span class="keyword">const</span> bindings::ops &#123;</span><br><span class="line">        &amp;Self::VTABLE <span class="keyword">as</span> *<span class="keyword">const</span> _</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义了上面三段后就可以定义一个自己的Ops</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyOps</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Ops <span class="keyword">for</span> MyOps &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后想要得到MyOps的对应的C的ops结构体只需要</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ops = OperationsVtable&lt;MyOps&gt;::build();</span><br></pre></td></tr></table></figure>


<h2 id="现在的成果和收获"><a href="#现在的成果和收获" class="headerlink" title="现在的成果和收获"></a>现在的成果和收获</h2><p>对Linux的C代码中的serial_core.h中的uart_driver和uart_port以及console做了比较完整的抽象。</p>
<p>我也能够比较好的使用Rust中的Pin使数据固定在内存上的某个地方了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/06/29/2024%E6%98%A5%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%E4%B8%80%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A--%E7%AC%A6%E4%BF%8A%E6%9D%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/06/29/2024%E6%98%A5%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%E4%B8%80%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A--%E7%AC%A6%E4%BF%8A%E6%9D%B0/" class="post-title-link" itemprop="url">2024春开源操作系统训练营第三阶段项目一总结报告--符俊杰</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-29 04:17:48" itemprop="dateCreated datePublished" datetime="2024-06-29T04:17:48+00:00">2024-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第三阶段总结"><a href="#第三阶段总结" class="headerlink" title="第三阶段总结"></a>第三阶段总结</h3><h4 id="前期实验"><a href="#前期实验" class="headerlink" title="前期实验"></a>前期实验</h4><p>第三阶段前期老师带领我们基于Arceos做了两周的实验</p>
<ul>
<li><strong>练习1：支持彩色打印 println!</strong><br>较为简单，且有多种解法，可以在项目不同的层次进行修改来支持彩色打印</li>
<li><strong>练习2：支持HashMap数据类型</strong><br>在官网找到HashMap的源码然后进行一定增删就可以实现，因为初学rust，有些高级用法很生疏，改起来有点费劲。</li>
<li><strong>练习3：为内存分配器实现新的内存算法</strong><br>我的实现比较粗暴，有些内存空隙直接不要了</li>
<li><strong>练习4：解析dtb并打印</strong><br>在crate.io中有现成的解析dtb的crate，但是需要进行一定修改才能满足任务要求</li>
<li><strong>练习5：抢占式调度算法</strong><br>这个任务比较简单，改一下<code>crates/scheduler/src/fifo.rs</code>就好了</li>
</ul>
<p>第二周的五个实验如下：</p>
<ul>
<li><strong>实验一：从外部加载应用</strong></li>
<li><strong>实验2：把应用拷贝到执行区域并执行</strong></li>
<li><strong>实验3：通过 ABI 调用 ArceOS 功能</strong></li>
<li><strong>实验4：正式在 App 中调用 ABI</strong></li>
<li><strong>实验5：支持内核和应用分离的地址空间及切换</strong></li>
</ul>
<p>对于第二周的五个实验总体来说就是把外部应用APP写入PFLASH中，然后在内核中写一个APP加载器，为APP初始好寄存器后跳转到APP执行，同时支持多地址空间以及给APP传递内核<code>API_TABLE</code>的地址。第二周让我印象深刻的是跳转到APP执行前对寄存器的初始化很重要，如果初始化不到位可能会导致运行APP的时候出现各种错误。同时实验4也让我学到了如何以通过传参的方式支持APP调用内核API。</p>
<p>之后就是进入真正的项目阶段了，项目阶段是在lkmodel上开发，lkmodel相比Arceos我个人感觉难度还是有一定提升，且前两周刚熟悉完Arceos的代码和模块（T_T），一开始还是挺畏难的。不过最后在做的过程中慢慢熟悉lkmodel后也就不那么害怕了。</p>
<h4 id="进入真正的项目阶段"><a href="#进入真正的项目阶段" class="headerlink" title="进入真正的项目阶段"></a>进入真正的项目阶段</h4><h5 id="musl入手"><a href="#musl入手" class="headerlink" title="musl入手"></a>musl入手</h5><p>由于musl编译出来的app系统调用要比glibc简单的多且少得多，因此我先尝试支持用musl-gcc编译的hello_world程序。<br>经历大概如下：</p>
<ul>
<li>支持加载hello_world.bin程序并执行</li>
<li>支持对elf的解析</li>
<li>支持对hello_world.elf程序的执行</li>
</ul>
<h4 id="支持glibc"><a href="#支持glibc" class="headerlink" title="支持glibc"></a>支持glibc</h4><p>要支持glibc要实现和空实现一些syscall，让我印象比较深的是writev_syscall<br>原本lkmodel的writev_syscall实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pub fn writev(fd: usize, iov_array: &amp;[iovec]) -&gt; usize &#123;</span><br><span class="line">    assert!(fd &#x3D;&#x3D; 1 || fd &#x3D;&#x3D; 2);</span><br><span class="line">    for iov in iov_array &#123;</span><br><span class="line">        debug!(&quot;iov: &#123;:#X&#125; &#123;:#X&#125;&quot;, iov.iov_base, iov.iov_len);</span><br><span class="line">        let bytes &#x3D; unsafe &#123; core::slice::from_raw_parts(iov.iov_base as *const _, iov.iov_len) &#125;;</span><br><span class="line">        let s &#x3D; String::from_utf8(bytes.into());</span><br><span class="line">        error!(&quot;&#123;&#125;&quot;, s.unwrap());</span><br><span class="line">    &#125;</span><br><span class="line">    iov_array.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是运行的时候发现没有输出，于是我简单的在writev里面加了一个<code>early_console::write_bytes(bytes);</code>。但发现输出的时候遇到了奇怪的现象，例如输出一个<code>Hello_world</code>，他会进行多次输出，并且输出的字符个数逐渐减少。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改后：</span><br></pre></td></tr></table></figure>
<p>pub fn writev(fd: usize, iov_array: &amp;[iovec]) -&gt; usize {<br>    assert!(fd == 1 || fd == 2);<br>    let mut total_bytes_written = 0;<br>    for iov in iov_array {<br>        //debug!(“iov: {:#X} {:#X}”, iov.iov_base, iov.iov_len);<br>        let bytes = unsafe { core::slice::from_raw_parts(iov.iov_base as *const _, iov.iov_len) };<br>        let s = String::from_utf8(bytes.into());<br>        early_console::write_bytes(bytes);<br>        total_bytes_written += iov.iov_len;<br>    }<br>    total_bytes_written<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 发现的问题及解决思路</span><br><span class="line">1. 在支持glibc的时候由于glibc调用了一些task相关的syscall，需要拿到当前的task_sched_info，但是每次都拿不到（None），就很奇怪，明明也进行了task::init()，为什么拿不到呢？后面一直跟踪拿task_sched_info的源码才发现是通过读gp寄存器拿的，即项目中的&#96;&#96;&#96;pub fn gen_read_current_raw(symbol: &amp;Ident, ty: &amp;Type) -&gt; proc_macro2::TokenStream &#96;&#96;&#96;存也是把task_sched_info的地址存在gp寄存器上&#96;&#96;&#96;pub fn gen_write_current_raw(symbol: &amp;Ident, val: &amp;Ident, ty: &amp;Type) -&gt; proc_macro2::TokenStream &#96;&#96;&#96;。然后我就怀疑gp寄存器在app运行时被改变了，于是查看qemu.log，果然一开始就动了gp寄存器。于是我采用一个全局静态变量来存当前的task_sched_info，这样就可以顺利拿到了。</span><br><span class="line">2. 一开始没有清理.bss，导致运行时各种奇怪的问题。其实一开始没清理.bss是因为我在做payload的时候是创建了一个32M的空文件（全0），然后把app.elf文件写进去，我心想写的时候是全0，我就不用清理了吧，但在debug的时候发现利用lkmodel下的elf crate来对app.elf进行解析的时候竟然把.bss那块儿区域写了一些数据，就因为偷了个懒，导致又浪费一大把时间debug。</span><br><span class="line">3. 在支持vfork时，vfork的子进程由于要copy父进程的进入trap_handler时的寄存器信息以正确返回。在子进程返回时发现其trap上下文的sepc寄存器一直是0，且其他寄存器的值也不正常，经过调试发现是copy父进程的trap上下文时出现了问题，最后发现问题如下：</span><br><span class="line">pt_regs_addr()函数（即拿到trap上下地址的函数）原来是</span><br></pre></td></tr></table></figure>
<pre><code>pub fn pt_regs_addr(&amp;self) -&gt; usize {
    self.kstack.as_ref().unwrap().top() - align_down(TRAPFRAME_SIZE, STACK_ALIGN)
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是由于align_down导致减去的值不是TRAPFRAME_SIZE</span><br><span class="line">但在汇编中却是用self.kstack.as_ref().unwrap().top() 直接减去TRAPFRAME_SIZE</span><br><span class="line">如下：</span><br></pre></td></tr></table></figure>
<p>.Ltrap_entry_s:<br>    addi    sp, sp, -{trapframe_size}<br>    SAVE_REGS 0<br>    mv      a0, sp<br>    auipc   a1, 0          # Load the upper 20 bits of the PC into a1<br>    addi    a1, a1, 12<br>    call    riscv_trap_handler<br>    RESTORE_REGS 0<br>    sret</p>
<p>.Ltrap_entry_u:<br>    addi    sp, sp, -{trapframe_size}<br>    SAVE_REGS 1<br>    mv      a0, sp<br>    li      a1, 1<br>    call    riscv_trap_handler<br>    addi    t0, sp, {trapframe_size}    // put supervisor sp to scratch<br>    csrw    sscratch, t0<br>    RESTORE_REGS 1<br>    sret</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因此在rust中是用pt_regs_addr()获取trap_frame地址然后进行读写操作是和汇编里面的存储位置不匹配。</span><br><span class="line">4. 不知道是不是因为静态链接的原因，我这边argc,argv,env在栈上的排布和ppt不一样，用ppt的方式排布app拿不到argv</span><br><span class="line">下面是我在其他地方看到的另一种排布方式，用此方式排布app可以正确拿到argv参数</span><br></pre></td></tr></table></figure>
<h2 id="高地址"><a href="#高地址" class="headerlink" title="高地址"></a>高地址</h2><p>  0<br>  …<br>  envp[1]<br>  envp[0]<br>  0<br>  …<br>  argv[1]<br>  argv[0]<br>  argc<br>–<br>低地址</p>
<p>```</p>
<ol start="5">
<li>由于要支持多地址空间，因此我需要给每个app重新分配一个页表，并在这个基础上为app分配内存。同时我为了复用lkmodel下的代码，我采用<code>user_mode_thread</code>来创建一个新的进程，因此我需要对<code>user_mode_thread</code>代码进行修改，最重要的是修改地址空间那块，我需要为app准备一个新的地址空间，而不是和内核共享同一个地址空间。于是我考虑更改mm_copy模块，但后面想到不能直接改这里，因为mm_copy这个函数会被多个模块调用，我改了可能其他模块就跑不通了。于是我决定在<code>user_mode_thread</code>外面为app的task.mm重新赋值（即建立新的地址空间），但神奇的事情发生了，赋值后会导致内核的页表（即之前task.mm指向的区域）被回收（Arc指针计数并不为0），之后为了验证是否是我修改了其他模块导致该问题，于是我重新git clone下来了原仓库并在原仓库基础上进行测试，发现还是会出现相同的问题。最后我通过其他手段绕过了该问题。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>这一个月的项目实习使我debug能力又有了提升同时更加深刻的理解了musl-gcc,glib-gcc的区别，同时也更加深刻的了解了Unikernel。同时也跟同学老师们学到了很多东西。</li>
</ol>
<h4 id="仓库链接"><a href="#仓库链接" class="headerlink" title="仓库链接"></a>仓库链接</h4><p><a href="https://github.com/xhyf77/lkmodel/tree/dev" target="_blank" rel="noopener">https://github.com/xhyf77/lkmodel/tree/dev</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/06/28/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A53%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-xuejianxinokok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/06/28/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A53%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-xuejianxinokok/" class="post-title-link" itemprop="url">2024春夏季开源操作系统训练营3阶段总结-xuejianxinokok</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-28 11:17:04" itemprop="dateCreated datePublished" datetime="2024-06-28T11:17:04+00:00">2024-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://gitee.com/xuejianxinokok/mysqldoc/blob/master/rust/arcos%E9%97%AE%E9%A2%98.md#arceos-lkmodel-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">请转到:2024春夏季开源操作系统训练营3阶段总结-xuejianxinokok</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/06/01/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-charain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/06/01/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-charain/" class="post-title-link" itemprop="url">2024春季开源操作系统训练营第一阶段总结报告-charain</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-01 20:12:36" itemprop="dateCreated datePublished" datetime="2024-06-01T20:12:36+00:00">2024-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<p><del>报告编写时间好像有点晚</del></p>
<h2 id="第一阶段总结报告"><a href="#第一阶段总结报告" class="headerlink" title="第一阶段总结报告"></a>第一阶段总结报告</h2><p>大概是寒假的时候，在网络上寻找一些学习操作系统的资料时，接触到了rcore lab和这个训练营，然后看到有一起学习的群友报名了这个训练营之后，立马顺着链接跟过来了。</p>
<p>在此之前并没有编写过类似的操作系统，了解学习过一些操作系统的知识，而且也对rust不是很熟悉。</p>
<h3 id="rust语言"><a href="#rust语言" class="headerlink" title="rust语言"></a>rust语言</h3><p>在参加这个训练营之前，是尝试学习过rust的，当时rust吸引我的原因不是因为它在内存安全方面的独特特性，而是它是一门现代的，系统级编程语言。而我确实也需要这样的语言(尝试为c语言寻找更加现代的替代)。不过当时由于rust特有的难以入门的特性和陡峭的学习曲线，随后便暂时放弃了这个语言的学习。</p>
<p>在参加了这个训练营之后，重新捡起来rust语言，发现也并不是想象中的那么可怕，其语言特性的设计理念，也可以理解。而且从这里，也进一步的体验到了其作为一门现代语言的好处。例如包管理器(安装新的工具链太方便啦)，更好的lsp服务器(感觉比clangd强)，以及语言提供的恰到好处的抽象设计，都让人感到很舒心。而且作为一门系统级语言，也很方便的可以在之后帮助我编写运行在一些裸机上的应用程序。</p>
<h3 id="rustlings"><a href="#rustlings" class="headerlink" title="rustlings"></a>rustlings</h3><p>这个练习前半部分基本都是和语言特性相关的内容，做起来还是很迅速的，基本上没有花费很长的时间便完成了这一部分的内容。但是对于后面的算法题部分，便开始困难起来了。倒不是这些数据结构和算法不清楚，如果使用c语言实现它们，那么将易如反掌，但是对于自己不熟悉，且时时刻刻强调内存安全的rust语言而言，便显得很困难。好在在查阅资料和不断的尝试下，还是将这一部分内容给完成了。</p>
<h2 id="第二阶段总结报告"><a href="#第二阶段总结报告" class="headerlink" title="第二阶段总结报告"></a>第二阶段总结报告</h2><p>第二阶段的前三个实验，基本上是连着几天完成的，最后两个实验拖慢了几天。</p>
<p>总的来说，对于这一部分，还是学到了很多知识。</p>
<p>首先说一说riscv方面吧，对于这一方面相对更加熟悉，之前也编写过riscv的处理器和模拟器，并且也使用c语言编写过裸机应用，对于riscv相关的知识方面，还是很顺滑的便掌握了。</p>
<p>对于rust语言，写到这个阶段已经比第一阶段顺手多了，不过在使用这个语言时使用的很多设计理念，例如资源获取即初始化，等等设计方面的考量，还是学习到了很多。或许在完成这一部分内容之后，可以试着使用rust去重构之前写过的一些c语言项目了(乐)。</p>
<p>随后是对于操作系统相关的知识，之前学习过一些操作系统的概念和知识，但是对于真正的将操作系统实现出来，还是第一次尝试做出来。以前学习操作系统时还尝试看过一些linux内核设计相关的书籍，最后的结果是看的比较稀里糊涂。通过这次操作系统设计之后，或许之后入门linux能够更加顺利一些。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/31/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-qiuanran/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/31/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-qiuanran/" class="post-title-link" itemprop="url">2024春夏季训练营第一阶段总结-qiuanran</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-31 01:17:02" itemprop="dateCreated datePublished" datetime="2024-05-31T01:17:02+00:00">2024-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在去年秋天听闻了这个训练营，机缘巧合之下结识了Rust和rcore。 也许是由于rust这门语言入门门槛比较高，加之当时没有其他更modern语言的学习经验，只做完Rustlings就已经打算放弃了。从去年秋天到现在一直在写Rust,也了解了许多系统方面的知识，就打算在这次训练营中弥补一些遗憾。</p>
<h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>第一阶段更多的是教初学者通过查手册、book或者是问AI来逐渐了解Rust的各种特性，如所有权机制（一个value只能对应一个所有者）、RAII机制（自动回收）、智能指针（个人认为智能指针的学习更多的应该落实于应用场景：即它为什么而存在的问题）、生命周期（我认为它的存在更多的是帮助编译器编译）等，这些是Rust比较有意思的机制，也是大大保障了代码安全性的由来。</p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>有了去年以来一直积累的Rust经验，做Rustlings倒是非常快了。最后出的十道算法题非常有意思，大大加深了我对于智能指针的认识，虽然都是入门的算法题倒算是个很新奇的体验。</p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="https://github.com/LearningOS/rust-based-os-comp2024/blob/main/2024-spring-scheduling-1.md" target="_blank" rel="noopener">由训练营给出的学习资料</a>，同时也推荐Stanford的CS110L。 </p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><h3 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h3><p>rcore这个类Unix内核对于了解各种OS的各种核心内容而言是非常有帮助的，实际上，若不是有了Rust的一些经验，很难理清由理论转换为具体实现的过程。</p>
<p>对于rcore的学习，刚开始我十分痛苦，看着后面的实验要求一时间无计可施，只能由各种已经实现的syscall一个个去trace他们的调用关系，才有了一点点的大致思路。但具体实现起来又有其他的问题，这时候我的目光就放在了具体的数据结构上，需要彻底弄明白每一个数据结构的具体功能、与其他数据结构的关联，才能够说很好的掌握了整个流程。</p>
<h3 id="rcore总结"><a href="#rcore总结" class="headerlink" title="rcore总结"></a>rcore总结</h3><ul>
<li>Chapter1-2：需要关注于环境如何一步步搭建，如何切换特权级</li>
<li>Chapter3：难点在于理解任务切换时候的流程：trap上下文的保存。应用在内核中处理时， 其 Trap 控制流调用__switch函数，这个函数非常重要，里面就是任务的上下文寄存器。</li>
<li>Chapter4：对于我而言，虚拟内存几乎是最难的一个章节了，以至于看到实验要求的时候说注意数据被切分成两个不同的页表中时我甚至不知道它想表达什么，反复观看、查找资料之后才能艰难完成。</li>
<li>Chapter5：关键在于理解有关进程的每一个数据结构，以及它的调度机制，重点需要弄明白suspend_current_and_run_next这个函数以及整个task的工作流程：take_current_task 来取出当前正在执行的任务，修改其进程控制块内的状态变成Running，随后将这个任务放入任务管理器的队尾。接着调用 schedule 函数来触发调度并切换任务。</li>
<li>Chapter6：文件系统相比起前面的章节有些异常庞大了，需要抓住核心抽象以及它的层次结构。</li>
<li>Chapter7：了解进程之间如何通信，关注于各种不同的通信方式。</li>
<li>Chapter8：并发是OS绕不开的一个话题，掌握各种锁+线程的概念对于理解并发有奇效，但其实Rust的很受欢迎的异步并发并没有提及，想来是语言特性而不属于OS教学层面上的。推荐一个了解Rust异步并发非常好的读物：<a href="https://tokio.rs/tokio/tutorial/async" target="_blank" rel="noopener">Async in depth | Tokio - An asynchronous Rust runtime</a></li>
</ul>
<h3 id="一些心得"><a href="#一些心得" class="headerlink" title="一些心得"></a>一些心得</h3><p>我觉得最重要的，也是支撑我艰难走过rcore这道难关的就是一个观念，在南京大学的OS课程上反复强调的：操作系统就是一个应用程序。这也是我在进行每一个lab后最大的感触。在接管了trap之后，所有的一切都是逻辑上的开发，与不同的应用程序没有什么区别。</p>
<h3 id="资料-1"><a href="#资料-1" class="headerlink" title="资料"></a>资料</h3><ul>
<li>南京大学OS课程</li>
<li>MIT6.S081: xv6 book</li>
<li>CSAPP</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/30/opencamp-24sp-%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/30/opencamp-24sp-%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">opencamp-24sp-第一二阶段总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-30 22:27:58" itemprop="dateCreated datePublished" datetime="2024-05-30T22:27:58+00:00">2024-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DAY0-DAY"><a href="#DAY0-DAY" class="headerlink" title="DAY0-DAY?"></a>DAY0-DAY?</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>本篇内容为<code>基础阶段 - Rust编程</code>的总结，分为<code>环境配置</code>及<code>语言学习</code>两个板块。</p>
<p>因为语言学习涉及内容较为零散，故将DAY0-DAY?汇聚成一篇。</p>
<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h2><h3 id="1-0-前言"><a href="#1-0-前言" class="headerlink" title="1.0 前言"></a>1.0 前言</h3><p>环境配置部分主要流程就是根据教程内容一步步安装，同时需要注意以下几点：</p>
<ul>
<li>学会分析报错内容</li>
<li>学会利用搜索引擎/gpt解决报错问题<h3 id="1-1-wsl-ubuntu22-04-vscode"><a href="#1-1-wsl-ubuntu22-04-vscode" class="headerlink" title="1.1 wsl+ubuntu22.04+vscode"></a>1.1 wsl+ubuntu22.04+vscode</h3>之前在完成pintos时配置过，故省略</li>
</ul>
<h3 id="1-2-配置rust环境"><a href="#1-2-配置rust环境" class="headerlink" title="1.2 配置rust环境"></a>1.2 配置rust环境</h3><p>按照LearningOS仓库中readme指定的<a href="https://rcore-os.cn/arceos-tutorial-book/ch01-02.html" target="_blank" rel="noopener">教程</a>一步步操作即可</p>
<p>注意没有<code>curl</code>需要先通过如下命令安装（其他同理）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure>

<h3 id="1-3-配置git-github-ssh并clone代码"><a href="#1-3-配置git-github-ssh并clone代码" class="headerlink" title="1.3 配置git+github ssh并clone代码"></a>1.3 配置git+github ssh并clone代码</h3><p>之前配置过，故省略</p>
<p>注意：配置ssh后，git push到github时若仍然提示输入密码，可修改.git/config文件中的url，从HTTPS <a href="https://github.com/achintski/opencamp-24sp-daily.git" target="_blank" rel="noopener">https://github.com/achintski/opencamp-24sp-daily.git</a> 更新为SSH <a href="mailto:git@github.com">git@github.com</a>:achintski/opencamp-24sp-daily.git</p>
<h2 id="2-rust语法学习及rustlings"><a href="#2-rust语法学习及rustlings" class="headerlink" title="2 rust语法学习及rustlings"></a>2 rust语法学习及rustlings</h2><h3 id="2-0-前言"><a href="#2-0-前言" class="headerlink" title="2.0 前言"></a>2.0 前言</h3><ul>
<li>初学一门新语言，通常可以采用孟岩老师提倡的“快速掌握一个语言最常用的50%”方法，快速入门</li>
<li>但注意到rust语言的特殊性以及接下来rCore的开发的复杂性，我们必须还要通过阅读系统而权威的大部头书籍来全面深入地学习</li>
<li>同时，一些特别细节的点在入门资料和书籍中未必涉及，需要我们查阅<a href="https://doc.rust-lang.org/stable/std/all.html" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<p>因此我穿插查阅/参考了如下资料：</p>
<ul>
<li>快速入门：<ul>
<li><a href="https://www.runoob.com/rust/rust-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li>
<li><a href="https://course.rs/about-book.html" target="_blank" rel="noopener">《Rust语言圣经》</a>(最推荐，整合了很多其他的经典资料)</li>
</ul>
</li>
<li>官方文档：<ul>
<li><a href="https://doc.rust-lang.org/stable/std/index.html" target="_blank" rel="noopener">The Rust Standard Library</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/" target="_blank" rel="noopener">《The Rust Reference》</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/index.html" target="_blank" rel="noopener">《Rust By Example》</a></li>
</ul>
</li>
<li>Slides:<ul>
<li><a href="https://lab.cs.tsinghua.edu.cn/rust/" target="_blank" rel="noopener">thu 程序设计训练（Rust）</a></li>
<li><a href="https://opencamp.cn/os2edu/camp/2024spring/stage/1" target="_blank" rel="noopener">2024春夏季训练营课程资料</a></li>
</ul>
</li>
<li>Books：<ul>
<li><a href="https://www.amazon.com/Rust-Programming-Language-2nd-dp-1718503105/dp/1718503105/ref=dp_ob_title_bk" target="_blank" rel="noopener">《The Rust Programming Language, 2nd Edition》</a></li>
</ul>
</li>
</ul>
<p>并通过穿插完成<code>rustlings</code>作业进行巩固练习</p>
<h3 id="2-1-rust语法"><a href="#2-1-rust语法" class="headerlink" title="2.1 rust语法"></a>2.1 rust语法</h3><h4 id="2-1-0-前言"><a href="#2-1-0-前言" class="headerlink" title="2.1.0 前言"></a>2.1.0 前言</h4><p>注意：第一次学一个概念时一定要打好基础，不要为了追求进度而忽略质量</p>
<h4 id="2-1-1-常见内容"><a href="#2-1-1-常见内容" class="headerlink" title="2.1.1 常见内容"></a>2.1.1 常见内容</h4><ul>
<li><p>HelloWorld</p>
</li>
<li><p>类型<br>  *原生类型</p>
<pre><code>* 布尔 bool：两个值 true/false。
* 字符 char：用单引号，例如 &apos;R&apos;、&apos;计&apos;，是 Unicode 的。
* 数值：分为整数和浮点数，有不同的大小和符号属性。
    * i8、i16、i32、i64、i128、isize
    * u8、u16、u32、u64、u128、usize
    * f32、f64
    * 其中 isize 和 usize 是指针大小的整数，因此它们的大小与机器架构相关。
    * 字面值 (literals) 写为 10i8、10u16、10.0f32、10usize 等。
    * 字面值如果不指定类型，则默认整数为 i32，浮点数为 f64。
* 数组 (arrays)、切片 (slices)、str 字符串 (strings)、元组 (tuples)
* 指针 &amp; 引用
* 函数
* 闭包</code></pre><ul>
<li>组合类型<ul>
<li>结构体（逻辑与）</li>
<li>标签联合（逻辑或）</li>
</ul>
</li>
</ul>
</li>
<li><p>条件</p>
</li>
<li><p>循环</p>
</li>
<li><p>结构化数据</p>
</li>
<li><p>IO</p>
<h4 id="2-1-2-特殊内容"><a href="#2-1-2-特殊内容" class="headerlink" title="2.1.2 特殊内容"></a>2.1.2 特殊内容</h4><p>Q：任何行为背后都有动机，Rust特性这样设计的动机是什么呢？</p>
</li>
<li><p>变量绑定–<code>let</code></p>
</li>
<li><p>不可变变量 vs 常量</p>
</li>
<li><p>语句 vs 表达式</p>
</li>
<li><p>所有权 &amp; 生命周期</p>
<ul>
<li>高级语言 <code>Python/Java</code> 等往往会弱化堆栈的概念，但是要用好 <code>C/C++/Rust</code>，就必须对堆栈有深入的了解，原因是两者的内存管理方式不同：前者有 <code>GC</code> 垃圾回收机制，因此无需你去关心内存的细节。</li>
<li>在所有权模型下：堆内存的生命周期，和创建它的栈内存的生命周期保持一致</li>
<li><code>copy</code> / <code>move</code></li>
<li><code>borrow</code>（借用）<ul>
<li>借用<code>&amp;</code>与可变借用<code>&amp;mut</code></li>
<li>借用规则</li>
</ul>
</li>
<li>函数的参数和返回值与变量绑定的规则相同</li>
</ul>
</li>
</ul>
<h3 id="2-2-rustlings"><a href="#2-2-rustlings" class="headerlink" title="2.2 rustlings"></a>2.2 rustlings</h3><p>大致步骤：终端输入命令<code>rustlings watch</code>、修改代码、删掉注释并自动跳转下一题<br>注意：后两个资料中概念介绍顺序和习题涉及概念顺序一致<br>技巧：学会分析编译器提示，有的题目是语法错误，有的是考虑不周导致测试过不去</p>
<ul>
<li><p>vec2</p>
</li>
<li><p>enums3</p>
</li>
<li><p>strings3&amp;strings4</p>
<ul>
<li><code>into()</code></li>
</ul>
</li>
<li><p>hashmaps2</p>
<ul>
<li><code>HashMap</code>的<code>get()</code>方法只能返回值的引用</li>
<li>解引用操作<code>*</code>也需要转移所有权</li>
</ul>
</li>
<li><p>quiz2</p>
<ul>
<li>match中模式绑定的值，如：<code>Command::Append(n) =&gt; {}</code> 中的n是&amp;usize类型，可以使用<code>for i in 0..*n</code>完成遍历</li>
<li>对于<code>不可变引用的string</code>，要想修改需要先将其<code>clone</code>给一个可变变量</li>
</ul>
</li>
<li><p>options1</p>
<ul>
<li>可用<code>match</code>，也可以用<code>if</code></li>
</ul>
</li>
<li><p>options2</p>
<ul>
<li>注意<code>Options枚举</code>的本质目的：解决<code>Rust</code>中变量是否有值的问题，因此第二个任务中需要两层嵌套的<code>Some</code></li>
<li><code>if let</code> / <code>while let</code>本质上是<code>match</code></li>
<li><code>match</code>中匹配后的绑定</li>
</ul>
</li>
<li><p>options3</p>
<ul>
<li>在 <code>Some(p) =&gt; println!(&quot;Co-ordinates are {},{} &quot;, p.x, p.y)</code> 处，value partially moved here；而在最后返回值<code>y</code>处，value used here after partial move</li>
<li>因此需要：borrow this binding in the pattern to avoid moving the value</li>
<li>区分<code>ref</code>和<code>&amp;</code></li>
</ul>
</li>
<li><p>errors2</p>
<ul>
<li>对于返回结果是<code>Result</code>的函数，一定要显式进行处理</li>
<li><code>?</code>操作符（本质是宏，同时可以链式调用）<ul>
<li>作用：提前传播错误</li>
<li>场合：返回值是 Result 或者 Option 函数中</li>
<li>对于 Result 类型，<ul>
<li>如果是 Err 则提前返回，当前函数立即返回该错误。</li>
<li>否则，从 Ok 中取出返回值作为 ? 操作符的结果。</li>
</ul>
</li>
<li>对于 Option 类型，<ul>
<li>如果是 None 则提前返回，当前函数立即返回 None。</li>
<li>否则，从 Some 中取出返回值作为 ? 操作符的结果。</li>
</ul>
</li>
</ul>
</li>
<li>本题既可以使用<code>?</code>操作符，也可以使用<code>match</code></li>
</ul>
</li>
<li><p>errors3</p>
<ul>
<li><code>?</code>操作符只能在返回值为<code>Result</code> / <code>Option</code> 的函数中使用</li>
<li>需要修改三处：<ul>
<li><code>use std::error::Error;</code></li>
<li>给<code>main</code>函数增加返回值 <code>-&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;</code></li>
<li>末尾返回 <code>Ok(())</code></li>
</ul>
</li>
<li>也可以用<code>match</code> / <code>if else</code></li>
</ul>
</li>
<li><p>errors4</p>
<ul>
<li>法一：利用<code>match guard</code></li>
<li>法二：<code>if</code> &amp; <code>else</code></li>
</ul>
</li>
<li><p>errors6</p>
<ul>
<li>impl<ul>
<li>rust中<strong>对象定义和方法定义是分开的</strong></li>
<li>一个/多个<code>impl</code>模块</li>
<li><code>self</code>、<code>&amp;self</code>和<code>&amp;mut self</code>及所有权<ul>
<li><code>self</code>表示<code>实现方法的结构体类型的实例</code>的所有权转移到该方法中，这种形式用的较少</li>
<li><code>&amp;self</code>表示该方法对<code>实现方法的结构体类型的实例</code>的不可变借用</li>
<li><code>&amp;mut self</code>表示可变借用</li>
</ul>
</li>
</ul>
</li>
<li>闭包<ul>
<li>可以看做匿名函数</li>
<li>||中间放参数</li>
</ul>
</li>
<li>map_err()<ul>
<li>用来处理Err类型的变量</li>
<li>参数是函数/闭包</li>
</ul>
</li>
<li><code>PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)</code>仅可以用来处理x&lt;=0的情况，而x非数字的情况无法处理<ul>
<li><code>?</code>操作符：<code>Err</code> / <code>None</code> 类型直接立即结束，提前返回；否则从<code>Ok</code> / <code>Some</code> 中取出返回值作为<code>?</code>操作符的结果</li>
<li>或者用match平替</li>
</ul>
</li>
</ul>
</li>
<li><p>generics1</p>
<ul>
<li><code>&amp;str</code> vs <code>String</code></li>
<li>也可以用<code>_</code>来让编译器自动推断</li>
</ul>
</li>
<li><p>generics2</p>
<ul>
<li>泛型可以类比多态</li>
<li>结构体中的泛型 &amp; 方法中使用泛型</li>
<li>例如（from Rust Course）：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用泛型参数前，依然需要提前声明：<code>impl&lt;T&gt;</code></li>
<li>上述代码中，<code>Point&lt;T&gt;</code>不再是泛型声明，而是一个完整的结构体类型，因为我们定义的结构体就是 <code>Point&lt;T&gt;</code>而不再是<code>Point</code></li>
<li>除了结构体中的泛型参数，我们还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样</li>
<li>对于<code>Point&lt;T&gt;</code>类型，你不仅能定义基于<code>T</code>的方法，还能针对特定的具体类型，进行方法定义</li>
</ul>
</li>
</ul>
</li>
<li><p><em>trait(特征)</em></p>
<ul>
<li><code>impl Trait for Type</code>：为Type类型实现Trait特征</li>
<li>特征定义与实现的位置(孤儿规则)</li>
<li>方法的默认实现 vs 重载</li>
<li><code>impl Trait</code><ul>
<li>作为函数参数<ul>
<li><code>impl Trait</code>此时为语法糖,可用<code>特征约束</code>写出完整版</li>
<li><code>多重约束</code>：<code>impl T1 + T2</code></li>
</ul>
</li>
<li>作为函数返回值（只能返回某一种类型）</li>
</ul>
</li>
</ul>
</li>
<li><p>quiz3</p>
<ul>
<li>restricting type parameter <code>T</code>：<code>impl&lt;T: std::fmt::Display&gt; ReportCard&lt;T&gt; {...}</code>（根据编译器help提示）</li>
</ul>
</li>
<li><p>lifetims1</p>
<ul>
<li>标记的生命周期只是为了取悦编译器，告诉编译器多个引用之间的关系，当不满足此约束条件时，就拒绝编译通过；并不会改变任何引用的实际作用域</li>
<li>和泛型一样，使用生命周期参数，需要先声明 <code>&lt;&#39;a&gt;</code></li>
<li>本题中：把具体的引用传给<code>longest</code>时，那生命周期<code>&#39;a</code>的大小就是<code>x</code>和<code>y</code>的作用域的重合部分，换句话说，<code>&#39;a</code>的大小将等于<code>x</code>和<code>y</code>中较小的那个</li>
<li>编译器提示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">help</span>: consider introducing a named lifetime parameter</span><br><span class="line">    |</span><br><span class="line">13  | fn longest&lt;<span class="string">'a&gt;(x: &amp;'</span>a str, y: &amp;<span class="string">'a str) -&gt; &amp;'</span>a str &#123;</span><br><span class="line">    |           ++++     ++          ++          ++</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>lifetimes2</p>
<ul>
<li>在<code>longest</code>函数中，<code>string2</code>的生命周期也是<code>&#39;a</code>，由此说明<code>string2</code>也必须活到 println! 处，可是<code>string2</code>在代码中实际上只能活到内部语句块的花括号处<code>}</code>，小于它应该具备的生命周期<code>&#39;a</code>，因此编译出错（编译器没法知道返回值没有用到<code>string2</code>）</li>
<li>hint：<br>Remember that the generic lifetime ‘a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y.<br>You can take at least two paths to achieve the desired result while keeping the inner block:<ol>
<li>Move the string2 declaration to make it live as long as string1 (how is result declared?)</li>
<li>Move println! into the inner block</li>
</ol>
</li>
</ul>
</li>
<li><p>lifetimes3</p>
<ul>
<li>结构体中生命周期标注：<ul>
<li>对结构体本身类似泛型：<code>&lt;&#39;a&gt;</code></li>
<li>对结构体成员：<code>&amp;&#39;a</code></li>
</ul>
</li>
<li>结构体成员引用的生命周期要大于等于结构体</li>
</ul>
</li>
<li><p>lifetime others</p>
<ul>
<li>输入生命周期 &amp; 输出生命周期</li>
<li>生命周期的消除</li>
<li>方法中的生命周期（类似泛型参数语法）<ul>
<li><code>impl</code>中必须使用结构体的完整名称，包括<code>&lt;&#39;a&gt;</code>，因为生命周期标注也是结构体类型的一部分！</li>
<li>方法签名中，往往不需要标注生命周期，得益于生命周期消除的第一和第三规则</li>
</ul>
</li>
<li>静态生命周期</li>
</ul>
</li>
<li><p>tests4</p>
<ul>
<li><code>#[should_panic]</code>：The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t panic.<br>&lt;!– * tests5（自动进行时这个被跳过了，直接到了迭代器）</li>
<li>unsafe函数：<ul>
<li>使用<code>unsafe fn</code>来进行定义</li>
<li>这种定义方式是为了告诉调用者：当调用此函数时，你需要注意它的相关需求，因为Rust无法担保调用者在使用该函数时能满足它所需的一切需求</li>
<li>因此在使用<code>unsafe</code>声明的函数时，一定要看看相关的文档，确定自己没有遗漏什么 –&gt;</li>
</ul>
</li>
</ul>
</li>
<li><p>iterators1</p>
<ul>
<li>Rust的迭代器是指实现了<code>Iterator trait</code>的类型</li>
<li>最主要的一个方法：<code>next()</code><ul>
<li>对迭代器的遍历是消耗性的</li>
<li>返回的是<code>Option&lt;Item&gt;</code>类型，当有值时返回<code>Some(Item)</code>，无值时返回<code>None</code></li>
<li>手动迭代必须将迭代器声明为<code>mut</code>可变，因为调用<code>next</code>会改变迭代器其中的状态数据（当前遍历的位置等），而<code>for</code>循环去迭代则无需标注<code>mut</code>，因为它会帮我们自动完成</li>
</ul>
</li>
</ul>
</li>
<li><p>iterators2</p>
<ul>
<li><p><code>iter()</code></p>
<ul>
<li><code>Iterator adapters</code>（<em>迭代器适配器</em>）<ul>
<li>Adapters operate on an iterator and return a new iterator</li>
<li>是<em>惰性接口</em>：iterators are lazy and do nothing unless consumed</li>
<li>常见的有：<code>map()</code>、<code>filter()</code>、<code>take()</code>、<code>zip()</code>、<code>rev()</code></li>
<li>需要一个<em>消费器</em>来收尾，例如：<code>collect()</code>、<code>sum()</code>、<code>any()</code></li>
</ul>
</li>
<li>注：如果集合里的类型是非<code>Copy</code>类型，消费者在取得每个值后，在迭代器被清除后，集合里的元素也会被清除。集合会只剩“空壳”，当然剩下的“空壳”也会被清除</li>
<li>迭代器是<em>可组合的</em></li>
</ul>
</li>
<li><p>一个例子：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">v1.iter().map(|x| x + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  map 函数的闭包并没有获得迭代器的所有权。具体解释如下：</p>
<ul>
<li><p><code>v1.iter()</code>创建了一个针对<code>v1</code>中元素的迭代器。这个迭代器是对<code>v1</code>的不可变引用，也就是说，它拥有对<code>v1</code>中元素的借用权，但并不拥有所有权。</p>
</li>
<li><p><code>map(|x| x + 1)</code>是对上述迭代器应用的一个闭包。闭包内部的<code>|x| x + 1</code>表示对迭代器产生的每个元素<code>x</code>加上 1。在这个过程中，闭包接收的是<code>x</code>的不可变引用，同样没有获取<code>x</code>或迭代器的所有权。</p>
<p>综上所述，闭包并未获得迭代器的所有权。它只是在<code>map</code>函数执行期间，对迭代器提供的每个元素借用并进行计算。一旦<code>map</code>函数结束，闭包对元素的借用也随之结束，不会影响到<code>v1</code>或其迭代器的所有权状态。<br>…<br>如果您想让闭包返回的新值形成一个新的集合（如 Vec<i32>），您需要调用 collect() 方法来完成这一过程：</i32></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incremented_values: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = v1.iter().map(|x| x + <span class="number">1</span>).collect();</span><br></pre></td></tr></table></figure>
<p>在这里，<code>collect()</code>方法会消费<code>map</code>返回的迭代器，并将其内容收集到一个新的<code>Vec&lt;i32&gt;</code>中。然而，即使如此，闭包本身仍然没有获得迭代器的所有权，而是<code>collect()</code>函数在处理过程中获取了所有权并完成了数据的转移。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>iterators3</p>
<ul>
<li>从容器创造出迭代器一般有三种方法：<ul>
<li><code>iter()</code> takes elements by reference.</li>
<li><code>iter_mut()</code> takes mutable reference to elements.</li>
<li><code>into_iter()</code> takes ownership of the values and consumes the actual type once iterated completely. The original collection can no longer be accessed.</li>
</ul>
</li>
<li><code>collect()</code>会根据函数返回值自动调整格式</li>
</ul>
</li>
<li><p>iterators4</p>
<ul>
<li>这不让用那不让用，那自然是得用自带的工具咯</li>
<li>(1..=num).product()</li>
</ul>
</li>
<li><p>iterators5</p>
<ul>
<li>一点思考：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_for</span></span>(map: &amp;HashMap&lt;<span class="built_in">String</span>, Progress&gt;, value: Progress) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> map.values() &#123;</span><br><span class="line">        <span class="comment">// 此处为什么不是*val == value呢？</span></span><br><span class="line">        <span class="comment">// 下面这中方式中，实际上是在比较两者对应的实体是否相同</span></span><br><span class="line">        <span class="keyword">if</span> val == &amp;value &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><em>扁平化（Flatten）</em>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_collection_iterator</span></span>(collection: &amp;[HashMap&lt;<span class="built_in">String</span>, Progress&gt;], value: Progress) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    collection.iter() <span class="comment">// Iterate over the slice of hashmaps</span></span><br><span class="line">        .flat_map(|map| map.values()) <span class="comment">// Flatten the values of each hashmap into a single iterator</span></span><br><span class="line">        .filter(|val| **val == value) <span class="comment">// Filter values equal to the target value</span></span><br><span class="line">        .count() <span class="comment">// Count the filtered values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在上述实现中：<ul>
<li>首先使用 <code>collection.iter()</code> 创建一个迭代器，它遍历 <code>collection</code> 中的每一个 <code>HashMap</code> 引用。</li>
<li>然后对每个 <code>HashMap</code> 应用 <code>flat_map(|map| map.values())</code>，将每个 <code>HashMap</code> 的值迭代器扁平化为单个包含所有 <code>HashMap</code> 值的迭代器。<br>接着使用 <code>filter(|val| *val == value)</code>，筛选出与目标 <code>value</code> 相同的 <code>Progress</code> 枚举值。</li>
<li>最后，通过 <code>count()</code> 方法计算筛选后的元素数量，即符合条件的 <code>Progress</code> 枚举值的总数，返回这个计数值作为函数结果。</li>
</ul>
</li>
</ul>
</li>
<li><p>smart_pointers（<em>智能指针</em>）</p>
<ul>
<li>前言<ul>
<li>相比其它语言，Rust 堆上对象还有一个特殊之处—它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可）</li>
<li>例如以下代码：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> b = foo(<span class="string">"world"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"Hello, "</span>.to_string() + x;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在 <code>foo</code> 函数中，<code>a</code> 是 <code>String</code> 类型，它其实是一个智能指针结构体，该智能指针存储在函数栈中，指向堆上的字符串数据。当被从 <code>foo</code> 函数转移给 <code>main</code> 中的 <code>b</code> 变量时，栈上的智能指针被复制一份赋予给 <code>b</code>，而底层数据无需发生改变，这样就完成了所有权从 <code>foo</code> 函数内部到 <code>b</code> 的转移。</li>
</ul>
</li>
<li>在 <code>Rust</code> 中，凡是需要做资源回收的数据结构，且实现了 <code>Deref</code>/<code>DerefMut</code>/<code>Drop</code>，都是<code>智能指针</code></li>
</ul>
</li>
<li><p>arc1</p>
<ul>
<li>使用 <code>let shared_numbers = Arc::new(numbers);</code> ：将 <code>numbers</code> 向量封装在一个 <code>Arc&lt;Vec&lt;u32&gt;&gt;</code> 中。</li>
<li><code>Arc</code> 允许多个线程同时拥有对同一数据的访问权，且其内部的引用计数机制确保数据在所有持有者都不再需要时会被正确释放。这样，<code>numbers</code> 可以在多个线程间共享而无需复制整个向量，既节省了内存，又保证了线程安全性</li>
<li>使用 <code>let child_numbers = Arc::clone(&amp;shared_numbers);</code> ：创建 <code>shared_numbers</code> 的克隆（实际上是增加其引用计数）。每个线程都获得一个指向相同底层数据的独立 <code>Arc</code> </li>
<li><code>thread::spawn</code>创建一个线程</li>
<li><code>move</code>关键字：指示闭包在捕获外部变量时采取“所有权转移”策略，而非默认的借用策略</li>
<li><code>join()</code> 方法会阻塞当前线程，直到指定的线程完成其任务。<code>unwrap()</code> 处理 <code>join()</code> 返回的 <code>Result</code>，在没有错误时提取出结果（这里没有错误处理，因为假设所有线程都能成功完成）。这样，<code>main()</code> 函数会等待所有子线程计算完毕后再继续执行</li>
</ul>
</li>
<li><p>cow1</p>
</li>
<li><p>threads1</p>
<ul>
<li>如果你想创建新线程，可以使用<code>thread::spawn</code>函数并传递一个闭包，在闭包中包含要在新线程 执行的代码。</li>
<li>默认情况下，当主线程执行结束，所有子线程也会立即结束，且不管子线程中的代码是否执行完毕。极端情况下，如果主线程在创建子线程后就立即结束，子线程可能根本没机会开始执行。</li>
<li>为避免上述情况的发生，我们可以通过阻塞主线程来等待子线程执行完毕。这里所说的阻塞线程，是指阻止该线程工作或退出。</li>
<li><code>Rust</code>标准库提供的<code>thread::JoinHandle</code>结构体的<code>join</code>方法，可用于把子线程加入主线程等待队列，这样主线程会等待子线程执行完毕后退出。</li>
<li><code>unwrap()</code></li>
</ul>
</li>
<li><p>threads2</p>
<ul>
<li>Mutex确保在某一时刻只有一个thread可以更新jobs_completed</li>
<li>thread闭包中，使用lock()上锁</li>
<li>注意：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"jobs completed &#123;&#125;"</span>, status.lock().unwrap().jobs_completed);</span><br></pre></td></tr></table></figure>
  如果放到循环内，就是输出10次<code>jobs completed x</code>，<code>x</code>的值有时候全是10，有时候有一部分是10；放到循环外就是一次<code>jobs completed 10</code></li>
</ul>
</li>
<li><p>threads3</p>
<ul>
<li>报错内容：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line">29 | fn send_tx(q: Queue, tx: mpsc::Sender&lt;u32&gt;) -&gt; () &#123;</span><br><span class="line">   |                      -- move occurs because `tx` has <span class="built_in">type</span> `Sender&lt;u32&gt;`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">...</span><br><span class="line">34 |     thread::spawn(move || &#123;</span><br><span class="line">   |                   ------- value moved into closure here</span><br><span class="line">...</span><br><span class="line">37 |             tx.send(*val).unwrap();</span><br><span class="line">   |             -- variable moved due to use <span class="keyword">in</span> closure</span><br><span class="line">...</span><br><span class="line">42 |     thread::spawn(move || &#123;</span><br><span class="line">   |                   ^^^^^^^ value used here after move</span><br><span class="line">...</span><br><span class="line">45 |             tx.send(*val).unwrap();</span><br><span class="line">   |             -- use occurs due to use <span class="keyword">in</span> closure</span><br><span class="line">error: aborting due to 1 previous error</span><br></pre></td></tr></table></figure></li>
<li>分析：<code>tx</code>变量<code>move</code>到第一个闭包后，已经无法在该闭包外获取了，而在第二次进程创建仍然尝试<code>move</code>。通过为每个变量创建<code>tx</code>的<code>clone</code>，我们确保了每个闭包都拥有其独立的<code>sender</code>，从而避免了<code>use after move</code>错误</li>
</ul>
</li>
<li><p>macros4</p>
<ul>
<li>每个macro规则后面加;</li>
</ul>
</li>
<li><p>clippy1</p>
<ul>
<li>根据编译器提示修改</li>
<li>const PI: f32 = std::f32::consts::PI;</li>
</ul>
</li>
<li><p>clippy3</p>
<ul>
<li>已经通过 <code>is_none()</code> 检查确保了 <code>my_option</code> 是 <code>None</code>，因此接下来不应该再尝试调用 <code>unwrap()</code></li>
<li><code>Vec::resize</code> 方法用于改变已有向量的长度，如果新的长度大于当前长度，则填充指定的默认值。<ul>
<li>但是，你的用法存在一些问题。首先，你试图创建一个空向量（通过将大小更改为0），但直接使用 <code>resize(0, 5)</code> 并不是正确做法，因为这会让人们以为你要填充默认值5到一个空向量中，而实际上你是从一个非空向量开始的。</li>
<li>如果你想从 <code>vec![1, 2, 3, 4, 5]</code> 起始，然后得到一个空向量，你应该直接使用 <code>clear</code> 方法，而不是 <code>resize</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>as_ref_mut</p>
<ul>
<li>根据注释完成</li>
</ul>
</li>
<li><p>using_as</p>
<ul>
<li>报错内容：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   --&gt; exercises/conversions/using_as.rs:17:11</span><br><span class="line">   |</span><br><span class="line">17 |     total / values.len()</span><br><span class="line">   |           ^ no implementation <span class="keyword">for</span> `f64 / usize`</span><br><span class="line">   |</span><br><span class="line">   = <span class="built_in">help</span>: the trait `Div&lt;usize&gt;` is not implemented <span class="keyword">for</span> `f64`</span><br><span class="line">   = <span class="built_in">help</span>: the following other types implement trait `Div&lt;Rhs&gt;`:</span><br><span class="line">               &lt;&amp;<span class="string">'a f64 as Div&lt;f64&gt;&gt;</span></span><br><span class="line"><span class="string">               &lt;&amp;f64 as Div&lt;&amp;f64&gt;&gt;</span></span><br><span class="line"><span class="string">               &lt;f64 as Div&lt;&amp;f64&gt;&gt;</span></span><br><span class="line"><span class="string">               &lt;f64 as Div&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>分析：错误提示指出 <code>f64</code> 类型没有实现 <code>Div&lt;usize&gt;</code> trait，因此无法执行除法操作。为了解决这个问题，我们可以将 <code>values.len()</code> 转换为 <code>f64</code> 类型，以便进行除法运算。<br>在修改后的代码中，我们使用 <code>values.len() as f64</code> 将 <code>values.len()</code> 的结果转换为 <code>f64</code> 类型，以便与 <code>total</code> 执行除法操作。</li>
</ul>
</li>
<li><p>from_into</p>
<ul>
<li>为<code>Person</code>结构实现<code>From&lt;&amp;str&gt;</code> trait</li>
</ul>
</li>
<li><p>from_str</p>
<ul>
<li>需要实现<code>FromStr</code> trait 来将字符串解析为 <code>Person</code> 结构体，并返回相应的错误类型 <code>ParsePersonError</code></li>
</ul>
</li>
<li><p>tests5</p>
<ul>
<li><p>这段代码中，<code>modify_by_address</code> 函数使用了 <code>unsafe</code> 关键字来标记它的不安全性。根据注释，我们需要在函数的文档注释中提供有关函数行为和约定的描述。</p>
</li>
<li><p>以下是修改后的代码：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// # Safety</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The `address` must be a valid memory address that points to a mutable `u32` value.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It is the caller's responsibility to ensure that the `address` is a valid memory address</span></span><br><span class="line"><span class="comment">/// and that it points to a mutable `u32` value. Failing to meet these requirements may lead</span></span><br><span class="line"><span class="comment">/// to undefined behavior, such as memory corruption or crashes.</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">modify_by_address</span></span>(address: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// SAFETY: The caller must ensure that `address` is a valid memory address</span></span><br><span class="line">    <span class="comment">// and that it points to a mutable `u32` value.</span></span><br><span class="line">    <span class="keyword">let</span> value_ptr = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="keyword">let</span> value = &amp;<span class="keyword">mut</span> *value_ptr;</span><br><span class="line">    *value = <span class="number">0xAABBCCDD</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在函数的(文档)注释中，我们明确了对 <code>address</code> 参数的要求，即它必须是一个有效的内存地址，并指向一个可变的 <code>u32</code> 值。我们还提醒调用者必须满足这些要求，并在不满足要求时可能会导致的未定义行为。</p>
</li>
<li><p>在函数内部，我们使用了 <code>address</code> 参数将其转换为一个可变的 <code>u32</code> 指针 <code>value_ptr</code>，然后通过解引用该指针获取可变引用 <code>value</code>。最后，我们将 <code>value</code> 设置为 <code>0xAABBCCDD</code>。</p>
</li>
</ul>
</li>
<li><p>test6</p>
<ul>
<li>这段代码中，我们需要实现一个 <code>raw_pointer_to_box</code> 函数，它将一个原始指针转换为一个拥有所有权的 <code>Box&lt;Foo&gt;</code>。我们需要根据给定的指针重新构建一个 <code>Box&lt;Foo&gt;</code> 对象。</li>
</ul>
</li>
<li><p>test7&amp;test8</p>
<ul>
<li>在 <code>tests7</code> 部分，我们设置了一个名为 <code>TEST_FOO</code> 的环境变量，并使用 <code>rustc-env</code> 指令将其传递给Cargo。</li>
<li>在 <code>tests8</code> 部分，我们使用 <code>rustc-cfg</code> 指令启用了名为 <code>pass</code> 的特性。</li>
</ul>
</li>
<li><p>test9</p>
</li>
<li><p>algorithm1</p>
<ul>
<li>Note that we use the <code>Ord</code> and <code>Clone</code> traits for the generic type <code>T</code> to enable value comparisons and cloning, respectively.</li>
</ul>
</li>
<li><p>algorithm2</p>
<ol>
<li><p>定义两个指针 <code>current</code> 和 <code>prev</code>，分别指向当前节点和上一个节点。初始时 <code>current</code> 指向链表的头节点，<code>prev</code> 为 <code>None</code>。</p>
</li>
<li><p>进入循环，在每次迭代中:</p>
<ul>
<li>获取当前节点的可变引用 <code>node</code>。</li>
<li>将 <code>current</code> 移动到下一个节点。</li>
<li>将当前节点的 <code>next</code> 指针指向上一个节点 <code>prev</code>。</li>
<li>如果 <code>prev</code> 不为 <code>None</code>，则更新上一个节点的 <code>prev</code> 指针指向当前节点。</li>
<li>如果 <code>prev</code> 为 <code>None</code>，说明当前节点是新的尾节点，更新 <code>self.end</code> 为当前节点。</li>
<li>将 <code>prev</code> 更新为当前节点。</li>
</ul>
</li>
<li><p>循环结束后，将 <code>self.start</code> 更新为最后一个节点，即反转后的新头节点。</p>
</li>
</ol>
</li>
<li><p>algorithm9</p>
<ul>
<li>注意：在<code>next</code>中，对<code>vec</code>的处理除了要把最后一个元素拷贝到下标为<code>1</code>处，还需要把尾部元素用<code>pop()</code>删除。可以合起来写（后面加一个<code>?</code>），也可以分开。  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">self</span>.items[<span class="number">1</span>].clone();</span><br><span class="line">    <span class="keyword">self</span>.items[<span class="number">1</span>] = <span class="keyword">self</span>.items.pop().clone()?;</span><br><span class="line">    <span class="keyword">self</span>.count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span>.heapify_down(<span class="number">1</span>);</span><br><span class="line">    <span class="literal">Some</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>本地通过但autograde没通过：可以在actions-GitHub Classroon Workflow-最新的记录-Autograding complete的第二个日志中查看</p>
</li>
</ul>
<h1 id="rCore-Tutorial-Guide-2024S通关札记"><a href="#rCore-Tutorial-Guide-2024S通关札记" class="headerlink" title="rCore-Tutorial-Guide-2024S通关札记"></a>rCore-Tutorial-Guide-2024S通关札记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在学习操作系统的文件系统部分时，被国内的部分课本深深“恶心”到了，有幸阅读OSTEP以及一些其他的国外著作（如Unix Internals）并走了许多弯路后我发现一个问题：对于初学者来说，操作系统这种非常“工程类”的学科，（入门/初级阶段）应该采取的正确学习思路是用“增量法”，具体来说：就是从一个具有最基础功能的操作系统出发，不断分析现有问题、解决问题从而实现功能上的完善（即增量），这也是符合操作系统发展的历史脉络的。好巧不巧的是，rcore采取的正是这种教学策略：<br><img src="/blog/.io//image-5.png" alt="Alt text"><br>要是能早点遇到该多好☹…</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>rcore的文档非常之详细（对比xv6/pintos等），初学者很容易陷入到细节中去，因此在阅读文档/代码前建议先看一下每章的引言（相当于论文的abstract），明确每章要干什么以及代码的大致框架</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我自己采用的是（之前别的实验就配置好的）wsl2+ubuntu18.04+vscode+git，具体操作步骤文档内容写的很详细，网上也有很多相关教程</p>
<h3 id="18-04安装qemu7-0-0"><a href="#18-04安装qemu7-0-0" class="headerlink" title="18.04安装qemu7.0.0"></a>18.04安装qemu7.0.0</h3><p>根据文档一步步操作至：出现报错<br><img src="/blog/.io//image.png" alt="Alt text"><br><img src="/blog/.io//image-1.png" alt="Alt text"></p>
<p>sudo apt-get install ninja-build<br>随后继续按照文档操作<br>最终：<br><img src="/blog/.io//image-2.png" alt="Alt text"><br>在bashrc文件中配置路径：<br><img src="/blog/.io//image-3.png" alt="Alt text"><br><img src="/blog/.io//image-4.png" alt="Alt text"></p>
<h3 id="其余部分根据指导书操作即可"><a href="#其余部分根据指导书操作即可" class="headerlink" title="其余部分根据指导书操作即可"></a>其余部分根据指导书操作即可</h3><h2 id="rust语言"><a href="#rust语言" class="headerlink" title="rust语言"></a>rust语言</h2><p>不建议花费太多时间，个人感觉比较靠谱的策略就是“迅速掌握一门语言的50%”，剩下的内容现学现用（按需调用）<br>重点：所有权和生命周期、类型系统<br>推荐资料：rust语言圣经、清华rust课程ppt</p>
<h2 id="ci-user本地测试"><a href="#ci-user本地测试" class="headerlink" title="ci-user本地测试"></a>ci-user本地测试</h2><p>在确定好思路后一定要看一下测试代码再动手coding，有些测试并没有覆盖所有情况，因此一些特别繁琐的情况可以忽略掉（不是本次实验的重点）</p>
<h2 id="技能点"><a href="#技能点" class="headerlink" title="技能点"></a>技能点</h2><p>锻炼自己快速上手工程类代码的能力</p>
<h2 id="ch3-lab1"><a href="#ch3-lab1" class="headerlink" title="ch3-lab1"></a>ch3-lab1</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskInfo</span></span> &#123;</span><br><span class="line">    status: TaskStatus,</span><br><span class="line">    syscall_times: [<span class="built_in">u32</span>; MAX_SYSCALL_NUM],</span><br><span class="line">    time: <span class="built_in">usize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务：新增系统调用sys_task_info</p>
<p>分析：sys_task_info本质上是对参数中用户程序传入的指针指向的结构体赋值，因此本次实验的核心围绕这些值展开，需要思考的点就是：这些值要存放在什么地方？什么时候初始化？什么时候更新？为了获取这些值需要设计几个函数，这些函数哪些只能内部使用哪些是开放接口？</p>
<p>具体思维过程：</p>
<ol>
<li>只存储最原始的数据，也就是在<code>tcb</code>中存储<code>syscall_times</code>以及进程首次被调度的时间<code>start_time</code>，在需要时再将他们拼装成<code>TaskInfo</code></li>
<li>变量初始化时机：<code>tcb</code>初始化</li>
<li>变量更新时机：所有系统调用中，更新对应的<code>syscall_times[syscall_id]</code>用户程序（及<code>first task</code>）对应的tcb第一次被调用时，更新<code>start_time</code>（这就需要思考：负责进行任务调度的功能在哪里实现？怎么判断是否为第一次？）</li>
<li>函数：<ul>
<li>将重复多次的操作封装成函数</li>
<li>将私有变量/函数的操作封装成pub接口暴露给其他模块</li>
</ul>
</li>
<li>其他细节：空指针</li>
</ol>
<h2 id="ch4-lab2"><a href="#ch4-lab2" class="headerlink" title="ch4-lab2"></a>ch4-lab2</h2><p>任务：重写<code>sys_get_time</code>和<code>sys_task_info</code>，增加<code>sys_mma</code>p和<code>sys_munmap</code></p>
<p>分析：因为引入了虚拟内存机制，因此<code>sys_get_time</code>和<code>sys_task_info</code>系统调用传入的参数中，指针指向的地址是属于用户地址空间的，无法直接在内核地址空间中使用，需要进行转换。<code>sys_mmap</code>和<code>sys_munmap</code>手册里描述的有点模糊，实际上通过阅读样例可知，该系统调用的功能就是以页为单位进行分配/回收，而且不会出现复杂的情况（比如跨越<code>area</code>，部分可回收部分不可…），关键点就是边界条件、<code>port</code>以及每次分配/回收都要同时操作<code>pagetable</code>和<code>areas</code>，需要注意的点就是接口的设计问题（没有暴露出来的内容，需要用接口传参数进去在本地处理）</p>
<p>具体思维过程：</p>
<ol>
<li>sys_get_time和sys_task_info可以参考：<br><img src="/blog/.io//image-6.png" alt="Alt text"><br>我们平常编写用户程序的代码时，对指向某一类型变量的指针（虚拟地址）使用解引用，可以获得对应类型的变量，这是因为mmu自动帮我们完成了地址转换功能</li>
</ol>
<h2 id="ch5-lab3"><a href="#ch5-lab3" class="headerlink" title="ch5-lab3"></a>ch5-lab3</h2><h3 id="需要移植（兼容lab1-2）的地方："><a href="#需要移植（兼容lab1-2）的地方：" class="headerlink" title="需要移植（兼容lab1/2）的地方："></a>需要移植（兼容lab1/2）的地方：</h3><ul>
<li><p>start_time和syscall_times：tcb中添加，new中初始化，run_task切换进程中更新时间，各个系统调用（位于process.rs和fs.rs）中更新次数</p>
</li>
<li><p>task_info：new定义，更新</p>
</li>
<li><p>mmap和munmap：</p>
</li>
<li><p>系统调用次数更新：update_syscall_times</p>
</li>
<li><p>page_table.rs和memory_set.rs和frame_allocator.rs中：一些用于检查的函数</p>
</li>
<li><p>注：</p>
<ul>
<li>第2-4都位于processor.rs（用于处理当前进程相关的内容）中</li>
<li>注意实现细节的变化</li>
<li>注意crate管理</li>
<li>注意注释标出新增功能，以及impl需要文档注释</li>
</ul>
</li>
</ul>
<h3 id="需要新增的功能："><a href="#需要新增的功能：" class="headerlink" title="需要新增的功能："></a>需要新增的功能：</h3><ul>
<li>sys_spawn：<ol>
<li>分析参数路径是否合法（参考exec）</li>
<li>返回值是pid/-1</li>
<li>tcb impl中，实现spawn</li>
<li>spawn中：（参考new+fork+exec）核心就是分配并初始化tcb，然后更新父进程内容，最后切换<ul>
<li>tcb及其字段的分配参考new（除了tcbinner的parent）</li>
<li>父进程更新父子关系、状态、最后加入taskmanager</li>
<li>修改processor中的current</li>
<li>销毁exclusive变量并进行__switch</li>
</ul>
</li>
</ol>
</li>
<li>stride：（注意stride scheduling论文中的pass和stride的含义和本实验中相反，这里我们采用的是论文中的定义）<ul>
<li>变量：<ul>
<li>tcb中新增stride、prio、pass</li>
<li>全局变量新增BIG_STRIDE</li>
</ul>
</li>
<li>变量初始化：<ul>
<li>prio初始16，pass初始0，stride初始BIG_STRIDE/16</li>
</ul>
</li>
<li>变量更新：<ul>
<li>每次调度后，更新pass+= stride（在run_task中）</li>
<li>每次set_prio后，更新stride= BIG_STRIDE/new_prio</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一些提交时未考虑到的细节："><a href="#一些提交时未考虑到的细节：" class="headerlink" title="一些提交时未考虑到的细节："></a>一些提交时未考虑到的细节：</h3><ul>
<li>切换前更新task_inner.start_time</li>
<li>syscall_read没有更新syscall_times</li>
<li>sys_spawn的trace中not implement忘记删除</li>
</ul>
<h2 id="ch6-lab4"><a href="#ch6-lab4" class="headerlink" title="ch6-lab4"></a>ch6-lab4</h2><p>框架分析：思考读一个文件时发生了什么？</p>
<p><strong>easy-fs/src</strong></p>
<p>easyfs 文件系统的整体架构自下而上可分为五层：</p>
<ol>
<li>磁盘块设备接口层：/block_dev.rs</li>
</ol>
<ul>
<li>归根结底是在块设备上以块为单位读写，</li>
<li>读写磁盘块设备的trait接口– BlockDevice trait（仅需read_block 和 write_block）</li>
</ul>
<ol start="2">
<li>块缓存层：/block_cache.rs</li>
</ol>
<ul>
<li>缓冲区是块设备的上一层，以块为单位管理对应的块缓存</li>
<li>BlockCache：创建时会触发read_block</li>
<li>BlockManager：以类似FIFO方式管理BlockCache，被换出时可能触发write_block</li>
<li>get_block_cache 接口：通过block_id和block_dev参数，在BlockManager中查询对应的BlockCache，如果存在则直接使用，否则加载（核心是new中的block_device.read_block函数，将编号为 block_id 的块从磁盘读入内存中的缓冲区 buf）进BlockManger</li>
</ul>
<ol start="3">
<li>磁盘数据结构层：/layout.rs /bitmap.rs</li>
</ol>
<ul>
<li>典型unix布局：超级块+inode位图+data位图+inode分区+data分区</li>
<li>表示磁盘文件系统的数据结构：SuperBlock、Bitmap、BlockInode、DirEntry、DataBlock</li>
<li>注意：<ul>
<li>一个BlockCache块缓存对应一个块512B，而一个块中有4个BlockInode</li>
<li>对BlockInode添加新的元数据字段需要修改一级索引的长度，以保证总大小为128B</li>
<li>DiskInode 方法：</li>
<li>get_block_id：数据块索引功能</li>
<li>read_at：将dkinode对应的文件从offset字节开始读到buf中（需要先通过get_block_id及索引定位到块号，然后用get_block_cache读入到内存中）</li>
</ul>
</li>
</ul>
<ol start="4">
<li>磁盘块管理器层：/efs.rs</li>
</ol>
<ul>
<li>管理磁盘数据结构的控制逻辑</li>
<li>EasyFileSystem</li>
<li>注意从这一层开始，所有的数据结构就都放在内存上了</li>
<li>重要方法：<ul>
<li>get_disk_inode_pos</li>
<li>get_data_block_id</li>
</ul>
</li>
</ul>
<ol start="5">
<li>索引节点层：/vfs.rs</li>
</ol>
<ul>
<li>对单个文件的管理和读写的控制逻辑</li>
<li>Inode（why/how对应DiskInode）：通过用efs的get_disk_inode_pos方法和BlockInode的inode_id可以算出该BlockInode所在block的block_id以及磁盘内偏移block_offset，而用get_block_cache接口和block_id以及block_device可以获得对应Block的BlockCache，使用BlockCache的read/modify方法就可以读/写Inode对应BlockInode对应的块缓存中的区域。因此，总的来说定位一个BlockInode需要block_id、block_offset、block_device、fs四个要素，这也正是vfs Inode的组成</li>
<li>重要方法：<ul>
<li>read/modify_disk_inode：读/写Inode对应的DiskInode对应的BlockCache区域</li>
</ul>
</li>
</ul>
<p><strong>easy-fs-fuse</strong></p>
<p>在（linux上的文件模拟出来的）一个虚拟块设备上创建并初始化文件系统</p>
<p><strong>操作系统中对接easy-fs文件系统的各种结构</strong></p>
<ol>
<li><p>块设备驱动层</p>
<p> 将平台上的块设备驱动起来并实现 easy-fs 所需的 BlockDevice Trait</p>
</li>
<li><p>easy-fs层</p>
<p> 借助一个块设备BlockDevice，打开EasyFileSystem文件系统，进而获取Inode数据结构，从而进行各种操作</p>
</li>
<li><p>内核索引节点层</p>
</li>
</ol>
<ul>
<li>将 easy-fs 提供的 Inode 进一步封装成 OSInode</li>
<li>OSInode 中要维护一些额外的信息</li>
</ul>
<ol start="4">
<li>文件描述符层</li>
</ol>
<ul>
<li>常规文件对应的 OSInode 是文件的内核内部表示</li>
<li>需要为它实现 File Trait</li>
</ul>
<ol start="5">
<li>系统调用层</li>
</ol>
<h2 id="ch8-lab5"><a href="#ch8-lab5" class="headerlink" title="ch8-lab5"></a>ch8-lab5</h2><p>任务：sys_enable_deadlock_detect</p>
<p>分析：银行家算法（即通过对已知数据的计算完成死锁判断）很好实现，关键是在何时/以什么形式记录/更新数据</p>
<p>具体思维过程：</p>
<ol>
<li>把银行家算法涉及的所有数组封装成结构体，把相关的操作封装成对应的impl中的函数，并放到os/src/sync下一个新建的rs文件中</li>
<li>注意到测试数据中仅考虑了单个用户程序中的死锁问题，并不需要（实际上也无法，因为没有跨用户程序的接口实现锁/信号量/条件变量）考虑用户程序间的死锁，因此我们要以用户程序即pcb为单位进行死锁检测。为此我们要为pcb新增一个字段来容纳死锁检测结构体实例（如果是所有用户程序之间也需要检测，我们可以用<code>lazy_static</code>来实现），这涉及了初始化及更新的问题。对于数组的下标，我们用<code>task_id</code>和<code>sem_id/mutex_id</code>来区分即可保证唯一性</li>
<li>死锁检测结构体初始化需要在<code>impl</code>中实现一个<code>new</code>函数，把数组初始化为0/1，并在<code>tcb</code>初始化时调用；每次检测后（检测前也可以），我们需要将<code>finish</code>和<code>work</code>数组单独初始化一次</li>
<li>更新主要围绕<code>available</code>、<code>allocation</code>和<code>need</code>数组，其中回收时（<code>sem_up/mutex_unlock</code>）<code>available+1</code>、<code>allocation-1</code>，分配时（<code>sem_down/mutex_lock</code>），若不能分配，则<code>need+1</code>，若能分配则<code>available-1</code>、<code>allocation-=1</code>。所有情况都需要考虑死锁检测，若检测成功则继续，若检测不成功则返回-0xdead（这里我们的实现不够优雅，需要在检测不成功时对数组恢复，实际上优雅的做法是把数组操作放在检测之后进行）。我们必须在最底层函数（<code>sem_up/mutex_unlock/sem_down/mutex_lock</code>）中实现，因为一但检测失败我们需要停止后续操作并立即返回。</li>
<li>一些细节：比如<code>sem_id/mutex_id</code>需要用参数传递进去，以及为此需要修改<code>trait</code>…</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/30/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-squanchhhhh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/30/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-squanchhhhh/" class="post-title-link" itemprop="url">2024开源操作系统训练营第二阶段总结-squanchhhhh</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-30 15:43:07" itemprop="dateCreated datePublished" datetime="2024-05-30T15:43:07+00:00">2024-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-24 11:28:48" itemprop="dateModified" datetime="2025-05-24T11:28:48+00:00">2025-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-学习心得"><a href="#1-学习心得" class="headerlink" title="1.学习心得"></a>1.学习心得</h2><pre><code>在参加本次课程之前，我正在做MIT6.081的实验，在谁演的过程中，我发现自己对操作系统的了解还不是特别深刻，于是去b站上寻找相关的视频，无意中发现了rcore的课程，便报名参加了，相比起xv6直接给出完整的代码，这个课程的设计可谓亲切许多，通过由浅入深，由表及里的设计，让学生对操作系统的了解更为深刻。</code></pre><h2 id="2-学习成果"><a href="#2-学习成果" class="headerlink" title="2.学习成果"></a>2.学习成果</h2><h3 id="2-1-gdb"><a href="#2-1-gdb" class="headerlink" title="2.1 gdb"></a>2.1 gdb</h3><pre><code>本次实验的成果之一就是对gdb的了解更加深刻，从页表开始，调试程序就变得困难起来，因为不能像第一个实验那样直接顺序执行代码，在切换程序时，会同时切换程序的页表，刚开始也不知道该怎么调试这样的代码，后来发现gdb可以直接将断点设置为*0x0，由于每个用户程序的开始地址都是*0x0，这样当切换进程的时候，就可以很方便的进入用户空间。</code></pre><h3 id="2-2-makefile"><a href="#2-2-makefile" class="headerlink" title="2.2 makefile"></a>2.2 makefile</h3><pre><code>如果引入本地测试的话，测试程序会修改makefile，这样每次都需要重新编写debug的makefile。</code></pre><h3 id="2-3-进程"><a href="#2-3-进程" class="headerlink" title="2.3 进程"></a>2.3 进程</h3><pre><code>在学习操作系统理论知识的时候，对进程控制块的理解不是很深刻，知道是一个很重要的组件，但是没有见到它的真实面貌，在实验中，为了给操作系统添加各种功能，也是为进程控制块添加了不少字段，理解更为深刻。</code></pre><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><pre><code>在计算机的学习中，动手往往比理论更加重要，做一个操作系统往往效果比学习操作系统理论要好得多。</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/30/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/blog/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/70/">70</a><a class="extend next" rel="next" href="/blog/page/32/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
