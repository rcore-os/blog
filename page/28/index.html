<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/28/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/28/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">722</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">630</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024-%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-yck/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024-%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-yck/" class="post-title-link" itemprop="url">2024 秋冬季开源操作系统训练营第一二阶段总结-yck</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 21:15:38" itemprop="dateCreated datePublished" datetime="2024-11-08T21:15:38+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Rustlings"><a href="#Rustlings" class="headerlink" title="Rustlings"></a>Rustlings</h1><p>关于第一阶段的Rustlings，还是花了很多时间去学习Rust。一开始是直接去看《Rust程序设计语言》，看了大概大半个月吧，把一些较为简单的概念和程序过了一遍。也是第一次接触这类内存安全类语言，第一次看到所有权，引用的时候还有点畏惧，对于没怎么深入学习过C++的人来说学起来还是有些吃力的。后面又去看了《Rust圣经》，发现有趣多了，提供了很多代码案例，很有意思。最后也跟着写了一个rust小项目minigrep。rustlings也是边学边查文档边做，做起来很有意思很有成就感。</p>
<h1 id="rcore实验"><a href="#rcore实验" class="headerlink" title="rcore实验"></a>rcore实验</h1><h2 id="rcore批处理系统编译逻辑"><a href="#rcore批处理系统编译逻辑" class="headerlink" title="rcore批处理系统编译逻辑"></a>rcore批处理系统编译逻辑</h2><ul>
<li>link.ld链接脚本将程序分成.text、.rodata、.data、.bss。</li>
<li>build.py会将app目录下的bin文件进行编译，将程序的text段加载到以0x8040000开始的用来存放app代码的内存空间，且规定每块app空间为0x2000。</li>
<li>build.rs会遍历user目录下的build文件夹中刚才通过objcopy生成的bin文件，然后生成对应的link_app.S。其实就是将app下的bin文件进行装载，在每个app的内存空间开始和结尾设置标号，并暴露给os以供调用。</li>
</ul>
<h2 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h2><p>单页表：<strong>一块地址空间分为用户虚拟地址和内核虚拟地址，内核虚拟地址映射到内核物理地址</strong></p>
<p>单页表会出现熔断漏洞</p>
<p>比如在用户虚拟空间中有一段代码需要访问内核数据空间的页面，因为cpu流水线机制，数据可能已经被放在cache中。但如果这时候我们取值失败了但是由于已经把数据放在了cache中。下一次我们从用户态直接访问这几个页面的时候，总有那么一个页面访问的速度远比其他的页面快。</p>
<p>双页表：<strong>分为用户地址空间和内核地址空间，用户地址空间又分内核态代码和用户态代码。</strong></p>
<p>那么当我们在用户态访问内核数据时，其实是不知道数据放在哪的，这样就可以避免熔断漏洞。</p>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Load a new elf to replace the original application address space and start execution</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;</span><br><span class="line">        <span class="comment">// memory_set with elf program headers/trampoline/trap context/user stack</span></span><br><span class="line">        <span class="keyword">let</span> (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><br><span class="line">        <span class="keyword">let</span> trap_cx_ppn = memory_set</span><br><span class="line">            .translate(VirtAddr::from(TRAP_CONTEXT_BASE).into())</span><br><span class="line">            .unwrap()</span><br><span class="line">            .ppn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **** access current TCB exclusively</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner_exclusive_access();</span><br><span class="line">        <span class="comment">// substitute memory_set</span></span><br><span class="line">        inner.memory_set = memory_set;</span><br><span class="line">        <span class="comment">// update trap_cx ppn</span></span><br><span class="line">        inner.trap_cx_ppn = trap_cx_ppn;</span><br><span class="line">        <span class="comment">// initialize base_size</span></span><br><span class="line">        inner.base_size = user_sp;</span><br><span class="line">        <span class="comment">// initialize trap_cx</span></span><br><span class="line">        <span class="keyword">let</span> trap_cx = inner.get_trap_cx();</span><br><span class="line">        *trap_cx = TrapContext::app_init_context(</span><br><span class="line">            entry_point,</span><br><span class="line">            user_sp,</span><br><span class="line">            KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">            <span class="keyword">self</span>.kernel_stack.get_top(),</span><br><span class="line">            trap_handler <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// **** release inner automatically</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤-1：创建新的-MemorySet"><a href="#步骤-1：创建新的-MemorySet" class="headerlink" title="步骤 1：创建新的 MemorySet"></a>步骤 1：创建新的 <code>MemorySet</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let (memory_set, user_sp, entry_point) &#x3D; MemorySet::from_elf(elf_data);</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 <code>MemorySet::from_elf</code> 解析传入的 ELF 数据，并创建一个新的 <code>MemorySet</code>，即新的地址空间。</li>
<li>该函数返回以下三个值：<ul>
<li><code>memory_set</code>：表示该进程的新内存映射集合，包含代码段、数据段、用户栈等信息。</li>
<li><code>user_sp</code>：新用户栈的栈顶地址。</li>
<li><code>entry_point</code>：新程序的入口地址，表示从此处开始执行新的 ELF 程序。</li>
</ul>
</li>
</ul>
<h3 id="步骤-2：获取新的-trap-cx-ppn"><a href="#步骤-2：获取新的-trap-cx-ppn" class="headerlink" title="步骤 2：获取新的 trap_cx_ppn"></a>步骤 2：获取新的 <code>trap_cx_ppn</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let trap_cx_ppn &#x3D; memory_set</span><br><span class="line">    .translate(VirtAddr::from(TRAP_CONTEXT_BASE).into())</span><br><span class="line">    .unwrap()</span><br><span class="line">    .ppn();</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>translate</code> 方法，将 <code>TRAP_CONTEXT_BASE</code> 这个虚拟地址转换为物理页号（<code>trap_cx_ppn</code>）。</li>
<li><code>trap_cx_ppn</code> 表示陷入上下文（<code>TrapContext</code>）所在的物理页号，用于进程的系统调用或异常处理。</li>
</ul>
<h3 id="步骤-3：独占访问当前进程控制块（TCB）"><a href="#步骤-3：独占访问当前进程控制块（TCB）" class="headerlink" title="步骤 3：独占访问当前进程控制块（TCB）"></a>步骤 3：独占访问当前进程控制块（TCB）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mut inner &#x3D; self.inner_exclusive_access();</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>inner_exclusive_access</code> 方法独占访问当前进程的 <code>TaskControlBlockInner</code> 结构体，确保在以下步骤中可以对进程的内部状态进行修改。</li>
</ul>
<h3 id="步骤-4：替换-MemorySet"><a href="#步骤-4：替换-MemorySet" class="headerlink" title="步骤 4：替换 MemorySet"></a>步骤 4：替换 <code>MemorySet</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inner.memory_set &#x3D; memory_set;</span><br></pre></td></tr></table></figure>

<ul>
<li>将当前进程的 <code>memory_set</code> 替换为新创建的 <code>memory_set</code>，这样新加载的 ELF 程序就成为该进程的地址空间。</li>
<li>这一步实现了对原应用程序地址空间的替换。</li>
</ul>
<h3 id="步骤-5：更新-trap-cx-ppn"><a href="#步骤-5：更新-trap-cx-ppn" class="headerlink" title="步骤 5：更新 trap_cx_ppn"></a>步骤 5：更新 <code>trap_cx_ppn</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inner.trap_cx_ppn &#x3D; trap_cx_ppn;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 <code>trap_cx_ppn</code> 字段，设置新的 <code>trap_cx_ppn</code>，确保进程的陷入上下文指针正确指向新的物理页。</li>
</ul>
<h3 id="步骤-6：初始化-base-size"><a href="#步骤-6：初始化-base-size" class="headerlink" title="步骤 6：初始化 base_size"></a>步骤 6：初始化 <code>base_size</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inner.base_size &#x3D; user_sp;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新 <code>base_size</code> 字段为新的用户栈顶地址 <code>user_sp</code>。</li>
<li><code>base_size</code> 用于保存用户栈的初始栈顶，便于栈空间管理。</li>
</ul>
<h3 id="步骤-7：初始化-trap-cx"><a href="#步骤-7：初始化-trap-cx" class="headerlink" title="步骤 7：初始化 trap_cx"></a>步骤 7：初始化 <code>trap_cx</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let trap_cx &#x3D; inner.get_trap_cx();</span><br><span class="line">*trap_cx &#x3D; TrapContext::app_init_context(</span><br><span class="line">    entry_point,</span><br><span class="line">    user_sp,</span><br><span class="line">    KERNEL_SPACE.exclusive_access().token(),</span><br><span class="line">    self.kernel_stack.get_top(),</span><br><span class="line">    trap_handler as usize,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用 <code>get_trap_cx</code> 获取当前进程的陷入上下文指针。</p>
</li>
<li><p>使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrapContext::app_init_context</span><br></pre></td></tr></table></figure>

<p> 函数重新初始化陷入上下文，设置新程序的执行信息：</p>
<ul>
<li><code>entry_point</code>：新程序的入口地址。</li>
<li><code>user_sp</code>：用户栈顶地址。</li>
<li><code>KERNEL_SPACE.exclusive_access().token()</code>：内核空间的访问令牌，确保正确的权限。</li>
<li><code>self.kernel_stack.get_top()</code>：内核栈的栈顶地址，用于中断或系统调用时的上下文切换。</li>
<li><code>trap_handler as usize</code>：陷入处理函数的地址，用于异常处理。</li>
</ul>
</li>
</ul>
<h3 id="结尾：释放-inner-锁"><a href="#结尾：释放-inner-锁" class="headerlink" title="结尾：释放 inner 锁"></a>结尾：释放 <code>inner</code> 锁</h3><p>在 <code>inner</code> 独占访问结束时，<code>inner_exclusive_access()</code> 产生的独占访问会自动释放，允许其他任务对该进程进行访问。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该 <code>exec</code> 方法执行以下步骤来加载和执行一个新的 ELF 程序：</p>
<ol>
<li>从 ELF 数据中构建新的 <code>MemorySet</code>、用户栈顶地址、程序入口点。</li>
<li>获取并设置新的陷入上下文物理页号 <code>trap_cx_ppn</code>。</li>
<li>独占访问当前进程控制块，并逐步替换内存集、更新陷入上下文等信息。</li>
<li>重新初始化陷入上下文，确保该进程从新的程序入口执行。</li>
</ol>
<h2 id="rcore调度策略"><a href="#rcore调度策略" class="headerlink" title="rcore调度策略"></a>rcore调度策略</h2><p>TaskManager任务管理器管理着一个任务就绪队列（先进先出策略），os初始化过后会在<code>run_tasks</code>中无限循环，取出任务及任务保存的寄存器<code>task_cx</code>，然后通过<code>__switch</code>切换<code>idle_task</code>到<code>next_task</code>(实际就是task_cx中寄存器的切换)，如果没有任务或当前任务释放控制权则会调用<code>schedule</code>切换到<code>idle_task</code></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h3><p>可表示为两个文件描述符加一段<strong>内核空间</strong>中的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传入数组，转换成管道的读写端的文件描叙符</span><br><span class="line">int pipe(int pipefd[2]);</span><br></pre></td></tr></table></figure>

<p>通过操作文件描述符来分别操作读写端进行进程间通信</p>
<ul>
<li>如何实现shell中管道符“|”功能</li>
</ul>
<p>可以fork两个子进程，pid1的执行流可以使用dup2函数将stdout重定向到pipefd[1] （写端），并关闭管道的读写端，执行第一条命令</p>
<p>pid2的执行流使用dup2函数将stdin重定向到pipefd[0] （读端），关闭管道的读写端，执行第二条命令</p>
<p>最后父进程关闭读写端并wait两个子进程</p>
<p><strong>匿名管道</strong>：只能是<strong>具有血缘关系</strong>的进程之间通信；它只能实现一个进程写另一个进程读，而如果需要两者同时进行时，就得重新打开一个管道。</p>
<p>为了使任意两个进程之间能够通信，就提出了<strong>命名管道</strong>（named pipe 或 FIFO）。<br>1、与管道的区别：提供了<strong>一个路径名与之关联</strong>，以FIFO文件的形式存储于文件系统中，能够<strong>实现任何两个进程之间通信</strong>。而匿名管道对于文件系统是不可见的，它仅限于在父子进程之间的通信。<br>2、FIFO是一个设备文件，在文件系统中以文件名的形式存在，因此即使进程与创建FIFO的进程不存在血缘关系也依然可以通信，前提是可以访问该路径。<br>3、FIFO(first input first output)总是遵循先进先出的原则，即第一个进来的数据会第一个被读走。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h3 id="信号（Signal）"><a href="#信号（Signal）" class="headerlink" title="信号（Signal）"></a>信号（Signal）</h3><p>在rCore中，当trap发生进入<code>trap_handler</code>函数，其中会调用<code>handle_signals</code>，循环调用<code>check_pending_signals</code>检测进程结构体中的成员来判断是否有<code>signal</code>到来，如果是内核信号，则在内核执行处理函数<code>call_kernel_signal_handler(signal)</code>，如果是用户信号则需要返回用户态执行处理函数<code>call_user_signal_handler(sig, signal)</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E4%B8%8E%E6%80%BB%E7%BB%93-%E6%AC%A7%E9%98%B3%E5%85%B4%E9%93%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%E4%B8%8E%E6%80%BB%E7%BB%93-%E6%AC%A7%E9%98%B3%E5%85%B4%E9%93%96/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营一二阶段学习报告与总结-欧阳兴铖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 20:37:31" itemprop="dateCreated datePublished" datetime="2024-11-08T20:37:31+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>参加这次训练营时，我刚刚才进入大三，大三是个非常关键的时期，在之前的时间里已经积累了很多的基础，我在之前所学习到的知识将在这个时间段被检验被拷打，而翻过这座山后，学习的高度将建立在这个这个时期的过渡，所以不仅为了巩固与纠正之前的知识还为了能在这个过渡期将知识储备量进一步提高层次。我选择了这个训练营。我不仅能学到一门强大，前沿，更现代的技术，我还能对硬件与程序之间的桥梁——操作系统有更加深入的了解。能够得到丰富收获的同时也面临一系列的挑战。但是每当遇到困难与压力，我都够挺过来。难题来临，不得不顶上去，敢问路在何方，路就在脚下。</p>
<h1 id="二、第一阶段"><a href="#二、第一阶段" class="headerlink" title="二、第一阶段"></a>二、第一阶段</h1><h2 id="1-总述"><a href="#1-总述" class="headerlink" title="1.总述"></a>1.总述</h2><p>第一阶段主要涉及的是Rust这门语言的学习，初次接触到Rust这门语言，可能最直观的感受是它的要求很多，比如可变引用于不可变引用、所有权、trait、mod等等。但是这也是Rust与其他语言不同的地方，它会在错误发生之前就尽力扼杀全部错误，这是其他语言所不具备的，这得益于Rust强大的编译器。另外，Rust编程的主要思想仍然是面向对象编程。这使得Rust在大型工程里会使代码更加模块化。</p>
<h2 id="2-特殊机制"><a href="#2-特殊机制" class="headerlink" title="2.特殊机制"></a>2.特殊机制</h2><p>Rust的基础特性与其他语言类似这里不做描述，比如基本数据类型、结构体、枚举。这里只列举一些，有待补充。</p>
<h3 id="1-Option类型"><a href="#1-Option类型" class="headerlink" title="(1) Option类型"></a>(1) Option类型</h3><p>这是一个枚举的变体（是基于枚举类型实现的），它在各种语义里发挥作用，其根本特别之处在于它的None和Some（），它与传统意义的Null不同，例如C语言里的Null表示为空值。它的设计能对Null做出处理而不简单停留在标识空值，他提供了更多选项。</p>
<h3 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="(2) 生命周期"></a>(2) 生命周期</h3><p>这是Rust强大的编译器带来的特性，它会检查在程序里每处被定义的内存的存在周期，以在编译阶段就避免悬垂指针的出现，这样的话内存的安全性将大大提高。</p>
<h3 id="3-所有权机制"><a href="#3-所有权机制" class="headerlink" title="(3) 所有权机制"></a>(3) 所有权机制</h3><p>这是Rust独一档的特性，它会让Rust每处内存同一时间只会所属于一个变量，而其他变量只能引用这处内存，这样的定义使得Rust制定出了所有权规则，为内存提供了特殊的定义机制，这使得引用内存变得更加安全可靠。</p>
<h3 id="4-模式匹配"><a href="#4-模式匹配" class="headerlink" title="(4) 模式匹配"></a>(4) 模式匹配</h3><p>针对模式匹配，Rust提供了match、if let、while let等来实现模式匹配，这使得我们在Rust可以对变量进行类型判断，增加了每条判断语句灵活性。</p>
<h1 id="三、第二阶段"><a href="#三、第二阶段" class="headerlink" title="三、第二阶段"></a>三、第二阶段</h1><h2 id="1-总述-1"><a href="#1-总述-1" class="headerlink" title="1.总述"></a>1.总述</h2><p>第二阶段主要聚焦于基于risc-v架构的类Unix操作系统，我们采用了Rust语言来编写rcore内核，这是因为Rust在这方面有得天独厚的优势。操作系统在各领域都有所涉及，例如计算机体系架构、计算机组成、计算机网络、数据结构等。所以学习操作系统更够窥探更多计算机的秘密，因此我操作系统有非常浓厚的兴趣。</p>
<h3 id="从裸机运行到单道批处理系统"><a href="#从裸机运行到单道批处理系统" class="headerlink" title="从裸机运行到单道批处理系统"></a>从裸机运行到单道批处理系统</h3><ul>
<li>没有任何操作系统，能够直接硬件的程序运行被称为裸机程序。这样做有一点历史原因，虽然这样做对程序员来说十分自由、没有限制。但这样会造成许多问题，例如安全问题、不具通用性难以移植以及对硬件资源的利用率很低等等。</li>
<li>于是有了单道批操作系统，在rcore表现为加入了初步的简陋的操作系统。为了安全性，借助硬件上划分的运行特权级将程序的执行环境人为与操作系统分隔开，同时也添加了系统调用，因此可以将多个程序按照一定的批次放在内存里约定的位置，以达到运行多个程序的目的。</li>
<li>此时会将所有的程序编译并链接后，生成bin文件，将bin文件先加载到内存里，然后操作系统执行时会将需要执行的程序加载到0x80400000这个约定的地址。</li>
</ul>
<h3 id="从单道批处理到进程调度"><a href="#从单道批处理到进程调度" class="headerlink" title="从单道批处理到进程调度"></a>从单道批处理到进程调度</h3><ul>
<li>单道批处理系统已经明显的区别于裸机运行，但是这样的系统仍然还有进步空间，对硬件资源的利用率还是不高，比如说是cpu的处理能力没有充分利用以及内存资源的分配等等。</li>
<li>因此在单道批处理系统的基础上，我们不只是将程序加载进内存后让其滞留在那里而是每个程序都可以运行起来，于是提出了时间片的概念，让每个程序尽量都能被cpu执行，这样cpu的空闲时间会下降，相反性能将大幅提高，同时还让持有内存资源的程序能够及时得到执行，提高了内存利用率。</li>
<li>在rcore里，他是risc-v架构，使用内部的定时器来对运行时间进行切分，同时为了能成功切换程序，建立了新的数据结构TCB来维护与更新每个程序的关键信息。</li>
</ul>
<h3 id="内存地址空间的管理策略"><a href="#内存地址空间的管理策略" class="headerlink" title="内存地址空间的管理策略"></a>内存地址空间的管理策略</h3><ul>
<li>以往所提到的地址或是所使用的地址都是物理地址，意思为所有数据都是直接承载在物理地址上的，且所存与所访问的地址是一一对应的。但是这样的话会带来很多问题，例如内存空间的不安全以及局限性等等。</li>
<li>因此提出了多种存储管理策略来使程序能够重定位，这极大地提高了内存地址空间的灵活性，同时使访问内存变得更加安全。实现这一算法需要硬件上的支持，因为如果在软件层面上让操作系统来翻译性能会大幅降低，对于硬件资源更适合去干这份工作。因此诞生了mmu。</li>
<li>这里的rcore使用的是SV39这种内存管理策略。依赖的是页机制，且使用的是多级页表。这我们对整个物理内存划分为一个很小的页面，这样我们对内存的分配更加灵活、安全、高效。</li>
</ul>
<h3 id="对外部存储空间的抽象与管理"><a href="#对外部存储空间的抽象与管理" class="headerlink" title="对外部存储空间的抽象与管理"></a>对外部存储空间的抽象与管理</h3><ul>
<li>内存虽说是直接与cpu交互，但内存的大小十分有限，我们不能够仅仅依靠内存来存储数据。我们使用计算机通常会产生、使用以及删除十分庞大数据，因此我们不得不依靠外部存储器件来存储数据，但这部分器件往往无法被cpu直接访问，因此我们需要操作系统来操作接口与设备来使数据放在内存里。</li>
<li>但是管理一个庞大的存储空间不是一件简单的事，并且内存与外存的存储结构通常是有很大差别的，所以我们需要实现对存储空间进行抽象然后再建立新的数据结构进行管理。这里引入的就是文件系统。</li>
<li>rcore里的文件系统将每个文件（站在人的视角看叫做文件）抽象成了多个存储节点（站在存储器件的角度上），每个节点的数据结构里含有数据索引，名称，权限，文件关系等重要信息。这样我们访问文件时，操作系统会根据我们的需要去检索节点然后去访问数据。</li>
<li>在类Unix操作系统里文件系统采用了统一的框架“”fd（文件描述符）”去描述每个“文件”。由于许多外部设备的访问操作时相似的，例如“打开”、“读”、“写”等，因此对许多类似的设备重定向，建立适配该框架的数据结构，使得可以利用这个框架去访问外部设备。 </li>
</ul>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul>
<li>之前我们通常将每个程序作为进程受操作系统管理然后运行，操作系统分配资源的对象为进程，cpu运行的单位也是进程。但是这样的设计仍然会带有一定的局限性，因此我们进程再度细分，将进程分为了线程，进程可以申请线程。</li>
<li>进程本身就是一个最大的主线程，它作为线程但又区别于子线程。每个线程都在在进程的环境里运行，所得到的资源也为该进程。因此操作系统分配资源的对象仍为进程，但cpu运行的单位变成了线程。这样提高了进程的运行响应，同时优化了操作系统的调度运行。</li>
<li>但这样也带来了一定的问题，会出现一些线程间的冲突，因此我们需要调和线程之间的运行。这里rcore就使用到了信号量和互斥。</li>
</ul>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>在这两个阶段里，我学到了很多，一门新的语言Rust、一种类Unix基于risc-v架构的操作系统。从9月29日开始到现在第二阶段11月10日的结束，无论是知识上的或是技术上的，我收获到了许多。我知道这只是基础，我渴望能在第三阶段学习到更成熟的操作系统，以此能加强我对Rust的学习、对risc-v架构的理解、对类Unix系统的理解以及更前沿的编程技术。感谢。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-dccif/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-dccif/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营第一、二阶段总结报告-dccif</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 19:58:17" itemprop="dateCreated datePublished" datetime="2024-11-08T19:58:17+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段的Rustlings"><a href="#第一阶段的Rustlings" class="headerlink" title="第一阶段的Rustlings"></a>第一阶段的Rustlings</h1><p>关于第一阶段的Rustlings，还是花了很多时间去学习Rust。一开始是直接去看《Rust程序设计语言》，随后还看了《Rust圣经》，把一些较为简单的概念和程序过了一遍。可是发现做题时还是难以掌握，随后只能带着疑问和不懂的地方边做边查，做完一套后终于有点入门的感觉了，我感觉rust对我或者别的语言的用户来说，一大难点就是自造的概念太多了+ 第一次接触时的api暴露太多了，有一点不知如何下手。然后再结合上生命周期，就更难上手了。</p>
<h1 id="rcore实验"><a href="#rcore实验" class="headerlink" title="rcore实验"></a>rcore实验</h1><h2 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h2><p>这个实验主要是实现一个简单sys_task_info多任务系统. 通过这个实验, 了硬件是如何在不同的特权级之间切换的, 以及操作系统是如何管理这些特权级的，知道什么是系统调用和特权级的应用</p>
<h2 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab 2"></a>Lab 2</h2><p>lab2是实现在启用虚拟地址的情况下重写sys_get_time和sys_task_info, 并实现sys_mmap和sys_munmpa系统调用, 因为启用了分页机制, 学习到了地址空间的概念, 应用程序只需要关心自己的地址空间, 而不需要关心其他应用程序的地址空间, 在实现过程中我对操作系统对代码中的地址空间, 页表的地址转换有了更深的理解  </p>
<h2 id="Lab-3"><a href="#Lab-3" class="headerlink" title="Lab 3"></a>Lab 3</h2><p>lab3是实现sys_spawn和stride调度算法, 学习到了进程是如何创建的, 以及进程是如何执行的</p>
<h2 id="Lab-4"><a href="#Lab-4" class="headerlink" title="Lab 4"></a>Lab 4</h2><p>lab4是实现硬链接和获取文件信息的系统调用,  需要对inode和disk_inode有较深的理解, 学习了文件系统是如何与物理存储设备交互的</p>
<h2 id="Lab-5"><a href="#Lab-5" class="headerlink" title="Lab 5"></a>Lab 5</h2><p>lab5是实现死锁检测, 需要理解死锁检测算法 need矩阵</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024-%E7%A7%8B%E5%86%AC%E5%AD%A3-rcore%E9%98%B6%E6%AE%B5%E4%BA%8Cblog-%E6%9D%8E%E5%BD%A6%E6%B3%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024-%E7%A7%8B%E5%86%AC%E5%AD%A3-rcore%E9%98%B6%E6%AE%B5%E4%BA%8Cblog-%E6%9D%8E%E5%BD%A6%E6%B3%BD/" class="post-title-link" itemprop="url">2024 秋冬季 rcore阶段二blog  李彦泽</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 19:33:49" itemprop="dateCreated datePublished" datetime="2024-11-08T19:33:49+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>补充第一阶段的内容:主要就是学习rust的使用,基本上问题都能够解决</p>
<p>在阶段二让我对操作系统和rust有了更加深刻的理解</p>
<h2 id="操作系统部分"><a href="#操作系统部分" class="headerlink" title="操作系统部分"></a>操作系统部分</h2><p>其实我是有linux内核和驱动的开发经验的，所以对虚拟地址、物理地址、页表、等等知识都是有接触的，但是主要还是停留在书本或者内核提供的api，这五次作业，让我用rust这门最开始接触的语言来实现底层，也还是难度不小。</p>
<p>最开始的页表啊、映射啊、以及一些环境搭建还有git使用对我来说基本没有难度，但是到了第四个lab和第五个lab就开始难了。</p>
<p>文件系统：这个本身我对其就没有太清楚的了解过内部结构，只是会用，这次lab4的作业，强制我要去看源码实现，对超级区块，以及bitmap管理分配的索引，以及bitmap管理内容区块，再到系统层面通过OSInode来管理每个文件的inode，以及管理到物理磁盘上的inode，以及文件名啥的相互联系，让我从底层的磁盘到上层OS的管理链路有了比较清晰的认识，并且对rust的使用有了更加深刻的理解(没错，特指生命周期，和mut ref),因为这两个没少出现借用的问题。</p>
<p>死锁检测:这个部分也是耗时很长，其实我认为这部分的理解不难，因为我很早就接触了锁、信号量这些，我觉得这部分最难的在于调试。由于是并发编程，遇到的情况千奇百怪，以及难以定位。所以我写了很多的log，并且以非常人性化的输出来查看，虽然这部分耗时比较久，但是打好log对后续的开发是如虎添翼。也不会有陷入log中无法自拔的问题。并且通过实现了这个算法，算是开辟了新的知识点，以前从来没有想到还能死锁检测。</p>
<h2 id="对同学的建议"><a href="#对同学的建议" class="headerlink" title="对同学的建议"></a>对同学的建议</h2><p>总的来说难度不小，并且其实资料是比较有限的(对于无从下手的新手来说),所以如果卡关了还是要多去搜索资料，以及看源码(这个很重要)，去看具体的实现，以及画流程图和结构体之间的关系图，以及标注重要的api(找到合适的api可以事半功倍)</p>
<h2 id="对项目建议"><a href="#对项目建议" class="headerlink" title="对项目建议"></a>对项目建议</h2><p>总的来说操作系统的重点都有涉及，知识面还是很充足的!!</p>
<p>但是在编写过程中明显感觉到由于前向兼容导致测试用例的编译越到后期越慢，每次run光编译就会花费一分钟，其实可以优化makefile来单独编译某些测例来减少测试开发的时间。</p>
<p>以及最后两个lab难度上升有点大，并且文章 中是对功能的描述居多(很多对于实验有用的点会被淹没在其中)虽然在边做lab边反复查看资料时可以发现，但是对于没有接触过的同学可能很多api看过就没印象了，在后续做lab中也找不到，所以可以适当增加一下强调或者提示，来减少难度增加坡度。</p>
<p>最后还可以收集一下大家的调试方法，这样对于后续对debug无从下手的同学也有参考意义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024a-rcore-%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024a-rcore-%E4%B8%80%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/" class="post-title-link" itemprop="url">2024a-rcore-一阶段总结-明扬</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 15:52:11" itemprop="dateCreated datePublished" datetime="2024-11-08T15:52:11+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为我已经工作有12年了, Rust也写了有几万行, 所以第一阶段对我来说没什么难度. 但是我还是按照训练营的要求, 完成了rustlings的练习.</p>
<h1 id="rustlings"><a href="#rustlings" class="headerlink" title="rustlings"></a>rustlings</h1><p>rustlings的练习很简单, 但是对于新手来说, 是一个很好的入门练习. 通过这些练习, 可以很快的了解rust的基本语法和特性.</p>
<p>不过我仍然从中学到了一些新东西, 比如 <code>BinaryHeap</code>. 之前我在编写应用程序的时候一直用 <code>Vec</code> 来实现优先队列, 现在我知道了 <code>BinaryHeap</code> 这个更好的实现.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理解了 Drop 就入门了 Rust.<br>理解了 Trait 就熟悉了 Rust.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E5%91%A8%E9%B8%BF%E9%92%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E5%91%A8%E9%B8%BF%E9%92%A7/" class="post-title-link" itemprop="url">2024秋冬季开源操作系统训练营第二阶段总结报告_周鸿钧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 15:33:10" itemprop="dateCreated datePublished" datetime="2024-11-08T15:33:10+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024秋冬季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就Rust语言来说，我认为这是开创新时代的语言，一直在努力学习。<br>我自己学Rust语言的过程，分了三个阶段，最初纯粹是好奇。<br>用Rust自己写了一些小程序后，对Rust有了实际的体验，感觉体验很好、值得信赖。<br>于是有了更深入学习的想法，前面参加了InfiniTensor训练营，了解到使用Rust开发更复杂程序的方法。<br>现在参加操作系统训练营，是对自己更高的挑战。</p>
<p>开发一个操作系统内核是一个宏大的课题，需要认真的思考、深入地研究。训练营在短时间内整个拉了一遍，<br>给了学员一个宏观的体验，这非常宝贵，这是我参加训练营的原因。同时，在这个过程中，通过交流和学习，<br>也触发了我个人的深层思考，这对我个人尤为宝贵。<br>限于时间，我没法把所有问题思考透彻，但又不能感兴趣的问题轻易丢弃，于是写这篇总结，留待以后。<br>标题叫Something Not yet done，就是我想做、想探寻但还没有答案的东西。</p>
<h1 id="基础阶段"><a href="#基础阶段" class="headerlink" title="基础阶段"></a>基础阶段</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>基础段主要涉及Rust语言的学习。</p>
<ul>
<li>Rust语言的unsafe部分</li>
<li>Rust语言的异步和并行部分</li>
</ul>
<h2 id="Rust语言的unsafe部分"><a href="#Rust语言的unsafe部分" class="headerlink" title="Rust语言的unsafe部分"></a>Rust语言的unsafe部分</h2><p>第一次涉及到unsafe部分代码的编写，经历了程序的崩溃，意识到unsafe的危险；到使用安全方法怎么也无<br>法实现想要的功能，明白了Rust的哲学，unsafe的重要性。从享受Rust的安全编程，转变为谨慎地编写unsafe<br>然后再享受Rust的安全编程，对于Rust的编程理念有了更近一步的了解。<br>但如何安全地编写unsafe，仍然有很多知识需要学习和实践，包括：</p>
<ul>
<li>unsafe function</li>
<li>unsafe trait</li>
<li>unsafe extern</li>
</ul>
<p>要完全掌握Rust，unsafe是必须跨越的一步。</p>
<h2 id="Rust语言的异步和并行部分"><a href="#Rust语言的异步和并行部分" class="headerlink" title="Rust语言的异步和并行部分"></a>Rust语言的异步和并行部分</h2><p>对于如何编写高性能的Rust程序，还缺乏实践。</p>
<h1 id="专业阶段"><a href="#专业阶段" class="headerlink" title="专业阶段"></a>专业阶段</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>专业阶段主要涉及对rCore的代码分析、学习，和部分功能实现。</p>
<ul>
<li>系统调用</li>
<li>虚拟地址</li>
<li>进程管理和调度</li>
<li>文件系统</li>
<li>并行控制</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>这部分功能比较简单。</p>
<h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><p>引入虚拟地址后，所有系统调用的参数传递，都需要进行地址转换。目前都在系统调用处理函数中，复制粘贴<br>代码来实现，格外得丑陋。希望在第三阶段的时候，对这部分进行封装。</p>
<h2 id="进程管理和调度"><a href="#进程管理和调度" class="headerlink" title="进程管理和调度"></a>进程管理和调度</h2><p>stride是比较简单的调度算法，希望在后面能够尝试将Linux的调度算法移植过来。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在实现功能的过程中，在File trait中增加的一个方法。不知道有没有破坏原有的抽象，三阶段看看完整的<br>项目是如何解决File到Inode转换的。</p>
<h2 id="并行控制"><a href="#并行控制" class="headerlink" title="并行控制"></a>并行控制</h2><p>死锁检测的实现中，感觉对于列表的实现有点丑陋，目前可用的集合类就只有VecDeque，三阶段看看有没有<br>其他实现方式。</p>
<h1 id="项目阶段"><a href="#项目阶段" class="headerlink" title="项目阶段"></a>项目阶段</h1><p>待补充。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024%E5%B9%B4%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-silent12rt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024%E5%B9%B4%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-silent12rt/" class="post-title-link" itemprop="url">2024年开源操作系统训练营第一和二阶段总结-silent12rt</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 14:57:58" itemprop="dateCreated datePublished" datetime="2024-11-08T14:57:58+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024秋冬季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="rustlings-总结"><a href="#rustlings-总结" class="headerlink" title="rustlings  总结"></a>rustlings  总结</h1><p>Rustlings 是学习 Rust 编程语言的极佳练习工具，它包含了多个由浅入深的练习题目，帮助学习者快速掌握 Rust 的基础知识和重要概念。</p>
<h3 id="1-变量与可变性"><a href="#1-变量与可变性" class="headerlink" title="1. 变量与可变性"></a>1. 变量与可变性</h3><ul>
<li>Rust 中的变量默认是不可变的（immutable），即变量在声明后无法更改。要让变量可变，必须显式添加 <code>mut</code> 关键字。</li>
<li>这种默认不可变性帮助开发者避免无意的状态变化，提高代码的安全性和可维护性。</li>
</ul>
<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><ul>
<li>Rust 是静态类型语言，编译器会在编译阶段检查数据类型。</li>
<li>Rust 支持多种数据类型，包括标量类型（整型、浮点型、布尔型、字符）和复合类型（元组、数组等）。</li>
</ul>
<h3 id="3-所有权机制"><a href="#3-所有权机制" class="headerlink" title="3. 所有权机制"></a>3. 所有权机制</h3><ul>
<li>Rust 的所有权系统是其内存安全性和性能的重要保障。</li>
<li>每个值在同一时间只能有一个所有者，当所有者变量超出作用域时，内存会自动释放。所有权的转移、借用和引用（可变和不可变）是理解 Rust 内存管理的关键。</li>
</ul>
<h3 id="4-借用与引用"><a href="#4-借用与引用" class="headerlink" title="4. 借用与引用"></a>4. 借用与引用</h3><ul>
<li>借用（Borrowing）允许在不转移所有权的情况下使用数据。</li>
<li>Rust 有严格的借用规则：在同一作用域中，只允许一个可变引用或多个不可变引用，确保内存安全。</li>
</ul>
<h3 id="5-结构体与枚举"><a href="#5-结构体与枚举" class="headerlink" title="5. 结构体与枚举"></a>5. 结构体与枚举</h3><ul>
<li>结构体（Struct）用于将不同的数据组合成一个复合类型，枚举（Enum）用于定义一组可能的状态或值。</li>
<li>Rust 的枚举非常强大，支持绑定数据，并且可以与模式匹配一起使用，帮助更清晰地处理复杂的逻辑分支。</li>
</ul>
<h3 id="6-模式匹配"><a href="#6-模式匹配" class="headerlink" title="6. 模式匹配"></a>6. 模式匹配</h3><ul>
<li><code>match</code> 表达式和 <code>if let</code> 是 Rust 中处理分支的主要工具，尤其是当处理枚举和结果类型（<code>Result</code>）时。</li>
<li><code>match</code> 语法不仅简洁，还能避免遗漏某些分支，确保代码的健壮性。</li>
</ul>
<h3 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h3><ul>
<li>Rust 提供了 <code>Result</code> 和 <code>Option</code> 类型来进行错误处理和空值处理。</li>
<li>使用 <code>unwrap</code>、<code>expect</code>、<code>match</code> 等方式处理这些类型，开发者可以编写出更健壮的代码，避免程序在运行时崩溃。</li>
</ul>
<h3 id="8-所有权的移动与复制"><a href="#8-所有权的移动与复制" class="headerlink" title="8. 所有权的移动与复制"></a>8. 所有权的移动与复制</h3><ul>
<li>移动（Move）：当变量的所有权被转移时，源变量将不可用。</li>
<li>复制（Copy）：对于实现了 <code>Copy</code> 特征的类型（如基本数据类型），赋值不会转移所有权，而是直接复制。</li>
</ul>
<h3 id="9-特征"><a href="#9-特征" class="headerlink" title="9. 特征"></a>9. 特征</h3><ul>
<li>Rust 中的特征类似于其他语言的接口，用于定义一组方法签名，供结构体或枚举实现。</li>
<li>特征使得 Rust 支持多态，通过泛型和特征约束实现代码的复用和接口一致性。</li>
</ul>
<h3 id="10-智能指针"><a href="#10-智能指针" class="headerlink" title="10. 智能指针"></a>10. 智能指针</h3><ul>
<li>Rust 的标准库中提供了 <code>Box</code>、<code>Rc</code> 和 <code>RefCell</code> 等智能指针类型，帮助管理内存和共享数据。</li>
<li><code>Box</code> 实现堆分配，<code>Rc</code> 实现引用计数，<code>RefCell</code> 提供运行时的可变性检查，用于实现更复杂的数据结构。</li>
</ul>
<h3 id="11-并发编程"><a href="#11-并发编程" class="headerlink" title="11. 并发编程"></a>11. 并发编程</h3><ul>
<li>Rust 的所有权机制让多线程编程更加安全。</li>
<li>使用 <code>std::thread</code> 库可以方便地创建线程，并且借助 <code>Arc</code> 和 <code>Mutex</code> 等类型来实现线程间的数据共享和同步。</li>
</ul>
<h3 id="12-生命周期（Lifetimes）"><a href="#12-生命周期（Lifetimes）" class="headerlink" title="12. 生命周期（Lifetimes）"></a>12. 生命周期（Lifetimes）</h3><ul>
<li>Rust 使用生命周期注解来管理引用的生命周期，确保程序不会引用无效数据。</li>
<li>生命周期的概念是 Rust 内存安全的重要组成部分，编译器会自动推断大部分生命周期，但有时需要显式标注。</li>
</ul>
<h1 id="OS-实现"><a href="#OS-实现" class="headerlink" title="OS 实现"></a>OS 实现</h1><p>第二阶段主要分为八个章节，每个章节层层递进，深入揭示操作系统的底层逻辑以及实现原理。</p>
<h3 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h3><p>为了实现 sys_task_info 系统调用，首先在 TaskManager 中为任务控制块 (TCB) 扩展结构体，加入如下字段：sys_call_times:[u32;MAX_SYSCALL_NUM]，然后在在mod.rs中增加increase_sys_call和get_sys_call_times函数，进而在syscall函数中调用increase_sys_call函数，</p>
<p>在系统调用处理逻辑中，维护当前任务的系统调用次数计数，每次进入系统调用时在数组中相应位置加一。在 sys_task_info 系统调用实现中，将当前任务的状态（应为 Running）、系统调用次数、以及通过 get_time() 获取的任务总运行时间写入 TaskInfo 结构体。</p>
<h3 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h3><ul>
<li>完成sys_get_time和sys_task_info函数，需要定义一个translated_struct_ptr，它通过页表（PageTable）将一个指向结构体（<code>*mut T</code>）的指针翻译为对应的物理地址，并返回一个可变引用（&amp;’static mut T），这样可以直接操作映射后的物理内存。在sys_task_info函数中，需要获取系统调用时间和任务运行时间，所以需要在task.rs中定义并实现它们。</li>
<li>完成sys_mmap和sys_munmap函数，用于申请和释放虚拟内存映射。sys_mmap 通过指定的起始地址 start、长度 len 和内存页属性 port 来映射一段物理内存到虚拟地址空间。该函数会检查起始地址对齐情况、port 的合法性，并将内存页映射为可读、可写或可执行。sys_munmap 则用于取消内存映射，释放从 start 开始的一段虚拟内存。（注意，需要判断地址是否对齐）</li>
</ul>
<h3 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h3><ul>
<li>实现了自定义的spawn的系统调用来创建新进程，以便简化进程创建的过程而无需使用fork+exec的组合操作。通过sys_spawn，直接从指定的路径启动目标程序，成功返回子程序的进程id，否则返回-1。</li>
<li>实现了stride调度算法，为每个进程设置优先级与其调度权重，使得系统资源能够更公平分配。<code>stride</code>调度通过设置初始优先级与动态步长（pass值），优先调度累计步长最小的进程，并对选中的进程步长进行累加调整，确保各进程的运行比例与优先级成正比。我还新增了 <code>sys_set_priority</code> 系统调用，以便动态调整进程优先级，增强调度灵活性。</li>
</ul>
<h3 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h3><p>在本次作业中，我实现了三个系统调用：linkat、unlinkat 和 fstat，以支持硬链接和文件状态获取。</p>
<ol>
<li>linkat：该调用用于创建一个文件的硬链接。它接收原有文件路径和新链接路径作为参数，并将新路径指向与原文件相同的磁盘块。在实现中，我确保在创建链接时不允许同名文件的存在，避免潜在的未定义行为。</li>
<li>unlinkat：此调用用于删除文件的链接。当调用 unlinkat 时，如果文件的引用计数降至零，它将回收与文件关联的 inode 及其数据块。我的实现确保正确处理文件的彻底删除，维护文件系统的一致性。</li>
<li>fstat：该调用获取指定文件描述符的状态信息。它将文件状态结构体填充以提供有关文件的详细信息，如大小、权限和时间戳等，便于用户或其他系统调用进行进一步处理。<br>通过这三个系统调用的实现，我的文件系统支持了硬链接的创建与删除，以及文件状态的查询，从而增强了其功能和灵活性。</li>
</ol>
<h3 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h3><p>我实现的功能包括对进程和线程的资源管理，主要是通过互斥量（mutex）和信号量（semaphore）来控制并发访问。具体而言，为每个线程维护了四个关键数据结构：m_allocation 和 s_allocation 用于记录已分配的互斥量和信号量的数量，m_need 和 s_need 则用于跟踪线程尚需的资源数量。在系统调用中，加入了对死锁的检测逻辑，确保在尝试获取新资源之前检查当前资源的可用性。如果发现潜在的死锁情况，则会拒绝资源请求，并返回相应的错误代码。此外，还实现了调整资源需求的方法，以便在资源分配和释放时动态更新状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024%E5%B9%B4%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-silent12rt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024%E5%B9%B4%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-silent12rt/" class="post-title-link" itemprop="url">2024年开源操作系统训练营第三阶段总结-silent12rt</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 14:57:58" itemprop="dateCreated datePublished" datetime="2024-11-08T14:57:58+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024秋冬季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C /home/linux/vscode/arceos A=/home/linux/vscode/my_arceos_app ARCH=aarch64 LOG=debug SMP=1 run</span><br></pre></td></tr></table></figure>

<h2 id="U-1-0-HelloWorld"><a href="#U-1-0-HelloWorld" class="headerlink" title="U.1.0 HelloWorld"></a>U.1.0 HelloWorld</h2><p>![![[Pasted image 20241111091146.png]]](&lt;2024年开源操作系统训练营第三阶段总结-silent12rt/Pasted image 20241111091146.png&gt;)<br>该图展示了一个应用程序（<code>hello_world</code>）在系统中各个模块（如<code>axruntime</code>、<code>axhal</code>、<code>axstd</code>、<code>arceos</code>）之间的结构和交互关系。以下是各个部分的功能说明：</p>
<ol>
<li><p><strong>axhal</strong>（硬件抽象层）：该层对硬件细节进行抽象，为更高层提供一个屏蔽底层硬件的基础，使上层不需要直接管理底层硬件。</p>
</li>
<li><p><strong>axruntime</strong>（运行时环境）：该层管理应用程序的运行时环境，包括内存分配、线程调度和其他运行时服务，是应用程序正常运行的基础。</p>
</li>
<li><p><strong>ulib（axstd）</strong>：这是一个标准库，为应用层提供通用功能和实用工具，可能包含基本的I/O操作、数据处理等辅助功能。</p>
</li>
<li><p><strong>api（arceos）</strong>：这是与底层操作系统（ArceOS）的应用编程接口，允许应用程序执行系统级操作，如文件管理、进程间通信等。</p>
</li>
<li><p><strong>app（hello_world）</strong>：这是用户的应用程序，利用<code>axstd</code>和<code>arceos</code>提供的库和接口来执行特定任务。</p>
</li>
<li><p><strong>执行流程</strong>：</p>
<ul>
<li>左侧的<strong>准备环境</strong>（蓝色箭头）表示系统的准备阶段，在此阶段，配置和初始化必要的资源和环境。</li>
<li>右侧的<strong>调用功能</strong>（橙色箭头）表示应用程序在运行时与<code>axstd</code>和<code>arceos</code>进行的交互，通过这些库和API执行特定功能。</li>
</ul>
</li>
</ol>
<h2 id="U-2-0-Collections"><a href="#U-2-0-Collections" class="headerlink" title="U.2.0 Collections"></a>U.2.0 Collections</h2><h4 id="Buddy-System（伙伴系统）"><a href="#Buddy-System（伙伴系统）" class="headerlink" title="Buddy System（伙伴系统）"></a>Buddy System（伙伴系统）</h4><ol>
<li>分配内存单元<br> 设置最小分配单元（通常是 2 的幂次方大小），而不是按1字节来分配。这种划分可以提高分配效率，并且降低管理开销。例如，如果分配单元是 8 字节，最小分配的内存块将是 8 字节。在 Buddy System 中，不同大小的块按 2 的幂次划分（即 8、16、32、64 等），每个大小被称为一个 order。每个 order 是一种特定大小的块。</li>
<li>分配过程<ul>
<li>寻找最小满足请求的块。当程序请求内存时，分配器首先确定需要分配的块的大小（例如 64 字节）。然后分配器会在内存池中找到最小的能满足此请求的 order 块（例如 128 字节的块，若没有 64 字节的块）。</li>
<li>二分切割。如果找到的 order 大于所需的大小，那么分配器将不断地对该块进行 二分切割，直到得到匹配所需大小的块。</li>
<li>返回分配的块：分配器返回一个与请求大小匹配的块，并将它从空闲列表中移除。此时，程序可以使用该块。</li>
</ul>
</li>
<li>释放过程<ul>
<li>检查是否有空闲的邻居块：当程序释放某块内存时，分配器会检查该块是否有“伙伴”块（即同一级的邻居块）也是空闲的。两个邻居块的地址通常具有某种关系，使分配器可以根据地址快速定位伙伴块。</li>
<li>合并到高 order：如果找到空闲的伙伴块，分配器会将两个相邻的空闲块合并成一个更大的块。这个合并过程会尽量继续进行，直到不能再合并为止。</li>
<li>挂到 Order List：如果无法进一步合并，最终的空闲块会挂到相应的空闲列表（Order List）中，以备后续分配使用。</li>
</ul>
</li>
</ol>
<h4 id="内存分配算法-Slab"><a href="#内存分配算法-Slab" class="headerlink" title="内存分配算法-Slab"></a>内存分配算法-Slab</h4><p>![![[Pasted image 20241111191653.png]]](&lt;2024年开源操作系统训练营第三阶段总结-silent12rt/Pasted image 20241111191653 1.png&gt;)<br>分配过程</p>
<ol>
<li>找到合适的OrderList<br> 根据请求的内存大小，找到合适的 OrderList。OrderList 会匹配内存大小，确保分配合适的 Slab。</li>
<li>从 Slab 的空闲块链表中获取 block<ul>
<li>从空闲块链表 (Free Block List) 中弹出一个 block，完成分配。</li>
<li>如果空闲块链表中没有可用的 block，则进入下一步。</li>
</ul>
</li>
<li>调用 BuddyAllocator 分配新块：<ul>
<li>当空闲链表中没有足够的块时，向 Buddy Allocator 请求一个较大的内存块。</li>
<li>将分配到的较大内存块切分为符合 Slab 需求大小的 block，然后加入到该 Slab 的空闲块链表。</li>
<li>最终，分配请求从空闲块链表中取出一个 block 返回。</li>
</ul>
</li>
</ol>
<p>释放过程</p>
<ol>
<li>释放 block 到空闲块链表<ul>
<li>释放时，将 block 放回对应 Slab 的空闲块链表。</li>
<li>这样，当后续需要分配类似大小的块时，可以直接从该空闲块链表中分配，避免重复分配和释放较大块的开销。</li>
</ul>
</li>
<li>管理内存回收<ul>
<li>如果某个 Slab 变得完全空闲（即所有 block 都释放），可以选择将该 Slab 的内存归还给 Buddy Allocator，以释放更多内存供其他用途。</li>
</ul>
</li>
</ol>
<h2 id="U-3-0-Collections"><a href="#U-3-0-Collections" class="headerlink" title="U.3.0 Collections"></a>U.3.0 Collections</h2><h2 id="U-4-0-Collections"><a href="#U-4-0-Collections" class="headerlink" title="U.4.0 Collections"></a>U.4.0 Collections</h2><h4 id="核心算法：context-switch"><a href="#核心算法：context-switch" class="headerlink" title="核心算法：context_switch"></a>核心算法：context_switch</h4><p>任务上下文Context: 保存任务状态的最小的寄存器状态集合。<br>![![[Pasted image 20241112144224.png]]](&lt;2024年开源操作系统训练营第三阶段总结-silent12rt/Pasted image 20241112144224.png&gt;)<br>ra: 函数返回地址寄存器，这个切换实现了任务执行指令流的切换。<br>sp: 任务即线程，这个是线程栈<br>s0~s11：按照riscv规范，callee不能改这组寄存器的信息，所以需要保存。</p>
<h4 id="抢占式调度算法ROUND-ROBIN"><a href="#抢占式调度算法ROUND-ROBIN" class="headerlink" title="抢占式调度算法ROUND_ROBIN"></a>抢占式调度算法ROUND_ROBIN</h4><p>在协作式调度FIFO的基础上，由定时器定时递减当前任务的时间片，耗尽时允许调度，一旦外部条件符合，边沿触发抢占，当前任务排到队尾，如此完成各个任务的循环排列。<br>![![[Pasted image 20241112151551.png]]](&lt;2024年开源操作系统训练营第三阶段总结-silent12rt/Pasted image 20241112151551.png&gt;)</p>
<h4 id="抢占式调度算法CFS-Completely-Fair-Scheduler"><a href="#抢占式调度算法CFS-Completely-Fair-Scheduler" class="headerlink" title="抢占式调度算法CFS(Completely Fair Scheduler)"></a>抢占式调度算法CFS(Completely Fair Scheduler)</h4><p>![![[Pasted image 20241112151735.png]]](&lt;2024年开源操作系统训练营第三阶段总结-silent12rt/Pasted image 20241112151735.png&gt;)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/2024a-rcore-%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/2024a-rcore-%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E6%98%8E%E6%89%AC/" class="post-title-link" itemprop="url">2024a-rcore-二阶段总结-明扬</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 11:45:02" itemprop="dateCreated datePublished" datetime="2024-11-08T11:45:02+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我是一位已经参加工作有12年的资深工程师, 职业生涯中曾经担任过 CTO, 也做过总架构师. 精通 5+ 门编程语言, 对 10+ 门编程语言有过万行生产环境编码经验.<br>但因为自己毕业于一所大专院校, 在大专学习期间学校并没有开设过这些计算机系基础课程. 在多年工作中我时常好奇: </p>
<ol>
<li>应用程序的内存是如何分配的</li>
<li>应用程序代码是如何启动的</li>
<li>应用如何与操作系统进行交互</li>
<li>操作系统是如何管理硬件资源的</li>
<li>多线程是如何实现的<br>等等问题.<br>抱着求知的心态, 我报名参加了这次的操作系统训练营.<br>这些基本能力, 对应用开发者来说就像超市货架上每天都能“生长”出来的食物, 操作系统是如何把他们实现的, 我想要了解这个过程.</li>
</ol>
<p>我曾在2021年参加过一次学堂在线的操作系统课程, 但是因为工作和家庭琐事繁忙, 最终没有完成. 这次我希望通过这次训练营, 继续学习操作系统的知识, 并且完成所有的实验.</p>
<p>我始终贯彻着一句话: 计算机是一门实践工程学科, 不管看的听的再怎么醍醐灌顶, 写不出来就是没学会.<br>学校的操作系统课程, 大多数都是讲理论, 缺乏实践. 这次训练营, 我希望能开发自己的内核程序, 并烧录到自己的硬件上运行.</p>
<h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><h2 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h2><p>这个实验主要是实现一个简单的多任务系统. 通过这个实验, 我理解了硬件是如何在不同的特权级之间切换的, 以及操作系统是如何管理这些特权级的.</p>
<h2 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab 2"></a>Lab 2</h2><p>这个实验启用了分页机制, 我学习到了地址空间的概念, 应用程序只需要关心自己的地址空间, 而不需要关心其他应用程序的地址空间. 同时我也学习到了内核是如何管理这些地址空间的.</p>
<h2 id="Lab-3"><a href="#Lab-3" class="headerlink" title="Lab 3"></a>Lab 3</h2><p>进程: 学习到了进程是如何创建的, 以及进程是如何执行的.</p>
<h2 id="Lab-4"><a href="#Lab-4" class="headerlink" title="Lab 4"></a>Lab 4</h2><p>文件系统: 学习到了文件系统是如何与物理存储设备交互的, 块存储设备是如何存储文件与数据的.</p>
<h2 id="Lab-5"><a href="#Lab-5" class="headerlink" title="Lab 5"></a>Lab 5</h2><p>多线程: 学习到了操作系统是如何实现多线程的, 以及多线程之间如何通过锁来通讯.<br>通过课程实验: 我学习了如何用银行家算法检测死锁.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这门课程我学习到了很多操作系统的基础知识, 包括:</p>
<ul>
<li>裸机程序是如何启动的</li>
<li>应用程序内存是如何分配与隔离的</li>
<li>操作系统是如何操作硬件的</li>
<li>应用程序是如何与操作系统进行交互的</li>
<li>文件系统是如何实现的</li>
<li>等等…<br>同时我也发现课程框架代码存在许多值得改进的地方, 所以我在尝试编写自己的内核程序.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/11/08/24aw-rcore-phease1and2-suspenss-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/11/08/24aw-rcore-phease1and2-suspenss-summary/" class="post-title-link" itemprop="url">24aw rcore labs summary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-08 11:40:28" itemprop="dateCreated datePublished" datetime="2024-11-08T11:40:28+00:00">2024-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-20 12:38:24" itemprop="dateModified" datetime="2025-06-20T12:38:24+00:00">2025-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="阶段1-语言学习"><a href="#阶段1-语言学习" class="headerlink" title="阶段1:语言学习"></a>阶段1:语言学习</h2><p>rust 是一门非常有意思的语言，它吸收了很多现代编程语言的特性，特别是来自函数式编程的许多特性，比如 默认不可变，模式匹配，流 api，以及 trait，可以以一种不同的方式去抽象与编码。<br>rust 的“人体工程学”做的也非常不错，有许多语法糖与内置宏，匿名函数的写法也足够简洁，在学习过程中感觉非常有趣。</p>
<p>在语言学习过程中重点学习了基本的语法以及一些库函数的使用，对语言周边，比如 clippy 的使用还不够好，build.rs 也不太会写，多线程编程也不够熟练，希望接下来的学习当中能再注意一下重点学一下这些东西。</p>
<h2 id="阶段2：rcore-labs-学习"><a href="#阶段2：rcore-labs-学习" class="headerlink" title="阶段2：rcore labs 学习"></a>阶段2：rcore labs 学习</h2><p>rcore 今年秋冬的任务是除了进程间通信以及io设备没有做过多要求，其余的每章都有一个编程练习，在我看来，编程练习的难度是适中的，但是依然要求完整的理解整个代码框架，对学习操作系统内核很有帮助。</p>
<p>前三章作为引子一步一步从裸机程序到一个批处理裸机程序的内核，后面几章的顺序是：虚拟内存（地址空间），进程，文件（持久化存储），再到并发。课程顺序与传统授课顺序不太一样，在我个人看来是一种由易到难的渐进学习过程：因为第八章的线程和并发编程真的感觉好难 debug 😂，在这章上浪费的时间也比较多。</p>
<p>印象最深刻的是对文件系统的讲解，将文件系统作为一个库抽象出来，内核也只是管理文件系统提供的 Inode 接口，以此来区分在内存中的 inode 和磁盘中的 inode，这样一层从 BlockDevice 到 FileSystem 再到 rcore-kernel 最后被封装为一些系统调用，这样层层抽象的写法看起来真的挺赏心悦目的哈哈，而且对知识的学习与综合起来也方便许多。</p>
<p>另外还有虚拟内存，内存模型也是内容量非常庞大的一章，需要理解 memory-set, map-aera, pagetable-entry, 以及物理地址和虚拟地址，物理页号和虚拟页号之间的关系，</p>
<p>抽象之下是和底层处理器的操作，内联汇编，riscv 库，以及 C ffi，rust 都支持的很好。处理 trap 的汇编函数也很有意思，以及一些 riscv csr，学习的同时也去了解了一下 riscv。不过本次学习，对rv要求的不是很多，更多的是以问答作业的形式去提问，不知道后面的阶段会不会有深入的机会。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/27/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/blog/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/73/">73</a><a class="extend next" rel="next" href="/blog/page/29/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
