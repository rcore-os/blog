<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/page/28/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/page/28/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">660</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">575</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/30/opencamp-24sp-%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/30/opencamp-24sp-%E7%AC%AC%E4%B8%80%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">opencamp-24sp-第一二阶段总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-30 22:27:58" itemprop="dateCreated datePublished" datetime="2024-05-30T22:27:58+00:00">2024-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DAY0-DAY"><a href="#DAY0-DAY" class="headerlink" title="DAY0-DAY?"></a>DAY0-DAY?</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>本篇内容为<code>基础阶段 - Rust编程</code>的总结，分为<code>环境配置</code>及<code>语言学习</code>两个板块。</p>
<p>因为语言学习涉及内容较为零散，故将DAY0-DAY?汇聚成一篇。</p>
<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h2><h3 id="1-0-前言"><a href="#1-0-前言" class="headerlink" title="1.0 前言"></a>1.0 前言</h3><p>环境配置部分主要流程就是根据教程内容一步步安装，同时需要注意以下几点：</p>
<ul>
<li>学会分析报错内容</li>
<li>学会利用搜索引擎/gpt解决报错问题<h3 id="1-1-wsl-ubuntu22-04-vscode"><a href="#1-1-wsl-ubuntu22-04-vscode" class="headerlink" title="1.1 wsl+ubuntu22.04+vscode"></a>1.1 wsl+ubuntu22.04+vscode</h3>之前在完成pintos时配置过，故省略</li>
</ul>
<h3 id="1-2-配置rust环境"><a href="#1-2-配置rust环境" class="headerlink" title="1.2 配置rust环境"></a>1.2 配置rust环境</h3><p>按照LearningOS仓库中readme指定的<a href="https://rcore-os.cn/arceos-tutorial-book/ch01-02.html" target="_blank" rel="noopener">教程</a>一步步操作即可</p>
<p>注意没有<code>curl</code>需要先通过如下命令安装（其他同理）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure>

<h3 id="1-3-配置git-github-ssh并clone代码"><a href="#1-3-配置git-github-ssh并clone代码" class="headerlink" title="1.3 配置git+github ssh并clone代码"></a>1.3 配置git+github ssh并clone代码</h3><p>之前配置过，故省略</p>
<p>注意：配置ssh后，git push到github时若仍然提示输入密码，可修改.git/config文件中的url，从HTTPS <a href="https://github.com/achintski/opencamp-24sp-daily.git" target="_blank" rel="noopener">https://github.com/achintski/opencamp-24sp-daily.git</a> 更新为SSH <a href="mailto:git@github.com">git@github.com</a>:achintski/opencamp-24sp-daily.git</p>
<h2 id="2-rust语法学习及rustlings"><a href="#2-rust语法学习及rustlings" class="headerlink" title="2 rust语法学习及rustlings"></a>2 rust语法学习及rustlings</h2><h3 id="2-0-前言"><a href="#2-0-前言" class="headerlink" title="2.0 前言"></a>2.0 前言</h3><ul>
<li>初学一门新语言，通常可以采用孟岩老师提倡的“快速掌握一个语言最常用的50%”方法，快速入门</li>
<li>但注意到rust语言的特殊性以及接下来rCore的开发的复杂性，我们必须还要通过阅读系统而权威的大部头书籍来全面深入地学习</li>
<li>同时，一些特别细节的点在入门资料和书籍中未必涉及，需要我们查阅<a href="https://doc.rust-lang.org/stable/std/all.html" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<p>因此我穿插查阅/参考了如下资料：</p>
<ul>
<li>快速入门：<ul>
<li><a href="https://www.runoob.com/rust/rust-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li>
<li><a href="https://course.rs/about-book.html" target="_blank" rel="noopener">《Rust语言圣经》</a>(最推荐，整合了很多其他的经典资料)</li>
</ul>
</li>
<li>官方文档：<ul>
<li><a href="https://doc.rust-lang.org/stable/std/index.html" target="_blank" rel="noopener">The Rust Standard Library</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/" target="_blank" rel="noopener">《The Rust Reference》</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/index.html" target="_blank" rel="noopener">《Rust By Example》</a></li>
</ul>
</li>
<li>Slides:<ul>
<li><a href="https://lab.cs.tsinghua.edu.cn/rust/" target="_blank" rel="noopener">thu 程序设计训练（Rust）</a></li>
<li><a href="https://opencamp.cn/os2edu/camp/2024spring/stage/1" target="_blank" rel="noopener">2024春夏季训练营课程资料</a></li>
</ul>
</li>
<li>Books：<ul>
<li><a href="https://www.amazon.com/Rust-Programming-Language-2nd-dp-1718503105/dp/1718503105/ref=dp_ob_title_bk" target="_blank" rel="noopener">《The Rust Programming Language, 2nd Edition》</a></li>
</ul>
</li>
</ul>
<p>并通过穿插完成<code>rustlings</code>作业进行巩固练习</p>
<h3 id="2-1-rust语法"><a href="#2-1-rust语法" class="headerlink" title="2.1 rust语法"></a>2.1 rust语法</h3><h4 id="2-1-0-前言"><a href="#2-1-0-前言" class="headerlink" title="2.1.0 前言"></a>2.1.0 前言</h4><p>注意：第一次学一个概念时一定要打好基础，不要为了追求进度而忽略质量</p>
<h4 id="2-1-1-常见内容"><a href="#2-1-1-常见内容" class="headerlink" title="2.1.1 常见内容"></a>2.1.1 常见内容</h4><ul>
<li><p>HelloWorld</p>
</li>
<li><p>类型<br>  *原生类型</p>
<pre><code>* 布尔 bool：两个值 true/false。
* 字符 char：用单引号，例如 &apos;R&apos;、&apos;计&apos;，是 Unicode 的。
* 数值：分为整数和浮点数，有不同的大小和符号属性。
    * i8、i16、i32、i64、i128、isize
    * u8、u16、u32、u64、u128、usize
    * f32、f64
    * 其中 isize 和 usize 是指针大小的整数，因此它们的大小与机器架构相关。
    * 字面值 (literals) 写为 10i8、10u16、10.0f32、10usize 等。
    * 字面值如果不指定类型，则默认整数为 i32，浮点数为 f64。
* 数组 (arrays)、切片 (slices)、str 字符串 (strings)、元组 (tuples)
* 指针 &amp; 引用
* 函数
* 闭包</code></pre><ul>
<li>组合类型<ul>
<li>结构体（逻辑与）</li>
<li>标签联合（逻辑或）</li>
</ul>
</li>
</ul>
</li>
<li><p>条件</p>
</li>
<li><p>循环</p>
</li>
<li><p>结构化数据</p>
</li>
<li><p>IO</p>
<h4 id="2-1-2-特殊内容"><a href="#2-1-2-特殊内容" class="headerlink" title="2.1.2 特殊内容"></a>2.1.2 特殊内容</h4><p>Q：任何行为背后都有动机，Rust特性这样设计的动机是什么呢？</p>
</li>
<li><p>变量绑定–<code>let</code></p>
</li>
<li><p>不可变变量 vs 常量</p>
</li>
<li><p>语句 vs 表达式</p>
</li>
<li><p>所有权 &amp; 生命周期</p>
<ul>
<li>高级语言 <code>Python/Java</code> 等往往会弱化堆栈的概念，但是要用好 <code>C/C++/Rust</code>，就必须对堆栈有深入的了解，原因是两者的内存管理方式不同：前者有 <code>GC</code> 垃圾回收机制，因此无需你去关心内存的细节。</li>
<li>在所有权模型下：堆内存的生命周期，和创建它的栈内存的生命周期保持一致</li>
<li><code>copy</code> / <code>move</code></li>
<li><code>borrow</code>（借用）<ul>
<li>借用<code>&amp;</code>与可变借用<code>&amp;mut</code></li>
<li>借用规则</li>
</ul>
</li>
<li>函数的参数和返回值与变量绑定的规则相同</li>
</ul>
</li>
</ul>
<h3 id="2-2-rustlings"><a href="#2-2-rustlings" class="headerlink" title="2.2 rustlings"></a>2.2 rustlings</h3><p>大致步骤：终端输入命令<code>rustlings watch</code>、修改代码、删掉注释并自动跳转下一题<br>注意：后两个资料中概念介绍顺序和习题涉及概念顺序一致<br>技巧：学会分析编译器提示，有的题目是语法错误，有的是考虑不周导致测试过不去</p>
<ul>
<li><p>vec2</p>
</li>
<li><p>enums3</p>
</li>
<li><p>strings3&amp;strings4</p>
<ul>
<li><code>into()</code></li>
</ul>
</li>
<li><p>hashmaps2</p>
<ul>
<li><code>HashMap</code>的<code>get()</code>方法只能返回值的引用</li>
<li>解引用操作<code>*</code>也需要转移所有权</li>
</ul>
</li>
<li><p>quiz2</p>
<ul>
<li>match中模式绑定的值，如：<code>Command::Append(n) =&gt; {}</code> 中的n是&amp;usize类型，可以使用<code>for i in 0..*n</code>完成遍历</li>
<li>对于<code>不可变引用的string</code>，要想修改需要先将其<code>clone</code>给一个可变变量</li>
</ul>
</li>
<li><p>options1</p>
<ul>
<li>可用<code>match</code>，也可以用<code>if</code></li>
</ul>
</li>
<li><p>options2</p>
<ul>
<li>注意<code>Options枚举</code>的本质目的：解决<code>Rust</code>中变量是否有值的问题，因此第二个任务中需要两层嵌套的<code>Some</code></li>
<li><code>if let</code> / <code>while let</code>本质上是<code>match</code></li>
<li><code>match</code>中匹配后的绑定</li>
</ul>
</li>
<li><p>options3</p>
<ul>
<li>在 <code>Some(p) =&gt; println!(&quot;Co-ordinates are {},{} &quot;, p.x, p.y)</code> 处，value partially moved here；而在最后返回值<code>y</code>处，value used here after partial move</li>
<li>因此需要：borrow this binding in the pattern to avoid moving the value</li>
<li>区分<code>ref</code>和<code>&amp;</code></li>
</ul>
</li>
<li><p>errors2</p>
<ul>
<li>对于返回结果是<code>Result</code>的函数，一定要显式进行处理</li>
<li><code>?</code>操作符（本质是宏，同时可以链式调用）<ul>
<li>作用：提前传播错误</li>
<li>场合：返回值是 Result 或者 Option 函数中</li>
<li>对于 Result 类型，<ul>
<li>如果是 Err 则提前返回，当前函数立即返回该错误。</li>
<li>否则，从 Ok 中取出返回值作为 ? 操作符的结果。</li>
</ul>
</li>
<li>对于 Option 类型，<ul>
<li>如果是 None 则提前返回，当前函数立即返回 None。</li>
<li>否则，从 Some 中取出返回值作为 ? 操作符的结果。</li>
</ul>
</li>
</ul>
</li>
<li>本题既可以使用<code>?</code>操作符，也可以使用<code>match</code></li>
</ul>
</li>
<li><p>errors3</p>
<ul>
<li><code>?</code>操作符只能在返回值为<code>Result</code> / <code>Option</code> 的函数中使用</li>
<li>需要修改三处：<ul>
<li><code>use std::error::Error;</code></li>
<li>给<code>main</code>函数增加返回值 <code>-&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;</code></li>
<li>末尾返回 <code>Ok(())</code></li>
</ul>
</li>
<li>也可以用<code>match</code> / <code>if else</code></li>
</ul>
</li>
<li><p>errors4</p>
<ul>
<li>法一：利用<code>match guard</code></li>
<li>法二：<code>if</code> &amp; <code>else</code></li>
</ul>
</li>
<li><p>errors6</p>
<ul>
<li>impl<ul>
<li>rust中<strong>对象定义和方法定义是分开的</strong></li>
<li>一个/多个<code>impl</code>模块</li>
<li><code>self</code>、<code>&amp;self</code>和<code>&amp;mut self</code>及所有权<ul>
<li><code>self</code>表示<code>实现方法的结构体类型的实例</code>的所有权转移到该方法中，这种形式用的较少</li>
<li><code>&amp;self</code>表示该方法对<code>实现方法的结构体类型的实例</code>的不可变借用</li>
<li><code>&amp;mut self</code>表示可变借用</li>
</ul>
</li>
</ul>
</li>
<li>闭包<ul>
<li>可以看做匿名函数</li>
<li>||中间放参数</li>
</ul>
</li>
<li>map_err()<ul>
<li>用来处理Err类型的变量</li>
<li>参数是函数/闭包</li>
</ul>
</li>
<li><code>PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)</code>仅可以用来处理x&lt;=0的情况，而x非数字的情况无法处理<ul>
<li><code>?</code>操作符：<code>Err</code> / <code>None</code> 类型直接立即结束，提前返回；否则从<code>Ok</code> / <code>Some</code> 中取出返回值作为<code>?</code>操作符的结果</li>
<li>或者用match平替</li>
</ul>
</li>
</ul>
</li>
<li><p>generics1</p>
<ul>
<li><code>&amp;str</code> vs <code>String</code></li>
<li>也可以用<code>_</code>来让编译器自动推断</li>
</ul>
</li>
<li><p>generics2</p>
<ul>
<li>泛型可以类比多态</li>
<li>结构体中的泛型 &amp; 方法中使用泛型</li>
<li>例如（from Rust Course）：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用泛型参数前，依然需要提前声明：<code>impl&lt;T&gt;</code></li>
<li>上述代码中，<code>Point&lt;T&gt;</code>不再是泛型声明，而是一个完整的结构体类型，因为我们定义的结构体就是 <code>Point&lt;T&gt;</code>而不再是<code>Point</code></li>
<li>除了结构体中的泛型参数，我们还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样</li>
<li>对于<code>Point&lt;T&gt;</code>类型，你不仅能定义基于<code>T</code>的方法，还能针对特定的具体类型，进行方法定义</li>
</ul>
</li>
</ul>
</li>
<li><p><em>trait(特征)</em></p>
<ul>
<li><code>impl Trait for Type</code>：为Type类型实现Trait特征</li>
<li>特征定义与实现的位置(孤儿规则)</li>
<li>方法的默认实现 vs 重载</li>
<li><code>impl Trait</code><ul>
<li>作为函数参数<ul>
<li><code>impl Trait</code>此时为语法糖,可用<code>特征约束</code>写出完整版</li>
<li><code>多重约束</code>：<code>impl T1 + T2</code></li>
</ul>
</li>
<li>作为函数返回值（只能返回某一种类型）</li>
</ul>
</li>
</ul>
</li>
<li><p>quiz3</p>
<ul>
<li>restricting type parameter <code>T</code>：<code>impl&lt;T: std::fmt::Display&gt; ReportCard&lt;T&gt; {...}</code>（根据编译器help提示）</li>
</ul>
</li>
<li><p>lifetims1</p>
<ul>
<li>标记的生命周期只是为了取悦编译器，告诉编译器多个引用之间的关系，当不满足此约束条件时，就拒绝编译通过；并不会改变任何引用的实际作用域</li>
<li>和泛型一样，使用生命周期参数，需要先声明 <code>&lt;&#39;a&gt;</code></li>
<li>本题中：把具体的引用传给<code>longest</code>时，那生命周期<code>&#39;a</code>的大小就是<code>x</code>和<code>y</code>的作用域的重合部分，换句话说，<code>&#39;a</code>的大小将等于<code>x</code>和<code>y</code>中较小的那个</li>
<li>编译器提示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">help</span>: consider introducing a named lifetime parameter</span><br><span class="line">    |</span><br><span class="line">13  | fn longest&lt;<span class="string">'a&gt;(x: &amp;'</span>a str, y: &amp;<span class="string">'a str) -&gt; &amp;'</span>a str &#123;</span><br><span class="line">    |           ++++     ++          ++          ++</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>lifetimes2</p>
<ul>
<li>在<code>longest</code>函数中，<code>string2</code>的生命周期也是<code>&#39;a</code>，由此说明<code>string2</code>也必须活到 println! 处，可是<code>string2</code>在代码中实际上只能活到内部语句块的花括号处<code>}</code>，小于它应该具备的生命周期<code>&#39;a</code>，因此编译出错（编译器没法知道返回值没有用到<code>string2</code>）</li>
<li>hint：<br>Remember that the generic lifetime ‘a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y.<br>You can take at least two paths to achieve the desired result while keeping the inner block:<ol>
<li>Move the string2 declaration to make it live as long as string1 (how is result declared?)</li>
<li>Move println! into the inner block</li>
</ol>
</li>
</ul>
</li>
<li><p>lifetimes3</p>
<ul>
<li>结构体中生命周期标注：<ul>
<li>对结构体本身类似泛型：<code>&lt;&#39;a&gt;</code></li>
<li>对结构体成员：<code>&amp;&#39;a</code></li>
</ul>
</li>
<li>结构体成员引用的生命周期要大于等于结构体</li>
</ul>
</li>
<li><p>lifetime others</p>
<ul>
<li>输入生命周期 &amp; 输出生命周期</li>
<li>生命周期的消除</li>
<li>方法中的生命周期（类似泛型参数语法）<ul>
<li><code>impl</code>中必须使用结构体的完整名称，包括<code>&lt;&#39;a&gt;</code>，因为生命周期标注也是结构体类型的一部分！</li>
<li>方法签名中，往往不需要标注生命周期，得益于生命周期消除的第一和第三规则</li>
</ul>
</li>
<li>静态生命周期</li>
</ul>
</li>
<li><p>tests4</p>
<ul>
<li><code>#[should_panic]</code>：The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t panic.<br>&lt;!– * tests5（自动进行时这个被跳过了，直接到了迭代器）</li>
<li>unsafe函数：<ul>
<li>使用<code>unsafe fn</code>来进行定义</li>
<li>这种定义方式是为了告诉调用者：当调用此函数时，你需要注意它的相关需求，因为Rust无法担保调用者在使用该函数时能满足它所需的一切需求</li>
<li>因此在使用<code>unsafe</code>声明的函数时，一定要看看相关的文档，确定自己没有遗漏什么 –&gt;</li>
</ul>
</li>
</ul>
</li>
<li><p>iterators1</p>
<ul>
<li>Rust的迭代器是指实现了<code>Iterator trait</code>的类型</li>
<li>最主要的一个方法：<code>next()</code><ul>
<li>对迭代器的遍历是消耗性的</li>
<li>返回的是<code>Option&lt;Item&gt;</code>类型，当有值时返回<code>Some(Item)</code>，无值时返回<code>None</code></li>
<li>手动迭代必须将迭代器声明为<code>mut</code>可变，因为调用<code>next</code>会改变迭代器其中的状态数据（当前遍历的位置等），而<code>for</code>循环去迭代则无需标注<code>mut</code>，因为它会帮我们自动完成</li>
</ul>
</li>
</ul>
</li>
<li><p>iterators2</p>
<ul>
<li><p><code>iter()</code></p>
<ul>
<li><code>Iterator adapters</code>（<em>迭代器适配器</em>）<ul>
<li>Adapters operate on an iterator and return a new iterator</li>
<li>是<em>惰性接口</em>：iterators are lazy and do nothing unless consumed</li>
<li>常见的有：<code>map()</code>、<code>filter()</code>、<code>take()</code>、<code>zip()</code>、<code>rev()</code></li>
<li>需要一个<em>消费器</em>来收尾，例如：<code>collect()</code>、<code>sum()</code>、<code>any()</code></li>
</ul>
</li>
<li>注：如果集合里的类型是非<code>Copy</code>类型，消费者在取得每个值后，在迭代器被清除后，集合里的元素也会被清除。集合会只剩“空壳”，当然剩下的“空壳”也会被清除</li>
<li>迭代器是<em>可组合的</em></li>
</ul>
</li>
<li><p>一个例子：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">v1.iter().map(|x| x + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  map 函数的闭包并没有获得迭代器的所有权。具体解释如下：</p>
<ul>
<li><p><code>v1.iter()</code>创建了一个针对<code>v1</code>中元素的迭代器。这个迭代器是对<code>v1</code>的不可变引用，也就是说，它拥有对<code>v1</code>中元素的借用权，但并不拥有所有权。</p>
</li>
<li><p><code>map(|x| x + 1)</code>是对上述迭代器应用的一个闭包。闭包内部的<code>|x| x + 1</code>表示对迭代器产生的每个元素<code>x</code>加上 1。在这个过程中，闭包接收的是<code>x</code>的不可变引用，同样没有获取<code>x</code>或迭代器的所有权。</p>
<p>综上所述，闭包并未获得迭代器的所有权。它只是在<code>map</code>函数执行期间，对迭代器提供的每个元素借用并进行计算。一旦<code>map</code>函数结束，闭包对元素的借用也随之结束，不会影响到<code>v1</code>或其迭代器的所有权状态。<br>…<br>如果您想让闭包返回的新值形成一个新的集合（如 Vec<i32>），您需要调用 collect() 方法来完成这一过程：</i32></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incremented_values: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = v1.iter().map(|x| x + <span class="number">1</span>).collect();</span><br></pre></td></tr></table></figure>
<p>在这里，<code>collect()</code>方法会消费<code>map</code>返回的迭代器，并将其内容收集到一个新的<code>Vec&lt;i32&gt;</code>中。然而，即使如此，闭包本身仍然没有获得迭代器的所有权，而是<code>collect()</code>函数在处理过程中获取了所有权并完成了数据的转移。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>iterators3</p>
<ul>
<li>从容器创造出迭代器一般有三种方法：<ul>
<li><code>iter()</code> takes elements by reference.</li>
<li><code>iter_mut()</code> takes mutable reference to elements.</li>
<li><code>into_iter()</code> takes ownership of the values and consumes the actual type once iterated completely. The original collection can no longer be accessed.</li>
</ul>
</li>
<li><code>collect()</code>会根据函数返回值自动调整格式</li>
</ul>
</li>
<li><p>iterators4</p>
<ul>
<li>这不让用那不让用，那自然是得用自带的工具咯</li>
<li>(1..=num).product()</li>
</ul>
</li>
<li><p>iterators5</p>
<ul>
<li>一点思考：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_for</span></span>(map: &amp;HashMap&lt;<span class="built_in">String</span>, Progress&gt;, value: Progress) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> map.values() &#123;</span><br><span class="line">        <span class="comment">// 此处为什么不是*val == value呢？</span></span><br><span class="line">        <span class="comment">// 下面这中方式中，实际上是在比较两者对应的实体是否相同</span></span><br><span class="line">        <span class="keyword">if</span> val == &amp;value &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><em>扁平化（Flatten）</em>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_collection_iterator</span></span>(collection: &amp;[HashMap&lt;<span class="built_in">String</span>, Progress&gt;], value: Progress) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    collection.iter() <span class="comment">// Iterate over the slice of hashmaps</span></span><br><span class="line">        .flat_map(|map| map.values()) <span class="comment">// Flatten the values of each hashmap into a single iterator</span></span><br><span class="line">        .filter(|val| **val == value) <span class="comment">// Filter values equal to the target value</span></span><br><span class="line">        .count() <span class="comment">// Count the filtered values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在上述实现中：<ul>
<li>首先使用 <code>collection.iter()</code> 创建一个迭代器，它遍历 <code>collection</code> 中的每一个 <code>HashMap</code> 引用。</li>
<li>然后对每个 <code>HashMap</code> 应用 <code>flat_map(|map| map.values())</code>，将每个 <code>HashMap</code> 的值迭代器扁平化为单个包含所有 <code>HashMap</code> 值的迭代器。<br>接着使用 <code>filter(|val| *val == value)</code>，筛选出与目标 <code>value</code> 相同的 <code>Progress</code> 枚举值。</li>
<li>最后，通过 <code>count()</code> 方法计算筛选后的元素数量，即符合条件的 <code>Progress</code> 枚举值的总数，返回这个计数值作为函数结果。</li>
</ul>
</li>
</ul>
</li>
<li><p>smart_pointers（<em>智能指针</em>）</p>
<ul>
<li>前言<ul>
<li>相比其它语言，Rust 堆上对象还有一个特殊之处—它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可）</li>
<li>例如以下代码：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> b = foo(<span class="string">"world"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"Hello, "</span>.to_string() + x;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在 <code>foo</code> 函数中，<code>a</code> 是 <code>String</code> 类型，它其实是一个智能指针结构体，该智能指针存储在函数栈中，指向堆上的字符串数据。当被从 <code>foo</code> 函数转移给 <code>main</code> 中的 <code>b</code> 变量时，栈上的智能指针被复制一份赋予给 <code>b</code>，而底层数据无需发生改变，这样就完成了所有权从 <code>foo</code> 函数内部到 <code>b</code> 的转移。</li>
</ul>
</li>
<li>在 <code>Rust</code> 中，凡是需要做资源回收的数据结构，且实现了 <code>Deref</code>/<code>DerefMut</code>/<code>Drop</code>，都是<code>智能指针</code></li>
</ul>
</li>
<li><p>arc1</p>
<ul>
<li>使用 <code>let shared_numbers = Arc::new(numbers);</code> ：将 <code>numbers</code> 向量封装在一个 <code>Arc&lt;Vec&lt;u32&gt;&gt;</code> 中。</li>
<li><code>Arc</code> 允许多个线程同时拥有对同一数据的访问权，且其内部的引用计数机制确保数据在所有持有者都不再需要时会被正确释放。这样，<code>numbers</code> 可以在多个线程间共享而无需复制整个向量，既节省了内存，又保证了线程安全性</li>
<li>使用 <code>let child_numbers = Arc::clone(&amp;shared_numbers);</code> ：创建 <code>shared_numbers</code> 的克隆（实际上是增加其引用计数）。每个线程都获得一个指向相同底层数据的独立 <code>Arc</code> </li>
<li><code>thread::spawn</code>创建一个线程</li>
<li><code>move</code>关键字：指示闭包在捕获外部变量时采取“所有权转移”策略，而非默认的借用策略</li>
<li><code>join()</code> 方法会阻塞当前线程，直到指定的线程完成其任务。<code>unwrap()</code> 处理 <code>join()</code> 返回的 <code>Result</code>，在没有错误时提取出结果（这里没有错误处理，因为假设所有线程都能成功完成）。这样，<code>main()</code> 函数会等待所有子线程计算完毕后再继续执行</li>
</ul>
</li>
<li><p>cow1</p>
</li>
<li><p>threads1</p>
<ul>
<li>如果你想创建新线程，可以使用<code>thread::spawn</code>函数并传递一个闭包，在闭包中包含要在新线程 执行的代码。</li>
<li>默认情况下，当主线程执行结束，所有子线程也会立即结束，且不管子线程中的代码是否执行完毕。极端情况下，如果主线程在创建子线程后就立即结束，子线程可能根本没机会开始执行。</li>
<li>为避免上述情况的发生，我们可以通过阻塞主线程来等待子线程执行完毕。这里所说的阻塞线程，是指阻止该线程工作或退出。</li>
<li><code>Rust</code>标准库提供的<code>thread::JoinHandle</code>结构体的<code>join</code>方法，可用于把子线程加入主线程等待队列，这样主线程会等待子线程执行完毕后退出。</li>
<li><code>unwrap()</code></li>
</ul>
</li>
<li><p>threads2</p>
<ul>
<li>Mutex确保在某一时刻只有一个thread可以更新jobs_completed</li>
<li>thread闭包中，使用lock()上锁</li>
<li>注意：  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"jobs completed &#123;&#125;"</span>, status.lock().unwrap().jobs_completed);</span><br></pre></td></tr></table></figure>
  如果放到循环内，就是输出10次<code>jobs completed x</code>，<code>x</code>的值有时候全是10，有时候有一部分是10；放到循环外就是一次<code>jobs completed 10</code></li>
</ul>
</li>
<li><p>threads3</p>
<ul>
<li>报错内容：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   |</span><br><span class="line">29 | fn send_tx(q: Queue, tx: mpsc::Sender&lt;u32&gt;) -&gt; () &#123;</span><br><span class="line">   |                      -- move occurs because `tx` has <span class="built_in">type</span> `Sender&lt;u32&gt;`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">...</span><br><span class="line">34 |     thread::spawn(move || &#123;</span><br><span class="line">   |                   ------- value moved into closure here</span><br><span class="line">...</span><br><span class="line">37 |             tx.send(*val).unwrap();</span><br><span class="line">   |             -- variable moved due to use <span class="keyword">in</span> closure</span><br><span class="line">...</span><br><span class="line">42 |     thread::spawn(move || &#123;</span><br><span class="line">   |                   ^^^^^^^ value used here after move</span><br><span class="line">...</span><br><span class="line">45 |             tx.send(*val).unwrap();</span><br><span class="line">   |             -- use occurs due to use <span class="keyword">in</span> closure</span><br><span class="line">error: aborting due to 1 previous error</span><br></pre></td></tr></table></figure></li>
<li>分析：<code>tx</code>变量<code>move</code>到第一个闭包后，已经无法在该闭包外获取了，而在第二次进程创建仍然尝试<code>move</code>。通过为每个变量创建<code>tx</code>的<code>clone</code>，我们确保了每个闭包都拥有其独立的<code>sender</code>，从而避免了<code>use after move</code>错误</li>
</ul>
</li>
<li><p>macros4</p>
<ul>
<li>每个macro规则后面加;</li>
</ul>
</li>
<li><p>clippy1</p>
<ul>
<li>根据编译器提示修改</li>
<li>const PI: f32 = std::f32::consts::PI;</li>
</ul>
</li>
<li><p>clippy3</p>
<ul>
<li>已经通过 <code>is_none()</code> 检查确保了 <code>my_option</code> 是 <code>None</code>，因此接下来不应该再尝试调用 <code>unwrap()</code></li>
<li><code>Vec::resize</code> 方法用于改变已有向量的长度，如果新的长度大于当前长度，则填充指定的默认值。<ul>
<li>但是，你的用法存在一些问题。首先，你试图创建一个空向量（通过将大小更改为0），但直接使用 <code>resize(0, 5)</code> 并不是正确做法，因为这会让人们以为你要填充默认值5到一个空向量中，而实际上你是从一个非空向量开始的。</li>
<li>如果你想从 <code>vec![1, 2, 3, 4, 5]</code> 起始，然后得到一个空向量，你应该直接使用 <code>clear</code> 方法，而不是 <code>resize</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>as_ref_mut</p>
<ul>
<li>根据注释完成</li>
</ul>
</li>
<li><p>using_as</p>
<ul>
<li>报错内容：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   --&gt; exercises/conversions/using_as.rs:17:11</span><br><span class="line">   |</span><br><span class="line">17 |     total / values.len()</span><br><span class="line">   |           ^ no implementation <span class="keyword">for</span> `f64 / usize`</span><br><span class="line">   |</span><br><span class="line">   = <span class="built_in">help</span>: the trait `Div&lt;usize&gt;` is not implemented <span class="keyword">for</span> `f64`</span><br><span class="line">   = <span class="built_in">help</span>: the following other types implement trait `Div&lt;Rhs&gt;`:</span><br><span class="line">               &lt;&amp;<span class="string">'a f64 as Div&lt;f64&gt;&gt;</span></span><br><span class="line"><span class="string">               &lt;&amp;f64 as Div&lt;&amp;f64&gt;&gt;</span></span><br><span class="line"><span class="string">               &lt;f64 as Div&lt;&amp;f64&gt;&gt;</span></span><br><span class="line"><span class="string">               &lt;f64 as Div&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>分析：错误提示指出 <code>f64</code> 类型没有实现 <code>Div&lt;usize&gt;</code> trait，因此无法执行除法操作。为了解决这个问题，我们可以将 <code>values.len()</code> 转换为 <code>f64</code> 类型，以便进行除法运算。<br>在修改后的代码中，我们使用 <code>values.len() as f64</code> 将 <code>values.len()</code> 的结果转换为 <code>f64</code> 类型，以便与 <code>total</code> 执行除法操作。</li>
</ul>
</li>
<li><p>from_into</p>
<ul>
<li>为<code>Person</code>结构实现<code>From&lt;&amp;str&gt;</code> trait</li>
</ul>
</li>
<li><p>from_str</p>
<ul>
<li>需要实现<code>FromStr</code> trait 来将字符串解析为 <code>Person</code> 结构体，并返回相应的错误类型 <code>ParsePersonError</code></li>
</ul>
</li>
<li><p>tests5</p>
<ul>
<li><p>这段代码中，<code>modify_by_address</code> 函数使用了 <code>unsafe</code> 关键字来标记它的不安全性。根据注释，我们需要在函数的文档注释中提供有关函数行为和约定的描述。</p>
</li>
<li><p>以下是修改后的代码：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// # Safety</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The `address` must be a valid memory address that points to a mutable `u32` value.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// It is the caller's responsibility to ensure that the `address` is a valid memory address</span></span><br><span class="line"><span class="comment">/// and that it points to a mutable `u32` value. Failing to meet these requirements may lead</span></span><br><span class="line"><span class="comment">/// to undefined behavior, such as memory corruption or crashes.</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">modify_by_address</span></span>(address: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// SAFETY: The caller must ensure that `address` is a valid memory address</span></span><br><span class="line">    <span class="comment">// and that it points to a mutable `u32` value.</span></span><br><span class="line">    <span class="keyword">let</span> value_ptr = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="keyword">let</span> value = &amp;<span class="keyword">mut</span> *value_ptr;</span><br><span class="line">    *value = <span class="number">0xAABBCCDD</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在函数的(文档)注释中，我们明确了对 <code>address</code> 参数的要求，即它必须是一个有效的内存地址，并指向一个可变的 <code>u32</code> 值。我们还提醒调用者必须满足这些要求，并在不满足要求时可能会导致的未定义行为。</p>
</li>
<li><p>在函数内部，我们使用了 <code>address</code> 参数将其转换为一个可变的 <code>u32</code> 指针 <code>value_ptr</code>，然后通过解引用该指针获取可变引用 <code>value</code>。最后，我们将 <code>value</code> 设置为 <code>0xAABBCCDD</code>。</p>
</li>
</ul>
</li>
<li><p>test6</p>
<ul>
<li>这段代码中，我们需要实现一个 <code>raw_pointer_to_box</code> 函数，它将一个原始指针转换为一个拥有所有权的 <code>Box&lt;Foo&gt;</code>。我们需要根据给定的指针重新构建一个 <code>Box&lt;Foo&gt;</code> 对象。</li>
</ul>
</li>
<li><p>test7&amp;test8</p>
<ul>
<li>在 <code>tests7</code> 部分，我们设置了一个名为 <code>TEST_FOO</code> 的环境变量，并使用 <code>rustc-env</code> 指令将其传递给Cargo。</li>
<li>在 <code>tests8</code> 部分，我们使用 <code>rustc-cfg</code> 指令启用了名为 <code>pass</code> 的特性。</li>
</ul>
</li>
<li><p>test9</p>
</li>
<li><p>algorithm1</p>
<ul>
<li>Note that we use the <code>Ord</code> and <code>Clone</code> traits for the generic type <code>T</code> to enable value comparisons and cloning, respectively.</li>
</ul>
</li>
<li><p>algorithm2</p>
<ol>
<li><p>定义两个指针 <code>current</code> 和 <code>prev</code>，分别指向当前节点和上一个节点。初始时 <code>current</code> 指向链表的头节点，<code>prev</code> 为 <code>None</code>。</p>
</li>
<li><p>进入循环，在每次迭代中:</p>
<ul>
<li>获取当前节点的可变引用 <code>node</code>。</li>
<li>将 <code>current</code> 移动到下一个节点。</li>
<li>将当前节点的 <code>next</code> 指针指向上一个节点 <code>prev</code>。</li>
<li>如果 <code>prev</code> 不为 <code>None</code>，则更新上一个节点的 <code>prev</code> 指针指向当前节点。</li>
<li>如果 <code>prev</code> 为 <code>None</code>，说明当前节点是新的尾节点，更新 <code>self.end</code> 为当前节点。</li>
<li>将 <code>prev</code> 更新为当前节点。</li>
</ul>
</li>
<li><p>循环结束后，将 <code>self.start</code> 更新为最后一个节点，即反转后的新头节点。</p>
</li>
</ol>
</li>
<li><p>algorithm9</p>
<ul>
<li>注意：在<code>next</code>中，对<code>vec</code>的处理除了要把最后一个元素拷贝到下标为<code>1</code>处，还需要把尾部元素用<code>pop()</code>删除。可以合起来写（后面加一个<code>?</code>），也可以分开。  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">self</span>.items[<span class="number">1</span>].clone();</span><br><span class="line">    <span class="keyword">self</span>.items[<span class="number">1</span>] = <span class="keyword">self</span>.items.pop().clone()?;</span><br><span class="line">    <span class="keyword">self</span>.count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span>.heapify_down(<span class="number">1</span>);</span><br><span class="line">    <span class="literal">Some</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>本地通过但autograde没通过：可以在actions-GitHub Classroon Workflow-最新的记录-Autograding complete的第二个日志中查看</p>
</li>
</ul>
<h1 id="rCore-Tutorial-Guide-2024S通关札记"><a href="#rCore-Tutorial-Guide-2024S通关札记" class="headerlink" title="rCore-Tutorial-Guide-2024S通关札记"></a>rCore-Tutorial-Guide-2024S通关札记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在学习操作系统的文件系统部分时，被国内的部分课本深深“恶心”到了，有幸阅读OSTEP以及一些其他的国外著作（如Unix Internals）并走了许多弯路后我发现一个问题：对于初学者来说，操作系统这种非常“工程类”的学科，（入门/初级阶段）应该采取的正确学习思路是用“增量法”，具体来说：就是从一个具有最基础功能的操作系统出发，不断分析现有问题、解决问题从而实现功能上的完善（即增量），这也是符合操作系统发展的历史脉络的。好巧不巧的是，rcore采取的正是这种教学策略：<br><img src="/blog/.io//image-5.png" alt="Alt text"><br>要是能早点遇到该多好☹…</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>rcore的文档非常之详细（对比xv6/pintos等），初学者很容易陷入到细节中去，因此在阅读文档/代码前建议先看一下每章的引言（相当于论文的abstract），明确每章要干什么以及代码的大致框架</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我自己采用的是（之前别的实验就配置好的）wsl2+ubuntu18.04+vscode+git，具体操作步骤文档内容写的很详细，网上也有很多相关教程</p>
<h3 id="18-04安装qemu7-0-0"><a href="#18-04安装qemu7-0-0" class="headerlink" title="18.04安装qemu7.0.0"></a>18.04安装qemu7.0.0</h3><p>根据文档一步步操作至：出现报错<br><img src="/blog/.io//image.png" alt="Alt text"><br><img src="/blog/.io//image-1.png" alt="Alt text"></p>
<p>sudo apt-get install ninja-build<br>随后继续按照文档操作<br>最终：<br><img src="/blog/.io//image-2.png" alt="Alt text"><br>在bashrc文件中配置路径：<br><img src="/blog/.io//image-3.png" alt="Alt text"><br><img src="/blog/.io//image-4.png" alt="Alt text"></p>
<h3 id="其余部分根据指导书操作即可"><a href="#其余部分根据指导书操作即可" class="headerlink" title="其余部分根据指导书操作即可"></a>其余部分根据指导书操作即可</h3><h2 id="rust语言"><a href="#rust语言" class="headerlink" title="rust语言"></a>rust语言</h2><p>不建议花费太多时间，个人感觉比较靠谱的策略就是“迅速掌握一门语言的50%”，剩下的内容现学现用（按需调用）<br>重点：所有权和生命周期、类型系统<br>推荐资料：rust语言圣经、清华rust课程ppt</p>
<h2 id="ci-user本地测试"><a href="#ci-user本地测试" class="headerlink" title="ci-user本地测试"></a>ci-user本地测试</h2><p>在确定好思路后一定要看一下测试代码再动手coding，有些测试并没有覆盖所有情况，因此一些特别繁琐的情况可以忽略掉（不是本次实验的重点）</p>
<h2 id="技能点"><a href="#技能点" class="headerlink" title="技能点"></a>技能点</h2><p>锻炼自己快速上手工程类代码的能力</p>
<h2 id="ch3-lab1"><a href="#ch3-lab1" class="headerlink" title="ch3-lab1"></a>ch3-lab1</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskInfo</span></span> &#123;</span><br><span class="line">    status: TaskStatus,</span><br><span class="line">    syscall_times: [<span class="built_in">u32</span>; MAX_SYSCALL_NUM],</span><br><span class="line">    time: <span class="built_in">usize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务：新增系统调用sys_task_info</p>
<p>分析：sys_task_info本质上是对参数中用户程序传入的指针指向的结构体赋值，因此本次实验的核心围绕这些值展开，需要思考的点就是：这些值要存放在什么地方？什么时候初始化？什么时候更新？为了获取这些值需要设计几个函数，这些函数哪些只能内部使用哪些是开放接口？</p>
<p>具体思维过程：</p>
<ol>
<li>只存储最原始的数据，也就是在<code>tcb</code>中存储<code>syscall_times</code>以及进程首次被调度的时间<code>start_time</code>，在需要时再将他们拼装成<code>TaskInfo</code></li>
<li>变量初始化时机：<code>tcb</code>初始化</li>
<li>变量更新时机：所有系统调用中，更新对应的<code>syscall_times[syscall_id]</code>用户程序（及<code>first task</code>）对应的tcb第一次被调用时，更新<code>start_time</code>（这就需要思考：负责进行任务调度的功能在哪里实现？怎么判断是否为第一次？）</li>
<li>函数：<ul>
<li>将重复多次的操作封装成函数</li>
<li>将私有变量/函数的操作封装成pub接口暴露给其他模块</li>
</ul>
</li>
<li>其他细节：空指针</li>
</ol>
<h2 id="ch4-lab2"><a href="#ch4-lab2" class="headerlink" title="ch4-lab2"></a>ch4-lab2</h2><p>任务：重写<code>sys_get_time</code>和<code>sys_task_info</code>，增加<code>sys_mma</code>p和<code>sys_munmap</code></p>
<p>分析：因为引入了虚拟内存机制，因此<code>sys_get_time</code>和<code>sys_task_info</code>系统调用传入的参数中，指针指向的地址是属于用户地址空间的，无法直接在内核地址空间中使用，需要进行转换。<code>sys_mmap</code>和<code>sys_munmap</code>手册里描述的有点模糊，实际上通过阅读样例可知，该系统调用的功能就是以页为单位进行分配/回收，而且不会出现复杂的情况（比如跨越<code>area</code>，部分可回收部分不可…），关键点就是边界条件、<code>port</code>以及每次分配/回收都要同时操作<code>pagetable</code>和<code>areas</code>，需要注意的点就是接口的设计问题（没有暴露出来的内容，需要用接口传参数进去在本地处理）</p>
<p>具体思维过程：</p>
<ol>
<li>sys_get_time和sys_task_info可以参考：<br><img src="/blog/.io//image-6.png" alt="Alt text"><br>我们平常编写用户程序的代码时，对指向某一类型变量的指针（虚拟地址）使用解引用，可以获得对应类型的变量，这是因为mmu自动帮我们完成了地址转换功能</li>
</ol>
<h2 id="ch5-lab3"><a href="#ch5-lab3" class="headerlink" title="ch5-lab3"></a>ch5-lab3</h2><h3 id="需要移植（兼容lab1-2）的地方："><a href="#需要移植（兼容lab1-2）的地方：" class="headerlink" title="需要移植（兼容lab1/2）的地方："></a>需要移植（兼容lab1/2）的地方：</h3><ul>
<li><p>start_time和syscall_times：tcb中添加，new中初始化，run_task切换进程中更新时间，各个系统调用（位于process.rs和fs.rs）中更新次数</p>
</li>
<li><p>task_info：new定义，更新</p>
</li>
<li><p>mmap和munmap：</p>
</li>
<li><p>系统调用次数更新：update_syscall_times</p>
</li>
<li><p>page_table.rs和memory_set.rs和frame_allocator.rs中：一些用于检查的函数</p>
</li>
<li><p>注：</p>
<ul>
<li>第2-4都位于processor.rs（用于处理当前进程相关的内容）中</li>
<li>注意实现细节的变化</li>
<li>注意crate管理</li>
<li>注意注释标出新增功能，以及impl需要文档注释</li>
</ul>
</li>
</ul>
<h3 id="需要新增的功能："><a href="#需要新增的功能：" class="headerlink" title="需要新增的功能："></a>需要新增的功能：</h3><ul>
<li>sys_spawn：<ol>
<li>分析参数路径是否合法（参考exec）</li>
<li>返回值是pid/-1</li>
<li>tcb impl中，实现spawn</li>
<li>spawn中：（参考new+fork+exec）核心就是分配并初始化tcb，然后更新父进程内容，最后切换<ul>
<li>tcb及其字段的分配参考new（除了tcbinner的parent）</li>
<li>父进程更新父子关系、状态、最后加入taskmanager</li>
<li>修改processor中的current</li>
<li>销毁exclusive变量并进行__switch</li>
</ul>
</li>
</ol>
</li>
<li>stride：（注意stride scheduling论文中的pass和stride的含义和本实验中相反，这里我们采用的是论文中的定义）<ul>
<li>变量：<ul>
<li>tcb中新增stride、prio、pass</li>
<li>全局变量新增BIG_STRIDE</li>
</ul>
</li>
<li>变量初始化：<ul>
<li>prio初始16，pass初始0，stride初始BIG_STRIDE/16</li>
</ul>
</li>
<li>变量更新：<ul>
<li>每次调度后，更新pass+= stride（在run_task中）</li>
<li>每次set_prio后，更新stride= BIG_STRIDE/new_prio</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一些提交时未考虑到的细节："><a href="#一些提交时未考虑到的细节：" class="headerlink" title="一些提交时未考虑到的细节："></a>一些提交时未考虑到的细节：</h3><ul>
<li>切换前更新task_inner.start_time</li>
<li>syscall_read没有更新syscall_times</li>
<li>sys_spawn的trace中not implement忘记删除</li>
</ul>
<h2 id="ch6-lab4"><a href="#ch6-lab4" class="headerlink" title="ch6-lab4"></a>ch6-lab4</h2><p>框架分析：思考读一个文件时发生了什么？</p>
<p><strong>easy-fs/src</strong></p>
<p>easyfs 文件系统的整体架构自下而上可分为五层：</p>
<ol>
<li>磁盘块设备接口层：/block_dev.rs</li>
</ol>
<ul>
<li>归根结底是在块设备上以块为单位读写，</li>
<li>读写磁盘块设备的trait接口– BlockDevice trait（仅需read_block 和 write_block）</li>
</ul>
<ol start="2">
<li>块缓存层：/block_cache.rs</li>
</ol>
<ul>
<li>缓冲区是块设备的上一层，以块为单位管理对应的块缓存</li>
<li>BlockCache：创建时会触发read_block</li>
<li>BlockManager：以类似FIFO方式管理BlockCache，被换出时可能触发write_block</li>
<li>get_block_cache 接口：通过block_id和block_dev参数，在BlockManager中查询对应的BlockCache，如果存在则直接使用，否则加载（核心是new中的block_device.read_block函数，将编号为 block_id 的块从磁盘读入内存中的缓冲区 buf）进BlockManger</li>
</ul>
<ol start="3">
<li>磁盘数据结构层：/layout.rs /bitmap.rs</li>
</ol>
<ul>
<li>典型unix布局：超级块+inode位图+data位图+inode分区+data分区</li>
<li>表示磁盘文件系统的数据结构：SuperBlock、Bitmap、BlockInode、DirEntry、DataBlock</li>
<li>注意：<ul>
<li>一个BlockCache块缓存对应一个块512B，而一个块中有4个BlockInode</li>
<li>对BlockInode添加新的元数据字段需要修改一级索引的长度，以保证总大小为128B</li>
<li>DiskInode 方法：</li>
<li>get_block_id：数据块索引功能</li>
<li>read_at：将dkinode对应的文件从offset字节开始读到buf中（需要先通过get_block_id及索引定位到块号，然后用get_block_cache读入到内存中）</li>
</ul>
</li>
</ul>
<ol start="4">
<li>磁盘块管理器层：/efs.rs</li>
</ol>
<ul>
<li>管理磁盘数据结构的控制逻辑</li>
<li>EasyFileSystem</li>
<li>注意从这一层开始，所有的数据结构就都放在内存上了</li>
<li>重要方法：<ul>
<li>get_disk_inode_pos</li>
<li>get_data_block_id</li>
</ul>
</li>
</ul>
<ol start="5">
<li>索引节点层：/vfs.rs</li>
</ol>
<ul>
<li>对单个文件的管理和读写的控制逻辑</li>
<li>Inode（why/how对应DiskInode）：通过用efs的get_disk_inode_pos方法和BlockInode的inode_id可以算出该BlockInode所在block的block_id以及磁盘内偏移block_offset，而用get_block_cache接口和block_id以及block_device可以获得对应Block的BlockCache，使用BlockCache的read/modify方法就可以读/写Inode对应BlockInode对应的块缓存中的区域。因此，总的来说定位一个BlockInode需要block_id、block_offset、block_device、fs四个要素，这也正是vfs Inode的组成</li>
<li>重要方法：<ul>
<li>read/modify_disk_inode：读/写Inode对应的DiskInode对应的BlockCache区域</li>
</ul>
</li>
</ul>
<p><strong>easy-fs-fuse</strong></p>
<p>在（linux上的文件模拟出来的）一个虚拟块设备上创建并初始化文件系统</p>
<p><strong>操作系统中对接easy-fs文件系统的各种结构</strong></p>
<ol>
<li><p>块设备驱动层</p>
<p> 将平台上的块设备驱动起来并实现 easy-fs 所需的 BlockDevice Trait</p>
</li>
<li><p>easy-fs层</p>
<p> 借助一个块设备BlockDevice，打开EasyFileSystem文件系统，进而获取Inode数据结构，从而进行各种操作</p>
</li>
<li><p>内核索引节点层</p>
</li>
</ol>
<ul>
<li>将 easy-fs 提供的 Inode 进一步封装成 OSInode</li>
<li>OSInode 中要维护一些额外的信息</li>
</ul>
<ol start="4">
<li>文件描述符层</li>
</ol>
<ul>
<li>常规文件对应的 OSInode 是文件的内核内部表示</li>
<li>需要为它实现 File Trait</li>
</ul>
<ol start="5">
<li>系统调用层</li>
</ol>
<h2 id="ch8-lab5"><a href="#ch8-lab5" class="headerlink" title="ch8-lab5"></a>ch8-lab5</h2><p>任务：sys_enable_deadlock_detect</p>
<p>分析：银行家算法（即通过对已知数据的计算完成死锁判断）很好实现，关键是在何时/以什么形式记录/更新数据</p>
<p>具体思维过程：</p>
<ol>
<li>把银行家算法涉及的所有数组封装成结构体，把相关的操作封装成对应的impl中的函数，并放到os/src/sync下一个新建的rs文件中</li>
<li>注意到测试数据中仅考虑了单个用户程序中的死锁问题，并不需要（实际上也无法，因为没有跨用户程序的接口实现锁/信号量/条件变量）考虑用户程序间的死锁，因此我们要以用户程序即pcb为单位进行死锁检测。为此我们要为pcb新增一个字段来容纳死锁检测结构体实例（如果是所有用户程序之间也需要检测，我们可以用<code>lazy_static</code>来实现），这涉及了初始化及更新的问题。对于数组的下标，我们用<code>task_id</code>和<code>sem_id/mutex_id</code>来区分即可保证唯一性</li>
<li>死锁检测结构体初始化需要在<code>impl</code>中实现一个<code>new</code>函数，把数组初始化为0/1，并在<code>tcb</code>初始化时调用；每次检测后（检测前也可以），我们需要将<code>finish</code>和<code>work</code>数组单独初始化一次</li>
<li>更新主要围绕<code>available</code>、<code>allocation</code>和<code>need</code>数组，其中回收时（<code>sem_up/mutex_unlock</code>）<code>available+1</code>、<code>allocation-1</code>，分配时（<code>sem_down/mutex_lock</code>），若不能分配，则<code>need+1</code>，若能分配则<code>available-1</code>、<code>allocation-=1</code>。所有情况都需要考虑死锁检测，若检测成功则继续，若检测不成功则返回-0xdead（这里我们的实现不够优雅，需要在检测不成功时对数组恢复，实际上优雅的做法是把数组操作放在检测之后进行）。我们必须在最底层函数（<code>sem_up/mutex_unlock/sem_down/mutex_lock</code>）中实现，因为一但检测失败我们需要停止后续操作并立即返回。</li>
<li>一些细节：比如<code>sem_id/mutex_id</code>需要用参数传递进去，以及为此需要修改<code>trait</code>…</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/30/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-squanchhhhh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/30/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-squanchhhhh/" class="post-title-link" itemprop="url">2024开源操作系统训练营第二阶段总结-squanchhhhh</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-30 15:43:07" itemprop="dateCreated datePublished" datetime="2024-05-30T15:43:07+00:00">2024-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-学习心得"><a href="#1-学习心得" class="headerlink" title="1.学习心得"></a>1.学习心得</h2><pre><code>在参加本次课程之前，我正在做MIT6.081的实验，在谁演的过程中，我发现自己对操作系统的了解还不是特别深刻，于是去b站上寻找相关的视频，无意中发现了rcore的课程，便报名参加了，相比起xv6直接给出完整的代码，这个课程的设计可谓亲切许多，通过由浅入深，由表及里的设计，让学生对操作系统的了解更为深刻。</code></pre><h2 id="2-学习成果"><a href="#2-学习成果" class="headerlink" title="2.学习成果"></a>2.学习成果</h2><h3 id="2-1-gdb"><a href="#2-1-gdb" class="headerlink" title="2.1 gdb"></a>2.1 gdb</h3><pre><code>本次实验的成果之一就是对gdb的了解更加深刻，从页表开始，调试程序就变得困难起来，因为不能像第一个实验那样直接顺序执行代码，在切换程序时，会同时切换程序的页表，刚开始也不知道该怎么调试这样的代码，后来发现gdb可以直接将断点设置为*0x0，由于每个用户程序的开始地址都是*0x0，这样当切换进程的时候，就可以很方便的进入用户空间。</code></pre><h3 id="2-2-makefile"><a href="#2-2-makefile" class="headerlink" title="2.2 makefile"></a>2.2 makefile</h3><pre><code>如果引入本地测试的话，测试程序会修改makefile，这样每次都需要重新编写debug的makefile。</code></pre><h3 id="2-3-进程"><a href="#2-3-进程" class="headerlink" title="2.3 进程"></a>2.3 进程</h3><pre><code>在学习操作系统理论知识的时候，对进程控制块的理解不是很深刻，知道是一个很重要的组件，但是没有见到它的真实面貌，在实验中，为了给操作系统添加各种功能，也是为进程控制块添加了不少字段，理解更为深刻。</code></pre><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><pre><code>在计算机的学习中，动手往往比理论更加重要，做一个操作系统往往效果比学习操作系统理论要好得多。</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/24/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E9%99%88%E8%BD%BD%E7%86%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/24/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E9%99%88%E8%BD%BD%E7%86%BA/" class="post-title-link" itemprop="url">2024开源操作系统训练营第二阶段总结-陈载熺</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-24 14:21:50" itemprop="dateCreated datePublished" datetime="2024-05-24T14:21:50+00:00">2024-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><h2 id="rustlings"><a href="#rustlings" class="headerlink" title="rustlings"></a>rustlings</h2><p>19号开始，把之前写过的rustlings合并，24号把补充的私货题目写完。</p>
<h2 id="对rust的一些认识"><a href="#对rust的一些认识" class="headerlink" title="对rust的一些认识"></a>对rust的一些认识</h2><h3 id="函数式思想"><a href="#函数式思想" class="headerlink" title="函数式思想"></a>函数式思想</h3><p>使用中用到函数式思想最多的是迭代器。不同于cpp的迭代器，rust的迭代器更“函数式“一点。比如对迭代器的修饰、map、collect等都很方便。根据the book，rust的闭包抽象成本比较低，“零成本”。</p>
<h3 id="外部符号与二进制文件"><a href="#外部符号与二进制文件" class="headerlink" title="外部符号与二进制文件"></a>外部符号与二进制文件</h3><p>补充题中的与Cargo.toml等的联动及外部函数、不混淆函数名宏的使用挺扩展我的认知的。rust提供的相当方便的core的宏（#[repr(c)]等）来控制二进制文件的形式。</p>
<h3 id="所有权和生命周期"><a href="#所有权和生命周期" class="headerlink" title="所有权和生命周期"></a>所有权和生命周期</h3><p>之前一直有些不理解，但是看到了一句话“所有权是释放对象的责任”，感觉懂了一点。</p>
<h3 id="rust的宏"><a href="#rust的宏" class="headerlink" title="rust的宏"></a>rust的宏</h3><p>很多功能，很黑魔法。翻了下宏的小册子，是在AST上替换的，很有趣，期待看到更多它的功能。</p>
<h2 id="其他材料"><a href="#其他材料" class="headerlink" title="其他材料"></a>其他材料</h2><ol>
<li>看了下rCore的发展历史。</li>
<li>riscv特权寄存器的文档。</li>
<li>示例文档中一位学长提到的《深入理解linux内核》中的i386分段部分</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初窥门径。感觉rust有很多简洁高效的地方，期待进一步的学习。</p>
<h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><h2 id="实验时间"><a href="#实验时间" class="headerlink" title="实验时间"></a>实验时间</h2><p>放完51假期，7号开始写lab，属于是开始的比较迟（都看到有答疑了，没有去看），超了ddl。但是想学不嫌晚，还是写份总结。</p>
<h2 id="印象"><a href="#印象" class="headerlink" title="印象"></a>印象</h2><p>总共的5个实验中我印象最深的是fs的实验，让我分开来了Data，Inode，DiskInode，OSInode以及各种数据位图之间的区别，diskinode是存放在硬盘上的索引，inode根据diskinode索引值存在于vfs中的对象，在VFS中本身只持有几个属性。做的时候改了diskInode，加了link，其中对块缓存的读取和写入都是传入函数闭包实现的，很有趣。</p>
<p>还想说下mm的实验，双页表的实现使用恒等映射，将高地址的一定段映射到各个进程及os相同的逻辑地址。这样在切换页表进入内核时，可以得到一个过渡区域来处理上下文。</p>
<p>当然，刚接触ch1和ch2时，读linkld是最初震撼，可惜没有实验，现在有些细节模糊了，还是多做总结。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>从代码中得到方法。在实现spawn中，仿照fork和exec的实现来照猫画虎，捏了个spawn(id)-&gt;tcb来，感触挺大，代码是详细的准确的教材。</li>
<li>曳光弹。之前看《程序员修炼之道》时看到的概念，是指开发时优先穿透各个层次直接看到效果。我觉得看代码也可以用这种方式快速把握具体的流程，由功能到达自己熟悉的代码结构。来快速认识代码功能。</li>
<li>互操作。灌了很多汇编、二进制、和rust代码的联动。二进制文件的布局、符号等，原来看csapp了解的悬空的“二进制文件”逐渐有了些实际的感觉。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/24/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E5%88%98%E6%A2%93%E9%99%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/24/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E5%88%98%E6%A2%93%E9%99%86/" class="post-title-link" itemprop="url">2024开源操作系统训练营第一阶段总结-刘梓陆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-24 10:04:16" itemprop="dateCreated datePublished" datetime="2024-05-24T10:04:16+00:00">2024-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024-开源操作系统训练营第二阶段总结-刘梓陆"><a href="#2024-开源操作系统训练营第二阶段总结-刘梓陆" class="headerlink" title="2024 开源操作系统训练营第二阶段总结-刘梓陆"></a>2024 开源操作系统训练营第二阶段总结-刘梓陆</h1><ul>
<li><a href="#2024-开源操作系统训练营第二阶段总结-刘梓陆">2024 开源操作系统训练营第二阶段总结-刘梓陆</a><ul>
<li><a href="#写在前面">写在前面</a></li>
<li><a href="#欢迎交流-">欢迎交流;-）</a></li>
<li><a href="#os-大概是个什么东西捏我在完成了这个阶段的任务之后的理解">OS 大概是个什么东西捏？我在完成了这个阶段的任务之后的理解</a><ul>
<li><a href="#os-下面还有一个-sbi">os 下面还有一个 sbi？</a></li>
<li><a href="#毫无疑问就是一个应用程序">毫无疑问就是一个应用程序</a></li>
<li><a href="#通过寄存器和-pc-的指令流">通过寄存器和 pc 的指令流</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>真是一段很长的旅程啊，怎么说呢，这一阶段的任务我基本上都是“挣扎”着完成的，一开始感觉以我对 Rust 和 OS 的理解，应该此阶段的任务不会非常困难。后来发现还得是“纸上得来终觉浅，绝知此事要躬行”，有些东西在课上学习理论知识和实际使用代码进行实现完全是不一样的感觉，而且怎么说呢，Rust 的运用程度实际上对编写操作系统的帮助也不是特别大，就好像你要和<em>亚里士多德</em>探讨哲学问题，重点是这个哲学问题，而不是<em>古希腊语</em>，当然你得先对古希腊语有一个大致的了解，但是古希腊语本身对理解这个哲学问题是没有什么帮助的。</p>
<p>反正总之由于种种原因，我感觉我在这方面的经验根本就是 0，导致本阶段的任务超出截止时间一周差不多才完成。</p>
<p>但是怎么说呢，就好比是 DND 里面的等级系统一样，在等级为 1 的情况下，升到 2 级所需要的经验值是很少的，所以这个训练营给我的提升感觉也特别大（OS 子职等级），了解到了很多之前根本没有机会接触的知识领域，最重要的，更是加深了我对 os 的理解。</p>
<p>我在第一阶段的总结之中也提到了我非常崇拜 Linux，现在感觉我离他好像又进一步了，感到非常开心！</p>
<h2 id="欢迎交流-）"><a href="#欢迎交流-）" class="headerlink" title="欢迎交流;-）"></a>欢迎交流;-）</h2><p>在写这篇博客时，本人<strong>东北大学</strong>大三在读，前两年东学西学，Rust 就是之一，说实话，在本学期开始时，我实在找不到什么东西来做，准备先买一本《趣读 Linux 源码》来看，感谢我学弟<strong>翊嘉</strong>，是他给我推荐了这个操作系统训练营，这样直接上手操作系统的效果比看书要好太多了，真的十分感谢！</p>
<p>我对 Rust 的理解还是比较少，future、unsafe 的内容更是知之甚少，所以大佬求带！看到我这篇总结报告之中有什么不足也请指出！</p>
<ul>
<li>github ID: <a href="https://github.com/destinyFvcker" target="_blank" rel="noopener">destinyFvcker</a></li>
<li>邮箱：<a href="mailto:&#100;&#101;&#x73;&#x74;&#x69;&#110;&#121;&#102;&#x75;&#x6e;&#107;&#64;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;">&#100;&#101;&#x73;&#x74;&#x69;&#110;&#121;&#102;&#x75;&#x6e;&#107;&#64;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;</a></li>
<li>微信号：wxid_r3se52q2d4pg22</li>
</ul>
<h2 id="OS-大概是个什么东西捏？我在完成了这个阶段的任务之后的理解"><a href="#OS-大概是个什么东西捏？我在完成了这个阶段的任务之后的理解" class="headerlink" title="OS 大概是个什么东西捏？我在完成了这个阶段的任务之后的理解"></a>OS 大概是个什么东西捏？我在完成了这个阶段的任务之后的理解</h2><p>最近在看 Linus 的自传，他在里面讲了一段关于 OS 的话感觉说得特别好：</p>
<blockquote>
<p>计算机上的所有功能要起作用，都得以操作系统为基础。于是，创造一个操作系统就成了终极挑战。你创造操作系统的时候，相当于给所有在这部电脑上跑的程序创造了一个全新的生存环境—从根本上说，其实就是在制定这个世界的规则：什么事可以接受、可以做，什么事不可以接受、不可以做。其实所有的程序都是在制定规则，只不过操作系统制定的是最根本的规则。创造一个操作系统，就相当于自己创造的一方土地制定宪法，而在电脑上跑的程序则相当于各式各样的普通法律。</p>
</blockquote>
<p>这段话形象地表达了操作系统的功能、作用、以及它对上层应用程序强大的控制能力，但是实际上感觉在实现了一些东西之后，好像也不完全是这样。</p>
<h3 id="os-下面还有一个-sbi？"><a href="#os-下面还有一个-sbi？" class="headerlink" title="os 下面还有一个 sbi？"></a>os 下面还有一个 sbi？</h3><p>原来就是认为是下面这个层级关系：</p>
<ul>
<li>计算机硬件 -&gt; os -&gt; user application</li>
</ul>
<p>但是在使用 RISC-V 实际上应该是这样的！</p>
<ul>
<li>计算机硬件 -&gt; sbi -&gt; os -&gt; user application</li>
</ul>
<p>实际上操作系统也要向下请求 sbi 提供的功能！在本次训练营之中一个比较常用的功能——往屏幕上输出字符就是通过 sbi 完成的。实际上完全不止于此，SBI 还会在计算机启动的时候进行它所负责的环境初始化工作，并将计算机控制权移交给内核，操作系统的关闭也是由 SBI 控制的。</p>
<p>从 RISC-V 特权级架构的视角来看，我们编写的 OS 内核位于 Supervisor 特权级，而 RustSBI 位于 Machine 特权级，也是最高的特权级。</p>
<p>说实话，我对 SBI 的理解就到此为止了，在代码之中，很贴心地向我们提供了 SBI 服务调用的接口，我们直接使用就可以了。</p>
<hr>
<p><strong>这部分我感觉还不是很清楚的内容：</strong><br>SBI 的内容我感觉真的后续还有必要继续学习一下。</p>
<hr>
<h3 id="毫无疑问就是一个应用程序"><a href="#毫无疑问就是一个应用程序" class="headerlink" title="毫无疑问就是一个应用程序"></a>毫无疑问就是一个应用程序</h3><p>在本阶段的相关代码项目之中，除了一些关键的处理 Trap 和上下文切换的逻辑是使用汇编进行编写的之外，其他都是使用 Rust 编写的、和普通的用户应用程序并没有什么不同。</p>
<p>在实现了地址空间之后，基本上就完全停留在逻辑上的开发了，不再关心操作系统的实现细节，实际上我在实现了进程和文件系统的相关功能之后回头一看都感觉地址空间之中的一些实现细节都开始遗忘了。</p>
<hr>
<p><strong>这部分我感觉还不是很清楚的内容：</strong><br>Rust 编译器是如何将这个汇编代码和 Rust 代码链接在一起的？<br>而且在 Rust 之中是如何调用在汇编代码之中定义的过程的？</p>
<hr>
<h3 id="通过寄存器和-pc-的指令流"><a href="#通过寄存器和-pc-的指令流" class="headerlink" title="通过寄存器和 pc 的指令流"></a>通过寄存器和 pc 的指令流</h3><p>而且我发现真的一个应用程序实际上非常简单，就是一堆指令，pc 拿到之后一条条执行，然后会有一个跳转指令跳转到另外一条指令进行执行，然后指令的操作数都是从寄存器拿出来的，线程或者进程实际上就是一个包装了指令流的上下文，在里面进行了一些簿记工作，记录了当前指令进行到了哪里，然后一些相关寄存器的状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/22/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-c2h4moe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/22/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-c2h4moe/" class="post-title-link" itemprop="url">二阶段总结报告--c2h4moe</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 19:47:45" itemprop="dateCreated datePublished" datetime="2024-05-22T19:47:45+00:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>狂赶一周，二阶段也算是终于做完了，这里就说说实验中令我印象比较深的部分吧。</p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>操作系统为每个应用程序制造了一种假象，仿佛它们能够独占并随意的使用巨大的内存空间，但实际上，这是硬件分页机制和操作系统维护页表共同营造的幻觉，在加载ELF文件时，操作系统会把程序加载到物理地址中一段空闲的区间，但会让ELF文件中指定的加载地址对应的页表指向真正的物理地址。</p>
<p>我觉得这个实验需要注意很多细节，比如，页表切换是一条指令完成的，如何保证切换完之后依然能够按照我们所期望的执行流继续执行呢？我们开辟了一个“跳板页”，让所有地址空间的最高一页都指向一段相同的物理地址，这样就可以保证页表切换是“平滑的”。</p>
<p>还有，之前想了很久为什么用户态的上下文是存在用户的地址空间而非内核的，后来看实验指导书才明白页表切换和内核栈切换是两步操作，但只有一个sscratch寄存器，无法在不破坏通用寄存器的条件下切换到内核空间并在内核栈保存上下文。</p>
<p>这章还有很多技术上的优化技巧，比如，如果为每个应用都建立一个能够映射全部空间的页表，会占有过大的物理空间，所以，我们不再对每一个地址都映射，而是根据ELF文件的程序头一段段来映射，并且引入类似“字典树”的数据结构来建立多级页表，有效的节省了空间。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>实现互斥锁可以有三种方式，一种是在纯软件形式在用户态通过类Peterson算法</p>
<p>实现锁，还有是在硬件的支持下通过原子指令来实现，还可以通过操作系统支持（假设内核进程不被打断）。</p>
<p>这章给我印象比较深的部分是引入互斥锁时举了一个计数器的例子，根据例子运行的异常提供了3个分析思路：是不是编译优化造成的？是不是OS调度造成的？是不是CPU造成的？并且逐一分析，最终找到根本原因，我认为这给我了一个关于系统编程方法论的启发。并且在分析错误原因时通过状态机和合法状态来分析，也是一个很深刻的想法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了上面说的一些底层的特性（页表，地址空间切换等等），操作系统大部分也只不过是个普通的应用程序。在看框架代码时，我也学习到了一些编程的技巧和方法，比如，通过drop trait来实现RAII，通过这个rust机制有效的减少了内存分配相关的错误。</p>
<p>总体来说，不管是对OS的理解，还是对rust的掌握，我都进步了很多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/21/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94Air-Suck/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/21/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A%E2%80%94%E2%80%94Air-Suck/" class="post-title-link" itemprop="url"><2024开源操作系统训练营总结报告——Air-Suck></a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-21 19:59:36" itemprop="dateCreated datePublished" datetime="2024-05-21T19:59:36+00:00">2024-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024春夏季开源操作系统训练营总结报告"><a href="#2024春夏季开源操作系统训练营总结报告" class="headerlink" title="2024春夏季开源操作系统训练营总结报告"></a>2024春夏季开源操作系统训练营总结报告</h1><h2 id="第一阶段总结报告"><a href="#第一阶段总结报告" class="headerlink" title="第一阶段总结报告"></a>第一阶段总结报告</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名大二在读生，在听同学说有一门语言很炫酷的时候，就算是面对着巨大的课业压力，我还是选择来看看rust到底是什么样的一门语言。</p>
<h3 id="Rustlings总结"><a href="#Rustlings总结" class="headerlink" title="Rustlings总结"></a>Rustlings总结</h3><p>刚刚接触rust语言时，我并没有意识到rust的强大之处，认为它只是一门新的语言罢了。但是当我跟着文档一步步去接触rust中全新的概念时，我才发现这门语言与其他的编程语言有多大的区别。</p>
<p>从rust变量的所有权与借用规则，再到后面的智能指针和生命周期，每一个特性都是那么晦涩难懂。我甚至在刚刚接触这些特性时，认为这些特性就是在束缚我，<strong>让我没法自由自在的编程</strong>。我甚至真的想过直接给我的所有rust代码套上一个unsafe。</p>
<p>但是没有束缚的自由也确实不是真正的自由。随着学校课程，尤其是操作系统课程的推进，让我知道了rust的所有权、借用规则以及智能指针，都是为了从语言层面提高整个计算机系统的性能，包括但不限于防止内存泄漏、不让指针乱飞、实现共享区互斥访问等。让我不用像写C语言一样，总是要考虑堆上变量有没有free，指针到底是几级指针，到底指的是什么玩意。不得不承认，经过rustlings110道练习的磨炼，我意识到，rust在通过它的特性，<strong>让我更自由的编程</strong>。</p>
<p>从头开始学习一门语言是不容易的，尤其是学习像rust这样特性贼多的语言。我在这里要感谢一位之前一直被我忽视的一位朋友——编译器。在之前编程时，不论是写C还是写Java，又或者是写Go，我总是认为编译器只不过是在检查我的语句是不是合法罢了。但是在写rust时，我就深深感受到，没有rust编译器，单单靠我一团浆糊的脑子和厚厚的文档，我是学不会rust的，甚至说都难以写出符合rust语法的程序。每次的报错都让我能够更深地了解rust的语言特性，每次的help，都能让我精确无误的修改错误。编译器好像一直在对我说：“嘿，跟着哥，哥带你学rust。”</p>
<p>希望我能够在接下来的阶段乃至之后与rust同行的时间里，跟着rust编译器，不断加深对rust的理解。</p>
<p>嘿，把rust当做母语真的很酷好吗。</p>
<h2 id="第二阶段总结报告"><a href="#第二阶段总结报告" class="headerlink" title="第二阶段总结报告"></a>第二阶段总结报告</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>进入到第二阶段的同时，学校其实也开始进入了期末考试的阶段，每天我说的最多的一句话就是：汗流浃背了。但是好在，我还是走完了这一艰难但是有意义的阶段。</p>
<h3 id="1-2-应用程序基本执行环境与批处理系统"><a href="#1-2-应用程序基本执行环境与批处理系统" class="headerlink" title="1-2 应用程序基本执行环境与批处理系统"></a>1-2 应用程序基本执行环境与批处理系统</h3><p>虽然第一章和第二章并没有让我动手实践，但是看着文档一步步从搭建最小环境，再到实现自己的print，再到实现riscv特权级的切换。很难想象这是我在两章里面能学到的东西。</p>
<h3 id="3-多道程序与分时多任务"><a href="#3-多道程序与分时多任务" class="headerlink" title="3 多道程序与分时多任务"></a>3 多道程序与分时多任务</h3><p>从这里开始，我终于能上手碰碰操作系统了。</p>
<p>这个实验主要是要让我通过rust实现一个任务状态查询的系统调用。我最自然的想法是，任务状态一定是跟任务绑定的，所以我直接在TCB中新增了一个计算系统调用的成员变量。实现下来也是非常自然顺畅的。但是我知道这个方法应该不是最好的方法，毕竟要在TCB中创建一个挺大的数组，而TCB是属于操作系统内核的，并且操作系统中可能有许多的任务，这样就会导致操作系统内核比较臃肿。</p>
<h3 id="4-地址空间"><a href="#4-地址空间" class="headerlink" title="4 地址空间"></a>4 地址空间</h3><p>这一章就涉及到了我之前很少接触到的部分——虚拟地址空间。</p>
<p>从sv39多级页表机制到内核与应用的地址空间，这些内容都挺让我头大的。虽然在进入第四章时走了点弯路，编写代码的时候甚至没有涉及到逻辑段。当后来发现其实框架代码中有一些函数接口可以直接调用（如：shrink_to、append_to、insert_framed_area等），我就开始吐槽之前浪费了太多的时间。但是现在想想，这一段小插曲让我对虚拟地址空间有了更深的了解：从分配物理页帧，到建立虚拟地址和物理地址之间的映射，再到用户程序逻辑段的构建。艰难但有意义。</p>
<h3 id="5-进程及进程管理"><a href="#5-进程及进程管理" class="headerlink" title="5 进程及进程管理"></a>5 进程及进程管理</h3><p>本章主要实现操作系统中一个重要的系统调用——spawn。此外还涉及到了一种调度算法——stride调度算法</p>
<p>spawn与fork+exec的最大的区别就是，spawn并不需要像fork一样完全复制父进程的地址空间，并依此再创建一个TCB，然后再通过exec将TCB重写为需要执行的用户程序的TCB。它是直接根据新的用户程序创建一个TCB，省去了重写TCB的开销。所以如果要实现一个spawn系统调用，就只需要模仿fork来实现就好了。</p>
<p>而stride调度算法就是在TCB中增加两个成员stride和priority，在不考虑性能的情况下，只需要遍历就绪队列并执行 stride最小的任务即可。但是受于双端队列的限制，就只能从队列中取出一个TCB然后进行比较，如果stride比当前已经选出的TCBstride还大的话就重新将其放回就绪队列，这样可行，但是会导致更大的系统开销。</p>
<h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul>
<li>由于系统终止一个进程的时候是根据TCB的Arc指针强引用数量来判断的，所以很多地方就不能让编译器帮我drop变量，而是需要进行显式的变量drop。</li>
</ul>
<h3 id="6-文件系统与I-O重定向"><a href="#6-文件系统与I-O重定向" class="headerlink" title="6 文件系统与I/O重定向"></a>6 文件系统与I/O重定向</h3><p>在这一章的实验中我对操作系统中的另一个重要部分——文件系统有了基本的认识</p>
<p>从最底层的块设备、缓存，再到上层的文件系统以及操作系统相关的系统调用，学习下来我的感觉就是——多且杂，搞不明白为什么要分这么多层。但是现在回想一下这一切都是有意义的，这些分层让文件系统的不同层的代码高度解耦合，提高了文件系统的可移植性。</p>
<p>实验要求实现建立硬链接、释放硬链接以及查询文件状态系统调用。对于建立硬链接，我就按照文档上的提示按部就班为相同的磁盘索引块再创建了一个目录项。但是对于释放硬链接需要考虑的东西就多了：当一个文件在释放当前硬链接之后还存在硬链接的话，就只需要将磁盘上的某个目录项删除；当一个文件在释放当前硬链接之后没有硬链接了，那就需要将其在磁盘上所有的空间回收（虽然有同学说就算没有回收也能过测试用例）。而对于查询文件状态，我就是将需要查询的字段作为成员放在磁盘索引节点中，这样就能实现就算系统断电，文件的状态也不会丢失（由于是存储在磁盘块上而不是在内存中）</p>
<h4 id="一些注意点-1"><a href="#一些注意点-1" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul>
<li>删除目录项的时候按道理来说不能仅仅是将该目录项清零，而是应该将后面的目录项移动到前面来，并且如果移动后刚好空出了一个磁盘块，还需要去回收该磁盘块。但是在我的代码中仅仅实现到了将后面的目录项移动到前面，之后有时间可以尝试去改进一下。</li>
<li>在给磁盘索引节点增加成员的时候一定要减少直接索引的数量以保证一个磁盘块的大小是128字节。</li>
</ul>
<h3 id="7-8-进程间通信与并发"><a href="#7-8-进程间通信与并发" class="headerlink" title="7-8 进程间通信与并发"></a>7-8 进程间通信与并发</h3><p>这两章的实验主要实现了一个重要的算法——死锁检测算法</p>
<p>这个算法其实在学校的课程中学过，是一个非常类似于银行家算法的算法，但是银行家算法是为了避免死锁。</p>
<p>这个算法中我觉得最让我摸不着头脑的就是need矩阵到底应该如何初始化。Available矩阵可以根据剩余的信号量或者锁是否被占用来实现；Allocation可以根据查询当前哪些线程在占据资源来确定。而need呢？显然不能单从信号量和锁的阻塞队列来确定。</p>
<p>从结果来看，其实应该是我的理解错了，我将死锁检测算法和银行家算法混淆了。我之前一直以为死锁检测算法中的need是一个线程在<strong>全局角度</strong>上对资源的需求量。而实际上need矩阵只是系统在<strong>当前状态</strong>下各个线程对资源的需求量，在每次需要分配资源时都需要调用死锁检测算法。所以死锁检测算法中的need矩阵是由信号量或者锁的阻塞队列以及当前请求资源的线程决定的。接下来只需要按照算法描述进行编码问题就迎刃而解了。</p>
<p>虽然第三阶段的时间与学校期末考试的时间完美重合，但是从第二阶段的学习中我真正感受到了操作系统的魅力，冲就完了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-OSFantasy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-OSFantasy/" class="post-title-link" itemprop="url">2024开源操作系统训练营第二阶段总结-OSFantasy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 19:16:19" itemprop="dateCreated datePublished" datetime="2024-05-19T19:16:19+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二阶段-OS设计实现"><a href="#第二阶段-OS设计实现" class="headerlink" title="第二阶段 - OS设计实现"></a>第二阶段 - OS设计实现</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>由于我是二刷了，所以一阶段很快就搞完了，然后提前了一个月左右弄二阶段。最后赶在了五一假期前做完了二阶段的Lab。（PS：不得不说，群友都好强，Orz）</p>
<p>然后我五一假期过后，训练营学习基本上就有些摆了（除了上课就没干啥了）。一方面原因是学校课程忽然要考试了，二是不得不重视英语学习了，三是自制力下降了很多。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E8%9E%8D%E5%8C%96.png" alt="融化"></p>
<p>虽然是二刷训练营了，但是这次是第一次参与到二阶段的学习中（上次二阶段还没开始就没搞了）。不得不说二阶段真的学到了好多关于OS相关的知识，同时代码的实操非常有用。（PS：Tutorial-Book-V3的step-by-step真的很棒）</p>
<p>我本人是非计算机专业的，对于本次二阶段来说，基本上算是零基础了（没学过计组、操作系统概论、CSAPP、计算机体系结构等）。不过好在的是我对于单片机的开发还是比较熟悉的，在二阶段的学习中我也发现了OS开发和单片机开发的很多相似之处，比如：STM32有个东西叫HAL库，OS中有个东西叫HAL层(也就是SBI)，它两都是对硬件的一层抽象。</p>
<h2 id="1-环境与工具软件等"><a href="#1-环境与工具软件等" class="headerlink" title="1 环境与工具软件等"></a>1 环境与工具软件等</h2><h3 id="RustRover"><a href="#RustRover" class="headerlink" title="RustRover"></a>RustRover</h3><p>还是强推RustRover。毕竟rCore的代码量可不小，用vim在多个文件间切换太麻烦了。而且RR可以方便的查看函数的使用和trait的impl。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-19%20194056.png" alt="RR"></p>
<p>另外提一下，我在使用Ubuntu22上的RR2024.3时遇到了闪退问题。换回到RR2023后解决了。</p>
<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><p>这个主要是用来模拟一个risc-v64的机器在我们的x86_64的电脑上。</p>
<p>在安装的时候可能会遇到一个坑，就是在执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 安装编译所需的依赖包</span><br><span class="line">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \</span><br><span class="line">              gawk build-essential bison flex texinfo gperf libtool patchutils bc \</span><br><span class="line">              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev libslirp-dev \</span><br><span class="line">              git tmux python3 python3-pip ninja-build</span><br><span class="line"># 下载源码包</span><br><span class="line"># 如果下载速度过慢可以使用我们提供的百度网盘链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1dykndFzY73nqkPL2QXs32Q</span><br><span class="line"># 提取码：jimc</span><br><span class="line">wget https:&#x2F;&#x2F;download.qemu.org&#x2F;qemu-7.0.0.tar.xz</span><br><span class="line"># 解压</span><br><span class="line">tar xvJf qemu-7.0.0.tar.xz</span><br><span class="line"># 编译安装并配置 RISC-V 支持</span><br><span class="line">cd qemu-7.0.0</span><br><span class="line">.&#x2F;configure --target-list&#x3D;riscv64-softmmu,riscv64-linux-user  # 在第九章的实验中，可以有图形界面和网络。如果要支持图形界面，可添加 &quot; --enable-sdl&quot; 参数；如果要支持网络，可添加 &quot; --enable-slirp&quot; 参数</span><br><span class="line">make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>而后，可能会报错说缺少某个东西。这是因为第一步操作可能少了个需要的依赖。按照提示执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install &lt;缺少的某个依赖&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-OS知识"><a href="#2-OS知识" class="headerlink" title="2 OS知识"></a>2 OS知识</h2><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><p>站在应用程序的角度来看，我们可以发现常见的应用程序其实是运行在由硬件、操作系统内核、运行时库、图形界面支持库等所包起来的一个 执行环境 (Execution Environment) 中，如下图所示。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-19%20204200.png" alt="OS结构"></p>
<h3 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h3><p>在操作系统中，需要处理三类异常控制流：外设中断 (Device Interrupt) 、陷入 (Trap) 和异常 (Exception，也称Fault Interrupt)。</p>
<p>陷入 (Trap) 是程序在执行过程中由于要通过系统调用请求操作系统服务而有意引发的事件。产生陷入后，操作系统需要执行系统调用服务来响应系统调用请求，这会破坏陷入前应用程序的控制流上下文，所以操作系统要保存与恢复陷入前应用程序的控制流上下文。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-19%20232241.png" alt="异常控制流：陷入"></p>
<h3 id="RISC-V-特权级架构"><a href="#RISC-V-特权级架构" class="headerlink" title="RISC-V 特权级架构"></a>RISC-V 特权级架构</h3><p>RISC-V 架构中一共定义了 4 种特权级：</p>
<table>
<thead>
<tr>
<th>特权级</th>
<th>编码</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>00</td>
<td>用户/应用模式 (U)</td>
<td>用于运行普通的用户应用程序。在这个模式下，应用程序不能执行特权指令，也不能直接访问硬件资源。</td>
</tr>
<tr>
<td>1</td>
<td>01</td>
<td>监督模式 (S)</td>
<td>通常用于运行操作系统内核。在这个模式下，操作系统可以执行特权指令来管理进程、内存和其他系统资源，但是它不能直接访问所有的硬件资源。</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>虚拟监督模式 (H)</td>
<td>用于运行虚拟化管理程序（Hypervisor），它可以在物理硬件上管理多个虚拟机监视器（VMM）。Hypervisor模式可以执行一些特定的管理操作，但不是所有的机器级指令都是可用的。</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>机器模式 (M)</td>
<td>用于运行固件和操作系统内核。机器模式可以执行所有的指令，并且可以直接访问所有的硬件资源。通常，机器模式下的代码负责硬件管理和启动时的引导。</td>
</tr>
</tbody></table>
<p>其中，级别的数值越大，特权级越高，掌控硬件的能力越强。从表中可以看出， M 模式处在最高的特权级，而 U 模式处于最低的特权级。在CPU硬件层面，除了M模式必须存在外，其它模式可以不存在。</p>
<p>从特权级架构的角度，去分析支持应用程序运行的执行环境栈，如下图所示：</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/PrivilegeStack.png" alt="特权级"></p>
<p>其中，白色块表示一层执行环境，黑色块表示相邻两层执行环境之间的接口。这张图片给出了能够支持运行 Unix 这类复杂系统的软件栈。其中操作系统内核代码运行在 S 模式上；应用程序运行在 U 模式上。运行在 M 模式上的软件被称为 监督模式执行环境 (SEE, Supervisor Execution Environment)，如在操作系统运行前负责加载操作系统的 Bootloader – RustSBI。站在运行在 S 模式上的软件视角来看，它的下面也需要一层执行环境支撑，因此被命名为 SEE，它需要在相比 S 模式更高的特权级下运行，一般情况下 SEE 在 M 模式上运行。</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>在操作系统的管理下，应用程序不用理解持久存储设备的硬件细节，而只需对 文件 这种持久存储数据的抽象进行读写就可以了，由操作系统中的文件系统和存储设备驱动程序一起来完成繁琐的持久存储设备的管理与读写。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-20%20211446.png" alt="文件系统"></p>
<h3 id="移植FATFS"><a href="#移植FATFS" class="headerlink" title="移植FATFS"></a>移植FATFS</h3><p>之前移植FATFS文件系统到FeatOS（其实就是照着rCore写的，改了一点）中时，学习FATFS结构打的草稿。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/FATFS.jpg" alt="FATFS"></p>
<p>最后移植成功后，能够读取并运行FAT32文件系统镜像中的elf文件。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>这次总算是圆满完成第二阶段了，同时也取得了不错的成绩。文件系统和并发让我印象深刻，打算后面完成第三阶段后再回来详细的搞搞ch6后面的东西。</p>
<p><img src="https://osfantasyphoto.oss-cn-chengdu.aliyuncs.com/blog/os-lab/stage1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-20%20214215.png" alt="成绩"></p>
<p>感激社区提供了这样一个学习平台，它为我打开了一扇探索操作系统奥秘的大门。希望后续的学习我还能够坚持下去吧！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/Map-for-Rust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/Map-for-Rust/" class="post-title-link" itemprop="url">Summary of 2024s-rcore 1st stage  -- Map for Rust</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 15:58:49" itemprop="dateCreated datePublished" datetime="2024-05-19T15:58:49+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/catogory/" itemprop="url" rel="index"><span itemprop="name"><catogory></span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Rust 是一种高级程序设计语言</p>
<p>Rust 设计上的主要目标是保证内存安全，同时追求运行速度和内存利用率</p>
<p>个人认为，想要更好地理解和掌握 Rust，应该在探索 Rust 语法规则的同时思考 Rust 如何达成以上两个目标</p>
<h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p>高级程序设计语言的主要特征是高效的代码开发、管理和维护</p>
<p>在这一方面，Rust 提供了丰富的特性：</p>
<ul>
<li>泛型</li>
<li>强大的宏特性</li>
<li>Attribute</li>
<li>函数式</li>
<li>trait</li>
<li>强大的包管理器 Cargo</li>
<li>很好的学习资料和活跃的社区</li>
</ul>
<h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><p>为了实现零成本抽象，Rust 选择花更多的时间在编译阶段的静态分析上</p>
<p>Rust 一大核心功能——所有权系统，正是基于静态分析的 RAII 思想实践</p>
<p>RAII 思想的提出主要是针对动态数据类型（位于堆上的大部分数据）的释放问题，其基本思想是在变量获取存储资源时就为其绑定一个生命周期，资源将在生命周期结束后被自动释放</p>
<p>所有权系统保证了资源不会被二次释放</p>
<h1 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h1><p>这篇简短的博客作为2024春夏季开源操作系统训练营第一阶段的总结，我在其中简单概述了我对 Rust 语言的理解</p>
<p>因为我所学尚浅，且没有足够的实践经历，导致以上内容十分简略，甚至可能有不少错误</p>
<p>我并不希望这些内容就这样简短的结束并被掩埋和遗忘，所以我将在<a href="https://ldq3.github.io/" target="_blank" rel="noopener">我的个人博客</a>上持续更新我对 Rust 的理解</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/Rust-for-OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/Rust-for-OS/" class="post-title-link" itemprop="url">Summary of 2024s-rcore 2nd stage  -- Rust for OS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 15:58:49" itemprop="dateCreated datePublished" datetime="2024-05-19T15:58:49+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/catogory/" itemprop="url" rel="index"><span itemprop="name"><catogory></span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Rust 具有安全和高效的特性，这使得它有希望被用于构建更好的操作系统</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>在计算机的分层体系结构中，操作系统位于软件和硬件的分界处</p>
<p>操作系统的职责是帮助用户程序管理计算机硬件，这基于 CPU 提供 ISA 实现（在本次实验过程中，具体是 RISC-V）</p>
<p>操作系统的职责可以被进一步细分为几个方面——虚拟化、并发、持久性和驱动（和外部设备的通信）</p>
<p>在第二阶段，我们并没有太多的关于驱动的内容。虚拟化考虑如何在有限的硬件资源上为多个软件提供相互隔离的服务，并发考虑如何控制软件对共享资源的使用、持有性主要指文件系统</p>
<p>操作系统称得上是人类所设计的最复杂的一类程序，在这里你几乎能用上计算机中的所有知识</p>
<h1 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h1><p>这篇简短的博客作为2024春夏季开源操作系统训练营第二阶段的总结，我在其中简单概述了我对 Rust 用于构建操作系统的理解</p>
<p>因为我所学尚浅，且没有足够的实践经历，导致以上内容十分简略，甚至可能有不少错误</p>
<p>我并不希望这些内容就这样简短的结束并被掩埋和遗忘，所以我将在<a href="https://ldq3.github.io/" target="_blank" rel="noopener">我的个人博客</a>上持续更新我对使用 Rust 编写 OS 的理解</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2024/05/19/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E6%9D%8E%E5%B1%B9%E6%A5%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2024/05/19/2024%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93-%E6%9D%8E%E5%B1%B9%E6%A5%A0/" class="post-title-link" itemprop="url">2024S 开源操作系统训练营总结-李屹楠</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-19 00:29:45" itemprop="dateCreated datePublished" datetime="2024-05-19T00:29:45+00:00">2024-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:27:22" itemprop="dateModified" datetime="2025-05-15T08:27:22+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/2024%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">2024春夏季开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一阶段总结"><a href="#第一阶段总结" class="headerlink" title="第一阶段总结"></a>第一阶段总结</h1><p>因为想学习 rust,所以找找有没有用 rust 开发的项目，就找到了 rCore，然后刚好看到有个春季训练营，就参加了。刚刷完官方的 Rustlings，所以第一阶段完成的还挺快的。</p>
<h1 id="第二阶段总结"><a href="#第二阶段总结" class="headerlink" title="第二阶段总结"></a>第二阶段总结</h1><p>因为工作上也很忙，所以需要挤出时间来做，在 ddl 的最后一周才开始做，几乎一天一个 lab，也是有点忙坏了。</p>
<p>从课程上来看，因为在 21 年的时候有完成过 xv6-riscv ,所以 rCore 上手的时候主要难度还是在 rust 上面，经常用不明白 rust。又整体复习了一遍操作系统和 rust，希望后面能够继续去写 rust 代码，这感觉很有意思。</p>
<p>感谢清华大学, 感谢 rCore 社区</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/27/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/blog/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/66/">66</a><a class="extend next" rel="next" href="/blog/page/29/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
