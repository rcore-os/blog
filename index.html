<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="rcore-os Blog">
<meta property="og:url" content="http://rcore-os.github.io/blog/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="rcore-os Group">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">705</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">617</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/2025s-os-camp-123-summary-noah/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/2025s-os-camp-123-summary-noah/" class="post-title-link" itemprop="url">2025年春夏开源操作系统训练营三阶段总结-noah</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-05-25 14:33:00 / Modified: 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T14:33:00+00:00">2025-05-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/report/" itemprop="url" rel="index"><span itemprop="name">report</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2025-春季开源操作系统训练营前三阶段总结报告"><a href="#2025-春季开源操作系统训练营前三阶段总结报告" class="headerlink" title="2025 春季开源操作系统训练营前三阶段总结报告"></a>2025 春季开源操作系统训练营前三阶段总结报告</h1><h2 id="学习背景"><a href="#学习背景" class="headerlink" title="学习背景"></a>学习背景</h2><p>在进行网络编程的时候，如果要提高程序的并发性能会用到 io 多路复用和协程，很多框架和语言都会有自己的实现，在逐渐深入的过程中，就会提出一些问题：</p>
<ul>
<li>io 多路复用 select、epoll、io_uring 是如何做到可以提高并发性的</li>
<li>阻塞和非阻塞又是如何做到的</li>
<li>到底什么是同步什么是异步</li>
<li>协程底层是如何实现的</li>
</ul>
<p>这些问题虽然网上有很多资料，但如果自己不亲自去写一些 case 去验证，感觉是很难理解透彻的。而这些技术的实现都是直接或者间接的依赖操作系统才可以做到，也就是说要理解这些知识点，那就必须要学操作系统的知识。</p>
<p>正好我也在模仿着想实现一个协程框架(有栈的)，发现要用到汇编知识，发现写操作系统也需要汇编知识，于是顺手查了下比较好的操作系统课程：</p>
<ul>
<li>南京大学的操作系统</li>
<li>清华大学操作系统 - ucore &amp; rcore</li>
<li>MIT xv6 操作系统</li>
</ul>
<p>在视频网站上看到有人分享参加了开源操作系统训练营，于是便在今年 1 月份就定计划要专供下操作系统的知识，来参与下开源操作系统训练营了，也算是补上十多年前没学好的专业课吧(出来混，早晚都要还的)</p>
<p>另外，也想通过这次的学习，寻找一些志同道合的朋友，一起进步。</p>
<h2 id="学习仓库"><a href="#学习仓库" class="headerlink" title="学习仓库"></a>学习仓库</h2><p>跟着老师和同学们一起学习用的代码仓库，里面包含了每次作业的提交内容</p>
<ul>
<li><a href="https://github.com/LearningOS/2025s-rustling-CreatorMetaSky" target="_blank" rel="noopener">rustling</a></li>
<li><a href="https://github.com/LearningOS/2025s-rcore-CreatorMetaSky" target="_blank" rel="noopener">rcore</a></li>
<li><a href="https://github.com/LearningOS/2025s-arceos-CreatorMetaSky" target="_blank" rel="noopener">ucore</a></li>
<li><a href="https://github.com/osxspace/qhos" target="_blank" rel="noopener">qhos</a> - 记录了一些学习笔记 - 记录的有些凌乱</li>
</ul>
<h2 id="各阶段学习内容总结"><a href="#各阶段学习内容总结" class="headerlink" title="各阶段学习内容总结"></a>各阶段学习内容总结</h2><h3 id="第一阶段-rustling"><a href="#第一阶段-rustling" class="headerlink" title="第一阶段 rustling"></a>第一阶段 rustling</h3><p>rustling 很久之前曾经刷过一遍了，这次是温故知新，复习了以下知识点：</p>
<ul>
<li>rust 的基本语法</li>
<li>模式匹配</li>
<li>所有权转移</li>
<li>容器智能指针</li>
<li>包管理机制</li>
<li>使用 async await</li>
</ul>
<h3 id="第二阶段-rcore"><a href="#第二阶段-rcore" class="headerlink" title="第二阶段 rcore"></a>第二阶段 rcore</h3><p>在学习 rCore 的过程中，首先通读了一遍 <a href="https://learningos.cn/rCore-Tutorial-Guide-2025S" target="_blank" rel="noopener">rCore-Tutorial-Guide</a>， 发现其中大部分章节只是罗列了代码的改动，对于基础知识原理，并没有过多的介绍。<br>又开始阅读学习 <a href="https://rcore-os.cn/rCore-Tutorial-Book-v3" target="_blank" rel="noopener">rCore-Book</a>，后续配合陈渝老师导学阶段的视频(2022年教学视频)，才逐渐走上了学习的正轨。学到了以下知识：</p>
<p><strong>构建操作系统的步骤</strong></p>
<ul>
<li>env setup - 模拟器搭建裸机运行环境</li>
<li>libos - 在内核上跑一个最简单的程序</li>
<li>batchos - 支持批量运行多个程序 - 引入特权级机制</li>
<li>taskos - 实现分时多任务执行</li>
<li>asos - 地址空间以及映射</li>
<li>pos - 进程 - 从 TCB 到 PCB 的进化</li>
<li>fos - 支持文件系统 - 从文件读取程序执行</li>
<li>ipcos - 进程间通信 - shell 的方式进行进程切换</li>
<li>tcos - 线程、协程 - 进程对应资源，线程对应调度</li>
</ul>
<p><strong>操作系统内核核心组件</strong></p>
<ul>
<li>地址空间</li>
<li>进程管理和切换</li>
<li>文件系统</li>
</ul>
<p><strong>学到的具体知识点</strong></p>
<ul>
<li>程序的内存布局结构、如何通过 linker.ld 去修改程序布局</li>
<li>页表机制以及虚拟地址到物理地址的映射方式</li>
<li>进程的协作式调度和抢占式调度以及不同的调度算法的历史演进</li>
<li>文件系统 inode 的结构组织方式，逐层递进的调用方式，为深入理解一切皆 io 打下基础</li>
<li>从进程发展的角度去理解 fork exec spawn</li>
<li>进程间通信 pipe 和 shell</li>
<li>从操作系统源码层面深入的理解进程、线程、绿色线程以及它们的异同</li>
<li>理解互斥、同步的概念，锁、信号量、条件变量</li>
</ul>
<p><strong>帮助理解的知识点</strong></p>
<ul>
<li>操作系统的启动流程</li>
<li>中断和崩溃信号量机制的实现</li>
<li>内存分配和管理机制</li>
<li>IO 多路复用技术</li>
<li>协程以及调度实现</li>
<li>各种锁的实现原理</li>
<li>RingBuffer</li>
<li>LRU</li>
</ul>
<p>通过上述知识的学习，终于明白了操作系统是为上层应用开发提供硬件抽象的一种系统软件实现这句话，也为我揭开了操作系统的神秘面纱</p>
<h3 id="第三阶段-arceos"><a href="#第三阶段-arceos" class="headerlink" title="第三阶段 arceos"></a>第三阶段 arceos</h3><p>arceos 这部分主要是把老师的上课视频给走了一遍，个人理解就是把 rCore 中的各部分代码用 rust 的包管理机制打散，最终做到通过拼装组件就可以形成操作系统的效果，类似应用开发中的模块化和组件化。</p>
<p><strong>学到的知识点</strong></p>
<ul>
<li>unikernel 调用流程，如何从应用层通过系统调用调用内核的实现</li>
<li>如何拼装新的模块到 unikernel 中</li>
<li>理解 unikernel 到 宏内核的转变过程 - 解决特权级切换(用户态到内核态的切换)、地址空间的问题是关键</li>
<li>能够运行标准 linux 二进制 - 这块还是挺感兴趣的</li>
<li>hypervisor 这块牵扯到在虚拟环境中运行 rCore 操作系统 - 个人理解相当于在操作系统中再次嵌套操作系统 - 学的有点吃力了</li>
</ul>
<h2 id="总结学习方法"><a href="#总结学习方法" class="headerlink" title="总结学习方法"></a>总结学习方法</h2><h3 id="渐进式的学习"><a href="#渐进式的学习" class="headerlink" title="渐进式的学习"></a>渐进式的学习</h3><ul>
<li>what - 某个技术是什么，有个初步的认识</li>
<li>when - 什么时候用，在什么情况下或者说上下文下使用这种技术</li>
<li>how - 如何用这种技术，如何写代码</li>
<li>why - 为什么要用，为什么要使用这种技术</li>
<li>build - 内部是如何实现的，自己写一个</li>
</ul>
<h3 id="如何高效学习"><a href="#如何高效学习" class="headerlink" title="如何高效学习"></a>如何高效学习</h3><p>就像面试自己一样，不断地向自己提问题是最好的学习方式，这样才能加深理解，才算是真正理解</p>
<h2 id="遗憾之处"><a href="#遗憾之处" class="headerlink" title="遗憾之处"></a>遗憾之处</h2><ol>
<li>时间上的原因，并没有把自己提问的问题以及理解，全部深入的汇总出来</li>
<li>我们目前是学的 Risc-V 架构的操作系统，但是目前 x86 架构依然是主流，之前 uCore 的操作系统实现就是基于 x86 的，后续还要学习下 uCore 的实现。</li>
<li>在参加这次训练营的过程中，只是走马观花的看和了解了一些基础知识和概念，虽然也做了课后作业，但是跟自己实际上手去实现还是差着十万八千里，对于一些用到的库，基本都是拿来主义，也没有深入的去探索其内部的实现原理，如：内存分配算法，进程调度算法、rust-sbi，希望自己以后还是能脚踏实地的从头跟着 rCore-Book 手搓一个真正自己的操作系统。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/2025%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%9B%B9%E8%BE%B0%E5%AE%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/2025%E6%98%A5%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E6%9B%B9%E8%BE%B0%E5%AE%87/" class="post-title-link" itemprop="url">前三阶段总结报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-05-25 10:12:26 / Modified: 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T10:12:26+00:00">2025-05-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/os/" itemprop="url" rel="index"><span itemprop="name">os</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="各阶段总结"><a href="#各阶段总结" class="headerlink" title="各阶段总结"></a>各阶段总结</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>rust的基本筛查，没什么说的。rust的诸多库日后再学，目前就系统库使用比较多。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>这里是一个简单的小操作系统</p>
<p>好的，这是参照您提供的原文，并进行书面化、精炼化处理后的中文版本：</p>
<h3 id="Chapter-1-应用程序与基本执行环境"><a href="#Chapter-1-应用程序与基本执行环境" class="headerlink" title="Chapter 1: 应用程序与基本执行环境"></a>Chapter 1: 应用程序与基本执行环境</h3><p>本章旨在阐明操作系统作为系统软件与应用层软件在执行环境层面存在的本质差异，而非对操作系统自身的复杂理论进行深入剖析。<br>同时，通过具体的代码范例，演示了在操作系统此种独特的执行环境下构建可执行程序的途径。</p>
<p>用户态程序的运行普遍依赖于特定的语言运行时环境及其附带的标准库。所谓运行时，通常包含预先编译的代码片段，用以实现诸如数组边界检查等基础功能；<br>标准库则对底层系统调用进行了封装，例如，常见的打印函数其内部便是通过<code>write</code>系统调用将数据输出至显示设备。<br>操作系统亦承担了程序运行的准备与善后职责，涵盖虚拟内存空间的辟配、程序代码的加载以及退出时的资源清理等环节。<br>但是，操作系统是直接运行于硬件之上的，并无现成的系统调用或预置软件可供利用，一切功能从零开始编码实现。</p>
<h3 id="Chapter-2-批处理系统"><a href="#Chapter-2-批处理系统" class="headerlink" title="Chapter 2: 批处理系统"></a>Chapter 2: 批处理系统</h3><p>本章的核心议题集中于系统调用的具体实现过程，此过程涉及较多工程实践层面的细节。从上下文保存与恢复的视角来看，系统调用与常规的函数调用具有相似性：<br>两者均要求在调用发生前保存当前的执行上下文（主要指寄存器状态），并在调用返回时予以恢复，<br>这与编译原理中函数调用的序言（prologue）和尾声（epilogue）机制异曲同工。</p>
<p>其主要差异体现在以下两个方面：</p>
<ol>
<li>操作系统必须负责保存所有的通用寄存器（因为用户态的调用约定对此并无保障）以及一系列关键的控制状态寄存器（CSRs），例如<code>sstatus</code>（记录CPU当前的特权级别）、<code>sepc</code>（记录发生trap时的指令地址，即trap返回后应继续执行的地址）、<code>scause</code>/<code>stval</code>（分别记录trap发生的原因及相关的附加信息）。这些CSRs对于用户态程序而言通常是透明的。</li>
<li>出于安全性的考量，操作系统必须为内核态的执行维护一个独立的内核栈，而非在用户栈的基础上进行扩展。RISC-V架构为此提供了<code>sscratch</code>寄存器，可用于保存内核栈的地址。当陷入（trap）发生时，操作系统可以从<code>sscratch</code>寄存器中获取内核栈的起始地址，并切换至内核栈上开始后续处理。</li>
</ol>
<p>另外，在此阶段，所有的内存操作均基于物理地址进行，尚未实现内核态与用户态之间的内存隔离。<br>理论上，应用程序能够访问包括内核栈在内的所有物理内存区域，这具有极大的潜在风险。此内存隔离问题将在后续实现虚拟内存机制时得到解决。</p>
<h3 id="Chapter-3-多道程序与分时多任务"><a href="#Chapter-3-多道程序与分时多任务" class="headerlink" title="Chapter 3: 多道程序与分时多任务"></a>Chapter 3: 多道程序与分时多任务</h3><p>第三章引入了抢占式（preemptive）机制。这使得操作系统能够以分时复用的方式交替运行多个程序，从而显著提升了系统的交互体验。</p>
<p>实现分时系统的关键技术在于引入了时钟（timer）中断。定时器会周期性地产生中断信号，使操作系统得以重新获得CPU的控制权，<br>并依据预设的调度策略来决定是否需要切换到另一个应用程序执行。这种应用程序间的切换过程，与系统调用的处理流程相似，均涉及到中断当前应用的执行并在稍后某个时刻恢复其运行，<br>因此同样需要对应用程序的运行上下文进行细致的保存与恢复。</p>
<p>在本章中，应用程序被抽象为“任务”（Task）的实体，并通过“任务控制块”（Task Control Block, TCB）的数据结构来进行统一的调度与管理。<br>实验任务之一是实现<code>trace</code>系统调用。一个值得注意的实现细节是，若实验要求分别统计每个应用程序的系统调用次数，这通常需要借助特定的数据结构<br>（例如二维数组）来实现。在设计实现时，若将此统计结构直接置于<code>TaskControlBlock</code>内部，可能会因<code>TaskControlBlock</code>自身内存布局或大小的限制而引发内核崩溃。<br>因此，将此类统计结构设计在更高层级的<code>TaskManager</code>中，通常是更为稳妥和健壮的方案。</p>
<h3 id="Chapter-4-地址空间"><a href="#Chapter-4-地址空间" class="headerlink" title="Chapter 4: 地址空间"></a>Chapter 4: 地址空间</h3><p>本章的核心内容围绕虚拟内存的实现展开。通过引入虚拟内存机制，每个应用程序都能拥有各自独立的、私有的地址空间，从而无需关心其在物理内存中的实际存储位置。<br>虚拟内存的管理主要依赖于诸如<code>MemorySet</code>和<code>MapArea</code>（原文提及<code>MemoryMap</code>，但在教程实践中<code>MapArea</code>更为常用）等精心设计的数据结构，<br>其核心设计思想与Linux等成熟操作系统中的虚拟内存管理机制存在共通之处。</p>
<p>硬件层面，内存管理单元（MMU）承担了虚拟地址到物理地址的自动翻译工作。操作系统仅需将页表的根节点指针（例如在RISC-V架构中，<br>此指针存放于<code>satp</code>寄存器）加载到特定的控制寄存器中，即可启用地址翻译功能。</p>
<p>虚拟内存机制的引入，对内核的整体结构进行了一次较大规模的重构。其主要原因在于，先前在系统调用处理和程序切换过程中所保存的上下文内容，<br>由于地址空间的根本性变革，必须进行相应的调整以适应新的内存模型。此过程涉及到若干复杂的技术细节：<br>例如，在启用虚拟内存之后，当程序从用户态陷入（trap）到内核态时，内核需要借助应用态的页表（或预设的内核自身映射关系）来访问并保存用户程序的上下文信息。<br>此外，由于内核与应用程序的地址空间通常是不同的（或者说，它们各自拥有不同部分的内存映射），在从用户态陷入内核态之前，<br>往往需要借助一个位于固定虚拟地址的“跳板页”（trampoline page）来实现上下文的平滑、安全切换。这些具体的设计考量与实现细节，<br>可能是在先前纯理论学习阶段未曾深入探究的。</p>
<p>本章实验中的一个难点可能在于<code>sys_trace</code>函数的移植。当需要向目标地址写入数据时，<br>一个常见的理解误区涉及对物理页号（Physical Page Number, PPN）的认知：PPN本身并非一个带有零填充的完整物理地址，它仅仅是物理页帧的一个编号。<br>正确的物理地址应通过将PPN左移页大小对应的位数（PAGE_SIZE，通常为12位，即乘以$2^{12}$），再加上页内偏移（offset）来计算得到。</p>
<h3 id="Chapter-5-进程"><a href="#Chapter-5-进程" class="headerlink" title="Chapter 5: 进程"></a>Chapter 5: 进程</h3><p>本章正式引入了“进程”（Process）这一核心概念。进程可以被视为前四章所学知识（例如内存管理、任务调度等）的进一步抽象、封装与整合。<br>进程抽象使得操作系统能够支持更为丰富和高级的语义，例如实现更为灵活多样的进程调度策略，<br>以及通过<code>fork()</code>和<code>exec()</code>等经典的系统调用来创建新进程和加载执行新程序。本章还通过实现一个简易的Shell，使得该实验性操作系统在功能完备性上又迈进了一步。</p>
<p>本章内容主要在于如何有机地结合前述章节所介绍的技术手段来实现进程这一核心概念，并补充了进程管理相关的诸多细节，<br>例如初始进程（init process）的启动流程、进程正常或异常退出后的资源回收（reap）机制等。</p>
<p>本章的实验内容可能包括：</p>
<ul>
<li><code>spawn</code>系统调用：其实现可视为<code>fork</code>与<code>exec</code>系统调用的某种组合。但其区别在于，<code>spawn</code>通常用于创建一个全新的进程来执行一个指定的程序，</li>
<li>它会为新进程创建全新的地址空间（<code>MemorySet</code>）并加载目标程序，而不是像<code>fork</code>那样完全复制父进程的地址空间。</li>
<li>stride调度算法：其实现主要是在调度器（例如<code>TaskManager</code>）的数据结构中为每个进程维护其步长（stride）和优先级（priority）等属性，</li>
<li>并依据这些属性进行调度决策。在透彻理解相关数据结构之后，该算法的实现过程相对较为清晰。</li>
</ul>
<h3 id="Chapter-6-文件系统"><a href="#Chapter-6-文件系统" class="headerlink" title="Chapter 6: 文件系统"></a>Chapter 6: 文件系统</h3><p>本章介绍了文件系统的具体实现，这一机制使得程序和数据能够持久化地存储在块设备（如磁盘）之上，而不仅仅是暂时驻留在易失性的内存之中。<br>尽管文件系统的基本理论可能已在其他课程中有所涉猎，但通过本章的实际动手实现，学习者可以深入了解到诸多实践层面的细节，<br>例如操作系统是如何与磁盘驱动程序进行交互的。由于磁盘驱动程序通常已经提供了一层硬件抽象（例如通过<code>BlockDevice</code> trait定义接口），<br>文件系统的实现便主要集中在遵循这些预定义的接口规范，并构建文件系统自身的逻辑结构（例如inode、dentry、superblock等核心概念的实现）。</p>
<p>在实验中实现硬链接（hard link）功能时，正确的处理方式是在目录条目（directory entry）中将新的文件名链接到目标文件的inode之上，<br>而不是为每一个硬链接都创建一个全新的inode副本。</p>
<p>实验过程中可能的问题：在向<code>DiskInode</code>等核心数据结构中添加过多字段时，有时可能会偶发性地触发与虚拟内存相关的<code>LoadPageError</code>或类似的错误，<br>且这种错误行为可能表现出一定的随机性或平台依赖性。其深层原因可能与数据结构在内存中的对齐方式、大小变化触及了某些边界条件，<br>或是与底层内存管理模块之间存在一些微妙的交互问题有关，这类问题通常具有较高的调试难度。</p>
<p>此外，由于引入了标准输入（stdin）和标准输出（stdout）的概念（它们通常作为文件描述符0和1存在），在通过<code>spawn</code>或类似机制创建新进程时，<br>必须确保正确初始化其文件描述符表，特别是<code>stdin</code>和<code>stdout</code>的指向，<br>否则可能导致新创建的进程无法正常进行输入输出操作（例如，测试程序可能无法打印任何内容到控制台）。</p>
<h3 id="Chapter-7-进程间通信"><a href="#Chapter-7-进程间通信" class="headerlink" title="Chapter 7: 进程间通信"></a>Chapter 7: 进程间通信</h3><p>本章内容有助于加深对Shell命令执行机制的理解，特别是关于管道（pipe）和重定向（redirection）的处理方式。例如，对于形如<code>a | b</code>的管道命令，<br>以及包含输入/输出重定向的复杂命令（如<code>cmd xx &gt; yy &lt;&lt; zz</code>），<br>其解析和执行流程并非简单的串行化处理，而是由Shell进行统一的调度与编排，从而在不同程序（进程）之间建立起正确的数据流。</p>
<p>本章的核心技术在于，通过为不同类型的IPC（Inter-Process Communication，进程间通信）资源（例如管道Pipe）实现一个统一的<code>File</code><br>trait（可理解为接口或特性），使得进程可以使用与文件操作相一致的文件描述符来管理这些IPC资源。举例来说，标准输出可以被视为一个实现了<code>File</code><br>trait的对象，对其执行<code>write</code>操作最终会将数据导向屏幕显示或传递给管道的下一级。</p>
<p>I/O重定向（例如使用<code>&gt;</code>和<code>&lt;</code>符号）也遵循相似的原理：操作系统层面通过修改目标进程文件描述符表中的相应条目，<br>使其指向特定的文件或其他I/O端点，从而实现数据流向的改变。</p>
<p>对于其他形式的进程间通信机制，例如基于环形缓冲区（ring buffer）实现的管道，同样可以为其封装<code>read</code>和<code>write</code>等文件操作接口。<br>当进程调用这些接口时，数据被读入或写入共享的环形缓冲区，以此方式实现了进程间的数据交换。</p>
<h3 id="Chapter-8-并发"><a href="#Chapter-8-并发" class="headerlink" title="Chapter 8: 并发"></a>Chapter 8: 并发</h3><p>本章探讨了操作系统与并发编程中的若干经典并发控制机制，例如锁（包括互斥锁Mutex、自旋锁SpinLock）、信号量（Semaphore）以及条件变量（Condition Variable）。</p>
<p>本章关于线程（Thread）管理的具体实现尤为值得关注。在此阶段，rCore的调度模型进一步向类Linux系统演进：线程成为基本的调度单位，<br>而进程（Process）则更多地扮演资源容器的角色，负责管理诸如文件描述符表（<code>fd_table</code>）、地址空间（<code>MemorySet</code>）等由同一进程内所有线程共享的资源。</p>
<p>为了支持多线程，进程需要为每一个在其内部运行的线程维护独立的运行上下文（Trap Context）和内核栈（Kernel Stack）。<br>由于同一进程内的所有线程共享相同的地址空间，它们的线程栈（用户态栈）通常被统一分配和管理在进程用户地址空间内的特定区域<br>（或者由内核统一管理，但对用户而言是透明的）。线程切换的机制，在保存和恢复上下文方面，与早期章节中描述的任务切换机制基本一致。<br>若发生跨进程的线程切换（即从一个进程中的线程切换到另一个不同进程中的线程），<code>switch</code>函数除了需要切换线程的上下文外，<br>还必须负责切换地址空间（即更换当前生效的页表），以确保线程能够在新的目标进程的地址空间中正确运行。</p>
<p>本章的实验任务之一是实现银行家算法（Banker’s Algorithm），这是一个经典的用于避免死锁的算法。</p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>arcore 阶段，这是另一个更严谨也更复杂一点的系统</p>
<h3 id="组件化基础-Unikernel内核"><a href="#组件化基础-Unikernel内核" class="headerlink" title="组件化基础 - Unikernel内核"></a>组件化基础 - Unikernel内核</h3><h4 id="课堂"><a href="#课堂" class="headerlink" title="课堂"></a>课堂</h4><p>组件化内核设计，即通过选择和组合可复用的软件模块来构建内核。这种方法使得构建各种类型的内核（从简单的 Unikernel<br>到更复杂的宏内核或 Hypervisor）具有灵活性，可以通过增量添加或扩展组件来实现。系统的启动过程也正体现了这一理念：<br>首先由特定于体系结构的硬件抽象层 (axhal) 进行早期设置（如 MMU 和栈初始化），然后转换到通用运行时环境 (axruntime)，<br>后者会初始化日志、内存分配器和调度器等更多系统，并最终运行主应用程序。通过features可以实现定制化，允许开发者编译仅包含特定应用所需组件的内核。</p>
<p>之后我们讲了内存管理。</p>
<p>内存管理 是一个关键方面，包含两个核心领域：</p>
<p><strong>分页 (paging)</strong> 是分阶段实现的。这类似于现代操作系统（如 Linux 或 Windows）中的虚拟内存机制。<br>一个强制的初始阶段建立基本的内存映射（例如，内核代码和数据的直接映射）；<br>一个可选的第二阶段则重建更完整、更细粒度的虚拟到物理地址映射 ，这对于管理更大的地址空间（如整个物理内存上限）和设备 MMIO（内存映射 I/O，例如 UART、VirtIO 插槽的物理地址 0x1000_0000 等被映射到虚拟地址 0xffff_ffc0_1000_0000 ）至关重要。</p>
<p>通过 axalloc 组件引入了 动态内存分配，它提供了一个 GLOBAL_ALLOCATOR 。这与 C 语言中的 malloc/free 或 C++ 中的 new/delete 作用类似。该分配器支持字节和页分配，并采用了多种算法（如文稿中提到的 TLSF、Buddy、Slab 算法 ），从而能够支持像 Rust 的 Vec（动态数组）或 HashMap（哈希表）这类需要动态调整大小的数据结构 。</p>
<p><strong>任务管理与调度</strong>对于实现并发至关重要。系统定义了任务状态（如图中所示的运行、就绪、阻塞、退出 ），并使用 TaskContext（保存了如 ra 返回地址、sp 栈指针以及 s0-s11等被调用者保存寄存器 ）在上下文切换期间保存和恢复任务状态。探讨了多种调度算法：</p>
<p>协作式 FIFO调度：任务会一直运行，直到完成或主动调用 yield_now  放弃 CPU。这与早期单任务操作系统或者一些需要应用明确出让控制权的系统（如早期的 Windows）相似。<br>但是，如果一个任务陷入死循环或长时间不调用 yield_now，其他任务将得不到执行机会，造成系统“假死”。</p>
<p>抢占式轮询 (Round Robin, RR) 调度：为任务分配时间片（如 MAX_TIME_Slice ），当定时器中断发生，发现当前任务时间片耗尽时，调度器可以抢占该任务，并将其移至就绪队列的末尾 。这常见于简单的实时操作系统或分时系统。<br>注意时间片设置过短会导致频繁的上下文切换，增加系统开销；设置过长则会降低系统的响应速度。<br>完全公平调度器 (Completely Fair Scheduler, CFS)：这种抢占式算法使用一个名为 vruntime (虚拟运行时间) 的概念来确定任务优先级 。vruntime 最小的任务将下一个运行，而 vruntime 的值受任务实际运行时间和其 ‘nice’ 值（优先级）的影响 。Linux 当前的默认调度器就是 CFS 的一种实现。</p>
<p>最后是设备交互与文件系统：</p>
<p>设备管理框架 (AllDevices)  为访问不同类型的设备（如块设备、网络设备和显示设备 ）提供统一途径，类似于 Windows 中的设备管理器或 Unix 系统中的 /dev 目录。例如，当需要访问某个 VirtIO 块设备时，上层会通过 AllDevices 查找对应的驱动实例。<br>注意，设备驱动在 probe 阶段（如 probe_bus_devices  或针对 QEMU VirtIO MMIO 的地址范围探测 ）如果未能正确识别硬件或初始化失败，设备将无法使用。我在做题时因为漏了一个参数卡了半天（真半天）</p>
<p>VirtIO 模型被用作设备驱动程序的示例，突出了 vring（一种共享内存环形缓冲区）在客户机和主机之间高效通信以及中断处理方面的应用 。这是一种在虚拟化环境中（如 QEMU ）常用的半虚拟化设备接口。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>大部分题都在这一阶段，print_color更改下宏的定义就可以。hashmap我参考了hashbrown</p>
<p><strong>hashbrown</strong></p>
<p>hashbrown 之所以高效，主要归功于其精妙的SwissTable算法实现，该算法源自 Google。其核心优势在于缓存友好 (cache-friendliness) 和SIMD (Single Instruction, Multiple Data) 指令集的有效利用。</p>
<p>下面是一些核心要点：</p>
<p>开放寻址 (Open Addressing)：与链式哈希表（separate chaining）不同，hashbrown 使用开放寻址策略，将所有条目直接存储在主哈希表数组中。这减少了指针间接寻址带来的开销，并提高了缓存局部性。当发生哈希冲突时，它会探测（probe）数组中的其他位置，直到找到一个空槽。</p>
<p>二次探测：简单易懂，就是遇到冲突后再次探测</p>
<p>元数据与主数据分离存储: hashbrown 将每个槽的元数据（例如哈希值的高位和控制字节）与实际的键值对分开存储。元数据通常更小，可以更紧凑地排列。</p>
<p>SIMD 优化查找: hashbrown 利用 SIMD 指令并行地检查多个元数据槽。它将哈希值的一部分（通常是高7位）存储在控制字节中。在查找、插入或删除操作时，可以加载一组控制字节（例如16个字节），并使用单个 SIMD 指令与目标哈希值的高位进行比较。这极大地加速了匹配过程，尤其是在哈希表密集的情况下。</p>
<p>特殊控制字节 (Special Control Bytes)：控制字节不仅存储部分哈希值，还用于标记槽的状态，例如：</p>
<p>EMPTY: 槽为空。<br>DELETED (或称 TOMBSTONE): 槽之前被占用但现在已删除。这对于开放寻址的正确探测至关重要。<br>FULL: 槽已占用，并存储了部分哈希值。<br>低开销的元数据: 每个条目仅需要1字节的元数据开销（控制字节），这比许多其他哈希表实现要低得多，从而提高了内存效率。</p>
<p>默认使用快速的非加密哈希算法: hashbrown （以及现在 Rust 标准库中的 HashMap）通常默认使用像 FxHash 或类似的快速非加密哈希算法。这类哈希算法对于整数等简单键类型非常快，但可能不适用于需要抵抗哈希洪水攻击 (HashDoS) 的场景。</p>
<p><strong>bump内存算法</strong><br>这里我们的bump_allocator是一个双端分配器，一边是零散的小字节分配，一边是整页分配。只要注意好内存检查（插入内存有没有侵入已分配的这端的，以及<br>如果分配的特别多会不会影响到另一端的），然后两个标记指明当前内存分配位置即可。</p>
<h3 id="Monolithic-Kernel宏内核"><a href="#Monolithic-Kernel宏内核" class="headerlink" title="Monolithic Kernel宏内核"></a>Monolithic Kernel宏内核</h3><h4 id="课堂-1"><a href="#课堂-1" class="headerlink" title="课堂"></a>课堂</h4><p><strong>异构内核扩展</strong></p>
<p>核心目标是在保证可扩展性和高性能的前提下，让不同内核架构（如Unikernel、宏内核、Hypervisor）能够复用核心组件（称为”Backbone”）和系统服务 。</p>
<p>任务（Task）单元的扩展 是关键，因为任务是内核资源的集合体 。Unikernel的任务可能仅包含基本的上下文信息，而宏内核任务需要页表信息和文件描述符，Hypervisor任务则需要VCPU状态等 。<br>为了优雅地处理这些差异，而不直接修改核心Task结构（这会降低可读性和异构扩展性 ），或者避免像旧版Starry那样通过TaskID索引外部结构（这会带来性能开销 ），ArceOS引入了 extension域机制 。<br>这类似于在C语言结构体中预留一个void*指针，具体类型由使用者定义。具体做法是在Task结构中增加一个extension指针，外部模块可以预先定义好特定于某种内核模式的扩展对象（例如，宏内核的进程控制块），<br>然后在创建任务时在堆上分配内存给这个扩展对象，并将extension指针指向它 。这样，访问扩展域的开销接近于普通结构体成员访存，同时保证了不同内核模式按需扩展的灵活性 。<br>例如，宏内核的扩展可以包含指向其独立地址空间（页表）的引用和文件描述符表。未来的工作甚至设想了扩展的泛型化，使得不同类型的任务（Unikernel任务、宏内核进程、自定义任务）<br>可以携带不同的扩展，并在同一套调度、文件系统、网络框架下运行，例如在众核处理器上，某些核心运行Unikernel任务进行高性能计算，另一些核心运行宏内核任务负责管理和交互 。</p>
<p>系统服务的复用 也是一个重要议题，特别是如何让Unikernel已经提供的服务（如文件描述符表 Fd_table、虚拟内存管理、API处理器）方便地被其他架构（如宏内核）复用 。<br>挑战在于资源的隔离与共享：Unikernel中资源通常是全局唯一的，而宏内核中资源则归属于进程，并通过clone等机制控制共享 。<br>一个具体的复用目标是arceos_posix_api，它原本为Unikernel提供POSIX接口适配，但在宏内核场景下，可以直接复用其复杂的语义检查逻辑作为SYSCALL层的一部分，而无需为宏内核重新实现一套，从而减少冗余和开发精力 。<br>为了实现这种复用，引入了Resource（定义资源，使用Arc指针管理以支持共享）和NameSpace（保存所有Resource的集合）的概念 。对于Unikernel，NameSpace是全局唯一的；对于宏内核，每个任务（进程）拥有一份NameSpace，可以动态分配 。<br>Global namespace的布局可以在编译期通过link_section将所有全局Resource集中在特定段（如axns_resource段）来确定 。<br>当宏内核需要独有的NameSpace时，可以在堆上分配空间并将全局NameSpace拷贝过去；需要共享时，则利用Arc指针指向全局或父进程的Resource，<br>这样修改对共享的线程间可见，同时避免了不必要的拷贝开销 。这种设计使得新功能（如新的系统调用或资源类型）更容易接入，并与组件化思想联动。</p>
<p>总结来说，面对未来多样化的应用场景（如智能家居中需要高性能Unikernel的边缘节点和需要安全性的微内核或宏内核的控制中枢 ），组件化为异构内核的快速构建提供了有力支持，<br>它通过Unikernel基座和精心设计的扩展机制（如Task extension和Namespace），在最大化组件复用和灵活性的同时，兼顾了不同内核模式的特性需求 。<br><strong>宏内核演进</strong></p>
<p>核心在于引入用户特权级、独立的用户地址空间以及系统调用机制，最终目标是能够直接运行原始的Linux应用程序（二进制）。</p>
<p>从未经修改的Linux应用（通常使用glibc或musl-libc编译）的角度看，它期望运行在一个与内核隔离的用户地址空间，并通过标准的系统调用（syscall）接口与内核交互 。<br>为了实现这种兼容性，组件化宏内核需要在几个层面进行适配：</p>
<p>用户地址空间的创建与管理：与Unikernel共享单一地址空间不同，宏内核为每个用户应用（进程）创建独立的页表和地址空间（AddrSpace对象）。<br>通常，页表的高端部分映射内核空间（所有进程共享），低端部分则映射独立的用户应用空间 。这意味着加载应用时，<br>内核会将ELF文件的代码段和数据段加载到用户地址空间的预定虚拟地址 。</p>
<p>ELF格式应用的加载：大多数应用编译为ELF格式。内核需要解析ELF头获取入口点（Entry point）以及各个段（Segment）的信息，<br>特别是类型为LOAD的段（代码段和数据段）。需要注意，ELF文件中段的偏移（Offset）和文件大小（FileSiz）可能与加载到内存后的虚拟地址（VirtAddr）<br>和内存大小（MemSiz）不同，尤其是BSS段（未初始化数据段），它在ELF文件中不占空间，但加载时需要在内存中预留并清零 。</p>
<p>用户栈的初始化：Linux应用（尤其是使用标准C库的应用）的main函数执行前，C库的启动代码会检查用户栈上的参数，如argc（参数个数）、<br>argv（参数指针数组）和envp（环境变量指针数组），甚至auxv（辅助向量）。因此，内核在切换到用户态执行应用首条指令前，<br>必须在用户栈上按照约定的布局准备好这些信息，并正确设置用户栈指针（SP寄存器）。<br>特权级切换与系统调用处理：应用通过特定的指令（如RISC-V的ecall ）陷入内核态发起系统调用。内核需要在异常处理流程中识别出系统调用，<br>并根据调用号分发到相应的处理函数 。例如，示例m_3_0中涉及的set_tid_address (96), ioctl (29), writev (66), exit_group (94)等都是具体的系统调用 。<br>对于从内核态首次启动用户任务，由于多数架构没有直接的“切换到用户态”指令，一种常见的做法是在内核态伪造一个来自用户态的异常上下文现场（包括用户态的PC、SP、状态寄存器等），<br>然后通过异常返回指令（如RISC-V的sret）“返回”到用户态开始执行应用 。</p>
<p>任务属性扩展：为了在复用Unikernel调度机制的同时支持宏内核的进程概念，TaskInner结构通过ext成员进行了扩展 。<br>这个ext可以是一个空结构体（对于Unikernel），也可以是一个包含进程特有信息（如指向其用户地址空间AddrSpace的引用、进程ID等）的结构体（对于宏内核）。<br>这使得调度器只关注通用的任务属性，而将资源管理等模式相关的特性封装在扩展中 。</p>
<p>为了支持更高级的内存管理特性，如 缺页加载（Lazy Loading）和内存映射（mmap），内核需要处理页错误（Page Fault）异常 。<br>当应用访问一个尚未建立有效物理映射的虚拟地址时（例如，通过init_user_stack(&amp;mut uspace, false)设置用户栈为Lazy映射 ），会触发页错误。<br>内核的页错误处理函数（如handle_page_fault）会介入，它通常会查找该虚拟地址所属的MemoryArea（内存区域）。每个MemoryArea关联一个Backend，<br>负责具体的映射操作 。Backend可以有两种主要类型 ：</p>
<p>Linear Backend：用于已存在的、连续的物理内存区域的直接映射，例如设备MMIO或共享内存。</p>
<p>Alloc Backend：用于按需分配物理页帧并建立映射。在缺页异常发生时，Alloc后端会申请物理页帧，然后在页表中补齐映射 。<br>sys_mmap系统调用的实现也与此类似：如果populate参数为true，则立即分配并映射；如果为false，则仅建立空映射，<br>等待后续访问时通过缺页异常来实际分配物理页面 。</p>
<p>此外，为了更好地兼容Linux生态，还需要支持像ProcFS、SysFS这样的 伪文件系统，它们提供内核和进程信息的接口（如/proc）或暴露设备信息（如/sys）。<br>在ArceOS中，这些可以通过axfs_ramfs的实例或专门的axfs_devfs组件来实现 。</p>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><strong>page_fault</strong></p>
<p>缺页相应，这里其实系统里已经有不少实现了，我们只需要获取当前用户空间，然后调用find_free_area和map_alloc就可以了</p>
<p><strong>ramfs_rename</strong></p>
<p>这里首先要修正依赖，让测试依赖本地的axramfs（笑），这里依赖本地的库之后，在dir.rs中添加rename的函数，这里底层是用了BTreeMap来保存<br>已经申请过的文件，然后值对应着在内存中的物理节点。更改BTreeMap就可以了，字符串处理仿照其他实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5rcore%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97-%E8%83%A1%E6%97%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5rcore%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97-%E8%83%A1%E6%97%AD/" class="post-title-link" itemprop="url">第二阶段rcore学习心得-胡旭</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T08:53:05+00:00">2025-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这次的学习rcore有点艰辛，因为是把一个操作系统内核给完成了，虽然也只是补充了syscall里面的函数，但是&gt;把整体内核需要什么部件给摸索清楚了<br>出了有关rust语言特殊机制的bug，就看看别的函数是怎么写出规范的rust代码的，虽然看了文档后有个思路去写<br>那个函数，但是不知道怎么写时，参考周围代码就好多了，让我印象比较深的是，当一个结构体的对象要被调用&gt;的时候，比如inner，通常需要加个exclusive_access（）或者unwrap（）等等，这个rust语言虽然没有像C语言&gt;那么底层，但是感觉这么一写，就不会出现内存问题，很规范。再不会通常只能问大佬了哈哈哈。<br>在这个训练营，大佬云集，接触到了很多才学渊博的人，大家也来自不同的专业，有着不同的志向，也坚定了我&gt;跨越专业去学习更多知识的信心。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/%E6%A2%A6%E9%86%92%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/%E6%A2%A6%E9%86%92%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">梦醒的学习记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T08:53:05+00:00">2025-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>title: 梦醒的学习记录<br>date: 2025-03-25 21:02:12<br>tags:<br>mathjax: true</p>
<hr>
<p>今天重写了一遍rustlings，虽然在其他训练营已经写过了，但是这次依然有收获。比如我了解到了<br>match时的ref有什么作用，以及他和&amp;的区别</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/yjymosheng-2024%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/yjymosheng-2024%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2024三阶段总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T08:53:05+00:00">2025-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2024三阶段总结"><a href="#2024三阶段总结" class="headerlink" title="2024三阶段总结"></a>2024三阶段总结</h1><h2 id="Unikernel"><a href="#Unikernel" class="headerlink" title="Unikernel"></a>Unikernel</h2><blockquote>
<ul>
<li>print_with_color </li>
</ul>
<p>简单的利用ascll字符实现颜色</p>
<ul>
<li>support_hashmap</li>
</ul>
<p>看群内大佬讨论，就引了一个库</p>
<ul>
<li>alt_alloc</li>
</ul>
<p>这个难度不大，因为测例很简单。严格实现后我确实也不知道自己实现的正确与否</p>
<ul>
<li>shell</li>
</ul>
<p>原shell实现了有关rename的，rename我就直接调库了，然后通过创建文件、copy文件内容、删除原文件拼接除了mv的功能</p>
<ul>
<li>1115挑战（内存调度算法实现优化）</li>
</ul>
<p>说来惭愧，我这个印象最深。我写了3次，第一次好像是80多，第二次直接没跑起来，第三次是链表指针不知道指到哪里去了….反正都没超过170,也就没提交….</p>
</blockquote>
<h2 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h2><blockquote>
<ul>
<li>page_fault</li>
</ul>
<p>难度适中？ 感觉就是rcore上了一点</p>
<ul>
<li>sys_map</li>
</ul>
<p>就find_free_area然后read进去，虽然感觉用find_free_area找到的地方有些不符合man mmap的说明。</p>
</blockquote>
<h2 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h2><p>第一次了解hypervisor具体是怎么操作、干了什么….涨知识了…</p>
<blockquote>
<ul>
<li>simple_hv</li>
</ul>
<p>改一下guest的sepc，设置一下a0、a1的值</p>
<ul>
<li>pflash设备模拟方式</li>
</ul>
<p>一开始没有搞清gpa映射到hpa时，没有经过host的satp，导致在host中拿着pa当va来用，出现了问题。另外，在完成后，修改了一下pflash的内容，想要读u128转string输出，但是没想到，在对* u128解引用时，它居然会先读u128的高64位，导致映射时页面没对齐。</p>
</blockquote>
<h1 id="2024四阶段总结-Starry-Next-项目二方向一-感想"><a href="#2024四阶段总结-Starry-Next-项目二方向一-感想" class="headerlink" title="2024四阶段总结 - Starry-Next 项目二方向一 感想"></a>2024四阶段总结 - Starry-Next 项目二方向一 感想</h1><h1 id="仓库链接-https-github-com-yjymosheng-Starry-On-ArceOS-tree-main"><a href="#仓库链接-https-github-com-yjymosheng-Starry-On-ArceOS-tree-main" class="headerlink" title="仓库链接: https://github.com/yjymosheng/Starry-On-ArceOS/tree/main"></a>仓库链接: <a href="https://github.com/yjymosheng/Starry-On-ArceOS/tree/main" target="_blank" rel="noopener">https://github.com/yjymosheng/Starry-On-ArceOS/tree/main</a></h1><h1 id="最终-commit-ID-71650c57f8ef9a64a6bdf274d9890b5c0c96642d"><a href="#最终-commit-ID-71650c57f8ef9a64a6bdf274d9890b5c0c96642d" class="headerlink" title="最终 commit ID: 71650c57f8ef9a64a6bdf274d9890b5c0c96642d"></a>最终 commit ID: 71650c57f8ef9a64a6bdf274d9890b5c0c96642d</h1><h1 id="目前进展"><a href="#目前进展" class="headerlink" title="目前进展:"></a>目前进展:</h1><p>已经完成的syscall </p>
<p><img src="https://github.com/user-attachments/assets/835aaaf3-a3a4-4fc4-9214-f5c58e8af0f2" alt="a"></p>
<p>没有完成的syscall </p>
<p><img src="https://github.com/user-attachments/assets/7a21edfe-817f-4f42-84ed-fe0e488d6122" alt="b"></p>
<h3 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想 :"></a>个人感想 :</h3><p>这时我第二次参加os训练营,第一次的时候连rcore都没有完成,这一次由于对syscall的理解不够,相比其他同学浪费了很多时间在img的调试上.</p>
<p>可能下一次就能拿到优秀学员证书了也说不定?一次更比一次强嘛</p>
<p>虽然我的四阶段的学习可能差强人意,但是对我来说算是打开了操作系统的大门,希望明年的操作系统大赛上,能够有新的突破.</p>
<p>通过这次训练营，我进行了第一次对操作系统的尝试,与还对系统调用有了更加全面的认识。编写一个自己的操作系统不再只是纸上谈兵，而是一种有希望实现的技术。回顾整个过程，既有苦涩，也有喜悦，更重要的是，这让我对操作系统这条路充满了信心和期待。</p>
<p>希望未来，我能够在操作系统道路上走得更远，探索更多未知的可能性！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/reganzm-s-SOS/lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/reganzm-s-SOS/lab1/" class="post-title-link" itemprop="url">reganzm-s-SOS/lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T08:53:05+00:00">2025-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一直以来对OS非常感兴趣，通过本次的“代码调试”，熟悉了整个项目架构，并对OS有了进一步的深刻认识。在调试过程中不仅熟悉了OS，还对Rust语言有了更深入的认识。<br>本次实现的功能是打印任务信息：系统调用及调用次数，运行时间。<br>整体思路：在syscall入口处调用set_task_info方法。每调用一次系统调用，更新一次syscall_times和time。<br>踩的坑：需要注意Rust结构体与C结构体的区别，Rust编译器会对Rust中的字段进行重排序，以达到优化存储的目的。在OS中的结构体和user中的结构体字段要保持一致，否则会蛋疼:(<br>另外附图一张，表示我曾用心学习:)</p>
<p><img src="/blog/.io//%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.png" alt="笔记"></p>
<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>应用分别出现：</p>
<ul>
<li>PageFault in application, bad addr = 0x0 bad instruction = 0x804003a4 , kernel killed it.</li>
<li>IllegalInstruction in application, kernel killed it.<br>使用的sbi版本是：RustSBI version 0.3.0-alpha.2 </li>
</ul>
<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>1.刚进入__restore时，a0代表kernel stack pointer ， restore的两种使用场景：a.trap 恢复 b.创建新任务</p>
<p>2.处理了sstatus sepc sscratch。sstatus用于指定返回的特权级(SPP字段)；sepc用于指定返回后执行哪条指令；sscratch存储着用户栈地址，U态程序要执行必须正确找到U态的栈地址。</p>
<p>3.application不会使用x4;x2已经被交换到了sscratch代表着用户栈指针</p>
<p>4.sp指向user stack , sscratch 指向kernel stack</p>
<p>5.__restore总状态切换在csrw sstatus,t0这行指令，sstatus中的SPP字段记录了陷入前的特权级，csrw sstatus,t0执行后，恢复到用户特权级。最后的指令sret ，指令返回用户程序，原因是该指令会从sepc中读取指令地址，并赋予pc寄存器，而U态的栈等已恢复好，sret临门一脚，步入U世界。</p>
<p>6.指令之前sp -&gt; user stack , sscratch -&gt; kernel stack ;指令后sp -&gt; kernel stack, sscratch -&gt; user stack。指令进入内核运行。并且用sscratch保存着U态的栈地址，从内核态返回即可用sscratch恢复用户态栈指针。</p>
<ol start="7">
<li>csrrw sp,sccratch, sp是程序从U态进入S态的关键指令，sp指向内核栈。</li>
</ol>
<h4 id="荣誉准则"><a href="#荣誉准则" class="headerlink" title="荣誉准则"></a>荣誉准则</h4><ol>
<li><p>在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：<br>无</p>
</li>
<li><p>此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：</p>
<p>我的参考资料：rCore-Tutorial-Book-v3</p>
</li>
<li><p>我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。</p>
</li>
<li><p>我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/reganzm-s-SOS/lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/reganzm-s-SOS/lab2/" class="post-title-link" itemprop="url">reganzm-s-SOS/lab2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T08:53:05+00:00">2025-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>地址空间映射这一章知识密度较高，反复看了几遍才基本弄懂，调试代码陆陆续续调试了3天。(还是太菜，菜就多练！)<br>简单总结下本章：在开启分页SV39分页之前，OS和都是直接访问物理地址，这给系统带来很多潜在的安全隐患，例如地址空间未隔离等。开启分页模式后，OS和用户代码中就都是虚拟地址了，需要通过页表和MMU进行转换，并且页表上的属性区分出了U和S，进行了权限和空间的隔离，分别在特权级和地址空间上保证了OS内核的安全，同时也保证了用户程序之间相互隔离，彼此空间不会重叠。(虚拟空间可以重叠，但通过页表映射后通常是隔离的，有种特殊情况是通过映射到相同的物理也实现内存共享)</p>
<p>另外为了OS在开启分页后能平滑的访问，对于OS采用的是恒等映射(虚拟页号=物理页帧)。而对于用户程序通常采用Framed映射，通过栈式页帧分配器分配页帧并和虚拟页号建立映射关系，动态生成页表及页表项，实现物理页帧的按需分配。</p>
<p>另外一个比较好的抽象是地址空间MemorySet，它作为任务的一部分，管理着页表及和逻辑区。在实现采用了RAIL机制，加上rust的所有权及drop trait自动实现页表项的释放。</p>
<p><img src="/blog/.io//ch4_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.png" alt="笔记"></p>
<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>最低的位则是标志位，它们的含义如下：<br>仅当 V(Valid) 位为 1 时，页表项才是合法的；<br>R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；<br>U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；<br>G 全局页表项。这意味着即使是在上下文切换（例如，进程切换）之后，该页表项也不会被冲洗（flushed）或失效。简而言之，G位用于指示页表项在地址空间的多个上下文中保持有效。<br>A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；<br>D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。</p>
<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><h4 id="荣誉准则"><a href="#荣誉准则" class="headerlink" title="荣誉准则"></a>荣誉准则</h4><ol>
<li><p>在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：<br>无</p>
</li>
<li><p>此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：</p>
<p>我的参考资料：rCore-Tutorial-Book-v3</p>
</li>
<li><p>我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。</p>
</li>
<li><p>我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/reganzm-s-SOS/lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/reganzm-s-SOS/lab3/" class="post-title-link" itemprop="url">reganzm-s-SOS/lab3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T08:53:05+00:00">2025-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="荣誉准则"><a href="#荣誉准则" class="headerlink" title="荣誉准则"></a>荣誉准则</h4><ol>
<li><p>在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：<br>无</p>
</li>
<li><p>此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：</p>
<p>我的参考资料：rCore-Tutorial-Book-v3</p>
</li>
<li><p>我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。</p>
</li>
<li><p>我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/reganzm-s-SOS/lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/reganzm-s-SOS/lab4/" class="post-title-link" itemprop="url">reganzm-s-SOS/lab4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T08:53:05+00:00">2025-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h4><p>文件系统章节是我花时间最多的一个章节，时间主要花在了对文件系统的理解上，看源码也费了些时间。将细节通过在线文档整理如下图所示：<br><img src="/blog/.io//ch6_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.png" alt="ch6 基础知识"></p>
<h4 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h4><p>Root Inode 的作用：<br>文件系统的入口点：在类 Unix 文件系统中，root inode 是文件系统层次结构的根，即 / 目录。它是访问文件系统其余部分的起始点。<br>存储目录信息：root inode 存储了根目录下的文件和子目录的元数据，例如它们的名称、inode 编号、文件类型（文件或目录）等。<br>维护文件系统结构：root inode 作为文件系统结构的起点，确保了整个文件系统的组织性和可访问性。<br>权限控制：root inode 还包含了访问权限信息，用于控制对根目录及其下内容的访问。<br>如果 Root Inode 损坏：<br>如果 root inode 中的内容损坏，可能会发生以下情况：</p>
<p>无法访问文件系统：由于 root inode 是访问文件系统的入口，如果它损坏，可能会导致整个文件系统无法挂载，用户无法访问任何文件或目录。<br>数据丢失：虽然文件数据可能仍然存储在磁盘上，但如果 root inode 损坏，系统可能无法定位这些数据，导致数据看似丢失。<br>文件系统损坏：文件系统的元数据完整性对于文件系统的健康至关重要。root inode 损坏可能导致文件系统元数据不一致，进而导致整个文件系统损坏。<br>恢复困难：恢复损坏的 root inode 可能非常困难，可能需要专业的数据恢复工具和专业知识。</p>
<h4 id="荣誉准则"><a href="#荣誉准则" class="headerlink" title="荣誉准则"></a>荣誉准则</h4><ol>
<li><p>在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：<br>无</p>
</li>
<li><p>此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：</p>
<p>我的参考资料：rCore-Tutorial-Book-v3</p>
</li>
<li><p>我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。</p>
</li>
<li><p>我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/25/reganzm-s-SOS/lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/05/25/reganzm-s-SOS/lab5/" class="post-title-link" itemprop="url">reganzm-s-SOS/lab5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-25 08:53:05" itemprop="dateCreated datePublished" datetime="2025-05-25T08:53:05+00:00">2025-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h4><h4 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h4><h4 id="荣誉准则"><a href="#荣誉准则" class="headerlink" title="荣誉准则"></a>荣誉准则</h4><ol>
<li><p>在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：<br>无</p>
</li>
<li><p>此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：</p>
<p>我的参考资料：<br>rCore-Tutorial-Book-v3<br><a href="https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95</a></p>
</li>
</ol>
<ol start="3">
<li><p>我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。</p>
</li>
<li><p>我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/71/">71</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
