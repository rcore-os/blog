<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="Chapter 8-2IntroductionWe will develop exclusion mechanism previously mentioned. Beside construction, we need to abstract possible situation of data sharing. A usual native thought is a thread want to">
<meta property="og:type" content="article">
<meta property="og:title" content="rcore-handnote-8-2">
<meta property="og:url" content="http://rcore-os.github.io/blog/2025/04/27/Chap8-2/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:description" content="Chapter 8-2IntroductionWe will develop exclusion mechanism previously mentioned. Beside construction, we need to abstract possible situation of data sharing. A usual native thought is a thread want to">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-04-27T09:40:28.000Z">
<meta property="article:modified_time" content="2025-05-15T08:36:18.608Z">
<meta property="article:author" content="rcore-os Group">
<meta property="article:tag" content="2025春夏季开源操作系统训练营">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/2025/04/27/Chap8-2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>rcore-handnote-8-2 | rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-8-2"><span class="nav-number">1.</span> <span class="nav-text">Chapter 8-2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">1.2.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Design"><span class="nav-number">1.3.</span> <span class="nav-text">Design</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-Lock"><span class="nav-number">1.4.</span> <span class="nav-text">Basic Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#U-level"><span class="nav-number">1.4.1.</span> <span class="nav-text">U-level</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#M-level"><span class="nav-number">1.4.2.</span> <span class="nav-text">M-level</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S-level"><span class="nav-number">1.4.3.</span> <span class="nav-text">S-level</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">1.5.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conditional-Variable"><span class="nav-number">1.6.</span> <span class="nav-text">Conditional Variable</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">673</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">582</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap8-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rcore-handnote-8-2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 08:36:18" itemprop="dateModified" datetime="2025-05-15T08:36:18+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Chapter-8-2"><a href="#Chapter-8-2" class="headerlink" title="Chapter 8-2"></a>Chapter 8-2</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>We will develop exclusion mechanism previously mentioned.</p>
<p>Beside construction, we need to abstract possible situation of data sharing. A usual native thought is a thread want to modify one thing but due to thread switch, the data is already modified and we get wrong result. So based on this, we want a operation to be <strong>Atomic</strong>, which means the operation excluding others. Now we can alleviate this restriction and generalize this.</p>
<h3 id><a href="#" class="headerlink" title></a></h3><p>Generalization:</p>
<ul>
<li>Allow multiple but finite thread can join one atomic operation.</li>
<li>Allow condition of atomic operation.</li>
</ul>
<p>Before such generalization, we want a way to represent atomic operation. We call the content of this operation <strong>Critical Section</strong>, and multiple threads operations in indeterminate time sequence <strong>Race Condition</strong>. So the basic problem of data sharing push us to identify multiple different operations by different threads, we can’t restrict data because the problem is on modification by threads, we need to <strong>Lock</strong> operations!</p>
<p>So, it there’s a lock sharing by threads, each threads can declare <strong>Lock it!</strong>, and no other threads can access this thread again.</p>
<p>Now, back to our generalization. If this lock has a bound of access number, many can access until reaching a bound. That’s also a reasonable design, we call this <strong>Semaphore</strong>; If this lock has a signal which one thread can send it to others to allow others to access it, That’s also a reasonable design, we call this <strong>Condition Variable</strong>.</p>
<p>If the real minimal sharing thing is <strong>Lock</strong> rather than data, we can discard so called data problem, and focus on lock itself, each threads can do anything in this lock and excluding others.</p>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><p>No matter which kinds of lock, this is shared among threads.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    <span class="comment">// mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> lock_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Lock&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;LockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LockInner</span></span> &#123;</span><br><span class="line">	<span class="keyword">pub</span> data: ...</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In such design, one lock can push one thread to  <code>wait_queue</code> to stop it, and pop front to start it. <code>data</code> is a generalization for various locks.</p>
<p>Then, in one process, it owns many locks used in various conditions, one can easily take it as a generalization of many data(actually nothing related to real data) we want to share.</p>
<h3 id="Basic-Lock"><a href="#Basic-Lock" class="headerlink" title="Basic Lock"></a>Basic Lock</h3><p>Now, we want to construct a basic lock allowing simple <code>lock</code>, <code>unlock</code> operation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Mutex</span></span>: <span class="built_in">Sync</span> + <span class="built_in">Send</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, there’s U-level, M-level, S-level implementation. First, we gonna try first one easily, knowing the heuristic design of M-level, and extend basic thought to S-level.</p>
<hr>
<h4 id="U-level"><a href="#U-level" class="headerlink" title="U-level"></a>U-level</h4><p>A naive approach is to declare a global boolean indicating block state. <code>lock</code> will wait if the boolean is true and try to set it to true, and <code>unlock</code> will set it to false to release.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> mutex :<span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(mutex: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (mutex);</span><br><span class="line">    mutex = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(mutex: <span class="built_in">i32</span>)&#123;</span><br><span class="line">    mutex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, that’s wrong! We can’t construct lock by things we want to lock! Threads can jump in any instructions and break it! That’s means we can’t do it in U-level? We should ponder further in real situation, imagine two threads modify one thing in nearly same time, if we could set two global state in a operation that excluding each other(for example, one state set to 1 and another state set to 0), then only one operation can really be implemented and we can check this condition, allow it to get the lock.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> flag : [<span class="built_in">i32</span>;<span class="number">2</span>] = [<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">// 哪个线程想拿到锁？</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> turn : <span class="built_in">i32</span> = <span class="number">0</span>;         <span class="comment">// 排号：轮到哪个线程? (线程 0 or 1?)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>() &#123;</span><br><span class="line">    flag[<span class="keyword">self</span>] = <span class="number">1</span>;             <span class="comment">// 设置自己想取锁 self: 线程 ID</span></span><br><span class="line">    turn = <span class="number">1</span> - <span class="keyword">self</span>;            <span class="comment">// 设置另外一个线程先排号</span></span><br><span class="line">    <span class="keyword">while</span> ((flag[<span class="number">1</span>-<span class="keyword">self</span>] == <span class="number">1</span>) &amp;&amp; (turn == <span class="number">1</span> - <span class="keyword">self</span>)); <span class="comment">// 忙等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>() &#123;</span><br><span class="line">    flag[<span class="keyword">self</span>] = <span class="number">0</span>;             <span class="comment">// 设置自己放弃锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now analyze the code, we find that no matter which flag is 1, or both 1, indicating certain thread want to get lock, <code>turn</code> will be a excluding state to <code>flag</code>, which means if another thread modify <code>turn</code> in same time, the turn can only be in one of the state and only one thread can get the lock.</p>
<hr>
<h4 id="M-level"><a href="#M-level" class="headerlink" title="M-level"></a>M-level</h4><p>Is there any predefined operation in instructions that is atomic? Then we can use it as a lock. The answer is <strong>Yes</strong>, in RISC-V, it’s:</p>
<ul>
<li>AMO: Atomic memory operation</li>
<li>LR/SC: Load Reserved/Store Conditional</li>
</ul>
<p><strong>AMO</strong>: will read the value in memory and write new value, then store the old value to target register(s.t. <code>amoadd.w rd, rs2, (rs1)</code>). </p>
<p><strong>LR/SC</strong>: <strong>LR</strong> will read memory and store in target register, and leave the addr of this memory, then <strong>SC</strong> could check the addr and write data to this addr, output a condition(0/1) to target register.(s.t. <code>lr.w rd, (rs1)</code>, <code>sc.w rd, rs2, (rs1)</code>)</p>
<p>We can use it to implement a atomic function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># RISC-V sequence for implementing a TAS  at (s1)</span><br><span class="line">li t2, 1                 # t2 &lt;-- 1</span><br><span class="line">Try: lr  t1, s1          # t1 &lt;-- mem[s1]  (load reserved)</span><br><span class="line">        bne t1, x0, Try     # if t1 !&#x3D; 0, goto Try:</span><br><span class="line">        sc  t0, s1, t2      # mem[s1] &lt;-- t2  (store conditional)</span><br><span class="line">        bne t0, x0, Try     # if t0 !&#x3D;0 (&#39;sc&#39; Instr failed), goto Try:</span><br><span class="line">Locked:</span><br><span class="line">        ...                 # critical section</span><br><span class="line">Unlock:</span><br><span class="line">        sw x0,0(s1)         # mem[s1] &lt;-- 0</span><br></pre></td></tr></table></figure>

<p>Here the logic of <code>Try</code> is <code>mem[s1]</code> would be zero if it’s unlocked, and would be non-zero if it’s locked. So, <code>Try</code> will compare <code>t1</code> and <code>x0</code>, actually <code>mem[s1]</code> and <code>0</code>, if equal to zero, then try to store <code>t2</code> into <code>s1</code>, if succeed, it will compare it again for the output signal <code>t0</code> and <code>x0</code>, actually the output signal and <code>0</code>, if succeed, it will jump out otherwise repeat.In this process, if the write operation failed, <code>t0</code> would be non-zero, and repeat in <code>Try</code>.</p>
<p>If we want to <code>Unlock</code>, we write <code>x0</code> to <code>s1</code> to set <code>mem[s1]</code> to zero. Which is the unlocked state.</p>
<h4 id="S-level"><a href="#S-level" class="headerlink" title="S-level"></a>S-level</h4><p>Then we could take the function to rust and package it. A simple refactor is when we in repetition loop, we <code>yield</code>, and give CPU to others.</p>
<hr>
<p>Now, for any kinds of locks, we could apply it to our structure.</p>
<p>First, when we create a lock, we create and push it to list or set in empty element.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_create</span></span>(blocking: <span class="built_in">bool</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> mutex: <span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt; = <span class="keyword">if</span> !blocking &#123;</span><br><span class="line">        <span class="literal">Some</span>(Arc::new(MutexSpin::new()))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Some</span>(Arc::new(MutexBlocking::new()))</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(id) = process_inner</span><br><span class="line">        .mutex_list</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .find(|(_, item)| item.is_none())</span><br><span class="line">        .map(|(id, _)| id)</span><br><span class="line">    &#123;</span><br><span class="line">        process_inner.mutex_list[id] = mutex;</span><br><span class="line">        id <span class="keyword">as</span> <span class="built_in">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process_inner.mutex_list.push(mutex);</span><br><span class="line">        process_inner.mutex_list.len() <span class="keyword">as</span> <span class="built_in">isize</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When we call <code>lock</code>, we should provide corresponding id of the lock, if it’s already locked, we push to <code>wait_queue</code>, else we lock it and goes on.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_lock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(process_inner);</span><br><span class="line">    <span class="built_in">drop</span>(process);</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// os/src/sync/mutex.rs</span></span><br><span class="line"><span class="keyword">impl</span> Lock <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> mutex_inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">        <span class="keyword">if</span> ... &#123;</span><br><span class="line">            mutex_inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">			<span class="comment">// ... other operations</span></span><br><span class="line">            <span class="built_in">drop</span>(mutex_inner);</span><br><span class="line">            block_current_and_run_next();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// ... other operations</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Same reverse operation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/syscall/sync.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_unlock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> process = current_process();</span><br><span class="line">    <span class="keyword">let</span> process_inner = process.inner_exclusive_access();</span><br><span class="line">    <span class="keyword">let</span> mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(process_inner);</span><br><span class="line">    <span class="built_in">drop</span>(process);</span><br><span class="line">    mutex.unlock();</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// os/src/sync/mutex.rs</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> mutex_inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">		<span class="comment">// ... other operation</span></span><br><span class="line">		<span class="keyword">if</span> ... &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(waking_task) = mutex_inner.wait_queue.pop_front() &#123;</span><br><span class="line">				add_task(waking_task);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>It’s simple, we only need to switch boolean to number and check the bound. So, the initiated count is the bound, if one thread access, it will minus one, and release, add one. We only need to check positive or negative.</p>
<p>Apply our structure:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">up</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = inner.wait_queue.pop_front() &#123;</span><br><span class="line">            add_task(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">down</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> inner.count &lt; <span class="number">0</span> &#123;</span><br><span class="line">        inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">        <span class="built_in">drop</span>(inner);</span><br><span class="line">        block_current_and_run_next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the initiated count equal to <code>1</code>, we back to <code>mutex</code>!, which indicates sole thread access!</p>
<p>Actually, we could use it for <strong>synchronization</strong> operation, we set count to <code>0</code>, if one thread access, it will be blocked, and another thread will could release and add one to count, then the original thread finally could access. Then the second thread will always be advanced to first one.</p>
<p>Here, the first is always advanced to second.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SEM_SYNC: <span class="built_in">usize</span> = <span class="number">0</span>; <span class="comment">//信号量ID</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">first</span></span>() -&gt; ! &#123;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"First work and wakeup Second"</span>);</span><br><span class="line">    semaphore_up(SEM_SYNC); <span class="comment">//信号量V操作</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">second</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second want to continue,but need to wait first"</span>);</span><br><span class="line">    semaphore_down(SEM_SYNC); <span class="comment">//信号量P操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second can work now"</span>);</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Conditional-Variable"><a href="#Conditional-Variable" class="headerlink" title="Conditional Variable"></a>Conditional Variable</h3><p>If we want one thread owns the ability of release lock for others, we need the <code>CondVar</code>. We have to dispatch operation in <code>wait_queue</code>, if one thread <code>signal</code> others, it will pop out a thread, which means trigger it <strong>You are free!</strong>. And if one thread <code>wait</code>, it will push itself to queue to <strong>wait</strong>, The unlock and lock is important because in wait operation, it allow other thread to modify <strong>condition</strong>, but it should be after of the push operation, in case that the signal is before the push, then we can never receive the signal again! We won’t encapsulate condition check to <code>CondVar</code> because it should leave to user to design it, we only leave out interface for user.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">signal</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(task) = inner.wait_queue.pop_front() &#123;</span><br><span class="line">		add_task(task);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(&amp;<span class="keyword">self</span>, mutex: Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inner = <span class="keyword">self</span>.inner.exclusive_access();</span><br><span class="line">    inner.wait_queue.push_back(current_task().unwrap());</span><br><span class="line">    <span class="built_in">drop</span>(inner);</span><br><span class="line">    mutex.unlock();                 </span><br><span class="line">    block_current_and_run_next();</span><br><span class="line">    mutex.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, if condition check is leave out to user, we can’t ensure the condition be violated due to data sharing, so usually we need to append <code>mutex</code> lock for this section.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> A: <span class="built_in">usize</span> = <span class="number">0</span>;   <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONDVAR_ID: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> MUTEX_ID: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">first</span></span>() -&gt; ! &#123;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"First work, Change A --&gt; 1 and wakeup Second"</span>);</span><br><span class="line">    mutex_lock(MUTEX_ID);</span><br><span class="line">    A=<span class="number">1</span>;</span><br><span class="line">    condvar_signal(CONDVAR_ID);</span><br><span class="line">    mutex_unlock(MUTEX_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">second</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second want to continue,but need to wait A=1"</span>);</span><br><span class="line">    mutex_lock(MUTEX_ID);</span><br><span class="line">    <span class="keyword">while</span> A==<span class="number">0</span> &#123;</span><br><span class="line">        condvar_wait(CONDVAR_ID, MUTEX_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(MUTEX_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that if <code>A=1</code>, second won’t <code>wait</code> repeatly, and goes out.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" rel="tag"># 2025春夏季开源操作系统训练营</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2025/04/27/day-2/" rel="prev" title="arceos-handnote-2">
      <i class="fa fa-chevron-left"></i> arceos-handnote-2
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2025/04/27/Chap7-2/" rel="next" title="rcore-handnote-7-2">
      rcore-handnote-7-2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
