<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="Chapter 6-1IntroductionThe demand of persistent storage is with growth of computer. Currently we can only store things on our map memory, but it’s only exist in running time, which is Internal Storage">
<meta property="og:type" content="article">
<meta property="og:title" content="rcore-handnote-6-1">
<meta property="og:url" content="http://rcore-os.github.io/blog/2025/04/27/Chap6-1/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:description" content="Chapter 6-1IntroductionThe demand of persistent storage is with growth of computer. Currently we can only store things on our map memory, but it’s only exist in running time, which is Internal Storage">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://rcore-os.github.io/blog/.io//assets/Lab6-1.png">
<meta property="og:image" content="http://rcore-os.github.io/blog/.io//assets/Lab6-2.png">
<meta property="article:published_time" content="2025-04-27T09:40:28.000Z">
<meta property="article:modified_time" content="2025-05-15T07:27:13.102Z">
<meta property="article:author" content="rcore-os Group">
<meta property="article:tag" content="2025春夏季开源操作系统训练营">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rcore-os.github.io/blog/.io//assets/Lab6-1.png">

<link rel="canonical" href="http://rcore-os.github.io/blog/2025/04/27/Chap6-1/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>rcore-handnote-6-1 | rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-6-1"><span class="nav-number">1.</span> <span class="nav-text">Chapter 6-1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concept"><span class="nav-number">1.2.</span> <span class="nav-text">Concept</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Regular-File"><span class="nav-number">1.2.1.</span> <span class="nav-text">Regular File</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dir"><span class="nav-number">1.2.2.</span> <span class="nav-text">Dir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-System"><span class="nav-number">1.2.3.</span> <span class="nav-text">File System</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Design"><span class="nav-number">1.3.</span> <span class="nav-text">Design</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Simplification"><span class="nav-number">1.3.1.</span> <span class="nav-text">Simplification</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache"><span class="nav-number">1.3.2.</span> <span class="nav-text">Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Block-Layout"><span class="nav-number">1.3.3.</span> <span class="nav-text">Block Layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-System-1"><span class="nav-number">1.3.4.</span> <span class="nav-text">File System</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">616</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">559</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/04/27/Chap6-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rcore-handnote-6-1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-04-27 09:40:28" itemprop="dateCreated datePublished" datetime="2025-04-27T09:40:28+00:00">2025-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-15 07:27:13" itemprop="dateModified" datetime="2025-05-15T07:27:13+00:00">2025-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/handnote/" itemprop="url" rel="index"><span itemprop="name">handnote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Chapter-6-1"><a href="#Chapter-6-1" class="headerlink" title="Chapter 6-1"></a>Chapter 6-1</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The demand of persistent storage is with growth of computer. Currently we can only store things on our map memory, but it’s only exist in running time, which is <strong>Internal Storage</strong>, now we want to store it to <strong>External Storage</strong>.</p>
<h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><h4 id="Regular-File"><a href="#Regular-File" class="headerlink" title="Regular File"></a>Regular File</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> os/src/</span><br><span class="line"><span class="built_in">stat</span> main.rs</span><br><span class="line"></span><br><span class="line">File: main.rs</span><br><span class="line">Size: 940           Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049d  Inode: 4975        Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/   oslab)   Gid: ( 1000/   oslab)</span><br><span class="line">Access: 2021-02-28 23:32:50.289925450 +0800</span><br><span class="line">Modify: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Change: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure>

<p>Beside usual info, if one file is not <code>regular</code>, it’s usually a block device file or character device file, whose major/minor ID will be shown.</p>
<ul>
<li>Links: alias name for one file</li>
<li>Inode: the underneath id used to route</li>
<li>Uid: the file belonged user id.</li>
<li>Gid: the file begloned group id.</li>
<li>Blocks: take amount of blocks(in linux, it’s 4096KB).</li>
</ul>
<h4 id="Dir"><a href="#Dir" class="headerlink" title="Dir"></a>Dir</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> os</span><br><span class="line">File: os</span><br><span class="line">Size: 4096          Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: 801h/2049d  Inode: 4982        Links: 5</span><br><span class="line">Access: (0755/drwxr-xr-x)  Uid: ( 1000/   oslab)   Gid: ( 1000/   oslab)</span><br><span class="line">Access: 2021-02-28 23:32:50.133927136 +0800</span><br><span class="line">Modify: 2021-02-28 23:32:50.129927180 +0800</span><br><span class="line">Change: 2021-02-28 23:32:50.129927180 +0800</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure>

<ul>
<li>Access:<ul>
<li>d: dir</li>
<li>r: allowed to read files and subdir</li>
<li>w: allowed to create and delete files and subdir</li>
<li>x: allowed to “pass” this dir.</li>
</ul>
</li>
</ul>
<h4 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h4><p>Play the role of mapping the given dir tree structure to persistent storage. For example: windows-FAT/NTPS; linux-Ext3/Ext4/Btrfs. Therefore, construct a <strong>VFS-Virtual File System</strong> is necessary to restrict unified interface.</p>
<hr>
<h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h4><ul>
<li>flatten: only root dir <code>/</code></li>
<li>permission: only user and no restriction on file access</li>
<li>no timestamp</li>
<li>no soft/hard link</li>
<li>many…</li>
</ul>
<p><img src="/blog/.io//assets/Lab6-1.png" alt></p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>For a persistent external storage, it will separate file in basic storage unit. Which is called <strong>sector</strong>(usually 512 bytes, 4KB), rather, file system will set its own storage unit which is called <strong>block</strong>, usually different from sector, but in this implementation, we set it as 512 bytes, same as sector.</p>
<p>A basic interface from device is:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/block_dev.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">BlockDevice</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> + Any &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File will not read and write directly often which will slow down speed, we will construct <strong>Block Cache</strong> to store read data. Then we unify all block cache in to a manager with limit size and used for allocation and deallocation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> BLOCK_SZ: <span class="built_in">usize</span> = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/block_cache.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ],</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    modified: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>&lt;T, V&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;T) -&gt; V) -&gt; V &#123;</span><br><span class="line">        f(<span class="keyword">self</span>.get_ref(offset))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">modify</span></span>&lt;T, V&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset:<span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> T) -&gt; V) -&gt; V &#123;</span><br><span class="line">        f(<span class="keyword">self</span>.get_mut(offset))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/block_cache.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BLOCK_CACHE_SIZE: <span class="built_in">usize</span> = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> alloc::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCacheManager</span></span> &#123;</span><br><span class="line">    queue: VecDeque&lt;(<span class="built_in">usize</span>, Arc&lt;Mutex&lt;BlockCache&gt;&gt;)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BlockCacheManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; queue: VecDeque::new() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl BlockCacheManager</span></span><br><span class="line"><span class="comment">// fn get_block_cache(&amp;mut self, block_id:usize, block_device: Arc&lt;dyn BlockDevice&gt;)</span></span><br><span class="line"><span class="comment">// if reach limit size:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.queue.len() == BLOCK_CACHE_SIZE &#123;</span><br><span class="line">    <span class="comment">// from front to tail</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((idx, _)) = <span class="keyword">self</span>.queue</span><br><span class="line">        .iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .find(|(_, pair)| Arc::strong_count(&amp;pair.<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.queue.drain(idx..=idx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">"Run out of BlockCache!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// load block into mem and push back</span></span><br><span class="line"><span class="keyword">let</span> block_cache = Arc::new(Mutex::new(</span><br><span class="line">    BlockCache::new(block_id, Arc::clone(&amp;block_device))</span><br><span class="line">));</span><br><span class="line"><span class="keyword">self</span>.queue.push_back((block_id, Arc::clone(&amp;block_cache)));</span><br><span class="line">block_cache</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Block-Layout"><a href="#Block-Layout" class="headerlink" title="Block Layout"></a>Block Layout</h4><p><img src="/blog/.io//assets/Lab6-2.png" alt="alt text"></p>
<p>We will design a whole map structure to control block caches.</p>
<p>First is <strong>Super Block</strong> which is a head to control everything, notice <code>magic</code> is magic number in mathematics to check the integrity of structure.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span></span> &#123;</span><br><span class="line">    magic: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.magic == EFS_MAGIC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bit Map</strong> is a nice structure to handle mapping operations, we set each block as 512 bytes(4KB), each bits represent a state of allocation(<code>1/0</code> for allocated/deallocated).</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/bitmap.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// notice it only store the id of start block and the len of blocks in its range.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitmap</span></span> &#123;</span><br><span class="line">    start_block_id: <span class="built_in">usize</span>,</span><br><span class="line">    blocks: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the true structure to map</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BitmapBlock</span></span> = [<span class="built_in">u64</span>; <span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// equal: 4096 bits</span></span><br><span class="line"><span class="keyword">const</span> BLOCK_BITS: <span class="built_in">usize</span> = BLOCK_SZ * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Bitmap &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> block_id <span class="keyword">in</span> <span class="number">0</span>..<span class="keyword">self</span>.blocks &#123;</span><br><span class="line">            <span class="keyword">let</span> pos = get_block_cache(</span><br><span class="line">                block_id + <span class="keyword">self</span>.start_block_id <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device),</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .modify(<span class="number">0</span>, |bitmap_block: &amp;<span class="keyword">mut</span> BitmapBlock| &#123;</span><br><span class="line">                <span class="comment">// core!</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((bits64_pos, inner_pos)) = bitmap_block</span><br><span class="line">                    .iter()</span><br><span class="line">                    .enumerate()</span><br><span class="line">                    .find(|(_, bits64)| **bits64 != <span class="built_in">u64</span>::MAX)</span><br><span class="line">                    .map(|(bits64_pos, bits64)| &#123;</span><br><span class="line">                        (bits64_pos, bits64.trailing_ones() <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">                    &#125;) &#123;</span><br><span class="line">                    <span class="comment">// modify cache</span></span><br><span class="line">                    bitmap_block[bits64_pos] |= <span class="number">1u64</span> &lt;&lt; inner_pos;</span><br><span class="line">                    <span class="literal">Some</span>(block_id * BLOCK_BITS + bits64_pos * <span class="number">64</span> + inner_pos <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="literal">None</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> pos.is_some() &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Based on such structure, we could exposit what is <strong>Inode</strong> and <strong>Data</strong> Block, not all block will store real data because some of them need to be used as guidance. However, we also need to know where and how these route blocks be allocated. That’s the reason of <strong>Bit Map</strong>! Now we delve into <strong>Inode</strong>.</p>
<p>To make one inode control many data blocks, we will design layer of route for it. Beside direct index, it also store the index of layer 1 and layer 2 to route other index block(which is considered same as data block), and route to real data block. Notice one block contains 512 bytes, which is 512 u8, so it contains 512/4 = 128 u32, so one index block can route 128 * 512 bytes = 128 * 0.5 KB = 64 KB in one layer. In second layer, it can route as much as 128 * 64 KB = 64 MB.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INODE_DIRECT_COUNT: <span class="built_in">usize</span> = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// 128</span></span><br><span class="line"><span class="keyword">const</span> INODE_INDIRECT1_COUNT: <span class="built_in">usize</span> = BLOCK_SZ / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DiskInodeType</span></span> &#123;</span><br><span class="line">    File,</span><br><span class="line">    Directory,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Such <strong>Inode</strong> take 128 bytes, so in one block, it could contains 4 inodes. We should make a data structure could be fit exactly into a block size. Now we design route method.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 28 + 128</span></span><br><span class="line"><span class="keyword">const</span> INDIRECT1_BOUND: <span class="built_in">usize</span> = DIRECT_BOUND + INODE_INDIRECT1_COUNT;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">IndirectBlock</span></span> = [<span class="built_in">u32</span>; BLOCK_SZ / <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> DiskInode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_id</span></span>(&amp;<span class="keyword">self</span>, inner_id: <span class="built_in">u32</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> inner_id = inner_id <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        <span class="keyword">if</span> inner_id &lt; INODE_DIRECT_COUNT &#123;</span><br><span class="line">            <span class="keyword">self</span>.direct[inner_id]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> inner_id &lt; INDIRECT1_BOUND &#123;</span><br><span class="line">            get_block_cache(<span class="keyword">self</span>.indirect1 <span class="keyword">as</span> <span class="built_in">usize</span>, Arc::clone(block_device))</span><br><span class="line">                .lock()</span><br><span class="line">                .read(<span class="number">0</span>, |indirect_block: &amp;IndirectBlock| &#123;</span><br><span class="line">                    indirect_block[inner_id - INODE_DIRECT_COUNT]</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> last = inner_id - INDIRECT1_BOUND;</span><br><span class="line">            <span class="keyword">let</span> indirect1 = get_block_cache(</span><br><span class="line">                <span class="keyword">self</span>.indirect2 <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device)</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .read(<span class="number">0</span>, |indirect2: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect2[last / INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;);</span><br><span class="line">            get_block_cache(</span><br><span class="line">                indirect1 <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">                Arc::clone(block_device)</span><br><span class="line">            )</span><br><span class="line">            .lock()</span><br><span class="line">            .read(<span class="number">0</span>, |indirect1: &amp;IndirectBlock| &#123;</span><br><span class="line">                indirect1[last % INODE_INDIRECT1_COUNT]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we design <strong>Data</strong> block, which is simple. Because for file system, any data are just bytes.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BLOCK_SZ = 512</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">DataBlock</span></span> = [<span class="built_in">u8</span>; BLOCK_SZ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl DiskInode</span></span><br><span class="line">    <span class="comment">// pub fn read_at(</span></span><br><span class="line">    <span class="comment">//     &amp;self,</span></span><br><span class="line">    <span class="comment">//     offset: usize,</span></span><br><span class="line">    <span class="comment">//     buf: &amp;mut [u8],</span></span><br><span class="line">    <span class="comment">//     block_device: &amp;Arc&lt;dyn BlockDevice&gt;,</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// calculate end of current block</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> end_current_block = (start / BLOCK_SZ + <span class="number">1</span>) * BLOCK_SZ;</span><br><span class="line">    end_current_block = end_current_block.min(end);</span><br><span class="line">    <span class="comment">// read and update read size</span></span><br><span class="line">    <span class="keyword">let</span> block_read_size = end_current_block - start;</span><br><span class="line">    <span class="keyword">let</span> dst = &amp;<span class="keyword">mut</span> buf[read_size..read_size + block_read_size];</span><br><span class="line">    get_block_cache(</span><br><span class="line">        <span class="keyword">self</span>.get_block_id(start_block <span class="keyword">as</span> <span class="built_in">u32</span>, block_device) <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        Arc::clone(block_device),</span><br><span class="line">    )</span><br><span class="line">    .lock()</span><br><span class="line">    .read(<span class="number">0</span>, |data_block: &amp;DataBlock| &#123;</span><br><span class="line">        <span class="keyword">let</span> src = &amp;data_block[start % BLOCK_SZ..start % BLOCK_SZ + block_read_size];</span><br><span class="line">        dst.copy_from_slice(src);</span><br><span class="line">    &#125;);</span><br><span class="line">    read_size += block_read_size;</span><br><span class="line">    <span class="comment">// move to next block</span></span><br><span class="line">    <span class="keyword">if</span> end_current_block == end &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    start_block += <span class="number">1</span>;</span><br><span class="line">    start = end_current_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="File-System-1"><a href="#File-System-1" class="headerlink" title="File System"></a>File System</h4><p>Due to our consecutive layout, we will store bitmap and start block, then initiate a unified system to control allocation and route. We call it <strong>File System</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EasyFileSystem</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap: Bitmap,</span><br><span class="line">    <span class="keyword">pub</span> data_bitmap: Bitmap,</span><br><span class="line">    inode_area_start_block: <span class="built_in">u32</span>,</span><br><span class="line">    data_area_start_block: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(</span><br><span class="line">        block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">        total_blocks: <span class="built_in">u32</span>,</span><br><span class="line">        inode_bitmap_blocks: <span class="built_in">u32</span>,</span><br><span class="line">    ) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// calculate block size of areas &amp; create bitmaps</span></span><br><span class="line">        <span class="keyword">let</span> inode_bitmap = Bitmap::new(<span class="number">1</span>, inode_bitmap_blocks <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">        <span class="keyword">let</span> inode_num = inode_bitmap.maximum();</span><br><span class="line">        <span class="keyword">let</span> inode_area_blocks =</span><br><span class="line">            ((inode_num * core::mem::size_of::&lt;DiskInode&gt;() + BLOCK_SZ - <span class="number">1</span>) / BLOCK_SZ) <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">        <span class="keyword">let</span> inode_total_blocks = inode_bitmap_blocks + inode_area_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_total_blocks = total_blocks - <span class="number">1</span> - inode_total_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_bitmap_blocks = (data_total_blocks + <span class="number">4096</span>) / <span class="number">4097</span>;</span><br><span class="line">        <span class="keyword">let</span> data_area_blocks = data_total_blocks - data_bitmap_blocks;</span><br><span class="line">        <span class="keyword">let</span> data_bitmap = Bitmap::new(</span><br><span class="line">            (<span class="number">1</span> + inode_bitmap_blocks + inode_area_blocks) <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">            data_bitmap_blocks <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line">        );</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Use <strong>Bit Map</strong>, we finally know which is <strong>Inode</strong> and <strong>Data</strong>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_disk_inode_pos</span></span>(&amp;<span class="keyword">self</span>, inode_id: <span class="built_in">u32</span>) -&gt; (<span class="built_in">u32</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> inode_size = core::mem::size_of::&lt;DiskInode&gt;();</span><br><span class="line">        <span class="keyword">let</span> inodes_per_block = (BLOCK_SZ / inode_size) <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">        <span class="keyword">let</span> block_id = <span class="keyword">self</span>.inode_area_start_block + inode_id / inodes_per_block;</span><br><span class="line">        (block_id, (inode_id % inodes_per_block) <span class="keyword">as</span> <span class="built_in">usize</span> * inode_size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_data_block_id</span></span>(&amp;<span class="keyword">self</span>, data_block_id: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.data_area_start_block + data_block_id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our <strong>Disk Inode</strong> is aims for underneath system, not for user, so we need a real <strong>Inode</strong> as a interface for <strong>Disk Inode</strong> to route, which store its id and offset.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_offset: <span class="built_in">usize</span>,</span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">        get_block_cache(</span><br><span class="line">            <span class="keyword">self</span>.block_id,</span><br><span class="line">            Arc::clone(&amp;<span class="keyword">self</span>.block_device)</span><br><span class="line">        ).lock().read(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">modify_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">        get_block_cache(</span><br><span class="line">            <span class="keyword">self</span>.block_id,</span><br><span class="line">            Arc::clone(&amp;<span class="keyword">self</span>.block_device)</span><br><span class="line">        ).lock().modify(<span class="keyword">self</span>.block_offset, f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All methods exposed to user will be root inode.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/efs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">root_inode</span></span>(efs: &amp;Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt;) -&gt; Inode &#123;</span><br><span class="line">        <span class="keyword">let</span> block_device = Arc::clone(&amp;efs.lock().block_device);</span><br><span class="line">        <span class="comment">// acquire efs lock temporarily</span></span><br><span class="line">        <span class="keyword">let</span> (block_id, block_offset) = efs.lock().get_disk_inode_pos(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// release efs lock</span></span><br><span class="line">        Inode::new(</span><br><span class="line">            block_id,</span><br><span class="line">            block_offset,</span><br><span class="line">            Arc::clone(efs),</span><br><span class="line">            block_device,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, we still need one special data block which is <strong>DirEntry</strong>, as directory which store <code>inode_number</code> to route inode, <strong>DirEntry</strong> takes 32 bytes, so each block can store 4 <strong>DirEntry</strong>. Thus we can route to inode by <code>&amp;str</code>.</p>
<p>Notice disk_inode contains type for dir and file. So some of inodes will store dir data and some of inodes will store file data, we can get inode of data by inode of dir.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/layout.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NAME_LENGTH_LIMIT: <span class="built_in">usize</span> = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DirEntry</span></span> &#123;</span><br><span class="line">    name: [<span class="built_in">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>],</span><br><span class="line">    inode_number: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DIRENT_SZ: <span class="built_in">usize</span> = <span class="number">32</span>;</span><br></pre></td></tr></table></figure>

<p>First, we will </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// easy-fs/src/vfs.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">find</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> fs = <span class="keyword">self</span>.fs.lock();</span><br><span class="line">        <span class="keyword">self</span>.read_disk_inode(|disk_inode| &#123;</span><br><span class="line">            <span class="keyword">self</span>.find_inode_id(name, disk_inode)</span><br><span class="line">            .map(|inode_id| &#123;</span><br><span class="line">                <span class="keyword">let</span> (block_id, block_offset) = fs.get_disk_inode_pos(inode_id);</span><br><span class="line">                Arc::new(Self::new(</span><br><span class="line">                    block_id,</span><br><span class="line">                    block_offset,</span><br><span class="line">                    <span class="keyword">self</span>.fs.clone(),</span><br><span class="line">                    <span class="keyword">self</span>.block_device.clone(),</span><br><span class="line">                ))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_inode_id</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        name: &amp;<span class="built_in">str</span>,</span><br><span class="line">        disk_inode: &amp;DiskInode,</span><br><span class="line">    ) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// assert it is a directory</span></span><br><span class="line">        <span class="built_in">assert!</span>(disk_inode.is_dir());</span><br><span class="line">        <span class="keyword">let</span> file_count = (disk_inode.size <span class="keyword">as</span> <span class="built_in">usize</span>) / DIRENT_SZ;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dirent = DirEntry::empty();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..file_count &#123;</span><br><span class="line">            <span class="comment">// note assert_eq! has side effect: read data to dirent.</span></span><br><span class="line">            <span class="built_in">assert_eq!</span>(</span><br><span class="line">                disk_inode.read_at(</span><br><span class="line">                    DIRENT_SZ * i,</span><br><span class="line">                    dirent.as_bytes_mut(),</span><br><span class="line">                    &amp;<span class="keyword">self</span>.block_device,</span><br><span class="line">                ),</span><br><span class="line">                DIRENT_SZ,</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> dirent.name() == name &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Some</span>(dirent.inode_number() <span class="keyword">as</span> <span class="built_in">u32</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Usually, the workflow of create or delete, read or write would be:</p>
<ul>
<li>read/write<ul>
<li>get root inode which is dir type</li>
<li>read/write closure of disk inode through root inode</li>
<li>resize specified inode</li>
</ul>
</li>
<li>create/clear<ul>
<li>allocation/deallocation: alloc/dealloc inode by bitmap and get its index</li>
<li>initialization/clear by get its block cache by its index</li>
<li>resize root inode</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/2025%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" rel="tag"># 2025春夏季开源操作系统训练营</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2025/04/27/Chap6-2/" rel="prev" title="rcore-handnote-6-2">
      <i class="fa fa-chevron-left"></i> rcore-handnote-6-2
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2025/04/27/Chap5/" rel="next" title="rcore-handnote-5">
      rcore-handnote-5 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
