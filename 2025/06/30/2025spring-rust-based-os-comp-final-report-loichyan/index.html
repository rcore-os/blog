<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="异步通信框架: everingevering 是受 io_uring 启发的的异步通信框架，作为本文实现异步 IPC 的基石，它  🦀 基于 Rust 异步模型 🐧 基于共享内存 📡 提供双向 SPSC 消息队列 🎬 提供灵活的资源管理机制  evering 使用两个单生产者单消费者（SPSC）并发队列进行通信， 12345678910       Client">
<meta property="og:type" content="article">
<meta property="og:title" content="基于 uring 的异步 IPC">
<meta property="og:url" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:description" content="异步通信框架: everingevering 是受 io_uring 启发的的异步通信框架，作为本文实现异步 IPC 的基石，它  🦀 基于 Rust 异步模型 🐧 基于共享内存 📡 提供双向 SPSC 消息队列 🎬 提供灵活的资源管理机制  evering 使用两个单生产者单消费者（SPSC）并发队列进行通信， 12345678910       Client">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_all.svg">
<meta property="og:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_first_5.svg">
<meta property="og:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_mid_5.svg">
<meta property="og:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_last_5.svg">
<meta property="og:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4B_evering.jpg">
<meta property="og:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4B_tokio_epoll.jpg">
<meta property="og:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4M_evering.jpg">
<meta property="og:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4M_tokio_epoll.jpg">
<meta property="article:published_time" content="2025-06-30T23:00:00.000Z">
<meta property="article:modified_time" content="2025-07-01T13:02:45.056Z">
<meta property="article:author" content="rcore-os Group">
<meta property="article:tag" content="[object Object]">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_all.svg">

<link rel="canonical" href="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>基于 uring 的异步 IPC | rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#异步通信框架-evering"><span class="nav-number">1.</span> <span class="nav-text">异步通信框架: evering</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验性异步-IPC-模型-evering-ipc"><span class="nav-number">2.</span> <span class="nav-text">实验性异步 IPC 模型: evering-ipc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多种-IPC-方案的性能测试-ipc-benchmark"><span class="nav-number">3.</span> <span class="nav-text">多种 IPC 方案的性能测试: ipc-benchmark</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结果对比"><span class="nav-number">3.1.</span> <span class="nav-text">结果对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试结论"><span class="nav-number">3.2.</span> <span class="nav-text">测试结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未完成的任务"><span class="nav-number">4.</span> <span class="nav-text">未完成的任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#让-evering-支持-MPSC"><span class="nav-number">4.1.</span> <span class="nav-text">让 evering 支持 MPSC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于-evering-实现系统调用"><span class="nav-number">4.2.</span> <span class="nav-text">基于 evering 实现系统调用</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">729</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">633</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于 uring 的异步 IPC
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-30 23:00:00" itemprop="dateCreated datePublished" datetime="2025-06-30T23:00:00+00:00">2025-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-01 13:02:45" itemprop="dateModified" datetime="2025-07-01T13:02:45+00:00">2025-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">开源操作系统训练营</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="异步通信框架-evering"><a href="#异步通信框架-evering" class="headerlink" title="异步通信框架: evering"></a>异步通信框架: evering</h2><p><a href="https://loichyan.github.io/openoscamp-2025s/evering" target="_blank" rel="noopener">evering</a> 是受 <a href="https://en.wikipedia.org/wiki/Io_uring" target="_blank" rel="noopener">io_uring</a> 启发的的异步通信框架，作为本文实现异步 IPC 的基石，它</p>
<ul>
<li>🦀 基于 Rust 异步模型</li>
<li>🐧 基于共享内存</li>
<li>📡 提供双向 SPSC 消息队列</li>
<li>🎬 提供灵活的资源管理机制</li>
</ul>
<p>evering 使用两个单生产者单消费者（SPSC）并发队列进行通信，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       Client                                     Server</span><br><span class="line">         |                                           |</span><br><span class="line">.-------&gt;|                                           |&lt;---------.</span><br><span class="line">|        |               Request Queue               |          |</span><br><span class="line">|   (Send Request)   --&gt;-(3)-&gt;-(2)-&gt;-(1)-&gt;-- (Receive Response) |</span><br><span class="line">|        |                                           |          |</span><br><span class="line">|        |                                           |          |</span><br><span class="line">| (Receive Response) --&lt;-(1)-&lt;-(2)-&lt;-(3)-&lt;--   (Send Request)   |</span><br><span class="line">|        |               Response Queue              |          |</span><br><span class="line">&#39;--------&#39;                                           &#39;----------&#39;</span><br></pre></td></tr></table></figure>

<p>受限于 SPSC 通信，目前 evering 只能遵循 thread-per-core 模型，不同于 tokio、async-std 等使用 work-stealing 的运行时．在基于 thread-per-core 的异步模型中，每个线程有一个局部的运行时，不同线程之间保持最小的通信，甚至完全独立．而基于 work-stealing 的异步模型中，任何异步任务都可能由于运行时的调度而被“偷”到其他线程上运行．二者相比有以下异同：</p>
<ul>
<li>在 thread-per-core 模型中，异步任务不必担心同步问题，即在 Rust 中不需要使用诸如 <code>impl Send + Future</code> 的类型，这可以大大简化异步编码体验．而在 work-stealing 模型中，几乎所有的异步任务都需要注意线程之间的同步，这样难免会带来一些额外的开销，也使得异步编码更为繁琐<a href="https://maciej.codes/2022-06-09-local-async.html" target="_blank" rel="noopener">^1</a>．</li>
<li>正如 work-stealing 这名称所示，在此类模型中，运行时会根据程序实时状态对不同线程上的异步任务进行负载均衡，使得每个线程都不会陷入长时间的忙碌或空间．而对于 thread-per-core 模型，由于异步任务不能在多线程之间共享，当处理某个 CPU 密集型任务时，很可能因为长时间阻塞而导致该线程上的其他任务迟迟得不到处理，最终出现较高的响应延迟．因此 thread-per-core 不适合 I/O 密集混合 CPU 密集的场景．</li>
</ul>
<h2 id="实验性异步-IPC-模型-evering-ipc"><a href="#实验性异步-IPC-模型-evering-ipc" class="headerlink" title="实验性异步 IPC 模型: evering-ipc"></a>实验性异步 IPC 模型: evering-ipc</h2><p><a href="https://github.com/loichyan/openoscamp-2025s/tree/final/examples/evering-ipc" target="_blank" rel="noopener">evering-ipc</a> 在 evering 的基础上，同时利用 Linux 的共享内存机制实现了异步 IPC．具体而言，要通信的两个进程使用以下所示的共享内存区进行同步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.-----------------------------------------------------------------------------.</span><br><span class="line">|                   |               |                   |                     |</span><br><span class="line">| [1] uring offsets | [2] allocator | [3] uring buffers | [4] free memory ... |</span><br><span class="line">| ^                 |               |                   |                   ^ |</span><br><span class="line">&#39;-|-------------------------------------------------------------------------|-&#39;</span><br><span class="line">  &#39;-- start of the shared memory (page aligned)                             |</span><br><span class="line">                                                 end of the shared memory --&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>[1]</em> 是整个共享内存区的起始，通过 mmap(2) 映射到地址空间中，因此是页对齐的．</li>
<li><em>[1]</em> 中包含 evering 的两个通信队列的偏移量，基于这个偏移量配合 evering 提供的构造队列的接口，可以确保两个进程看到的状态是相同的．</li>
<li><em>[2]</em> 中包含一个单线程的内存分配器，这个分配器通常由客户端使用．</li>
<li><em>[3]</em> 是通信队列的实际所在位置．</li>
<li><em>[4]</em> 是其余全部的空闲内存，这些内存由 <em>[2]</em> 中的分配器管理．</li>
</ul>
<p>在 evering-ipc 中，uring 仅用于传递静态类型且通常仅有十几到几十个字节的<em>消息</em>．而对于更大的以及编译期间无法确定大小的<em>数据</em>，它利用共享的空闲内存来传递．具体而言，</p>
<ol>
<li>客户端获取内存分配器，从中分配合适的内存块，并写入<em>请求体</em>作为待传递<em>数据</em>．</li>
<li>客户端将该内存块指针以及其他信息构造成<em>请求头</em>作为<em>消息</em>写入请求队列．</li>
<li>服务端接收并解析请求，得到<em>请求头</em>和<em>请求体</em>．</li>
<li>服务端处理请求，将处理结果构造<em>响应头</em>作为<em>消息</em>写入响应队列．</li>
<li>客户端收到响应，检查结果并执行后续流程．</li>
</ol>
<p>当服务端同样也需要传<em>响应体</em>作为<em>数据</em>时，有多种思路可以实现：</p>
<ol>
<li>将分配器加锁使它能同时在服务端和客户端使用．对于请求频率特别高的场景，锁可能会降低整体性能．</li>
<li>增加一个分配器供服务端使用．对于空闲内存分配比例的设定可能不容易权衡．</li>
<li>结合前两个思路，使用两个分配器，但空闲内存加锁，根据程序运行状况动态调整分配给两方的空闲内存．</li>
<li>空闲内存完全由客户端管理，在请求时，客户端分配合适大小的内存块供服务端写入<em>响应体</em>．实际中，客户端可能需要预请求一次来确定<em>响应体</em>的大小．</li>
</ol>
<p>evering-ipc 目前采用第 4 种思路．此外，不难发现，在 evering-ipc 中，数据都是通过指针进行传递的．而在程序运行时，共享内存通常被映射到不同的地址，因此实际传递的是数据块在共享内存中的偏移量．同时，共享内存区的起始地址都是页对齐的，这保证了所有基于相对偏移量得到的地址，即使在两个进程间不同，对齐也是一致的，从而满足 Rust 对不同类型内存布局的要求．</p>
<h2 id="多种-IPC-方案的性能测试-ipc-benchmark"><a href="#多种-IPC-方案的性能测试-ipc-benchmark" class="headerlink" title="多种 IPC 方案的性能测试: ipc-benchmark"></a>多种 IPC 方案的性能测试: ipc-benchmark</h2><p><a href="https://github.com/loichyan/openoscamp-2025s/tree/final/examples/ipc-benchmark" target="_blank" rel="noopener">ipc-benchmark</a> 针对多种 IPC 方案进行了关于通信延迟的性能测试，这些方案包括：</p>
<ul>
<li>基于 evering + memfd 的 IPC</li>
<li>基于 shmipc + memfd 的 IPC</li>
<li>基于 tokio + epoll + UDS 的 IPC</li>
<li>基于 tokio + io_uring + UDS 的 IPC</li>
<li>基于 monoio + io_uring + UDS 的 IPC</li>
</ul>
<p>其中，</p>
<ul>
<li>memfd 是 create_memfd(2) 创建的匿名内存．</li>
<li>UDS 是指 Unix Domain Socket．</li>
<li><a href="https://github.com/cloudwego/shmipc-rs" target="_blank" rel="noopener">shmipc</a> 是基于共享内存的高性能 IPC 框架．</li>
<li><a href="https://tokio.rs/" target="_blank" rel="noopener">tokio</a> 是基于 epoll(7) 和 work-stealing 模型的异步 I/O 运行时．</li>
<li><a href="https://github.com/tokio-rs/tokio-uring" target="_blank" rel="noopener">tokio-uring</a> 为 tokio 提供了基于 io_uring 的异步 I/O 实现．</li>
<li><a href="https://github.com/bytedance/monoio" target="_blank" rel="noopener">monoio</a> 是基于 io_uring 和 thread-per-core 模型的异步 I/O 运行时．</li>
</ul>
<p>对于每个框架我们采用如下测试方案：</p>
<ol>
<li>启动两个线程作为客户端和服务端．</li>
<li>客户端写入 <code>i32</code> 的请求头以及大小为 <code>buf_size</code> 的请求体．</li>
<li>服务端接收并校验请求头和请求体，随后同样写入 <code>i32</code> 的响应头和 <code>buf_size</code> 大小的响应体．</li>
<li>客户端接收并校验响应头和响应体．</li>
</ol>
<p>其中，<code>buf_size</code> 以字节为单位，由 4B 逐渐增长到 4M．</p>
<h3 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h3><p>详细的性能测试的结果见 <a href="https://github.com/loichyan/openoscamp-2025s/tree/ipc-benchmark" target="_blank" rel="noopener">https://github.com/loichyan/openoscamp-2025s/tree/ipc-benchmark</a>，下面我们将对该结果进行简略的分析．</p>
<img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_all.svg" class="" title="ipc-benchmark 完整测试结果对比">

<p>此图对比了完整的测试结果，其中 $x$ 轴是上述的 <code>buf_size</code>，而 $y$ 轴则是完成一次测试所需的平均时间．可以看到，随着数据大小的增长 evering 和 shmipc 明显优于其他三者，并且相对于表现最差的 tokio_epoll，二者分别有接近 50% 和 30% 的性能提升．</p>
<img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_first_5.svg" class="" title="ipc-benchmark 前五轮测试结果对比">

<p>此图对比了前五个测试的结果，此时数据并不算大，都在通常范围之内．这里能发现相对于另外三者，evering 和 shmipc 都有超过 80% 的性能提升．</p>
<img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_mid_5.svg" class="" title="ipc-benchmark 中五轮测试结果对比">

<p>此图对比了中间五轮测试的结果，此时数据大小开始逐渐出现大幅度的增长．可以看到，除了 evering 和 shmipc 外的三者针对大块数据的传输并无明显差异．</p>
<img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/ipc_benchmark_last_5.svg" class="" title="ipc-benchmark 后五轮测试结果对比">

<p>此图对比了最后五轮测试的结果，此时数据大小已接近极端情况．这里能观察到与第一个对比图同样的结果．</p>
<h3 id="测试结论"><a href="#测试结论" class="headerlink" title="测试结论"></a>测试结论</h3><p>单从性能的角度来看，对于上述五种 IPC 方案，<code>evering &gt; shmipc &gt;&gt; monoio &gt; tokio_uring &gt; tokio_epoll</code>．</p>
<p>对比前两者，shmipc 支持 MPSC（多生产者多消费者）的通信方式，而本测试中仅使用 SPSC 的模型进行测试，因此无法发挥其完整的优势．另外，对共享内存处理的方式不同也可能导致了一些性能差异．而对于另外三者，由于使用 UDS 需要将数据在用户空间和内核空间来回拷贝，在面对大块数据时，这将大大降低整体性能．而对于极小的数据块，又由于系统调用等带来的开销，最终需要接近 10 倍的额外时间来完成测试．这一点可以在火焰图<a href="https://github.com/flamegraph-rs/flamegraph" target="_blank" rel="noopener">^2</a>中体现：</p>
<table>
<thead>
<tr>
<th align="center">evering (buf_size=4B)</th>
<th align="center">tokio-epoll (buf_size=4B)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4B_evering.jpg" class=""></td>
<td align="center"><img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4B_tokio_epoll.jpg" class=""></td>
</tr>
</tbody></table>
<p>此图中展示了在 4B 数据下，性能测试主体函数中各子过程的占比．其中，蓝色高亮部分是校验数据过程，用作参照．不难发现，evering 中主要时间都消耗在传递消息所需的多线程同步上了．而在 tokio-epoll 中则是多个与内核交互的函数调用占用主要时间．在后几轮测试中，当数据变得非常大时，这些消耗则变得无关紧要，此时的性能热点是数据传递引起的内存拷贝．下面的火焰图可以佐证：</p>
<table>
<thead>
<tr>
<th align="center">evering (buf_size=4M)</th>
<th align="center">tokio-epoll (buf_size=4M)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4M_evering.jpg" class=""></td>
<td align="center"><img src="/blog/2025/06/30/2025spring-rust-based-os-comp-final-report-loichyan/flamegraph-4M_tokio_epoll.jpg" class=""></td>
</tr>
</tbody></table>
<p>此图与上面两个图相同，不过这里的数据大小是 4M．很明显，当数据非常大时，evering 中绝大部分时间用来初始化需要传递的数据，但传递的过程几乎不占用太多时间．而 tokio-epoll 中的情况更加复杂，除了拷贝数据以外，还花费了相当一大部分时间执行内存分配，这些内存用于放置从内核空间传递来的数据．</p>
<p>至于后三者的性能差别，我们猜测主要是由于：</p>
<ol>
<li>设计架构不同，monoio 是单线程的 thread-per-core 模型，因此与我们的测试相性更好．</li>
<li>基于 io_uring 实现的异步 I/O 相对于基于 epoll 的，理论上会花费更少的时间在与内核交互上．并且测试中我们利用 io_uring_register(2) 做了进一步的优化，减少了传递小数据时内核处理的开销．</li>
</ol>
<h2 id="未完成的任务"><a href="#未完成的任务" class="headerlink" title="未完成的任务"></a>未完成的任务</h2><h3 id="让-evering-支持-MPSC"><a href="#让-evering-支持-MPSC" class="headerlink" title="让 evering 支持 MPSC"></a>让 evering 支持 MPSC</h3><p>正如开头所述，evering 目前只实现了 SPSC 队列，受限于此，不能很好的处理复杂的应用场景．而实现 MPSC 队列之后，客户端就能更好的与 tokio 等运行时协同工作．要实现这个目标，主要是对 evering 的队列结构 <code>RawUring</code> 和操作驱动结构 <code>Driver</code> 进行多线程改造，并且尽可能要实现无锁的数据结构．对于 <code>RawUring</code> 的改造可以参考现有的并发队列实现．而 <code>Driver</code> 底层依赖于 <a href="https://docs.rs/slab/latest/slab/" target="_blank" rel="noopener"><code>slab::Slab</code></a> 结构体，因此改造难度稍高．不过，目前 evering 已经支持使用固定大小的 <code>Slab</code>，基于这一点可以大幅降低多线程化的难度．</p>
<h3 id="基于-evering-实现系统调用"><a href="#基于-evering-实现系统调用" class="headerlink" title="基于 evering 实现系统调用"></a>基于 evering 实现系统调用</h3><p>evering-ipc 只适用于用户进程之间的通信，而本项目最初的目标是实现用户进程和内核的通信．对于这个目标，除了处理共享内存以外，可能还会遇到页表隔离的问题，以及用户进程意外退出后，对应内核异步任务的清理问题．更长远来看，当实现异步系统调用之后，那么可以将用户进程转彻底换成类似 Rust 中 <code>Future</code> 的无栈协程，从而将开销进一步降低．此外，迁移到异步系统调用时，不可避免的会破坏与现有同步代码的兼容性．因此，实现基于有栈绿色线程的异步系统调用也是一个值得尝试的目标．</p>
<!-- dprint-ignore-start -->

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/object-Object/" rel="tag"># [object Object]</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2025/06/30/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90os%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-%E9%82%B5%E5%8D%93%E7%82%9C/" rel="prev" title="第四阶段总结-邵卓炜">
      <i class="fa fa-chevron-left"></i> 第四阶段总结-邵卓炜
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2025/07/01/2023%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-%E5%91%A8%E7%9D%BF/" rel="next" title="2023开源操作系统训练营总结报告-周睿">
      2023开源操作系统训练营总结报告-周睿 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
