<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="rust基础的总结一.基本数据类型与所有权所有权系统核心规则 移动语义(Move)：123let s1 &#x3D; String::from(&quot;hello&quot;);  &#x2F;&#x2F; 堆分配let s2 &#x3D; s1;                    &#x2F;&#x2F; 所有权转移&#x2F;&#x2F; println!(&quot;&amp;#123;&amp;#125;&quot;, s1);           &#x2F;&#x2F; 错误！s1 已失效 借用规则： 任意时刻：一个可变引用 或">
<meta property="og:type" content="article">
<meta property="og:title" content="manchangfengxu">
<meta property="og:url" content="http://rcore-os.github.io/blog/2025/06/15/manchangfengxu/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:description" content="rust基础的总结一.基本数据类型与所有权所有权系统核心规则 移动语义(Move)：123let s1 &#x3D; String::from(&quot;hello&quot;);  &#x2F;&#x2F; 堆分配let s2 &#x3D; s1;                    &#x2F;&#x2F; 所有权转移&#x2F;&#x2F; println!(&quot;&amp;#123;&amp;#125;&quot;, s1);           &#x2F;&#x2F; 错误！s1 已失效 借用规则： 任意时刻：一个可变引用 或">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-15T13:31:42.000Z">
<meta property="article:modified_time" content="2025-11-07T04:51:28.974Z">
<meta property="article:author" content="rcore-os Group">
<meta property="article:tag" content="author:manchangfengxu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/2025/06/15/manchangfengxu/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>manchangfengxu | rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#rust基础的总结"><span class="nav-number">1.</span> <span class="nav-text">rust基础的总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-基本数据类型与所有权"><span class="nav-number">1.1.</span> <span class="nav-text">一.基本数据类型与所有权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#所有权系统核心规则"><span class="nav-number">1.1.1.</span> <span class="nav-text">所有权系统核心规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slice-类型"><span class="nav-number">1.1.2.</span> <span class="nav-text">Slice 类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-Crate-与模块系统"><span class="nav-number">1.2.</span> <span class="nav-text">二.Crate 与模块系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Crate-类型"><span class="nav-number">1.2.1.</span> <span class="nav-text">Crate 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块可见性规则"><span class="nav-number">1.2.2.</span> <span class="nav-text">模块可见性规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用外部-Crate"><span class="nav-number">1.2.3.</span> <span class="nav-text">使用外部 Crate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-Option-与错误处理"><span class="nav-number">1.3.</span> <span class="nav-text">三. Option 与错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Option-枚举"><span class="nav-number">1.3.1.</span> <span class="nav-text">Option 枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Result-lt-T-E-gt-错误处理"><span class="nav-number">1.3.2.</span> <span class="nav-text">Result&lt;T, E&gt; 错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误处理最佳实践"><span class="nav-number">1.3.3.</span> <span class="nav-text">错误处理最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-Trait-与泛型"><span class="nav-number">1.4.</span> <span class="nav-text">四. Trait 与泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Trait-定义与实现"><span class="nav-number">1.4.1.</span> <span class="nav-text">Trait 定义与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型函数"><span class="nav-number">1.4.2.</span> <span class="nav-text">泛型函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trait-Bound-语法糖"><span class="nav-number">1.4.3.</span> <span class="nav-text">Trait Bound 语法糖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期进阶"><span class="nav-number">1.4.4.</span> <span class="nav-text">生命周期进阶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-智能指针"><span class="nav-number">1.5.</span> <span class="nav-text">五. 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用智能指针对比"><span class="nav-number">1.5.1.</span> <span class="nav-text">常用智能指针对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用示例"><span class="nav-number">1.5.2.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-迭代器与闭包"><span class="nav-number">1.6.</span> <span class="nav-text">六.迭代器与闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包类型推断"><span class="nav-number">1.6.1.</span> <span class="nav-text">闭包类型推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包捕获模式"><span class="nav-number">1.6.2.</span> <span class="nav-text">闭包捕获模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器适配器"><span class="nav-number">1.6.3.</span> <span class="nav-text">迭代器适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义迭代器"><span class="nav-number">1.6.4.</span> <span class="nav-text">自定义迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-并发与异步编程"><span class="nav-number">1.7.</span> <span class="nav-text">七.并发与异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程创建"><span class="nav-number">1.7.1.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道通信-mpsc"><span class="nav-number">1.7.2.</span> <span class="nav-text">通道通信 (mpsc)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享状态-Mutex"><span class="nav-number">1.7.3.</span> <span class="nav-text">共享状态 (Mutex)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步编程-async-await"><span class="nav-number">1.7.4.</span> <span class="nav-text">异步编程 (async&#x2F;await)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-常用集合类型"><span class="nav-number">1.8.</span> <span class="nav-text">八.常用集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vec-动态数组"><span class="nav-number">1.8.1.</span> <span class="nav-text">Vec 动态数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-lt-K-V-gt-哈希表"><span class="nav-number">1.8.2.</span> <span class="nav-text">HashMap&lt;K, V&gt; 哈希表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#阶段二-os基础"><span class="nav-number">2.</span> <span class="nav-text">阶段二,os基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lab1"><span class="nav-number">2.1.</span> <span class="nav-text">lab1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与上下文-特权级有关的寄存器"><span class="nav-number">2.1.1.</span> <span class="nav-text">与上下文, 特权级有关的寄存器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lab2"><span class="nav-number">2.2.</span> <span class="nav-text">lab2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SV39"><span class="nav-number">2.2.1.</span> <span class="nav-text">SV39</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页"><span class="nav-number">2.2.2.</span> <span class="nav-text">分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#跳板意义"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">跳板意义:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TrapContext新增字段"><span class="nav-number">2.2.3.</span> <span class="nav-text">TrapContext新增字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lab3"><span class="nav-number">2.3.</span> <span class="nav-text">lab3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-number">2.3.1.</span> <span class="nav-text">fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#功能实现"><span class="nav-number">2.3.2.</span> <span class="nav-text">功能实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lab4"><span class="nav-number">2.4.</span> <span class="nav-text">lab4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统"><span class="nav-number">2.4.1.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#easy-fs磁盘布局"><span class="nav-number">2.4.2.</span> <span class="nav-text">easy-fs磁盘布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lab5"><span class="nav-number">2.5.</span> <span class="nav-text">lab5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现功能"><span class="nav-number">2.5.1.</span> <span class="nav-text">实现功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex实现问题"><span class="nav-number">2.5.2.</span> <span class="nav-text">Mutex实现问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三阶段"><span class="nav-number">3.</span> <span class="nav-text">第三阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-组件化内核基础与-Unikernel-模式"><span class="nav-number">3.1.</span> <span class="nav-text">一, 组件化内核基础与 Unikernel 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#组件化内核介绍"><span class="nav-number">3.1.1.</span> <span class="nav-text">组件化内核介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Unikernel-模式"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">Unikernel 模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#核心组件"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">核心组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unikernel-的启动链"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">Unikernel 的启动链</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验"><span class="nav-number">3.1.2.</span> <span class="nav-text">实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-主函数-src-main-rs"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">1. 主函数 src&#x2F;main.rs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-依赖管理-Cargo-toml"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">2. 依赖管理 Cargo.toml</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-features-动态配置"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">3. features 动态配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#println"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">println!</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashmap"><span class="nav-number">3.1.2.5.</span> <span class="nav-text">hashmap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-内存管理与多任务基础"><span class="nav-number">3.2.</span> <span class="nav-text">二, 内存管理与多任务基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-分页的两个阶段"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">1. 分页的两个阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-算法"><span class="nav-number">3.2.0.2.</span> <span class="nav-text">2. 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3"><span class="nav-number">3.2.0.3.</span> <span class="nav-text">3.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任务数据结构-TaskInner"><span class="nav-number">3.2.0.4.</span> <span class="nav-text">任务数据结构 TaskInner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协作式调度"><span class="nav-number">3.2.0.5.</span> <span class="nav-text">协作式调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#组件"><span class="nav-number">3.2.0.5.1.</span> <span class="nav-text">组件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">3.2.0.6.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#byte"><span class="nav-number">3.2.0.6.1.</span> <span class="nav-text">byte</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#page"><span class="nav-number">3.2.0.6.2.</span> <span class="nav-text">page</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、调度-块设备-文件系统"><span class="nav-number">3.3.</span> <span class="nav-text">三、调度,块设备,文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟中断："><span class="nav-number">3.3.1.</span> <span class="nav-text">时钟中断：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码（Riscv64-中断初始化）"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">代码（Riscv64 中断初始化）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#块设备驱动："><span class="nav-number">3.3.2.</span> <span class="nav-text">块设备驱动：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Trait：BlockDriverOps"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">Trait：BlockDriverOps</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统："><span class="nav-number">3.3.3.</span> <span class="nav-text">文件系统：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加载流程"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">加载流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用加载示例（U-8-实验）"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">应用加载示例（U.8 实验）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验实现"><span class="nav-number">3.3.4.</span> <span class="nav-text">实验实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#寻找ing"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">寻找ing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">注意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-地址空间管理"><span class="nav-number">3.4.</span> <span class="nav-text">四, 地址空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缺页异常处理"><span class="nav-number">3.4.1.</span> <span class="nav-text">缺页异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ELF-格式解析"><span class="nav-number">3.4.2.</span> <span class="nav-text">ELF 格式解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验实现-1"><span class="nav-number">3.4.3.</span> <span class="nav-text">实验实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-Hypervisor"><span class="nav-number">3.5.</span> <span class="nav-text">五, Hypervisor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hypervisor"><span class="nav-number">3.5.1.</span> <span class="nav-text">Hypervisor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-定义"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-核心功能"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">1.2 核心功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-与模拟器的区别"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">1.3 与模拟器的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-虚拟化类型"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">1.4 虚拟化类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-Riscv64虚拟化扩展（H扩展）"><span class="nav-number">3.5.2.</span> <span class="nav-text">二. Riscv64虚拟化扩展（H扩展）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-特权级扩展"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">2.1 特权级扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-关键寄存器"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">2.2 关键寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-模式切换机制"><span class="nav-number">3.5.3.</span> <span class="nav-text">3. 模式切换机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-从Host到Guest（run-guest函数）"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">3.1 从Host到Guest（run_guest函数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-VM-Exit处理（以SBI调用为例）"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">3.2 VM-Exit处理（以SBI调用为例）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-1"><span class="nav-number">3.5.4.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">732</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">638</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/06/15/manchangfengxu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          manchangfengxu
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-15 13:31:42" itemprop="dateCreated datePublished" datetime="2025-06-15T13:31:42+00:00">2025-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-11-07 04:51:28" itemprop="dateModified" datetime="2025-11-07T04:51:28+00:00">2025-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="rust基础的总结"><a href="#rust基础的总结" class="headerlink" title="rust基础的总结"></a>rust基础的总结</h1><h2 id="一-基本数据类型与所有权"><a href="#一-基本数据类型与所有权" class="headerlink" title="一.基本数据类型与所有权"></a>一.基本数据类型与所有权</h2><h3 id="所有权系统核心规则"><a href="#所有权系统核心规则" class="headerlink" title="所有权系统核心规则"></a>所有权系统核心规则</h3><ol>
<li><strong>移动语义(Move)</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);  <span class="comment">// 堆分配</span></span><br><span class="line"><span class="keyword">let</span> s2 = s1;                    <span class="comment">// 所有权转移</span></span><br><span class="line"><span class="comment">// println!("&#123;&#125;", s1);           // 错误！s1 已失效</span></span><br></pre></td></tr></table></figure></li>
<li><strong>借用规则</strong>：<ul>
<li>任意时刻：<strong>一个</strong>可变引用 <strong>或</strong> 多个不可变引用</li>
<li>引用必须始终有效（悬垂指针禁止）</li>
</ul>
</li>
<li><strong>生命周期标注</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Slice-类型"><a href="#Slice-类型" class="headerlink" title="Slice 类型"></a>Slice 类型</h3><ul>
<li><strong>无所有权引用</strong>：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">let</span> hello: &amp;<span class="built_in">str</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];    <span class="comment">// 字符串切片</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> slice: &amp;[<span class="built_in">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];  <span class="comment">// 数组切片</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二-Crate-与模块系统"><a href="#二-Crate-与模块系统" class="headerlink" title="二.Crate 与模块系统"></a>二.Crate 与模块系统</h2><h3 id="Crate-类型"><a href="#Crate-类型" class="headerlink" title="Crate 类型"></a>Crate 类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>文件扩展名</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>二进制 Crate</td>
<td><code>main.rs</code></td>
<td>可执行程序</td>
</tr>
<tr>
<td>库 Crate</td>
<td><code>lib.rs</code></td>
<td>可复用代码库</td>
</tr>
</tbody></table>
<h3 id="模块可见性规则"><a href="#模块可见性规则" class="headerlink" title="模块可见性规则"></a>模块可见性规则</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;          <span class="comment">// pub 使模块公有</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用绝对路径访问</span></span><br><span class="line">crate::front_of_house::hosting::add_to_waitlist();</span><br></pre></td></tr></table></figure>

<h3 id="使用外部-Crate"><a href="#使用外部-Crate" class="headerlink" title="使用外部 Crate"></a>使用外部 Crate</h3><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.toml</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">"0.8.5"</span>  <span class="comment"># 语义化版本</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num = rand::thread_rng().gen_range(<span class="number">1</span>..<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-Option-与错误处理"><a href="#三-Option-与错误处理" class="headerlink" title="三. Option 与错误处理"></a>三. Option 与错误处理</h2><h3 id="Option-枚举"><a href="#Option-枚举" class="headerlink" title="Option 枚举"></a>Option<T> 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全解包</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">"Value: &#123;&#125;"</span>, i),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Missing value"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Result-lt-T-E-gt-错误处理"><a href="#Result-lt-T-E-gt-错误处理" class="headerlink" title="Result&lt;T, E&gt; 错误处理"></a>Result&lt;T, E&gt; 错误处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误传播简写</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_config</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(<span class="string">"config.toml"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="literal">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理最佳实践"><a href="#错误处理最佳实践" class="headerlink" title="错误处理最佳实践"></a>错误处理最佳实践</h3><ol>
<li>优先使用 <code>Result</code> 而非 panic</li>
<li>使用 <code>?</code> 操作符传播错误</li>
<li>自定义错误类型实现 <code>std::error::Error</code></li>
</ol>
<h2 id="四-Trait-与泛型"><a href="#四-Trait-与泛型" class="headerlink" title="四. Trait 与泛型"></a>四. Trait 与泛型</h2><h3 id="Trait-定义与实现"><a href="#Trait-定义与实现" class="headerlink" title="Trait 定义与实现"></a>Trait 定义与实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    headline: <span class="built_in">String</span>,</span><br><span class="line">    location: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) -&gt; &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trait-Bound-语法糖"><a href="#Trait-Bound-语法糖" class="headerlink" title="Trait Bound 语法糖"></a>Trait Bound 语法糖</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法等价</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Display + <span class="built_in">Clone</span>&gt;(item: &amp;T) &#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;(<span class="keyword">impl</span> Display + <span class="built_in">Clone</span>)) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生命周期进阶"><a href="#生命周期进阶" class="headerlink" title="生命周期进阶"></a>生命周期进阶</h3><p><strong>生命周期标注必要性</strong>：</p>
<ol>
<li>结构体持有引用时必须显式标注生命周期，确保引用的有效性</li>
<li>方法实现中：<ul>
<li><code>&amp;self</code> 参数隐含 <code>&amp;&#39;a self</code> 生命周期</li>
<li>返回值关联结构体生命周期（通过生命周期消除规则第三项）</li>
</ul>
</li>
<li>遵循Rust生命周期消除三规则：<ul>
<li>每个输入引用自动获得独立生命周期</li>
<li>单个输入引用时所有输出引用与其生命周期对齐</li>
<li>方法签名中 <code>&amp;self</code> 使输出引用与结构体生命周期对齐</li>
</ul>
</li>
</ol>
<p><strong>错误</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangling_reference</span></span>() -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"temporary"</span>);</span><br><span class="line">    &amp;s[..]  <span class="comment">// 错误！返回局部变量引用</span></span><br><span class="line">&#125; <span class="comment">// s离开作用域被丢弃</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">announce_and_return</span></span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Attention: &#123;&#125;"</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-智能指针"><a href="#五-智能指针" class="headerlink" title="五. 智能指针"></a>五. 智能指针</h2><h3 id="常用智能指针对比"><a href="#常用智能指针对比" class="headerlink" title="常用智能指针对比"></a>常用智能指针对比</h3><table>
<thead>
<tr>
<th>类型</th>
<th>所有权</th>
<th>线程安全</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>Box&lt;T&gt;</code></td>
<td>单一</td>
<td>是</td>
<td>堆分配、递归类型</td>
</tr>
<tr>
<td><code>Rc&lt;T&gt;</code></td>
<td>共享</td>
<td>否</td>
<td>单线程引用计数</td>
</tr>
<tr>
<td><code>Arc&lt;T&gt;</code></td>
<td>共享</td>
<td>是</td>
<td>多线程引用计数</td>
</tr>
<tr>
<td><code>RefCell&lt;T&gt;</code></td>
<td>可变</td>
<td>否</td>
<td>运行时借用检查</td>
</tr>
</tbody></table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Box 用于递归类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rc 共享所有权</span></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">let</span> a = Rc::new(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> b = Rc::clone(&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefCell 运行时借用检查</span></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">let</span> c = RefCell::new(<span class="number">42</span>);</span><br><span class="line">*c.borrow_mut() += <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="六-迭代器与闭包"><a href="#六-迭代器与闭包" class="headerlink" title="六.迭代器与闭包"></a>六.迭代器与闭包</h2><h3 id="闭包类型推断"><a href="#闭包类型推断" class="headerlink" title="闭包类型推断"></a>闭包类型推断</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add_one = |x| x + <span class="number">1</span>;         <span class="comment">// 类型自动推导</span></span><br><span class="line"><span class="keyword">let</span> print = || <span class="built_in">println!</span>(<span class="string">"hello"</span>); <span class="comment">// 无参闭包</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包捕获模式"><a href="#闭包捕获模式" class="headerlink" title="闭包捕获模式"></a>闭包捕获模式</h3><table>
<thead>
<tr>
<th>捕获方式</th>
<th>关键字</th>
<th>所有权</th>
</tr>
</thead>
<tbody><tr>
<td>不可变借用</td>
<td>`</td>
<td></td>
</tr>
<tr>
<td>可变借用</td>
<td>`</td>
<td>mut</td>
</tr>
<tr>
<td>值捕获</td>
<td><code>move</code></td>
<td>转移</td>
</tr>
</tbody></table>
<h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"><span class="keyword">let</span> sum: <span class="built_in">i32</span> = v.iter()</span><br><span class="line">    .map(|x| x * <span class="number">2</span>)        <span class="comment">// 加倍</span></span><br><span class="line">    .filter(|x| x % <span class="number">4</span> == <span class="number">0</span>) <span class="comment">// 过滤4的倍数</span></span><br><span class="line">    .sum();                 <span class="comment">// 求和</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    count: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-并发与异步编程"><a href="#七-并发与异步编程" class="headerlink" title="七.并发与异步编程"></a>七.并发与异步编程</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"From spawned thread"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">handle.join().unwrap();</span><br></pre></td></tr></table></figure>

<h3 id="通道通信-mpsc"><a href="#通道通信-mpsc" class="headerlink" title="通道通信 (mpsc)"></a>通道通信 (mpsc)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx.send(<span class="string">"Message"</span>).unwrap();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Received: &#123;&#125;"</span>, rx.recv().unwrap());</span><br></pre></td></tr></table></figure>

<h3 id="共享状态-Mutex"><a href="#共享状态-Mutex" class="headerlink" title="共享状态 (Mutex)"></a>共享状态 (Mutex)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handles: <span class="built_in">Vec</span>&lt;_&gt; = (<span class="number">0</span>..<span class="number">10</span>).map(|_| &#123;</span><br><span class="line">    <span class="keyword">let</span> c = Arc::clone(&amp;counter);</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = c.lock().unwrap();</span><br><span class="line">        *num += <span class="number">1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).collect();</span><br></pre></td></tr></table></figure>

<h3 id="异步编程-async-await"><a href="#异步编程-async-await" class="headerlink" title="异步编程 (async/await)"></a>异步编程 (async/await)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_data</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">    reqwest::get(<span class="string">"https://api.example.com/data"</span>)</span><br><span class="line">        .<span class="keyword">await</span>?</span><br><span class="line">        .text()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> data = fetch_data().<span class="keyword">await</span>.unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Data: &#123;&#125;"</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八-常用集合类型"><a href="#八-常用集合类型" class="headerlink" title="八.常用集合类型"></a>八.常用集合类型</h2><h3 id="Vec-动态数组"><a href="#Vec-动态数组" class="headerlink" title="Vec 动态数组"></a>Vec<T> 动态数组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::with_capacity(<span class="number">10</span>);</span><br><span class="line">v.extend([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全访问</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(val) = v.get(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Second element: &#123;&#125;"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有权注意事项</span></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// v.push(4); // 编译错误！存在不可变引用时禁止修改</span></span><br></pre></td></tr></table></figure>

<h3 id="HashMap-lt-K-V-gt-哈希表"><a href="#HashMap-lt-K-V-gt-哈希表" class="headerlink" title="HashMap&lt;K, V&gt; 哈希表"></a>HashMap&lt;K, V&gt; 哈希表</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="string">"Blue"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry API 安全更新</span></span><br><span class="line">scores.entry(<span class="string">"Yellow"</span>).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="string">"Blue"</span>).and_modify(|e| *e += <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1 id="阶段二-os基础"><a href="#阶段二-os基础" class="headerlink" title="阶段二,os基础"></a>阶段二,os基础</h1><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><h3 id="与上下文-特权级有关的寄存器"><a href="#与上下文-特权级有关的寄存器" class="headerlink" title="与上下文, 特权级有关的寄存器"></a>与上下文, 特权级有关的寄存器</h3><ul>
<li>sstatus：包含了处理器的状态信息，包括特权级别和中断使能状态。恢复 sstatus 的值确保在返回用户态时，处理器的特权级别和中断状态与陷阱发生前一致。</li>
<li>sepc：保存了中断或异常发生时的程序计数器值。恢复 sepc 的值确保在返回用户态时，处理器能够从中断或异常发生的地方继续执行。</li>
<li>sscratch：保存了用户栈指针。在切换到用户态之前，将用户栈指针保存到 sscratch 寄存器中，以便在用户态下使用。</li>
<li>sret根据sstatus中的SPP位指示切换为用户态。（寄存器中的一个位，0,u_mode;1_,s_mode,s_mode）</li>
<li>scause: Trap原因/种类</li>
<li>stvec: trap_handle地址</li>
</ul>
<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><h3 id="SV39"><a href="#SV39" class="headerlink" title="SV39"></a>SV39</h3><ul>
<li>virtual page 39位, 38-12为虚拟页号</li>
<li>页表项PTE: Reserver: 10, PPN2: 26, PPN1: 9, PPN0: 9, RSW: 2, DAGUXWRV</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul>
<li>MMU地址转换</li>
<li>kernel address space最高位为 “跳板”, app ks, guard page</li>
<li>app address space, 最高位为跳板, TrapContext, UserStack, GP, Framed<h4 id="跳板意义"><a href="#跳板意义" class="headerlink" title="跳板意义:"></a>跳板意义:</h4>satp, 切换后,地址映射不同, 例如:上下文切换的restore, 在更改satp指令后, 保证下一条指令在不同的地址映射下能被正确寻址,保证指令的连续执行</li>
</ul>
<h3 id="TrapContext新增字段"><a href="#TrapContext新增字段" class="headerlink" title="TrapContext新增字段"></a>TrapContext新增字段</h3><p>在进行特权级转换时, 需要相应的sp以及satp的token</p>
<ul>
<li>pub kernel_satp: usize, 内核地址空间的 token</li>
<li>pub kernel_sp: usize, 当前应用在内核地址空间中的内核栈栈顶的虚拟地址</li>
<li>pub trap_handler: usize, 内核中 trap handler 入口点的虚拟地址</li>
</ul>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><ul>
<li>获得父进程的地址空间</li>
<li>sepc + 4</li>
<li>a0返回参数更改,父子进程不相同</li>
<li>维护父子进程关系</li>
<li>fd, 死锁检测等</li>
</ul>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ul>
<li><p>stride算法:</p>
<ul>
<li>为TCB加上schedule块(struct), 同时预留了pass设置的接口</li>
<li>为sys_set_priority加入了对priority的设置 </li>
<li>将TaskManager块改为了用binaryheap存储, 并为TCB分配了Ord特性,每次选取都会取stride最小的调度</li>
</ul>
</li>
<li><p>向前兼容</p>
<ul>
<li>重写mmap和munmap(用到了remove_area_with_start_vpn)</li>
<li>重写了sys_get_time,用到了translate_va</li>
</ul>
</li>
</ul>
<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统本质上是一堆块上的抽象, 在内存中有缓存块对其进行映射.</p>
<p>进程维护一个文件描述符表,可映射到对应的缓存块</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ],</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    modified: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供对应的接口调用</span></span><br></pre></td></tr></table></figure>

<h3 id="easy-fs磁盘布局"><a href="#easy-fs磁盘布局" class="headerlink" title="easy-fs磁盘布局"></a>easy-fs磁盘布局</h3><ul>
<li><p>超级块 (Super Block)，用于定位其他连续区域的位置，检查文件系统合法性。</p>
</li>
<li><p>索引节点位图，长度为若干个块。它记录了索引节点区域中有哪些索引节点已经被分配出去使用了。</p>
</li>
<li><p>索引节点区域，长度为若干个块。其中的每个块都存储了若干个索引节点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT],</span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>,</span><br><span class="line">    type_: DiskInodeType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据块位图，长度为若干个块。它记录了后面的数据块区域中有哪些已经被分配出去使用了。</p>
</li>
<li><p>数据块区域，其中的每个被分配出去的块保存了文件或目录的具体内容。</p>
</li>
</ul>
<h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>在引入线程后, 调度机制本质上是在线程块上进行切换. 会区分主线程和子线程</p>
<ul>
<li>创建线程不需要要建立新的地址空间</li>
<li>能够访问到进程所拥有的代码段， 堆和其他数据段</li>
<li>专有的用户态栈</li>
</ul>
<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><ul>
<li>在ProcessControlBlockInner加入了对mutex和sem的死锁检查块(all[], ava[], need[])</li>
<li>检测前对相应资源的need[] + 1</li>
<li>实现is_safe检测函数, 对finish==false和need &lt;= work的块, 回收allocation和finish=true,对标记flag=true, 当finish没有任何改变, 即本次循环flag==false时退出loop, 利用闭包all,检测finish所有线程是否全是true</li>
<li>若为unsafe, 则回退need, 返回-0xdead</li>
<li>若为safe, 则在down和lock之前drop(process_inner),防止线程堵塞无法释放资源, 在down和lock之后同时更新检查块中的矩阵</li>
<li>为up和unlock加上检查块的更新</li>
</ul>
<h3 id="Mutex实现问题"><a href="#Mutex实现问题" class="headerlink" title="Mutex实现问题"></a>Mutex实现问题</h3><ul>
<li>Mutex1的lock里,会一直尝试获取锁, 具体逻辑为当无法获得锁时,直接阻塞,让出cpu,直到被唤醒, 再重新尝试获得锁, unlock中释放锁,并且唤醒一个线程去竞争这个锁.</li>
<li>Mutex的lock,在无法获得锁时,直接堵塞,在unlock时,只有等待队列为空才释放锁.<pre><code>- 这里的unlock本质是锁资源的转移, A不释放锁, 而是唤醒一个直接使用这个资源的B线程(它醒来后直接运行临界区后的代码)</code></pre></li>
</ul>
<h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><h2 id="一-组件化内核基础与-Unikernel-模式"><a href="#一-组件化内核基础与-Unikernel-模式" class="headerlink" title="一, 组件化内核基础与 Unikernel 模式"></a><strong>一, 组件化内核基础与 Unikernel 模式</strong></h2><h3 id="组件化内核介绍"><a href="#组件化内核介绍" class="headerlink" title="组件化内核介绍"></a>组件化内核介绍</h3><h4 id="Unikernel-模式"><a href="#Unikernel-模式" class="headerlink" title="Unikernel 模式"></a>Unikernel 模式</h4><ul>
<li><strong>特点</strong>：<ul>
<li>应用与内核合一：编译为一个 Image，共享同一特权级（内核态）和地址空间。</li>
<li>无用户态 / 内核态切换：简单高效，但安全性较低（应用可直接访问内核资源）。</li>
</ul>
</li>
</ul>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><table>
<thead>
<tr>
<th>组件名称</th>
<th>功能描述</th>
<th>在实验中的作用</th>
</tr>
</thead>
<tbody><tr>
<td>axhal</td>
<td>硬件抽象层，屏蔽不同架构差异（如 Riscv64/ARM）</td>
<td>初始化串口、内存等硬件，提供底层 IO 接口</td>
</tr>
<tr>
<td>axruntime</td>
<td>内核运行时环境，负责引导流程、内存初始化、任务调度框架</td>
<td>执行内核启动流程，调用应用层代码</td>
</tr>
<tr>
<td>axstd</td>
<td>内核态标准库，提供基础数据结构和工具函数（如 println!）</td>
<td>实现字符终端输出功能</td>
</tr>
<tr>
<td>arceos_api</td>
<td>内核公共接口，定义组件间通信协议</td>
<td>统一组件间调用规范</td>
</tr>
</tbody></table>
<h4 id="Unikernel-的启动链"><a href="#Unikernel-的启动链" class="headerlink" title="Unikernel 的启动链"></a>Unikernel 的启动链</h4><ul>
<li><strong>硬件启动</strong>：通过 OpenSBI（Riscv 固件）加载内核 Image 到内存。</li>
<li><strong>引导阶段（axhal）</strong>：<ul>
<li>初始化 CPU 寄存器、MMU 分页（早期恒等映射）。</li>
<li>建立内核栈，为 Rust 运行时做准备。</li>
</ul>
</li>
<li><strong>运行时阶段（axruntime）</strong>：<ul>
<li>初始化内存分配器、日志系统。</li>
<li>调用应用层 main 函数，执行具体功能。</li>
</ul>
</li>
</ul>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="1-主函数-src-main-rs"><a href="#1-主函数-src-main-rs" class="headerlink" title="1. 主函数 src/main.rs"></a>1. 主函数 src/main.rs</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(feature = <span class="meta-string">"axstd"</span>, no_main)]</span> <span class="comment">// 若启用 axstd，不使用标准库的 main 入口</span></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"axstd"</span>)]</span> <span class="comment">// 根据 feature 条件编译</span></span><br><span class="line"><span class="keyword">use</span> axstd::println; <span class="comment">// 使用 axstd 的打印函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg_attr(feature = <span class="meta-string">"axstd"</span>, no_mangle)]</span> <span class="comment">// 避免符号名被修改</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, ArceOS!"</span>); <span class="comment">// 调用 axhal 提供的串口输出功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-依赖管理-Cargo-toml"><a href="#2-依赖管理-Cargo-toml" class="headerlink" title="2. 依赖管理 Cargo.toml"></a>2. 依赖管理 Cargo.toml</h4><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">axstd</span> = &#123; workspace = <span class="literal">true</span> &#125; // 引入 axstd 组件，支持标准库功能</span><br><span class="line"><span class="attr">arceos_api</span> = &#123; workspace = <span class="literal">true</span> &#125; // 引入内核公共接口</span><br></pre></td></tr></table></figure>

<h4 id="3-features-动态配置"><a href="#3-features-动态配置" class="headerlink" title="3. features 动态配置"></a>3. features 动态配置</h4><ul>
<li><strong>作用</strong>：通过编译参数控制组件的启用，实现 “按需构建”。</li>
<li><strong>示例</strong>：<ul>
<li>axstd 组件通过 feature = “axstd” 控制是否包含。</li>
<li>实验中默认启用 axstd，因此能使用 println!。</li>
</ul>
</li>
</ul>
<h4 id="println"><a href="#println" class="headerlink" title="println!"></a>println!</h4><p>通过更改ulib下axstd,macros文件中的println!</p>
<h4 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"alloc"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> collections;</span><br></pre></td></tr></table></figure>
<p>暴露自己写的collections</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies.hashbrown]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.14"</span></span><br><span class="line"><span class="attr">default-features</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>用了官方库的core版本</p>
<h2 id="二-内存管理与多任务基础"><a href="#二-内存管理与多任务基础" class="headerlink" title="二, 内存管理与多任务基础"></a><strong>二, 内存管理与多任务基础</strong></h2><h4 id="1-分页的两个阶段"><a href="#1-分页的两个阶段" class="headerlink" title="1. 分页的两个阶段"></a>1. 分页的两个阶段</h4><table>
<thead>
<tr>
<th>阶段</th>
<th>目标</th>
<th>实现方式</th>
<th>关键组件</th>
</tr>
</thead>
<tbody><tr>
<td>早期启用（必须）</td>
<td>快速建立基本映射，保证内核启动</td>
<td>1GB 恒等映射（虚拟地址 = 物理地址）</td>
<td>axhal 中的 BOOT_PT_SV39 页表</td>
</tr>
<tr>
<td>后期重映射（可选，需 paging feature）</td>
<td>扩展地址空间，支持设备 MMIO</td>
<td>细粒度权限控制（如只读、可执行）</td>
<td>axmm 中的 AddrSpace、PageTable</td>
</tr>
</tbody></table>
<h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h4><table>
<thead>
<tr>
<th>算法</th>
<th align="center">原理</th>
</tr>
</thead>
<tbody><tr>
<td>TLSF</td>
<td align="center">两级 Bitmap + 链表管理空闲块</td>
</tr>
<tr>
<td>Buddy</td>
<td align="center">基于 2 的幂次分裂 / 合并空闲块</td>
</tr>
<tr>
<td>Slab</td>
<td align="center">为特定大小对象创建缓存池</td>
</tr>
</tbody></table>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>全局分配器：通过 <code>#[global_allocator]</code> 声明，实现 <code>GlobalAlloc</code> trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg_attr(all(target_os = <span class="meta-string">"none"</span>, not(test)), global_allocator)]</span></span><br><span class="line"><span class="keyword">static</span> GLOBAL_ALLOCATOR: GlobalAllocator = GlobalAllocator::new();</span><br></pre></td></tr></table></figure>

<h4 id="任务数据结构-TaskInner"><a href="#任务数据结构-TaskInner" class="headerlink" title="任务数据结构 TaskInner"></a>任务数据结构 <code>TaskInner</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskInner</span></span> &#123;</span><br><span class="line">    id: TaskId,           <span class="comment">// 唯一标识</span></span><br><span class="line">    name: <span class="built_in">String</span>,         <span class="comment">// 任务名称（调试用）</span></span><br><span class="line">    state: AtomicU8,      <span class="comment">// 状态（Running/Ready/Blocked/Exited）</span></span><br><span class="line">    kstack: <span class="built_in">Option</span>&lt;TaskStack&gt;, <span class="comment">// 任务栈（类似线程栈）</span></span><br><span class="line">    ctx: UnsafeCell&lt;TaskContext&gt;, <span class="comment">// 上下文（保存寄存器状态）</span></span><br><span class="line">    <span class="comment">// 其他字段：调度相关（如时间片、优先级）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协作式调度"><a href="#协作式调度" class="headerlink" title="协作式调度"></a>协作式调度</h4><p>FIFO 队列：任务按 “先到先服务” 原则执行，当前任务需主动让出 CPU（调用 <code>yield_now()</code>）。</p>
<h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><table>
<thead>
<tr>
<th>组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>axsync</td>
<td>同步原语（自旋锁、互斥锁）</td>
</tr>
<tr>
<td>axtask</td>
<td>调度接口（spawn/yield_now 等）</td>
</tr>
</tbody></table>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>EarlyAllocator实现要求比较低</p>
<h5 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h5><ul>
<li><strong>alloc</strong><ul>
<li>注意每次分配内存时候的对齐</li>
<li>预分配，检查是否与p_pos重叠</li>
<li>为count++<ul>
<li>注意每次分配内存时候的对齐</li>
<li>预分配,检查是否与p_pos重叠</li>
<li>为count++</li>
</ul>
</li>
</ul>
</li>
<li>dealloc<ul>
<li>单纯的count–</li>
<li>count==0时,就可以重置b_pos了</li>
</ul>
</li>
</ul>
<h5 id="page"><a href="#page" class="headerlink" title="page"></a>page</h5><ul>
<li><strong>alloc</strong><ul>
<li>检查alignment是否有效</li>
<li>获取分配的size进行对齐，同时检查是否越界</li>
<li>更新数据<ul>
<li>检查alignment是否有效</li>
<li>获取分配的size进行对齐,同时检查是否越界</li>
<li>更新数据</li>
</ul>
</li>
</ul>
</li>
<li>dealloc<ul>
<li>不要求实现</li>
</ul>
</li>
</ul>
<h2 id="三、调度-块设备-文件系统"><a href="#三、调度-块设备-文件系统" class="headerlink" title="三、调度,块设备,文件系统"></a><strong>三、调度,块设备,文件系统</strong></h2><h3 id="时钟中断："><a href="#时钟中断：" class="headerlink" title="时钟中断："></a>时钟中断：</h3><h4 id="代码（Riscv64-中断初始化）"><a href="#代码（Riscv64-中断初始化）" class="headerlink" title="代码（Riscv64 中断初始化）"></a>代码（Riscv64 中断初始化）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axhal/src/platform/riscv64_qemu_virt/mod.rs</span></span><br><span class="line">axhal::irq::register_handler(TIMER_IRQ_NUM, || &#123;</span><br><span class="line">    update_timer(); <span class="comment">// 更新系统时间</span></span><br><span class="line">    axtask::on_timer_tick(); <span class="comment">// 触发调度器更新</span></span><br><span class="line">&#125;);</span><br><span class="line">axhal::arch::enable_irqs(); <span class="comment">// 开中断</span></span><br></pre></td></tr></table></figure>


<h3 id="块设备驱动："><a href="#块设备驱动：" class="headerlink" title="块设备驱动："></a>块设备驱动：</h3><h4 id="Trait：BlockDriverOps"><a href="#Trait：BlockDriverOps" class="headerlink" title="Trait：BlockDriverOps"></a>Trait：BlockDriverOps</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BlockDriverOps</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">num_blocks</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u64</span>; <span class="comment">// 磁盘总块数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">block_size</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span>; <span class="comment">// 块大小（512 字节）</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_id: <span class="built_in">u64</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; DevResult; <span class="comment">// 读块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="文件系统："><a href="#文件系统：" class="headerlink" title="文件系统："></a>文件系统：</h3><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>文件系统（FileSystem）：如 FAT32、EXT4。</p>
<p>目录（Dir）：存储文件 / 子目录元数据。</p>
<p>文件（File）：存储具体数据，支持读写操作。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">VfsOps</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">root_dir</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;DirNode; <span class="comment">// 获取根目录</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lookup</span></span>(&amp;<span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;FileNode&gt;; <span class="comment">// 解析路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h4><p>块设备读取：通过 VirtIO Blk 驱动读取磁盘前 512 字节（引导扇区）。</p>
<p>解析 BPB：获取 FAT 表起始地址、簇大小等参数。</p>
<p>挂载文件系统：将 FAT32 的根目录挂载到 VFS 的 / 节点。</p>
<h4 id="应用加载示例（U-8-实验）"><a href="#应用加载示例（U-8-实验）" class="headerlink" title="应用加载示例（U.8 实验）"></a>应用加载示例（U.8 实验）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 FAT32 文件系统加载应用程序</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">load_app</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> root = vfs.root_dir();</span><br><span class="line">    <span class="keyword">let</span> file = root.lookup(path).ok_or(<span class="string">"文件不存在"</span>)?;</span><br><span class="line">    file.read_to_end() <span class="comment">// 读取文件内容到内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h3><h4 id="寻找ing"><a href="#寻找ing" class="headerlink" title="寻找ing"></a>寻找ing</h4><p>在axfs_ramf中实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> VfsNodeOps <span class="keyword">for</span> DirNode&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>文件时通过封装的BTreeMap管理的, 替换相应键值对即可</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">rename</span></span>(&amp;<span class="keyword">self</span>, src_path: &amp;<span class="built_in">str</span>, dst_path: &amp;<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<p>src和dst_path路径层级不一样<br>我使用了split_path_to_end来获取最终的文件名</p>
<h2 id="四-地址空间管理"><a href="#四-地址空间管理" class="headerlink" title="四, 地址空间管理"></a><strong>四, 地址空间管理</strong></h2><h3 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键修改：init_user_stack的lazy参数设为false</span></span><br><span class="line"><span class="keyword">let</span> ustack_top = init_user_stack(&amp;<span class="keyword">mut</span> uspace, <span class="literal">false</span>).unwrap(); <span class="comment">// 延迟映射</span></span><br></pre></td></tr></table></figure>

<p><strong>缺页异常处理流程</strong></p>
<ul>
<li>异常触发：用户态访问未映射地址（如栈写入），CPU 陷入内核。</li>
<li>处理逻辑：<ol>
<li>通过handle_page_fault函数申请物理页帧（alloc_frame）</li>
<li>在页表中建立虚拟地址与物理页帧的映射（pt.remap）</li>
</ol>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_page_fault</span></span>(...) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> frame = alloc_frame(<span class="literal">true</span>); <span class="comment">// 申请物理页</span></span><br><span class="line">    pt.remap(vaddr, frame, orig_flags); <span class="comment">// 建立映射</span></span><br><span class="line">    tlb.flush(); <span class="comment">// 刷新TLB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ELF-格式解析"><a href="#ELF-格式解析" class="headerlink" title="ELF 格式解析"></a>ELF 格式解析</h3><p>关键段：<br>LOAD 段：包含代码段（R E标志）和数据段（RW标志）。<br>BSS 段：未初始化数据，ELF 文件不存储，内核需预留空间并清零。<br>加载逻辑：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> segment <span class="keyword">in</span> elf.segments &#123;</span><br><span class="line">    if segment.type == LOAD &#123;</span><br><span class="line">        <span class="keyword">let</span> vaddr = segment.virt_addr;</span><br><span class="line">        <span class="keyword">let</span> phys_frame = alloc_frame(segment.mem_siz);</span><br><span class="line">        map_virtual_to_physical(vaddr, phys_frame, segment.flags);</span><br><span class="line">        <span class="keyword">if</span> segment.has_data &#123;</span><br><span class="line">            copy_file_data(vaddr, segment.file_offset, segment.file_siz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zero_memory(vaddr, segment.mem_siz); <span class="comment">// BSS段清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验实现-1"><a href="#实验实现-1" class="headerlink" title="实验实现"></a>实验实现</h3><p>得到aspace-&gt;分配内存-&gt;将文件信息写入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAP_SHARED = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;    <span class="comment">// 共享映射，对映射区域的修改会反映到文件中</span></span><br><span class="line"><span class="keyword">const</span> MAP_PRIVATE = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;   <span class="comment">// 私有映射，对映射区域的修改不会反映到文件中</span></span><br><span class="line"><span class="keyword">const</span> MAP_FIXED = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;     <span class="comment">// 必须使用指定的映射地址</span></span><br><span class="line"><span class="keyword">const</span> MAP_ANONYMOUS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>; <span class="comment">// 匿名映射，不与文件关联</span></span><br><span class="line"><span class="keyword">const</span> MAP_NORESERVE = <span class="number">1</span> &lt;&lt; <span class="number">14</span>; <span class="comment">// 不保留交换空间</span></span><br><span class="line"><span class="keyword">const</span> MAP_STACK = <span class="number">0x20000</span>;    <span class="comment">// 用于栈分配</span></span><br></pre></td></tr></table></figure>

<p>这里只处理MAP_PRIVATE,<br>同时addr.is_null(),可通过aspace.find_free_area寻找内存</p>
<h2 id="五-Hypervisor"><a href="#五-Hypervisor" class="headerlink" title="五, Hypervisor"></a><strong>五, Hypervisor</strong></h2><h3 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>Hypervisor（虚拟机监控器）是运行在物理硬件与虚拟机之间的虚拟化层软件，允许多个虚拟机共享物理资源，每个虚拟机拥有独立的虚拟硬件环境（如vCPU、vMem、vDevice）。</p>
<h4 id="1-2-核心功能"><a href="#1-2-核心功能" class="headerlink" title="1.2 核心功能"></a>1.2 核心功能</h4><ul>
<li><strong>资源虚拟化</strong>：模拟CPU、内存、设备等硬件资源</li>
<li><strong>隔离与调度</strong>：确保虚拟机之间资源隔离，并高效调度物理资源</li>
<li><strong>模式切换</strong>：在Host（Hypervisor）与Guest（虚拟机）之间双向切换</li>
</ul>
<h4 id="1-3-与模拟器的区别"><a href="#1-3-与模拟器的区别" class="headerlink" title="1.3 与模拟器的区别"></a>1.3 与模拟器的区别</h4><table>
<thead>
<tr>
<th>维度</th>
<th>Hypervisor</th>
<th>模拟器(Emulator)</th>
</tr>
</thead>
<tbody><tr>
<td>ISA一致性</td>
<td>虚拟环境与物理环境ISA一致</td>
<td>可模拟不同ISA（如x86模拟ARM）</td>
</tr>
<tr>
<td>指令执行</td>
<td>大部分指令直接在物理CPU执行</td>
<td>全部指令需翻译/解释执行</td>
</tr>
<tr>
<td>性能目标</td>
<td>高效（虚拟化开销低）</td>
<td>侧重仿真效果，性能要求低</td>
</tr>
</tbody></table>
<h4 id="1-4-虚拟化类型"><a href="#1-4-虚拟化类型" class="headerlink" title="1.4 虚拟化类型"></a>1.4 虚拟化类型</h4><ol>
<li><strong>I型Hypervisor</strong>：直接运行在硬件上（如Xen、KVM），性能高</li>
<li><strong>II型Hypervisor</strong>：运行在宿主OS上（如VirtualBox），依赖宿主资源管理</li>
</ol>
<h3 id="二-Riscv64虚拟化扩展（H扩展）"><a href="#二-Riscv64虚拟化扩展（H扩展）" class="headerlink" title="二. Riscv64虚拟化扩展（H扩展）"></a>二. Riscv64虚拟化扩展（H扩展）</h3><h4 id="2-1-特权级扩展"><a href="#2-1-特权级扩展" class="headerlink" title="2.1 特权级扩展"></a>2.1 特权级扩展</h4><p>新增特权级：</p>
<ul>
<li><strong>HS</strong>(Hypervisor Supervisor)：Host域的管理级，负责虚拟化控制</li>
<li><strong>VS</strong>(Virtual Supervisor)：Guest域的内核级，运行Guest OS内核</li>
<li><strong>VU</strong>(Virtual User)：Guest域的用户级，运行Guest应用</li>
</ul>
<p>特权级关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">物理机：M（最高） &gt; HS &gt; U</span><br><span class="line">虚拟机：VS（Guest内核） &gt; VU（Guest用户）</span><br></pre></td></tr></table></figure>

<h4 id="2-2-关键寄存器"><a href="#2-2-关键寄存器" class="headerlink" title="2.2 关键寄存器"></a>2.2 关键寄存器</h4><ul>
<li><strong>hstatus</strong>：控制Host与Guest的模式切换<ul>
<li>SPV位：指示进入HS前的模式（0：非虚拟化模式；1：来自Guest的VS模式）</li>
<li>SPVP位：控制HS是否有权限操作Guest的地址空间</li>
</ul>
</li>
<li><strong>vs[xxx]/hs[xxx]</strong>：分别用于Guest和Host的上下文管理</li>
<li><strong>misa</strong>：标识是否支持H扩展（bit7=1表示支持）</li>
</ul>
<h3 id="3-模式切换机制"><a href="#3-模式切换机制" class="headerlink" title="3. 模式切换机制"></a>3. 模式切换机制</h3><h4 id="3-1-从Host到Guest（run-guest函数）"><a href="#3-1-从Host到Guest（run-guest函数）" class="headerlink" title="3.1 从Host到Guest（run_guest函数）"></a>3.1 从Host到Guest（run_guest函数）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存Host寄存器状态</span></span><br><span class="line">sd ra, (hyp_ra)(a0)  <span class="comment">// 保存返回地址</span></span><br><span class="line"><span class="comment">// 加载Guest寄存器状态</span></span><br><span class="line">ld sstatus, guest_sstatus(a0)</span><br><span class="line"><span class="comment">// 执行sret指令切换到VS模式</span></span><br><span class="line">sret</span><br></pre></td></tr></table></figure>
<p>可参考guest.s</p>
<ul>
<li>a0指向的guest_reg区域 与 当前reg的替换<h4 id="3-2-VM-Exit处理（以SBI调用为例）"><a href="#3-2-VM-Exit处理（以SBI调用为例）" class="headerlink" title="3.2 VM-Exit处理（以SBI调用为例）"></a>3.2 VM-Exit处理（以SBI调用为例）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">    Trap::Exception(Exception::VirtualSupervisorEnvCall) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> sbi_msg = SbiMessage::from_regs(ctx.guest_regs.gpr);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(SbiMessage::Reset(Shutdown)) = sbi_msg &#123;</span><br><span class="line">            ax_println!(<span class="string">"Shutdown vm normally!"</span>);</span><br><span class="line">            <span class="comment">// 清理Guest资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>根据结果硬编码,更改guest_reg的值</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/author-manchangfengxu/" rel="tag"># author:manchangfengxu</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2025/06/04/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-joeschmo/" rel="prev" title="2025 春夏季开源操作系统训练营阶段总结-joeschmo">
      <i class="fa fa-chevron-left"></i> 2025 春夏季开源操作系统训练营阶段总结-joeschmo
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2025/06/16/2025-%E6%98%A5%E5%A4%8F%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" rel="next" title="2025 春夏季开源操作系统训练营 学习总结">
      2025 春夏季开源操作系统训练营 学习总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
