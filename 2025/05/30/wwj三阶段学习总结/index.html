<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="RUST学习总结函数： 函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -&gt; {} 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可 每个函数参数都需要标注类型  所有权基础类型：不会转移所有权，属于复制变量的值 复合类型：会转移所有权，相当于重新绑定变量  （深拷贝：复合类型变量名.clone()，不转移所有权） 引用  以&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="wwj三阶段学习总结">
<meta property="og:url" content="http://rcore-os.github.io/blog/2025/05/30/wwj%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:description" content="RUST学习总结函数： 函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -&gt; {} 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可 每个函数参数都需要标注类型  所有权基础类型：不会转移所有权，属于复制变量的值 复合类型：会转移所有权，相当于重新绑定变量  （深拷贝：复合类型变量名.clone()，不转移所有权） 引用  以&amp;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-30T10:26:23.000Z">
<meta property="article:modified_time" content="2025-12-17T05:36:30.163Z">
<meta property="article:author" content="rcore-os Group">
<meta property="article:tag" content="author:Keranthos">
<meta property="article:tag" content="repo:https:&#x2F;&#x2F;github.com&#x2F;LearningOS&#x2F;2025s-rcore-Keranthos">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/2025/05/30/wwj%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>wwj三阶段学习总结 | rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RUST学习总结"><span class="nav-number">1.</span> <span class="nav-text">RUST学习总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数："><span class="nav-number">1.0.1.</span> <span class="nav-text">函数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#所有权"><span class="nav-number">1.0.2.</span> <span class="nav-text">所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合类型"><span class="nav-number">1.0.3.</span> <span class="nav-text">复合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构体"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程控制"><span class="nav-number">1.0.4.</span> <span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式匹配"><span class="nav-number">1.0.5.</span> <span class="nav-text">模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#match和if-let"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">match和if let</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Option-lt-T-gt"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">Option&lt;T&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">1.0.6.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型"><span class="nav-number">1.0.7.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特征"><span class="nav-number">1.0.8.</span> <span class="nav-text">特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特征约束"><span class="nav-number">1.0.8.1.</span> <span class="nav-text">特征约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特征对象"><span class="nav-number">1.0.8.2.</span> <span class="nav-text">特征对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合类型"><span class="nav-number">1.0.9.</span> <span class="nav-text">集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态数组Vector"><span class="nav-number">1.0.9.1.</span> <span class="nav-text">动态数组Vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KV存储HashMap"><span class="nav-number">1.0.9.2.</span> <span class="nav-text">KV存储HashMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期"><span class="nav-number">1.0.10.</span> <span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数中的生命周期"><span class="nav-number">1.0.10.1.</span> <span class="nav-text">函数中的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构体中的生命周期"><span class="nav-number">1.0.10.2.</span> <span class="nav-text">结构体中的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生命周期声明消除"><span class="nav-number">1.0.10.3.</span> <span class="nav-text">生命周期声明消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法中的生命周期"><span class="nav-number">1.0.10.4.</span> <span class="nav-text">方法中的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态生命周期"><span class="nav-number">1.0.10.5.</span> <span class="nav-text">静态生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">1.0.11.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常见类型"><span class="nav-number">1.0.11.1.</span> <span class="nav-text">常见类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误处理"><span class="nav-number">1.0.12.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#panic"><span class="nav-number">1.0.12.1.</span> <span class="nav-text">panic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Result"><span class="nav-number">1.0.12.2.</span> <span class="nav-text">Result</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Option与Result的转换"><span class="nav-number">1.0.12.3.</span> <span class="nav-text">Option与Result的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包与模块"><span class="nav-number">1.0.13.</span> <span class="nav-text">包与模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Package-包"><span class="nav-number">1.0.13.1.</span> <span class="nav-text">Package(包)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Crate-单元-箱"><span class="nav-number">1.0.13.2.</span> <span class="nav-text">Crate(单元&#x2F;箱)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mod-模块"><span class="nav-number">1.0.13.3.</span> <span class="nav-text">Mod(模块)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#use"><span class="nav-number">1.0.13.4.</span> <span class="nav-text">use</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式编程"><span class="nav-number">1.0.14.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包"><span class="nav-number">1.0.14.1.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器Iterator"><span class="nav-number">1.0.14.2.</span> <span class="nav-text">迭代器Iterator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入类型"><span class="nav-number">1.0.15.</span> <span class="nav-text">深入类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类型转换"><span class="nav-number">1.0.15.1.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newtype"><span class="nav-number">1.0.15.2.</span> <span class="nav-text">newtype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型别名"><span class="nav-number">1.0.15.3.</span> <span class="nav-text">类型别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不定长类型DST"><span class="nav-number">1.0.15.4.</span> <span class="nav-text">不定长类型DST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举与整数"><span class="nav-number">1.0.15.5.</span> <span class="nav-text">枚举与整数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能指针"><span class="nav-number">1.0.16.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Box-lt-T-gt-堆对象分配"><span class="nav-number">1.0.16.1.</span> <span class="nav-text">Box&lt;T&gt;堆对象分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deref解引用"><span class="nav-number">1.0.16.2.</span> <span class="nav-text">Deref解引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Drop释放资源"><span class="nav-number">1.0.16.3.</span> <span class="nav-text">Drop释放资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rc"><span class="nav-number">1.0.16.4.</span> <span class="nav-text">Rc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cell和RefCell"><span class="nav-number">1.0.16.5.</span> <span class="nav-text">Cell和RefCell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环引用与自引用"><span class="nav-number">1.0.16.6.</span> <span class="nav-text">循环引用与自引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程并发编程"><span class="nav-number">1.0.17.</span> <span class="nav-text">多线程并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用线程"><span class="nav-number">1.0.17.1.</span> <span class="nav-text">使用线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程同步"><span class="nav-number">1.0.17.2.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#消息传递"><span class="nav-number">1.0.17.2.1.</span> <span class="nav-text">消息传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁、Condvar"><span class="nav-number">1.0.17.2.2.</span> <span class="nav-text">锁、Condvar</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#也可以使用下面的相对路径"><span class="nav-number">2.</span> <span class="nav-text">也可以使用下面的相对路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hello-macro-derive-path-“-hello-macro-derive”"><span class="nav-number">3.</span> <span class="nav-text">hello_macro_derive &#x3D; { path &#x3D; “.&#x2F;hello_macro_derive” }</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分时多任务"><span class="nav-number">3.0.1.</span> <span class="nav-text">分时多任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页表机制"><span class="nav-number">3.0.2.</span> <span class="nav-text">页表机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">3.0.3.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统"><span class="nav-number">3.0.4.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信"><span class="nav-number">3.0.5.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">3.0.6.</span> <span class="nav-text">并发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ArceOS学习记录"><span class="nav-number">4.</span> <span class="nav-text">ArceOS学习记录</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">743</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">646</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/30/wwj%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          wwj三阶段学习总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-30 10:26:23" itemprop="dateCreated datePublished" datetime="2025-05-30T10:26:23+00:00">2025-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-17 05:36:30" itemprop="dateModified" datetime="2025-12-17T05:36:30+00:00">2025-12-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="RUST学习总结"><a href="#RUST学习总结" class="headerlink" title="RUST学习总结"></a>RUST学习总结</h1><h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ul>
<li>函数名和变量名使用<a href="https://course.rs/practice/naming.html" target="_blank" rel="noopener">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; {}</code></li>
<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>
<li>每个函数参数都需要标注类型</li>
</ul>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>基础类型：不会转移所有权，属于复制变量的值</p>
<p>复合类型：会转移所有权，相当于重新绑定变量</p>
<p> （深拷贝：<code>复合类型变量名.clone()</code>，不转移所有权）</p>
<p><strong>引用</strong></p>
<ul>
<li>以<code>&amp;</code>表示引用，以<code>*</code>表示解引用</li>
<li>可变引用首先要求变量可变，引用时也要写成<code>&amp;mut 变量名</code>，否则是可变变量的不可变引用</li>
<li>一个变量的可变引用同时只能存在一个，可变与不可变引用不可同时存在</li>
<li>“同时”指引用的作用域，为引用”从创建开始，一直持续到它最后一次使用的地方“</li>
</ul>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>切片：对<code>string</code>类型中某一部分的引用，即<code>&amp;变量名[开始……终止]</code>，切片类型为<code>&amp;str</code></p>
<p><code>string</code>与<code>&amp;str</code>的转化：</p>
<p> <code>&amp;str</code>化成<code>string</code>: <code>String::from(&quot;字符串字面量&quot;)</code>/<code>&quot;字符串字面量&quot;.to_string()</code></p>
<p> <code>string</code>化成<code>&amp;str</code>: 取切片</p>
<p><strong>操作字符串</strong>（针对于<code>string</code>）</p>
<ul>
<li>追加：<code>push(字符)/push_str(字符串字面量（不能是string类型）)</code> 改变原有的字符串（不返回新值，必须<code>mut</code>可变）</li>
<li>插入：<code>insert()/insert_str()</code> 需要传入两个参数，第一个是插入位置索引，第二个是插入内容 改变原有字符串</li>
<li>替换：<code>replace(被替换的字符串，新的字符串)</code> 返回新的字符串（需要新变量接收）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let string_replace &#x3D; String::from(&quot;I like rust. Learning rust is my favorite!&quot;);</span><br><span class="line">let new_string_replace &#x3D; string_replace.replace(&quot;rust&quot;, &quot;RUST&quot;);</span><br></pre></td></tr></table></figure>

<p> <code>replacen(被替换的字符串，新的字符串，替换的个数)</code> 返回新的字符串</p>
<p> <code>replace_range(要替换的范围，新的字符串)</code> 改变原有的字符串</p>
<ul>
<li><p>删除：<code>pop()</code> 删除并返回最后一个字符 改变原有的字符串</p>
<p><code>remove(字符起始索引)</code> 删除并返回指定位置的字符 改变原有的字符串</p>
<p><code>truncate(字符起始索引)</code> 删除指定位置至结尾的所有字符 改变原有字符串</p>
<p><code>clear()</code> 清空字符串</p>
</li>
<li><p>连接：<code>+/+=</code> 相当于调用函数<code>add(self, s:&amp;str……)</code> 第一个参数是<code>string</code>,其所有权会被转移，后面的参数需要<code>&amp;str</code>类型 <code>&#39;+&#39;返回新的字符串</code></p>
<p> <code>format!(&quot;{}&quot;, s)</code> 用法与<code>println!</code>类似， 返回新的字符串</p>
</li>
</ul>
<p><strong>注：</strong>此处所有涉及索引的方法（包括切片），都是以字节为单位处理数据；对于<code>UTF-8</code>类型字符非常容易出错</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、&#x2F;&#x2F; 定义字段</span><br><span class="line">struct 结构体名称 &#123;</span><br><span class="line">    字段名称1： 类型 &#x2F;&#x2F;结构体字段</span><br><span class="line">&#125;</span><br><span class="line">gree</span><br><span class="line">2、&#x2F;&#x2F; 初始化：每个字段都要初始化，但顺序不一定一样</span><br><span class="line">let 变量名 &#x3D;  结构体名称 &#123;</span><br><span class="line">    字段名称1： 值 </span><br><span class="line">&#125;</span><br><span class="line">let 变量名 &#x3D;  结构体名称 &#123;</span><br><span class="line">    字段名称1： 值 </span><br><span class="line">    ..另一个同类型变量2名的名称	&#x2F;&#x2F;	剩余自动从另一变量中获取（该语句必须位于尾部）</span><br><span class="line">    				&#x2F;&#x2F;	同时变量2部分字段会发生所有权转移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、&#x2F;&#x2F; 访问字段</span><br><span class="line">变量名.字段名	</span><br><span class="line"></span><br><span class="line">4、&#x2F;&#x2F; 元组结构体、单元结构体</span><br><span class="line">let a : (i32, f64, u8) &#x3D; (500, 6.4, 1); &#x2F;&#x2F; (i32, f64, u8)是元组</span><br><span class="line">struct Color(i32, i32, i32); &#x2F;&#x2F; 元组结构体，适用于结构体有名称，字段没有的情况</span><br><span class="line">struct AlwaysEqual; &#x2F;&#x2F; 单元结构体，没有属性与字段</span><br><span class="line"></span><br><span class="line">5、 &#x2F;&#x2F; 结构体数据所有权：字段值最好不要基于引用，否则需要加上生命周期</span><br><span class="line"></span><br><span class="line">6、 &#x2F;&#x2F; 正常情况无法&#123;&#125;打印，需要在开头加上#[derive(Debug)]，使用&#123;:?&#125;或&#123;:#?&#125;来打印</span><br></pre></td></tr></table></figure>



<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 枚举变体携带数据</span><br><span class="line">enum PokerCard &#123;</span><br><span class="line">    Clubs(u8),</span><br><span class="line">    Spades(u8),</span><br><span class="line">    Diamonds(char),</span><br><span class="line">    Hearts(char),</span><br><span class="line">&#125; &#x2F;&#x2F; 任何类型的数据都可以放入枚举成员中，包括另一个枚举或者结构体</span><br><span class="line">let c1 &#x3D; PokerCard::Spades(5);</span><br></pre></td></tr></table></figure>



<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>分为静态的<code>array</code>和动态数组<code>vector</code>，先看<code>array</code></p>
<p><code>array</code>可以正常使用下标访问，可以使用<code>{:?}</code>打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; [1, 2, 3, 4, 5]; &#x2F;&#x2F; 定义</span><br><span class="line">let a: [i32; 5] &#x3D; [1, 2, 3, 4, 5]; &#x2F;&#x2F; 需要声明类型时</span><br><span class="line">let a &#x3D; [3; 5]; &#x2F;&#x2F; 某个值重复出现</span><br><span class="line">let arrays: [[u8; 3]; 4]  &#x3D; [one, two, blank1, blank2]; &#x2F;&#x2F; 二维数组</span><br><span class="line"></span><br><span class="line">let slice: &amp;[i32] &#x3D; &amp;a[1..3]; &#x2F;&#x2F; 数组切片</span><br></pre></td></tr></table></figure>



<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>if:</strong> <code>if</code>语句块是表达式，可以有返回值</p>
<p><strong>for</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for 元素 in 集合&#x2F;0..集合.len() &#123; &#x2F;&#x2F; 注意，此处集合需要使用引用，否则所有权会被转移（如需更改加上mut）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 想要获取元素的索引</span><br><span class="line">let a &#x3D; [4, 3, 2, 1];</span><br><span class="line">for (i, v) in a.iter().enumerate() &#123;</span><br><span class="line">    println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;, i + 1, v); &#x2F;&#x2F; .iter()方法把 &#96;a&#96; 数组变成一个迭代器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只在意循环次数</span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>continue</code>与<code>break</code>依然存在</p>
<p><strong>while</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while 条件 &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>loop</strong></p>
<p>无条件循环，必须搭配<code>break</code></p>
<p>（<code>break</code>类似于<code>return</code>，可以单独使用也可以带回来一个返回值；</p>
<p> loop同样是表达式，可以返回一个值）</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><h4 id="match和if-let"><a href="#match和if-let" class="headerlink" title="match和if let"></a>match和if let</h4><p><strong>match:</strong> 非常类似于<code>switch</code>(但匹配后只会执行当前分支，而不会往下”贯穿“)</p>
<p><code>match</code>同样是表达式，可以有返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">match target &#123;</span><br><span class="line">    模式1 &#x3D;&gt; 表达式1, &#x2F;&#x2F; &#x3D;&gt;代替了:</span><br><span class="line">    模式2 | 模式3 &#x3D;&gt; &#123;	&#x2F;&#x2F; X|Y</span><br><span class="line">        语句1;</span><br><span class="line">        语句2;</span><br><span class="line">        表达式2 &#x2F;&#x2F; 注意，语句同样可以返回()</span><br><span class="line">    &#125;,</span><br><span class="line">    _ &#x3D;&gt; 表达式3 &#x2F;&#x2F; _代替了default，必须穷尽所有情况否则会报错</span><br><span class="line">    &#x2F;&#x2F;或者 任意无关变量名 &#x3D;&gt; 表达式3  &#x2F;&#x2F; 此时就可以对该变量操作，不操作记得使用_开头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式绑定（从匹配到的分支中取出绑定的值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState), &#x2F;&#x2F; 25美分硬币</span><br><span class="line">&#125;</span><br><span class="line">match coin &#123;</span><br><span class="line">        Coin::Penny &#x3D;&gt; 1,</span><br><span class="line">        Coin::Nickel &#x3D;&gt; 5,</span><br><span class="line">        Coin::Dime &#x3D;&gt; 10,</span><br><span class="line">        Coin::Quarter(state) &#x3D;&gt; &#123;</span><br><span class="line">            println!(&quot;State quarter from &#123;:?&#125;!&quot;, state); &#x2F;&#x2F; 可以取出绑定的具体state值</span><br><span class="line">            25</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>if let:</strong> 适用于只需要判断一个模式是否匹配的情况,比<code>if</code>更适用于匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let some_value &#x3D; Some(5);</span><br><span class="line">if let Some(v) &#x3D; some_value &#123;</span><br><span class="line">    println!(&quot;Value is: &#123;&#125;&quot;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>while let:</strong> while和let的总和，即如果满足条件就可循环，同样可以从模式匹配中拆出值</p>
<p><strong>注：</strong>match/if let/while let都会转移被匹配值的借用值的所有权，需要使用<code>ref</code>抵消（<code>ref</code>只在左侧生效）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let Some(ref x) &#x3D; value</span><br><span class="line">match opt &#123;</span><br><span class="line">    Some(ref s) &#x3D;&gt; println!(&quot;Got a reference to string: &#123;&#125;&quot;, s),</span><br></pre></td></tr></table></figure>



<h4 id="Option-lt-T-gt"><a href="#Option-lt-T-gt" class="headerlink" title="Option&lt;T&gt;"></a><code>Option&lt;T&gt;</code></h4><p>表示一个值是否存在的<strong>枚举</strong>(<code>Some&lt;T&gt;</code>与<code>T</code>不是同一类型)</p>
<p>对于<code>Some</code>和<code>None</code>可以不加<code>Option::</code>前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),  &#x2F;&#x2F; 表示有值</span><br><span class="line">    None,     &#x2F;&#x2F; 表示无值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存储</span><br><span class="line">let x: Option&lt;i32&gt; &#x3D; Some(42);  &#x2F;&#x2F; Some(42) 代表 x 里面存了 42</span><br><span class="line">let y: Option&lt;i32&gt; &#x3D; None;      &#x2F;&#x2F; None 代表没有值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解构</span><br><span class="line">match x &#123;</span><br><span class="line">    Some(v) &#x3D;&gt; println!(&quot;Value is: &#123;&#125;&quot;, v),  &#x2F;&#x2F; 取出 v</span><br><span class="line">    None &#x3D;&gt; println!(&quot;No value&quot;),</span><br><span class="line">&#125;</span><br><span class="line">if let Some(v) &#x3D; x &#123;</span><br><span class="line">    println!(&quot;Value is: &#123;&#125;&quot;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>impl</code>中存储方法与<code>struct</code>中声明字段分开，同时一个结构体可以有多个<code>impl</code>块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; &amp;self代替了self:&amp;Self</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li><p><code>self</code> 表示 <code>Rectangle</code> 的所有权转移到该方法中，这种形式用的较少</p>
<p><code>&amp;self</code> 表示该方法对 <code>Rectangle</code> 的不可变借用</p>
<p><code>&amp;mut self</code> 表示可变借用</p>
</li>
<li><p>允许方法名和字段名相同</p>
</li>
<li><p>在调用方法时只有<code>.</code>没有<code>-&gt;</code></p>
</li>
<li><p>枚举同样可以定义方法</p>
</li>
</ul>
<p><strong>关联函数</strong></p>
<p>定义在结构体<code>impl</code>且没有<code>self</code>的函数</p>
<p>不能使用<code>变量.函数()</code>的方法调用，只能使用<code>结构体名称::函数名(参数)</code>来调用</p>
<p>比如<code>String::from()</code></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>为了抽象不同的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn 函数名&lt;T&gt;(变量名: T) -&gt; T &#123; &#x2F;&#x2F; 函数泛型</span><br><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125; &#x2F;&#x2F; 结构体泛型，多个类型也可以声明如struct Point&lt;T,U&gt;</span><br><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125; &#x2F;&#x2F; 枚举泛型，可以根据返回值的类型判断是否成功</span><br><span class="line">struct Point&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; </span><br><span class="line">    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: self.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 结构体泛型，impl处需要另外声明，impl中的方法可以拥有自己的泛型</span><br><span class="line">  &#x2F;&#x2F;对于结构体泛型，还可以为特定的泛型单独声明方法</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用<code>T</code>前需要先声明<code>&lt;T&gt;</code>，<code>T</code>的名字可以随便取</li>
<li>有时在调用泛型函数时需使用<code>函数名::&lt;具体类型&gt;()</code>来显式指定<code>T</code>的类型</li>
</ul>
<p><strong>const泛型</strong></p>
<p>允许常量值成为泛型变量，语法为<code>const N: usize</code>，表示const泛型N，它的值基于<code>usize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Buffer&lt;T, const N: usize&gt; &#123;</span><br><span class="line">    data: [T; N], &#x2F;&#x2F; N 作为数组大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const fn:</code> 在函数声明前加上<code>const</code>关键字</p>
<p><strong>注：</strong><code>const</code>泛型与<code>const fn</code>都需要在编译时确定，<code>const fn</code>就可以用于给<code>const</code>泛型赋值</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>定义了一组可以被共享的行为，只要实现了特征，你就能使用这组行为（类似于接口）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String; &#x2F;&#x2F; 只是一个抽象接口，而不具体实现</span><br><span class="line">&#125; &#x2F;&#x2F; 定义特征</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为每个需要的类单独实现特征</span><br><span class="line">impl Summary for Post &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;, self.title, self.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Summary for Weibo &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;, self.username, self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>孤儿规则：如果你想要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> <strong>或者</strong> <code>T</code> 至少有一个是在当前作用域中定义的（另一个可以在其他库中引入）</li>
<li>默认实现：可以在特征中定义具有默认实现的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法（默认实现允许调用特征中其他方法，哪怕这个方法没有默认实现）</li>
</ul>
<h4 id="特征约束"><a href="#特征约束" class="headerlink" title="特征约束"></a><strong>特征约束</strong></h4><p>特征作为函数参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify(item: &amp;impl Summary) &#123; &#x2F;&#x2F; 实现了Summary特征 的 item 参数</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 对于结构体方法</span><br><span class="line">impl&lt;T: Display&gt; ToString for T &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形如 <code>T: Summary</code> 被称为特征约束</p>
<p>多重约束:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 要求同时实现了两个特征的参数</span><br><span class="line">pub fn notify(item: &amp;(impl Summary + Display)) &#123;&#125;</span><br><span class="line">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>where</code>约束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 &#123;&#125;</span><br><span class="line">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32</span><br><span class="line">    where T: Display + Clone,</span><br><span class="line">          U: Clone + Debug</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>函数返回值：</p>
<p>通过 <code>impl Trait</code> 来说明一个函数返回了一个类型，该类型实现了某个特征</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn returns_summarizable() -&gt; impl Summary &#123; &#x2F;&#x2F; 返回一个实现了Summary特征的类型</span><br></pre></td></tr></table></figure>



<h4 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h4><table>
<thead>
<tr>
<th>特征约束</th>
<th>特征对象</th>
</tr>
</thead>
<tbody><tr>
<td><code>impl Trait</code></td>
<td><code>dyn Trait</code></td>
</tr>
<tr>
<td>接收所有实现了<code>Trait</code>的类型</td>
<td>接收所有实现了<code>Trait</code>的类型</td>
</tr>
<tr>
<td>认为是不一样的类型，不能一起存储</td>
<td>认为是相同的类型，可以一起存储</td>
</tr>
<tr>
<td>静态分发，编译时确定</td>
<td>动态分发，运行时确定</td>
</tr>
</tbody></table>
<p>允许你使用 不同类型 但 实现了相同特征 的对象，使它们可以在 同一个变量、参数或返回值 中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 语法</span><br><span class="line">&amp;dyn 特征名 &#x2F;&#x2F; 必须要使用指针，否则无法确定大小</span><br><span class="line">Box&lt;dyn 特征名&gt; &#x2F;&#x2F; 智能指针</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态数组</span><br><span class="line">Vec&lt;Box&lt;dyn 特征名&gt;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><h4 id="动态数组Vector"><a href="#动态数组Vector" class="headerlink" title="动态数组Vector"></a>动态数组<code>Vector</code></h4><p>使用<code>Vec&lt;T&gt;</code>表示，只能存储相同类型的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建数组</span><br><span class="line">let v: Vec&lt;i32&gt; &#x3D; Vec::new();</span><br><span class="line">let mut v &#x3D; Vec::new(); &#x2F;&#x2F; 在添加元素后会自动推导</span><br><span class="line">let mut v: Vec&lt;i32&gt; &#x3D; Vec::with_capacity(5); &#x2F;&#x2F; 预先分配空间</span><br><span class="line"></span><br><span class="line">let v &#x3D; vec![1, 2, 3]; &#x2F;&#x2F; 宏vec!可以给予初始值</span><br><span class="line">let v &#x3D; vec![0; 3];   &#x2F;&#x2F; 默认值为 0，初始长度为 3</span><br><span class="line">let v_from &#x3D; Vec::from([0, 0, 0]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新（需要为mut）</span><br><span class="line">v.push(n); &#x2F;&#x2F; 可变引用，不能与其他引用同时存在</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问元素</span><br><span class="line">v[下标] &#x2F;&#x2F;		越界不会检查</span><br><span class="line">v.get(下标) &#x2F;&#x2F; 返回Option&lt;T&gt;,需要match来解构出值		确保不会越界</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for i in &amp;(mut) v &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 常见方法</span><br><span class="line">v.is_empty()</span><br><span class="line">v.insert(pos, val) &#x2F;&#x2F; 在指定索引pos处插入数值val</span><br><span class="line">v.remove(pos) &#x2F;&#x2F; 删除在pos处的数并返回该数</span><br><span class="line">v.pop() &#x2F;&#x2F; 删除尾部的数并返回(返回的是Option&lt;T&gt;的枚举值)</span><br><span class="line">v.clear()</span><br><span class="line">v.append(&amp;mut v1) &#x2F;&#x2F; v1所有数据全部转入v，v1被清空</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排序</span><br><span class="line">sort&#x2F;sort_unstable() &#x2F;&#x2F; 默认按照升序类型，且要元素可比较</span><br><span class="line">sort_by&#x2F;sort_unstable_by(闭包实现) &#x2F;&#x2F; 可以自定义比较规则来实现多种类型的比较</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>可以通过使用枚举类型和特征对象来实现不同类型元素的存储</p>
<h4 id="KV存储HashMap"><a href="#KV存储HashMap" class="headerlink" title="KV存储HashMap"></a><code>KV</code>存储<code>HashMap</code></h4><p>需要使用<code>use std::collections::HashMap;</code>来引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建与插入</span><br><span class="line">let mut my_gems &#x3D; HashMap::new();</span><br><span class="line">my_gems.insert(&quot;红宝石&quot;, 1);</span><br><span class="line"></span><br><span class="line">HashMap::with_capacity(capacity)</span><br><span class="line"></span><br><span class="line">let teams_list &#x3D; vec![</span><br><span class="line">        (&quot;中国队&quot;.to_string(), 100),</span><br><span class="line">        (&quot;美国队&quot;.to_string(), 10),</span><br><span class="line">        (&quot;日本队&quot;.to_string(), 50),</span><br><span class="line">    ];</span><br><span class="line">let teams_map: HashMap&lt;_,_&gt; &#x3D; teams_list.into_iter().collect(); &#x2F;&#x2F; 从动态数组转化为hashmap</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在表中查询元素</span><br><span class="line">let score: Option&lt;&amp;value类型&gt; &#x3D; 表名.get(key的引用); &#x2F;&#x2F; 注意返回的是Option&lt;T&gt;类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for (key, value) in &amp;表名 &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新表中的值</span><br><span class="line">let old &#x3D; scores.insert(&quot;Blue&quot;, 20); &#x2F;&#x2F; 会直接覆盖旧值，返回Some(旧值)&#x2F;None</span><br><span class="line">let v &#x3D; scores.entry(&quot;Yellow&quot;).or_insert(5); &#x2F;&#x2F; 查询Yellow对应的值，若不存在则插入新值；返回存储值的可变引用</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<p><code>HashMap</code> 的所有权规则与其它 Rust 类型没有区别：</p>
<ul>
<li>若类型实现 <code>Copy</code> 特征，该类型会被复制进 <code>HashMap</code>，因此无所谓所有权</li>
<li>若没实现 <code>Copy</code> 特征，所有权将被转移给 <code>HashMap</code> 中（使用引用要确保其生命周期足够长）</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>变量的生命周期声明方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#39;a i32     &#x2F;&#x2F; 具有显式生命周期的引用</span><br><span class="line">&amp;&#39;a mut i32 &#x2F;&#x2F; 具有显式生命周期的可变引用</span><br></pre></td></tr></table></figure>

<h4 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h4><p>需要标注生命周期的情况如下：</p>
<ul>
<li>首先返回值必须是引用类型，可能会出现悬垂引用错误</li>
<li>存在多个参数时，如果编译器无法确定返回值需要跟随哪个参数的生命周期（哪怕这两个参数的生命周期是一样的），那么不标注就会报错</li>
<li>标注之后，编译时就会检查返回值使用会不会超出某个参数，如果发现超出就会报错（标注生命周期实际上<strong>不会更改任何返回值或者变量的真实生命周期</strong>，只是告诉编译器当返回值的生命周期不与较短的参数生命周期一致时，不予通过）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用&#39;a显式表示生命周期，此处的&#39;a表示两个参数中较短的生命周期，需要提前标注</span><br><span class="line">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特殊情况：返回值永远只和一个参数有关&#x2F;返回值与参数无关</span><br><span class="line">fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;str) -&gt; &amp;&#39;a str &#123; &#x2F;&#x2F; 只与一个有关就只标注一个</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br><span class="line">fn longest(_x: &amp;str, _y: &amp;str) -&gt; String &#123; &#x2F;&#x2F; 与新建变量有关尽量不返回引用</span><br><span class="line">    String::from(&quot;really long string&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h4><p>如果结构体的字段值类型为引用型，也需要标注生命周期<code>&#39;a</code>（<code>a</code>可以任意替换）</p>
<p>作用是避免编译器报错、同时(提醒编译器)在编译时就检查其是否不超过原变量的生命周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    part: &amp;&#39;a str,</span><br><span class="line">&#125; &#x2F;&#x2F; 只要在结构体每一个引用标注上生命周期即可，此处也需要提前声明&lt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期声明消除"><a href="#生命周期声明消除" class="headerlink" title="生命周期声明消除"></a>生命周期声明消除</h4><p>为何在只有一个参数时可以不标注生命周期？</p>
<p>存在以下三个步骤可以省略生命周期声明（函数中参数的生命周期是输入生命周期，返回值为输出）：</p>
<ol>
<li><p>每一个引用参数都会获得独自的生命周期（所以不声明则多个参数有各自的生命周期声明）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32) &#x2F;&#x2F; 所以不显式标出不知道跟随a还是b</span><br></pre></td></tr></table></figure>
</li>
<li><p>若只有一个输入生命周期（函数参数中只有一个引用类型），那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32 &#x2F;&#x2F; 所以单个参数可以省略</span><br></pre></td></tr></table></figure>
</li>
<li><p>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</p>
</li>
</ol>
<h4 id="方法中的生命周期"><a href="#方法中的生命周期" class="headerlink" title="方法中的生命周期"></a>方法中的生命周期</h4><ul>
<li>类似于泛型结构体</li>
<li>方法签名中一般不需要标注，因为有<code>&amp;self</code>参数（根据以上第三条规则）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    part: &amp;&#39;a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;&#39;a&gt; ImportantExcerpt&lt;&#39;a&gt; &#123;</span><br><span class="line">    fn level(&amp;self) -&gt; i32 &#123;</span><br><span class="line">        3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h4><p>拥有<code>&#39;static</code>生命周期声明的引用生命周期是整个程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s: &amp;&#39;static str &#x3D; &quot;我没啥优点，就是活得久，嘿嘿&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是一种元数据，用于修改编译器的行为、提供额外信息或影响代码生成方式</p>
<p>使用<code>#[]</code>语法</p>
<h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><p><strong><code>#[derive()]</code></strong> 自动派生特征</p>
<p>用于让编译器自动为结构体或枚举实现特定的 <strong>trait</strong>（特征），如 <code>Debug</code>、<code>Clone</code> 等</p>
<p>注意只针对结构体与枚举，同时在实现某特征时（比如<code>Copy</code>）结构体中不能够有<code>String</code>这种无法自动实现<code>Copy</code>的字段</p>
<p><strong><code>#[cfg(...)]</code></strong> 条件编译</p>
<p>用于根据特定 条件选择性地编译代码，例如目标平台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(target_os &#x3D; &quot;linux&quot;)]</span><br><span class="line">fn platform_specific() &#123;</span><br><span class="line">    println!(&quot;Running on Linux!&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 只在linux上面编译</span><br><span class="line"></span><br><span class="line">#[cfg(feature &#x3D; &quot;logging&quot;)]</span><br><span class="line">fn log_message() &#123;</span><br><span class="line">    println!(&quot;Logging is enabled&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 启用了feature特征才能编译（feature特征是cargo.toml中定义的）</span><br></pre></td></tr></table></figure>

<p><strong><code>#[test]</code></strong> Rust 测试函数</p>
<p>用于标记测试函数，让 <code>cargo test</code> 自动运行它</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="panic"><a href="#panic" class="headerlink" title="panic"></a><code>panic</code></h4><ul>
<li>标识不可恢复错误</li>
<li>有被动与主动触发两种情况</li>
</ul>
<p>主动触发：使用<code>panic!</code>宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    panic!(&quot;crash and burn&quot;);</span><br><span class="line">&#125; &#x2F;&#x2F; 会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序</span><br></pre></td></tr></table></figure>

<h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a><code>Result</code></h4><p>标识可恢复的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回了该枚举类型之后就可以使用<code>match</code>来匹配解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let f &#x3D; match f &#123;</span><br><span class="line">       Ok(file) &#x3D;&gt; file,</span><br><span class="line">       Err(error) &#x3D;&gt; match error.kind() &#123;</span><br><span class="line">           ErrorKind::NotFound &#x3D;&gt; match File::create(&quot;hello.txt&quot;) &#123;</span><br><span class="line">               Ok(fc) &#x3D;&gt; fc,</span><br><span class="line">               Err(e) &#x3D;&gt; panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, e),</span><br><span class="line">           &#125;,</span><br><span class="line">           other_error &#x3D;&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, other_error),</span><br><span class="line">       &#125;,</span><br><span class="line">   &#125;; &#x2F;&#x2F; 一个打开文件的返回处理</span><br></pre></td></tr></table></figure>

<p>如果不需要处理错误情况（即要么<code>Ok()</code>要么<code>panic()</code>，就使用<code>unwrap()</code>/<code>expect</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;).unwrap();</span><br><span class="line">&#x2F;&#x2F; 要么返回正确值要么直接panic</span><br><span class="line"></span><br><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);</span><br><span class="line">&#x2F;&#x2F; 与unwrap()一样，只不过会报出里面的信息</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 改变错误类型：假设有f1(T)返回值T1类型，f2(F)返回值F2类型</span><br><span class="line">let n: u8 &#x3D; &quot;1&quot;.parse().map(f1).map_err(f2) &#x2F;&#x2F;原本返回T&#x2F;F,现在返回T1&#x2F;F1</span><br></pre></td></tr></table></figure>

<p><strong>传播错误</strong></p>
<p>如果需要上级来处理这个函数中出现的错误呢？</p>
<p>返回<code>Result&lt;, &gt;</code>类型</p>
<ul>
<li>使用<code>match</code>匹配，用分支来操作/返回</li>
<li>使用宏<code>?</code></li>
</ul>
<p><code>?</code>功能类似于match</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; match写法</span><br><span class="line">let f &#x3D; File::open(&quot;hello.txt&quot;);</span><br><span class="line">let mut f &#x3D; match f &#123;</span><br><span class="line">    Ok(file) &#x3D;&gt; file,</span><br><span class="line">    Err(e) &#x3D;&gt; return Err(e),</span><br><span class="line">&#125;;</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">match f.read_to_string(&amp;mut s) &#123;</span><br><span class="line">    Ok(_) &#x3D;&gt; Ok(s),</span><br><span class="line">    Err(e) &#x3D;&gt; Err(e),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ？写法：Err则该函数返回，Ok则语句返回正确值</span><br><span class="line">let mut f &#x3D; File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">f.read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br><span class="line">&#x2F;&#x2F; ？同时可以进行类型提升，把所有的错误类型都提升为std::error::Error</span><br><span class="line">&#x2F;&#x2F; 此时就是返回Result&lt;Ok值, Box&lt;dyn std::error::Error&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ？可以链式调用</span><br><span class="line">let mut s &#x3D; String::new();</span><br><span class="line">File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li><code>?</code>操作符一定需要一个变量来承接正确的值</li>
<li>函数一定要是<code>Result&lt;, &gt;</code>返回值</li>
</ul>
<h4 id="Option与Result的转换"><a href="#Option与Result的转换" class="headerlink" title="Option与Result的转换"></a><code>Option</code>与<code>Result</code>的转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Option&#96;转&#96;Result&#96;: 使用&#96;.ok_or()&#96;或&#96;.ok_or_else()</span><br><span class="line">&#x2F;&#x2F; Option&lt;T&gt;	Result&lt;T, E&gt;</span><br><span class="line">let res1: Result&lt;T, E&gt; &#x3D; Option类型值.ok_or(E类型值);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Result&#96;转&#96;Option&#96;: 丢弃错误使用&#96;ok()&#96;，丢弃成功值使用&#96;.err()</span><br><span class="line">&#x2F;&#x2F; Option&lt;T&gt;	Result&lt;T, E&gt;</span><br><span class="line">let opt1: Option&lt;T&gt; &#x3D; Result类型值.ok();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Option&lt;E&gt;	Result&lt;T, E&gt;</span><br><span class="line">let opt1: Option&lt;E&gt; &#x3D; Result类型值.err(); &#x2F;&#x2F; 如果Result类型值是ok()则丢弃</span><br></pre></td></tr></table></figure>

<h3 id="包与模块"><a href="#包与模块" class="headerlink" title="包与模块"></a>包与模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my_project&#x2F;</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src&#x2F;</span><br><span class="line">    ├── lib.rs         # library crate (名为 my_project)</span><br><span class="line">    ├── main.rs        # binary crate (名为 my_project)</span><br><span class="line">    └── bin&#x2F;</span><br><span class="line">        ├── tool1.rs   # binary crate (名为 tool1)</span><br><span class="line">        └── tool2.rs   # binary crate (名为 tool2)</span><br><span class="line">├── tests			   # 集成测试文件</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches			   # 基准性能测试文件</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples		   # 项目示例</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package&#96; &#x3D;&gt; &#96;Crate&#96; &#x3D;&gt; &#96;mod</span><br></pre></td></tr></table></figure>

<h4 id="Package-包"><a href="#Package-包" class="headerlink" title="Package(包)"></a><strong><code>Package(包)</code></strong></h4><p>一个<code>Package</code>就是一个项目，包含一个或多个<code>Crate</code>（最多一个）</p>
<p>每个 Package 必须包含一个 <code>Cargo.toml</code> 文件来描述包的元信息和依赖</p>
<h4 id="Crate-单元-箱"><a href="#Crate-单元-箱" class="headerlink" title="Crate(单元/箱)"></a><strong><code>Crate(单元/箱)</code></strong></h4><ul>
<li><code>crate</code> 是一个 Rust 项目或库的最小单元，即需要一起编译不可继续拆分</li>
<li>分为<code>lib</code>单元（入口文件一般为<code>src/lib.rs</code>；编译为库文件<code>.rlib</code>；不可单独执行，可以为其他项目提供依赖）和二进制单元（入口文件一般为<code>src/main.rs</code>或者在 <code>src/bin/</code> 目录下；编译为可执行文件）</li>
<li>一个<code>Package</code>最多可以包含一个库单元和多个二进制单元，也可以只包含一个库单元/一个或几个二进制单元</li>
<li>对于二进制单元，<code>src/main.rs</code>是默认的crate，其他的crate都在<code>src/bin/</code>（或其他）目录下，且文件可以单独编译（一个文件就是一个<code>crate</code>）</li>
</ul>
<p>考虑划分多个 crate 当：</p>
<ol>
<li>部分代码需要作为独立库被其他项目使用</li>
<li>项目包含多个独立可执行工具</li>
<li>某些功能需要单独编译和测试</li>
<li>需要减少编译时间（修改一个 crate 不会导致其他 crate 重新编译）</li>
</ol>
<h4 id="Mod-模块"><a href="#Mod-模块" class="headerlink" title="Mod(模块)"></a><strong><code>Mod(模块)</code></strong></h4><p>使用模块只是为了更好地组织代码，同时控制它们的可见性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义语法</span><br><span class="line">mod A &#123;</span><br><span class="line">	mod B &#123;fn B1()&#123;&#125;&#125; &#x2F;&#x2F;可以嵌套</span><br><span class="line">	mod C &#123;fn C1()&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路径引用</span><br><span class="line">fn D() &#123;</span><br><span class="line">    &#x2F;&#x2F; 绝对路径</span><br><span class="line">    crate::A::B::B1(); </span><br><span class="line">    &#x2F;&#x2F;相对路径：只能以super&#x2F;self&#x2F;模块名或Crate开头</span><br><span class="line">    A::B::B1(); &#x2F;&#x2F; 在同一个Crate根部的相对路径可以直接这么写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可见性设置</span><br><span class="line">pub mod hosting &#123; &#x2F;&#x2F; 模块写pub仅代表其可被访问，而其中的函数等还是对外界不可见</span><br><span class="line">    pub fn add_to_waitlist() &#123;&#125; &#x2F;&#x2F; 函数也需以pub开头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个<code>Crate</code>是一棵模块树，而<code>src/main.rs</code>及<code>src/lib.rs</code>就是该树的根</li>
<li>模块A包含模块B，则A是B的父模块，B是A的子模块</li>
<li>模块中可以定义各种<code>Rust</code>类型，如函数、结构体、枚举、特征等</li>
<li>在同一个<code>Crate</code>根下的模块，相互引用的相对路径可以直接以对方模块名称开头；在同一父模块下的两个子模块，若在同文件中实现则也可以以对方模块名称开头，否则需要通过<code>super::</code>来使用父模块中转</li>
<li>将结构体设置为 <code>pub</code>，但它的所有字段依然是私有的；将枚举设置为 <code>pub</code>，它的所有字段也将对外可见</li>
<li>可以把模块实现放入对应等级的<code>*.rs</code>文件中，<code>*</code>要等同于模块名（文件中便不必再写），模块的定义/声明还是在父文件/模块中</li>
</ul>
<h4 id="use"><a href="#use" class="headerlink" title="use"></a><code>use</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本引用方式：绝对或相对路径</span><br><span class="line">use crate::front_of_house::hosting; &#x2F;&#x2F; 引入模块</span><br><span class="line">use front_of_house::hosting::add_to_waitlist; &#x2F;&#x2F; 引入函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; as别名</span><br><span class="line">use std::fmt::Result;</span><br><span class="line">use std::io::Result as IoResult;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引入再导出</span><br><span class="line">pub use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简化引入</span><br><span class="line">use std::collections::&#123;HashMap,BTreeMap,HashSet&#125;;</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line">use std::io;</span><br><span class="line">use std::io::Write;</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br><span class="line"></span><br><span class="line">use std::collections::*; &#x2F;&#x2F; 引入模块下所有项</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>如果引入的函数存在同名的情况时，需使用<code>模块名::函数名</code>的方式或者<code>as</code>别名的方式来区分</li>
</ul>
<p><strong>限制可见性</strong></p>
<ul>
<li><code>pub</code> 意味着可见性无任何限制</li>
<li><code>pub(crate)</code> 表示在当前包可见</li>
<li><code>pub(self)</code> 在当前模块可见</li>
<li><code>pub(super)</code> 在父模块可见</li>
<li><code>pub(in &lt;path&gt;)</code> 表示在某个路径代表的模块中可见，其中 <code>path</code> 必须是父模块或者祖先模块</li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>简单来说，迭代器/高阶函数是“流水线模板”，提供规范流程（比如<code>map\filter</code>等等）；闭包是“可替换的工具”，即灵活调整传入的参数；而这两者都需要满足“不可变性”的安全要求</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是一种匿名函数，它<strong>可以赋值给变量也可以作为参数传递给其它函数</strong>，不同于函数的是，它<strong>允许捕获调用者作用域中的值</strong></p>
<p>闭包语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义闭包</span><br><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句1;</span><br><span class="line">    语句2;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125; </span><br><span class="line">|param1| 返回表达式 &#x2F;&#x2F; 只需要有一个表达式时</span><br><span class="line">|| &#123;&#125; &#x2F;&#x2F; 如果不需要参数时</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结构体中的闭包</span><br><span class="line">struct Cacher&lt;T&gt;</span><br><span class="line">where T: Fn(u32) -&gt; u32,</span><br><span class="line">&#123;</span><br><span class="line">    query: T,</span><br><span class="line">&#125;  &#x2F;&#x2F; 等价于struct Cacher&lt;T: Fn(u32) -&gt; u32&gt;，query字段同样也可以使用一个符合的函数作为值</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>闭包函数中是否标注类型皆可（如果未使用过则需要标注），同样可以以此省略返回值</li>
<li>闭包函数中的类型不可以是泛型，所以每次使用参数要求同类型</li>
</ul>
<p><strong>三种<code>Fn</code>特征</strong></p>
<p><code>FnOnce</code>: 强制需要闭包所捕获变量的所有权</p>
<p><code>FnMut</code>: 用于闭包函数内需要改变被捕获变量的值的情况，需要闭包和捕获变量都有<code>mut</code>声明</p>
<p><code>Fn</code>: 以不可变借用的方式捕获环境中的值(与<code>FnMut</code>不兼容，即不可改变捕获函数的值)</p>
<p><strong>注：</strong></p>
<ul>
<li><p>在<code>FnOnce</code>作为传入闭包的特征约束时，传入闭包和其捕获函数的所有权都会在第一次调用时被消耗；特殊情况：同时要求<code>FnOnce</code>与<code>Copy</code>（闭包会实现Copy，而其捕获的变量也会尽量实现Copy）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x &#x3D; vec![1, 2, 3];</span><br><span class="line">    fn_once(|z|&#123;z &#x3D;&#x3D; x.len()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fn_once&lt;F&gt;(func: F)</span><br><span class="line">where</span><br><span class="line">    F: FnOnce(usize) -&gt; bool,</span><br><span class="line">&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(3)); &#x2F;&#x2F; 捕获的Vec的所有权，闭包与变量一起消耗</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(4));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fn_once&lt;F&gt;(func: F)</span><br><span class="line">where</span><br><span class="line">    F: FnOnce(usize) -&gt; bool + Copy,&#x2F;&#x2F; 改动在这里</span><br><span class="line">&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(3)); &#x2F;&#x2F; 闭包实现Copy，不消耗；尽可能捕获可Copy的值如x.len()，没有则会在编译报错</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, func(4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由上所知，闭包的捕获行为会根据上下文约束来调整</p>
</li>
<li><p>闭包自动实现<code>Copy</code>特征的规则是，只要闭包捕获的类型都实现了<code>Copy</code>特征的话，这个闭包就会默认实现<code>Copy</code>特征</p>
</li>
<li><p><code>FnOnce</code>会消耗闭包的所有权；但无论按值还是按引用传递，<code>Fn</code>/<code>FnMut</code>通常都不会消耗闭包的所有权。即在传入一个有<code>Fn(Mut)</code>特征约束的函数之后，一个闭包函数的变量还可以继续使用</p>
</li>
<li><p>所有的闭包都自动实现了 <code>FnOnce</code> 特征，因此任何一个闭包都至少可以被调用一次；没有移出所捕获变量的所有权的闭包自动实现了 <code>FnMut</code> 特征；不需要对捕获变量进行改变的闭包自动实现了 <code>Fn</code> 特征</p>
</li>
</ul>
<p><strong><code>move</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let update_string &#x3D;  move || println!(&quot;&#123;&#125;&quot;,s); &#x2F;&#x2F; move强制闭包获取变量所有权</span><br></pre></td></tr></table></figure>

<p>闭包作为函数返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fn factory() -&gt; Fn(i32) -&gt; i32 &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    |x| x + num</span><br><span class="line">&#125; &#x2F;&#x2F; 报错，特征不是类型，需要其他辅助声明</span><br><span class="line"></span><br><span class="line">fn factory(x:i32) -&gt; impl Fn(i32) -&gt; i32 &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    if x &gt; 1&#123;</span><br><span class="line">        move |x| x + num</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        move |x| x - num</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 报错，返回的内容要求是同一类型，此处虽然满足同一特征，但属于不同类型</span><br><span class="line"></span><br><span class="line">fn factory(x:i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; &#123;</span><br><span class="line">    let num &#x3D; 5;</span><br><span class="line">    if x &gt; 1&#123;</span><br><span class="line">        Box::new(move |x| x + num)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Box::new(move |x| x - num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 正确，使用智能指针将其视为同一类型</span><br></pre></td></tr></table></figure>

<h4 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器<code>Iterator</code></h4><p>迭代器允许我们迭代一个连续的集合，例如数组、动态数组 <code>Vec</code>、<code>HashMap</code> 等，在此过程中，只需关心集合中的元素如何处理，而无需关心如何开始、如何结束、按照什么样的索引去访问</p>
<p>1、<code>.next</code>是迭代器中取下一个值的方式,返回<code>Option&lt;T&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</span><br><span class="line">    &#x2F;&#x2F; 省略其余有默认实现的方法</span><br><span class="line">&#125; &#x2F;&#x2F; 迭代器实现的特征Interator</span><br></pre></td></tr></table></figure>

<p>2、将数组转化为迭代器的三种方式(<code>Vec</code>动态数组实现的<code>IntoIterator</code>中的函数)：</p>
<ul>
<li><code>into_iter</code> 会夺走所有权</li>
<li><code>iter</code> 是借用</li>
<li><code>iter_mut</code> 是可变借用（<code>next</code>方法返回的<code>&amp;mut</code>）</li>
</ul>
<p>3、迭代器的消费者与适配器（都是迭代器特征中的方法）</p>
<ul>
<li><p>消费者：消费掉迭代器，返回一个值</p>
<p> 会拿走迭代器的所有权，即调用它之后迭代器无法再使用</p>
</li>
<li><p>适配器：返回一个新的迭代器，是链式调用的基础</p>
<p> 因此在链式调用末尾需要一个消费者来收尾用以返回一个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例1</span><br><span class="line">let v1: Vec&lt;i32&gt; &#x3D; vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">let v2: Vec&lt;_&gt; &#x3D; v1.iter().map(|x| x + 1).collect();</span><br><span class="line">&#x2F;&#x2F; collect():消费掉迭代器，把值收集成特定类型（需要显式注明）</span><br><span class="line">&#x2F;&#x2F; .map():对迭代器的每一个值操作，换为另一个新值</span><br><span class="line"></span><br><span class="line">assert_eq!(v2, vec![2, 3, 4]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例2</span><br><span class="line">let names &#x3D; [&quot;sunface&quot;, &quot;sunfei&quot;];</span><br><span class="line">let ages &#x3D; [18, 18];</span><br><span class="line">let folks: HashMap&lt;_, _&gt; &#x3D; names.into_iter().zip(ages.into_iter()).collect();</span><br><span class="line">&#x2F;&#x2F; .zip():将两个迭代器压缩在一起，形成Iterator&lt;Item&#x3D;(ValueFromA, ValueFromB)&gt; 这样的新的迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例3：闭包用作适配器参数</span><br><span class="line">fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.into_iter().filter(|s| s.size &#x3D;&#x3D; shoe_size).collect()</span><br><span class="line">&#125; &#x2F;&#x2F; filter():对迭代器每个值进行过滤，若满足则保留</span><br><span class="line">&#x2F;&#x2F; 此处闭包同样可以捕捉环境变量</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="深入类型"><a href="#深入类型" class="headerlink" title="深入类型"></a>深入类型</h3><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>as转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 3.1 as i8;</span><br><span class="line">let b &#x3D; 100_i8 as i32;</span><br><span class="line">let c &#x3D; &#39;a&#39; as u8; &#x2F;&#x2F; 将字符&#39;a&#39;转换为整数，97</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>转换不具有传递性：就算 <code>e as U1 as U2</code> 是合法的，也不能说明 <code>e as U2</code> 是合法的（<code>e</code> 不能直接转换成 <code>U2</code>）</p>
<p><strong><code>TryInto</code>转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: u8 &#x3D; 10;</span><br><span class="line">let b: u16 &#x3D; 1500;</span><br><span class="line">let b_: u8 &#x3D; b.try_into().unwrap(); &#x2F;&#x2F;尝试进行一次转换，并返回一个 Result</span><br></pre></td></tr></table></figure>

<p>注：<code>try_into</code> 转换会捕获大类型向小类型转换时导致的溢出错误</p>
<p><strong><code>From</code>和<code>Into</code>特征</strong></p>
<ul>
<li><strong><code>From&lt;T&gt;</code></strong>：定义如何从类型 <code>T</code> 转换到当前类型。</li>
<li><strong><code>Into&lt;T&gt;</code></strong>：自动为实现了 <code>From</code> 的类型生成反向转换。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">impl From&lt;i32&gt; for MyType &#123;</span><br><span class="line">    fn from(value: i32) -&gt; Self &#123;</span><br><span class="line">        MyType(value)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a &#x3D; MyType::from(42);  &#x2F;&#x2F; 显式调用</span><br><span class="line">let b: MyType &#x3D; 42.into(); &#x2F;&#x2F; 自动推导（需类型注解）</span><br></pre></td></tr></table></figure>

<h4 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a><code>newtype</code></h4><p>使用<a href="https://course.rs/basic/compound-type/struct.html#元组结构体tuple-struct" target="_blank" rel="noopener">元组结构体</a>的方式将已有的类型包裹起来：<code>struct Meters(u32);</code>，那么此处 <code>Meters</code> 就是一个 <code>newtype</code></p>
<ul>
<li>自定义类型可以让我们给出更有意义和可读性的类型名，例如与其使用 <code>u32</code> 作为距离的单位类型，我们可以使用 <code>Meters</code>，它的可读性要好得多</li>
<li>对于某些场景，只有 <code>newtype</code> 可以很好地解决</li>
<li>隐藏内部类型的细节</li>
</ul>
<p><strong>为外部类型实现外部特征</strong></p>
<p>孤儿规则：要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 必须至少有一个在当前的作用范围内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例：想为Vec实现Display特征，但这两个都在标准库中</span><br><span class="line">use std::fmt;</span><br><span class="line">struct Wrapper(Vec&lt;String&gt;);</span><br><span class="line">impl fmt::Display for Wrapper &#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f, &quot;[&#123;&#125;]&quot;, self.0.join(&quot;, &quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注：包裹一样类型的newtype是不同的类型,newtype与其内部包裹的类型同理</span><br></pre></td></tr></table></figure>



<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Meters &#x3D; u32</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>类型别名仅仅为了更好的可读性，与原类型没有任何区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 应用：减少代码模板的使用</span><br><span class="line">let f: Box&lt;dyn Fn() + Send + &#39;static&gt; &#x3D; Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line"></span><br><span class="line">type Thunk &#x3D; Box&lt;dyn Fn() + Send + &#39;static&gt;;</span><br><span class="line">let f: Thunk &#x3D; Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;常用于简化Result&lt;T, E&gt; 枚举中</span><br><span class="line">type Result&lt;T&gt; &#x3D; std::result::Result&lt;T, std::io::Error&gt;; &#x2F;&#x2F; 此处为std::io库中Error类型的简化</span><br></pre></td></tr></table></figure>



<h4 id="不定长类型DST"><a href="#不定长类型DST" class="headerlink" title="不定长类型DST"></a>不定长类型DST</h4><p>定长类型：基础类型、集合 <code>Vec</code>、<code>String</code> 和 <code>HashMap</code> 等(其在栈上拥有固定大小的指针)</p>
<p>不定长类型：<code>str</code>、特征对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn foobar_1(thing: &amp;dyn MyThing) &#123;&#125;     &#x2F;&#x2F; OK</span><br><span class="line">fn foobar_2(thing: Box&lt;dyn MyThing&gt;) &#123;&#125; &#x2F;&#x2F; OK</span><br><span class="line">fn foobar_3(thing: MyThing) &#123;&#125;          &#x2F;&#x2F; ERROR!</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>只能间接使用DST，通过引用或<code>Box</code>来使用</p>
<p><strong><code>Sized</code>特征</strong></p>
<p>怎么保证泛型参数是固定大小的类型？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T(: Sized)&gt;(t: T) &#123; &#x2F;&#x2F; 自动补全了Sized特征</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举与整数"><a href="#枚举与整数" class="headerlink" title="枚举与整数"></a>枚举与整数</h4><p>枚举到整数很容易，但反过来需要借助三方库来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">enum MyEnum &#123;</span><br><span class="line">    A &#x3D; 1,</span><br><span class="line">    B,</span><br><span class="line">    C,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将枚举转换成整数，顺利通过</span><br><span class="line">    let x &#x3D; MyEnum::C as i32;</span><br><span class="line">    &#x2F;&#x2F; 将整数转换为枚举，失败</span><br><span class="line">    match x &#123;</span><br><span class="line">        MyEnum::A &#x3D;&gt; &#123;&#125;</span><br><span class="line">        MyEnum::B &#x3D;&gt; &#123;&#125;</span><br><span class="line">        MyEnum::C &#x3D;&gt; &#123;&#125;</span><br><span class="line">        _ &#x3D;&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用num-traits&#x2F;num-derive库</span><br><span class="line">use num_derive::FromPrimitive;</span><br><span class="line">use num_traits::FromPrimitive;</span><br><span class="line"></span><br><span class="line">match FromPrimitive::from_i32(x) &#123;</span><br><span class="line">    Some(MyEnum::A) &#x3D;&gt; println!(&quot;Got A&quot;),</span><br><span class="line">    Some(MyEnum::B) &#x3D;&gt; println!(&quot;Got B&quot;),</span><br><span class="line">    Some(MyEnum::C) &#x3D;&gt; println!(&quot;Got C&quot;),</span><br><span class="line">    None            &#x3D;&gt; println!(&quot;Couldn&#39;t convert &#123;&#125;&quot;, x),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>引用（<code>&amp;T</code>/<code>&amp;mut T</code>）</strong></th>
<th><strong>智能指针（如 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所有权关系</strong></td>
<td>无所有权，仅是借用</td>
<td>通常拥有数据的所有权</td>
</tr>
<tr>
<td><strong>可变性控制</strong></td>
<td>分为共享引用（<code>&amp;T</code>）和可变引用（<code>&amp;mut T</code>）</td>
<td>通过内部可变性（如 <code>RefCell&lt;T&gt;</code>）或类型设计实现</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>必须显式或隐式标注生命周期</td>
<td>通常管理数据的整个生命周期（如 <code>Box</code> 负责释放）</td>
</tr>
<tr>
<td><strong>动态行为</strong></td>
<td>仅提供访问，无额外逻辑</td>
<td>可附加逻辑（如引用计数、自动释放、线程安全）</td>
</tr>
<tr>
<td><strong>常见类型</strong></td>
<td><code>&amp;T</code>, <code>&amp;mut T</code></td>
<td><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code></td>
</tr>
</tbody></table>
<p>智能指针与普通自定义结构体区别：实现了<code>Deref</code>和<code>Drop</code>特征</p>
<p>智能指针用于一些较引用更复杂的场景</p>
<h4 id="Box-lt-T-gt-堆对象分配"><a href="#Box-lt-T-gt-堆对象分配" class="headerlink" title="Box&lt;T&gt;堆对象分配"></a><code>Box&lt;T&gt;</code>堆对象分配</h4><p><code>Box</code> 简单的封装，用于将值存储在堆上</p>
<p>使用场景：</p>
<ul>
<li>特意的将数据分配在堆上</li>
<li>数据较大时，又不想在转移所有权时进行数据拷贝</li>
<li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时</li>
<li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将数据存储在堆上</span><br><span class="line">let a &#x3D; 3; &#x2F;&#x2F; a在栈上</span><br><span class="line">let a &#x3D; Box::new(3); &#x2F;&#x2F; 在堆上</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 避免栈上数据拷贝</span><br><span class="line">let arr &#x3D; [0;1000];</span><br><span class="line">let arr1 &#x3D; arr; &#x2F;&#x2F; 此时两份数据，是深拷贝</span><br><span class="line"></span><br><span class="line">let arr &#x3D; Box::new([0;1000]);</span><br><span class="line">let arr1 &#x3D; arr; &#x2F;&#x2F; 所有权顺利转移给 arr1，arr 不再拥有所有权</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提供固定大小</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, List), &#x2F;&#x2F; 递归类型：无法确定大小，因为DST报错</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, Box&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特征对象</span><br><span class="line">&#x2F;&#x2F; 想实现不同类型组成的数组只有两个办法：枚举和特征对象</span><br><span class="line">&#x2F;&#x2F; 特征对象其实就是把DST类型的特征转为固定大小</span><br></pre></td></tr></table></figure>

<p><strong>另：</strong><code>Box::leak</code>可以真正将一个运行期的值转化为<code>&#39;static</code>，如果只标注<code>&#39;static</code>可能无法成功</p>
<h4 id="Deref解引用"><a href="#Deref解引用" class="headerlink" title="Deref解引用"></a><code>Deref</code>解引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deref&#96; 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 &#96;*T</span><br></pre></td></tr></table></figure>

<p><strong><code>\*</code>:</strong> 对常规引用使用<code>*</code>操作符，即可以通过解引用的方式获取到内存地址对应的数据值</p>
<p><strong>智能指针解引用：</strong> 在使用给定的智能指针时，直接使用<code>*</code>解引用即可</p>
<p>在智能指针解引用时，实际上调用了<code>*(y.deref())</code>方法：<code>y.deref()</code>先返回了值的常规引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果要实现自己的智能指针同样要实现Deref特征</span><br><span class="line">use std::ops::Deref;</span><br><span class="line">impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;</span><br><span class="line">    type Target &#x3D; T;</span><br><span class="line">    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;</span><br><span class="line">        &amp;self.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; 实现该特征后才能使用*解引用</span><br></pre></td></tr></table></figure>

<p><strong>函数/方法中的隐式<code>Deref</code>转换</strong></p>
<p>函数和方法的传参中有<code>Deref</code>的隐式转换。</p>
<p>若一个类型实现了 <code>Deref</code> 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 <code>Deref</code> 转换(<code>Deref</code>支持连续的隐式转换)</p>
<p><strong>总结</strong></p>
<ul>
<li>一个类型为 <code>T</code> 的对象 <code>foo</code>，如果 <code>T: Deref&lt;Target=U&gt;</code>，那么，相关 <code>foo</code> 的引用 <code>&amp;foo</code> 在应用的时候会自动转换为 <code>&amp;U</code></li>
<li>在解引用时自动把智能指针和 <code>&amp;&amp;&amp;&amp;v</code> 做引用归一化操作，转换成 <code>&amp;v</code> 形式，最终再对 <code>&amp;v</code> 进行解引用（即将智能指针脱壳为内部的引用类型即<code>&amp;v</code>， 把多级引用归一为一级<code>&amp;v</code>）</li>
</ul>
<h4 id="Drop释放资源"><a href="#Drop释放资源" class="headerlink" title="Drop释放资源"></a><code>Drop</code>释放资源</h4><p>指定在一个变量超出作用域时，执行一段特定的代码，最终编译器将帮你自动插入这段收尾代码（无需在每一个使用该变量的地方，都写一段代码来进行收尾工作和资源释放）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Drop for Foo &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123; &#x2F;&#x2F; 传入的是可变借用</span><br><span class="line">        println!(&quot;Dropping Foo!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Drop 的顺序</strong></p>
<ul>
<li>变量级别，按照逆序的方式（<code>_x</code> 在 <code>_foo</code> 之前创建，因此 <code>_x</code> 在 <code>_foo</code> 之后被 <code>drop</code>）</li>
<li>结构体内部，按照顺序的方式</li>
</ul>
<p><strong>注：</strong></p>
<ul>
<li>Rust 自动为几乎所有类型都实现了 <code>Drop</code> 特征（除了栈上的简单类型）</li>
<li>不允许显式地调用析构函数<code>变量名.drop()</code>，但可以调用函数<code>drop(变量名)</code>（<code>drop()</code>函数会拿走目标值的所有权）</li>
<li><code>Copy</code>和<code>Drop</code>互斥，不会在一种类型上面出现（为了防止重复释放内存）</li>
</ul>
<h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a><code>Rc</code></h4><p>通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者</p>
<p>实现机制就是 <code>Rc</code> 和 <code>Arc</code>，前者适用于单线程，后者适用于多线程</p>
<p><strong><code>Rc&lt;T&gt;</code></strong></p>
<p>引用计数：通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放</p>
<p>当我们希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用 <code>Rc</code> 成为数据值的所有者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; Rc::new(String::from(&quot;hello, world&quot;)); &#x2F;&#x2F; 创建时引用计数+1，此时Rc::strong_count(&amp;a) 返回的值是 1</span><br><span class="line">let b &#x3D; Rc::clone(&amp;a); &#x2F;&#x2F; clone 仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据；同样可以使用a.clone()</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>这几个智能指针都是相同的所以<code>Rc::strong_count(&amp;a/b/c)</code>皆可</li>
<li>当其中一个变量离开作用域被销毁后，计数<code>-1</code>，但只有当计数为0时，这个指针和指向的底层数据才会销毁</li>
<li><code>Rc&lt;T&gt;</code>指向的是底层数据的不可变应用(相当于有多个不可变引用)</li>
<li>实现了<code>Deref</code>特征，可以直接使用里面的数值</li>
</ul>
<p><strong><code>Arc</code></strong></p>
<ul>
<li>原子化的 <code>Rc&lt;T&gt;</code> 智能指针,保证我们的数据能够安全的在线程间共享</li>
<li>与<code>Rc</code>的API完全相同</li>
<li><code>Arc</code> 和 <code>Rc</code> 并没有定义在同一个模块，前者通过 <code>use std::sync::Arc</code> 来引入，后者通过 <code>use std::rc::Rc</code></li>
</ul>
<h4 id="Cell和RefCell"><a href="#Cell和RefCell" class="headerlink" title="Cell和RefCell"></a><code>Cell</code>和<code>RefCell</code></h4><p>解决问题（相较于引用）：</p>
<ul>
<li>可以通过不可变引用来修改数据</li>
<li>绕过编译期借用检查</li>
<li>实现了部分可变性（比如标定结构体某个字段为内部可变）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><code>Cell&lt;T&gt;</code></th>
<th><code>RefCell&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td>获取不可变访问</td>
<td><code>get()</code> → <code>T</code>（复制）</td>
<td><code>borrow()</code> → <code>Ref&lt;T&gt;</code></td>
</tr>
<tr>
<td>获取可变访问</td>
<td><code>set(new_value)</code></td>
<td><code>borrow_mut()</code> → <code>RefMut&lt;T&gt;</code></td>
</tr>
<tr>
<td>运行时检查</td>
<td>无</td>
<td>有（可能 panic）</td>
</tr>
<tr>
<td>适用类型</td>
<td><code>T: Copy</code>（如 <code>i32</code>）</td>
<td>任意 <code>T</code>（如 <code>String</code>）</td>
</tr>
</tbody></table>
<p><strong><code>Cell</code></strong></p>
<p><code>Cell</code> 和 <code>RefCell</code> 在功能上没有区别，区别在于 <code>Cell&lt;T&gt;</code> 适用于 <code>T</code> 实现 <code>Copy</code> 的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let c &#x3D; Cell::new(42);</span><br><span class="line">let val &#x3D; c.get(); &#x2F;&#x2F; 复制值（42）</span><br><span class="line">c.set(100); &#x2F;&#x2F; 替换新值，仍然拥有所有权不会报错</span><br><span class="line"></span><br><span class="line">let c &#x3D; Cell::new(String::from(&quot;asdf&quot;)); &#x2F;&#x2F; 这样会报错</span><br></pre></td></tr></table></figure>

<p><strong><code>RefCell</code></strong></p>
<ul>
<li>允许通过不可变引用 (<code>&amp;T</code>) 修改内部数据（内部可变性）。</li>
<li>在运行时（而非编译期）检查借用规则，违反规则时触发 <code>panic</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; RefCell::new(String::from(&quot;hello, world&quot;)); &#x2F;&#x2F; s为RefCell&lt;T&gt;类型</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>borrow()</code></td>
<td>获取不可变引用 (<code>Ref&lt;T&gt;</code>)，增加不可变借用计数。若已有可变借用，则 <code>panic</code>。</td>
</tr>
<tr>
<td><code>borrow_mut()</code></td>
<td>获取可变引用 (<code>RefMut&lt;T&gt;</code>)，标记独占借用。若已有任何借用，则 <code>panic</code>。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Logger &#123;</span><br><span class="line">    logs: RefCell&lt;Vec&lt;String&gt;&gt;, &#x2F;&#x2F; 内部可变</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Logger &#123;</span><br><span class="line">    fn log(&amp;self, message: &amp;str) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过不可变的 &amp;self 修改 logs！</span><br><span class="line">        self.logs.borrow_mut().push(message.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong><code>RefCell</code> 的核心机制是，将一个本应可变的数据（如 <code>String</code>）包裹在“壳子”（<code>RefCell</code>）里，然后通过这个壳子的不可变引用（<code>&amp;RefCell&lt;T&gt;</code>），在运行时安全地修改内部数据</p>
<h4 id="循环引用与自引用"><a href="#循环引用与自引用" class="headerlink" title="循环引用与自引用"></a>循环引用与自引用</h4><p>面临问题：当使用<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>时，可以a指向b，b再指向a，出现循环引用，最后<code>Rc</code>计数无法归0</p>
<p><strong><code>Weak</code></strong></p>
<p>仅保存一份指向数据的弱引用，不保证引用关系依然存在，无法阻止所引用的内存值被释放</p>
<table>
<thead>
<tr>
<th><code>Weak</code></th>
<th><code>Rc</code></th>
</tr>
</thead>
<tbody><tr>
<td>不计数</td>
<td>引用计数</td>
</tr>
<tr>
<td>不拥有所有权</td>
<td>拥有值的所有权</td>
</tr>
<tr>
<td>不阻止值被释放(drop)</td>
<td>所有权计数归零，才能 drop</td>
</tr>
<tr>
<td>引用的值存在返回 <code>Some</code>，不存在返回 <code>None</code></td>
<td>引用的值必定存在</td>
</tr>
<tr>
<td>通过 <code>upgrade</code> 取到 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，然后再取值</td>
<td>通过 <code>Deref</code> 自动解引用，取值无需任何操作</td>
</tr>
</tbody></table>
<p><code>Weak</code> 通过 <code>use std::rc::Weak</code> 来引入，它具有以下特点:</p>
<ul>
<li>可访问，但没有所有权，不增加引用计数，因此不会影响被引用值的释放回收</li>
<li>可由 <code>Rc&lt;T&gt;</code> 调用 <code>Rc::downgrade</code> 方法转换成 <code>Weak&lt;T&gt;</code></li>
<li><code>Weak&lt;T&gt;</code> 可使用 <code>upgrade</code> 方法转换成 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，如果资源已经被释放，则 <code>Option</code> 的值是 <code>None</code></li>
<li>常用于解决循环引用的问题</li>
</ul>
<h3 id="多线程并发编程"><a href="#多线程并发编程" class="headerlink" title="多线程并发编程"></a>多线程并发编程</h3><p>并发：同时存在多个动作</p>
<p>并行：可以同时执行多个动作</p>
<p>关系：并发程序可以由人编写，但只有有多个CPU内核时才可以并行执行；</p>
<p> 并行一定并发，但只有多核时并发才能够并行</p>
<h4 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h4><p><strong>风险</strong></p>
<p>由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：</p>
<ul>
<li>竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源</li>
<li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li>
<li>一些因为多线程导致的很隐晦的 BUG，难以复现和解决</li>
</ul>
<p><strong>创建线程：</strong><code>thread::spawn</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let handle &#x3D; </span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        for i in 1..10 &#123;</span><br><span class="line">            println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(1)); &#x2F;&#x2F; thread::sleep 会让当前线程休眠指定的时间，随后其它线程会被调度运行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); &#x2F;&#x2F; 线程内部的代码使用闭包来执行</span><br><span class="line">    </span><br><span class="line">    handle.join().unwrap(); &#x2F;&#x2F; 让当前线程阻塞，直到它等待的子线程的结束</span><br><span class="line">    </span><br><span class="line">    for i in 1..5 &#123;</span><br><span class="line">        println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; &#x2F;&#x2F; main 线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>线程的启动结束时间点都是不固定的</li>
<li>由上一条，为了保证子线程中的变量一直有效，在子线程的闭包中捕获了环境变量时，需要使用<code>move</code>来转移所有权</li>
<li>主线程（<code>main</code>）退出时，会强制终止所有子线程（无论它们是否在运行）；父线程（非主线程）退出时，不会影响它创建的子线程</li>
<li><code>thread::spawn</code> 的返回值是<strong><code>std::thread::JoinHandle</code></strong>类型，表示对线程的控制权，允许主线程通过 <code>join()</code> 等待子线程结束，同样可以使用数组收集</li>
</ul>
<p><strong>多线程的性能</strong></p>
<p>当任务是 CPU 密集型时，就算线程数超过了 CPU 核心数，也并不能帮你获得更好的性能</p>
<p>当你的任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量（典型就是网络 IO 操作）</p>
<p><strong>线程屏障<code>Barrier</code></strong></p>
<p>让多个线程都执行到某个点后，才继续一起往后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Barrier&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let barrier &#x3D; Arc::new(Barrier::new(3));</span><br><span class="line">    let mut handles &#x3D; vec![];</span><br><span class="line"></span><br><span class="line">    for i in 0..3 &#123;</span><br><span class="line">        let barrier &#x3D; barrier.clone();</span><br><span class="line">        handles.push(thread::spawn(move || &#123;</span><br><span class="line">            println!(&quot;线程 &#123;&#125;: 阶段1&quot;, i);</span><br><span class="line">            barrier.wait(); &#x2F;&#x2F; 等待所有线程完成阶段1</span><br><span class="line">            println!(&quot;线程 &#123;&#125;: 阶段2&quot;, i);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<ul>
<li>需要<code>Arc</code>智能指针，作用是允许多个线程同时拥有同一数据（跨线程<code>Rc</code>）</li>
<li><code>Barrier::new(n)</code>中的<code>n</code>值一定要与实际调用<code>wait()</code>的线程数相等</li>
</ul>
<p><strong>多线程局部变量</strong></p>
<p>标准库<code>thread_local</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义</span><br><span class="line">thread_local! &#123;</span><br><span class="line">    static MY_TLS: 类型 &#x3D; 初始化值; &#x2F;&#x2F; 必须使用static声明为全局变量，一般使用RefCell&#x2F;Cell&#x2F;Mutex包裹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 语法：变量名.with(|绑定名| &#123; 操作 &#125;); 闭包传入参数即为局部变量</span><br><span class="line">thread::spawn(|| &#123;</span><br><span class="line">    &#x2F;&#x2F; 每个线程独立操作 COUNTER</span><br><span class="line">    COUNTER.with(|c| &#123;</span><br><span class="line">          *c.borrow_mut() +&#x3D; 1;</span><br><span class="line">          println!(&quot;Thread &#123;:?&#125;: &#123;&#125;&quot;, thread::current().id(), c.borrow());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>如果想使用多个局部变量的闭包函数，使用嵌套</p>
<p> 同样还有使用<code>use thread_local::ThreadLocal;</code>引用的三方库，这个库不仅仅使用了值的拷贝，而且还能自动把多个拷贝汇总到一个迭代器中，最后进行求和</p>
<p>条件控制线程的挂起和执行：<code>let pair = Arc::new((Mutex::new(false), Condvar::new()));</code></p>
<p>只会调用一次的函数：<code>static INIT: Once =Once::new();</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT.call_once(|| &#123;unsafe &#123;VAL &#x3D; 2;&#125;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a><strong>消息传递</strong></h5><p>线程通过发送和接收消息来通信，而非直接共享内存</p>
<p><strong>标准库工具<code>mpsc</code></strong>，允许多发送者，单接收者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个消息通道, 返回一个元组：(发送者，接收者)</span><br><span class="line">let (tx, rx) &#x3D; mpsc::channel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建线程，并发送消息</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    tx.send(1).unwrap(); &#x2F;&#x2F; 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span><br><span class="line">    &#x2F;&#x2F; tx.send(Some(1)).unwrap()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在主线程中接收子线程发送的消息并输出</span><br><span class="line">println!(&quot;receive &#123;&#125;&quot;, rx.recv().unwrap());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试接收一次消息，不会阻塞线程，当通道中没有消息时，它会立刻返回一个错误</span><br><span class="line">println!(&quot;receive &#123;:?&#125;&quot;, rx.try_recv());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 连续接收消息</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    let vals &#x3D; vec![</span><br><span class="line">        String::from(&quot;hi&quot;),</span><br><span class="line">        String::from(&quot;from&quot;),</span><br><span class="line">        String::from(&quot;the&quot;),</span><br><span class="line">        String::from(&quot;thread&quot;),</span><br><span class="line">    ];</span><br><span class="line">    for val in vals &#123;</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        thread::sleep(Duration::from_secs(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for received in rx &#123;</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用多发送者：克隆发送者，其余的线程拿走拷贝</span><br><span class="line">let tx1 &#x3D; tx.clone();</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    tx1.send(String::from(&quot;hi from cloned tx&quot;)).unwrap();</span><br><span class="line">&#125;); </span><br><span class="line">for received in rx &#123;</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;&#x2F;&#x2F; 需要所有的发送者都被drop掉后，接收者rx才会收到错误，进而跳出for循环，最终结束主线程；</span><br><span class="line">&#x2F;&#x2F; 两个子线程谁先创建完成是未知的，哪条消息先发送也是未知的</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步通道设置</span><br><span class="line">let (tx, rx)&#x3D; mpsc::sync_channel(n); &#x2F;&#x2F; n用来指定同步通道的消息缓存条数</span><br></pre></td></tr></table></figure>

<ul>
<li><code>tx</code>,<code>rx</code>对应发送者和接收者，它们的类型由编译器自动推导: <code>tx.send(1)</code>发送了整数，因此它们分别是<code>mpsc::Sender&lt;i32&gt;</code>和<code>mpsc::Receiver&lt;i32&gt;</code>类型，(一旦类型被推导确定，该通道就只能传递对应类型的值)</li>
<li>接收消息的操作<code>rx.recv()</code>会阻塞当前线程，直到读取到值，或者通道被关闭</li>
<li>需要使用<code>move</code>将<code>tx</code>的所有权转移到子线程的闭包中</li>
<li>使用通道来传输数据，一样要遵循 Rust 的所有权规则：<ul>
<li>若值的类型实现了<code>Copy</code>特征，则直接复制一份该值，然后传输过去，例如之前的<code>i32</code>类型</li>
<li>若值没有实现<code>Copy</code>（如<code>String</code>类型），则它的所有权会被转移给接收端，在发送端继续使用该值将报错</li>
</ul>
</li>
<li>异步中只有接收者会被阻塞，同步中发送者也会因为接收者接收不到消息被阻塞</li>
<li>所有发送者被<code>drop</code>或者所有接收者被<code>drop</code>后，通道会自动关闭</li>
</ul>
<h5 id="锁、Condvar"><a href="#锁、Condvar" class="headerlink" title="锁、Condvar"></a>锁、<code>Condvar</code></h5><p>使用共享内存来实现同步性</p>
<p>面临问题：多个线程同时修改同一数据时，结果不可预测；线程执行顺序影响最终结果</p>
<p><strong>互斥锁<code>Mutex</code></strong></p>
<p>同一时间，只允许一个线程<code>A</code>访问该值，其它线程需要等待<code>A</code>访问完成后才能继续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建实例：锁的容器</span><br><span class="line">let m &#x3D; Mutex::new(5);</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; lock返回的是Result</span><br><span class="line">    let mut num &#x3D; m.lock().unwrap(); &#x2F;&#x2F; .lock()向m申请锁的所有权（简称“锁”）：在获取锁之前会阻塞线程。同时只能有一个线程获得锁</span><br><span class="line">    &#x2F;&#x2F; 当拥有锁的线程panic，其他线程永远得不到这个锁</span><br><span class="line">    *num &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 锁自动被drop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多线程中使用锁</span><br><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">let counter &#x3D; Arc::new(Mutex::new(0));</span><br><span class="line">let mut handles &#x3D; vec![];</span><br><span class="line"></span><br><span class="line">for _ in 0..10 &#123;</span><br><span class="line">    let counter &#x3D; Arc::clone(&amp;counter);</span><br><span class="line">    &#x2F;&#x2F; 创建子线程，并将&#96;Mutex&#96;的所有权拷贝传入到子线程中，子线程需要通过move拿走锁的所有权</span><br><span class="line">    let handle &#x3D; thread::spawn(move || &#123;</span><br><span class="line">        let mut num &#x3D; counter.lock().unwrap();</span><br><span class="line">		*num +&#x3D; 1;</span><br><span class="line">    &#125;);</span><br><span class="line">    handles.push(handle);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 等待所有子线程完成</span><br><span class="line">for handle in handles &#123;</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>m.lock()</code>返回一个智能指针<code>MutexGuard&lt;T&gt;</code>，拥有<code>Deref</code>特征（自动解引用获取引用类型）与<code>Drop</code>特征（超出作用域自动释放锁）</li>
<li><code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code>用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutex&lt;T&gt;</code>用于多线程内部可变性</li>
</ul>
<p><strong>死锁</strong></p>
<ul>
<li>在另一个锁还未被释放时去申请新的锁，就会触发</li>
<li>当我们拥有两个锁的容器，且两个线程各自使用了其中一个锁，然后试图去访问另一个锁时，就可能发生死锁</li>
<li><code>try_lock()</code>: 尝试去获取一次锁，如果无法获取会返回一个错误，因此不会发生阻塞</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let guard &#x3D; MUTEX2.lock().unwrap();</span><br><span class="line">let guard &#x3D; MUTEX2.try_lock(); &#x2F;&#x2F; 返回错误</span><br></pre></td></tr></table></figure>

<p><strong>读写锁<code>RwLock</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Mutex&#96;会对每次读写都进行加锁，但某些时候，我们需要大量的并发读，&#96;Mutex&#96;就无法满足需求了，此时就可以使用&#96;RwLock</span><br><span class="line">use std::sync::RwLock;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let lock &#x3D; RwLock::new(5);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同一时间允许多个读</span><br><span class="line">    &#123;</span><br><span class="line">        let r1 &#x3D; lock.read().unwrap();</span><br><span class="line">        let r2 &#x3D; lock.read().unwrap();</span><br><span class="line">        assert_eq!(*r1, 5);</span><br><span class="line">        assert_eq!(*r2, 5);</span><br><span class="line">    &#125; &#x2F;&#x2F; 读锁在此处被drop</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同一时间只允许一个写</span><br><span class="line">    &#123;</span><br><span class="line">        let mut w &#x3D; lock.write().unwrap();</span><br><span class="line">        *w +&#x3D; 1;</span><br><span class="line">        assert_eq!(*w, 6);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以下代码会阻塞发生死锁，因为读和写不允许同时存在</span><br><span class="line">        &#x2F;&#x2F; 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于&#96;w&#96;的作用域中</span><br><span class="line">        &#x2F;&#x2F; let r1 &#x3D; lock.read();</span><br><span class="line">        &#x2F;&#x2F; println!(&quot;&#123;:?&#125;&quot;,r1);</span><br><span class="line">    &#125;&#x2F;&#x2F; 写锁在此处被drop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>try_write</code>和<code>try_read</code>来尝试进行一次写/读，若失败则返回错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Err(&quot;WouldBlock&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>条件变量<code>Condvar</code>控制线程同步</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex, Condvar&#125;;</span><br><span class="line"></span><br><span class="line">let pair &#x3D; Arc::new((Mutex::new(false), Condvar::new()));</span><br><span class="line">let (lock, cvar) &#x3D; &amp;*pair;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消费者线程（等待条件成立）</span><br><span class="line">let consumer &#x3D; thread::spawn(move || &#123;</span><br><span class="line">    let mut condition &#x3D; lock.lock().unwrap();</span><br><span class="line">    while !*condition &#123;</span><br><span class="line">        condition &#x3D; cvar.wait(condition).unwrap(); &#x2F;&#x2F; 释放锁并等待</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;Condition is now true!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产者线程（修改条件并通知）</span><br><span class="line">thread::spawn(move || &#123;</span><br><span class="line">    let mut condition &#x3D; lock.lock().unwrap();</span><br><span class="line">    *condition &#x3D; true;          &#x2F;&#x2F; 修改条件</span><br><span class="line">    cvar.notify_one();          &#x2F;&#x2F; 唤醒消费者</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">consumer.join().unwrap();</span><br></pre></td></tr></table></figure>

<p>消费者线程需等待条件成立才可执行：获取互斥锁检查条件是否成立 =&gt; 不成立则进入循环 =&gt; <code>cvar.wait(condition).unwrap()</code>执行时立即释放互斥锁（交由其他线程修改） =&gt; 其他线程修改后使用<code>cvar.notify_one()</code>唤醒该线程 =&gt; 返回条件重新检查</p>
<p>注：</p>
<ul>
<li><pre><code>notify_one()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">随机唤醒一个正在</span><br></pre></td></tr></table></figure>
wait()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  的线程（由操作系统调度决定）。</span><br><span class="line"></span><br><span class="line">  - 如果有多个线程在等待，不保证顺序（可能是最早等待的，也可能是随机的）。</span><br><span class="line">  - 如果没有线程在等待，这次通知会被丢弃（无效果）。</span><br><span class="line"></span><br><span class="line">- &#96;notify_all()&#96;： 唤醒所有正在 &#96;wait()&#96; 的线程，它们会竞争锁并依次检查条件。</span><br><span class="line"></span><br><span class="line">##### &#96;Atomic&#96;原子类型与内存顺序</span><br><span class="line"></span><br><span class="line">为解决锁的性能问题而生，通过 CPU 的原子指令实现无锁线程安全操作</span><br><span class="line"></span><br><span class="line">| 特性             | 说明                                                         |</span><br><span class="line">| ---------------- | ------------------------------------------------------------ |</span><br><span class="line">| **不可分割性**   | 操作一旦开始，不会被其他线程或 CPU 中断。                    |</span><br><span class="line">| **线程安全**     | 多线程同时执行同一原子指令时，结果依然正确                   |</span><br><span class="line">| **硬件直接支持** | 由 CPU 通过特定指令（如 &#96;LOCK&#96; 前缀）实现，而非软件模拟。    |</span><br><span class="line">| **内存顺序控制** | 通过 &#96;Ordering&#96; 参数指定操作前后的指令重排规则（如 &#96;SeqCst&#96;）。 |</span><br></pre></td></tr></table></figure>
use std::sync::atomic::AtomicUsize;
</code></pre></li>
</ul>
<p>let counter = AtomicUsize::new(0); // 常用场景是作为全局变量</p>
<p>counter.store(100, Ordering::Relaxed); // 存储值（写入）</p>
<p>let current = counter.load(Ordering::SeqCst);<br>println!(“Current value: {}”, current); // 加载值（读取）</p>
<p>let old = counter.fetch_add(10, Ordering::SeqCst); // 原子加法（返回旧值）旧值=100，新值=110</p>
<p>counter.fetch_sub(5, Ordering::Relaxed); // 原子减法 新值=105</p>
<p>counter.fetch_or(0b1, Ordering::Relaxed); // 原子位操作 按位或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**内存顺序**</span><br><span class="line"></span><br><span class="line">面临问题：编译器可能导致指令重排</span><br></pre></td></tr></table></figure>
<p>X = 1;<br>Y = 3;<br>X = 2; // 直接变成</p>
<p>X = 2;<br>Y = 3;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内存顺序指定</span><br><span class="line"></span><br><span class="line">| **Ordering** | 作用                                                         |</span><br><span class="line">| ------------ | ------------------------------------------------------------ |</span><br><span class="line">| &#96;Relaxed&#96;    | 仅保证原子性，不保证顺序（性能最高）                         |</span><br><span class="line">| &#96;Release&#96;    | 写入操作：确保之前的指令不会被重排到它之后，（在这条指令前写入的数据）对其他线程可见 |</span><br><span class="line">| &#96;Acquire&#96;    | 读取操作：确保之后的指令不会被重排到它之前，能读到其他线程的修改 |</span><br><span class="line">| &#96;SeqCst&#96;     | 严格顺序一致性（性能最低，但最安全）                         |</span><br></pre></td></tr></table></figure>
<p>use std::sync::atomic::{AtomicBool, Ordering};</p>
<p>let ready = AtomicBool::new(false);<br>let data = 42;</p>
<p>// 线程1：发布数据<br>thread::spawn(move || {<br>    data = 100;                        // 非原子写入<br>    ready.store(true, Ordering::Release); // 保证 data 写入对其他线程可见<br>});</p>
<p>// 线程2：读取数据<br>thread::spawn(move || {<br>    while !ready.load(Ordering::Acquire) {} // 等待并同步内存<br>    println!(“Data: {}”, data);        // 保证看到 data=100<br>});</p>
<p>// 多线程需要用到Arc与clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 全局变量</span><br><span class="line"></span><br><span class="line">全局变量的生命周期肯定是&#96;&#39;static&#96;，但是不代表它需要用&#96;static&#96;来声明</span><br><span class="line"></span><br><span class="line">- 编译期初始化的全局变量，&#96;const&#96;创建常量，&#96;static&#96;创建静态变量，&#96;Atomic&#96;创建原子类型</span><br><span class="line">- 运行期初始化的全局变量，&#96;lazy_static&#96;用于懒初始化，&#96;Box::leak&#96;利用内存泄漏将一个变量的生命周期变为&#96;&#39;static&#96;</span><br><span class="line"></span><br><span class="line">#### 编译期初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**静态常量**</span><br></pre></td></tr></table></figure>
<p>const MAX_ID: usize =  usize::MAX / 2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关键字是&#96;const&#96;而不是&#96;let&#96;</span><br><span class="line">- 定义常量必须指明类型（如 i32）不能省略</span><br><span class="line">- 定义常量时变量的命名规则一般是全部大写</span><br><span class="line">- 常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址</span><br><span class="line">- 常量的赋值只能是常量表达式&#x2F;数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式</span><br><span class="line">- 对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义</span><br><span class="line"></span><br><span class="line">**静态变量**</span><br></pre></td></tr></table></figure>
<p>static mut REQUEST_RECV: usize = 0;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 必须使用&#96;unsafe&#96;语句块才能访问和修改&#96;static&#96;变量</span><br><span class="line">- 定义静态变量的时候必须赋值为在编译期就可以计算出的值(常量表达式&#x2F;数学表达式)，不能是运行时才能计算出的值(如函数)</span><br><span class="line"></span><br><span class="line">**原子类型**</span><br><span class="line"></span><br><span class="line">想要全局计数器、状态控制等功能，又想要线程安全的实现</span><br></pre></td></tr></table></figure>
<p>use std::sync::atomic::{AtomicUsize, Ordering};<br>static REQUEST_RECV: AtomicUsize  = AtomicUsize::new(0);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 运行期初始化</span><br><span class="line"></span><br><span class="line">解决问题：无法用函数进行静态初始化</span><br><span class="line"></span><br><span class="line">**&#96;lazy_static&#96;**</span><br><span class="line"></span><br><span class="line">用于懒初始化（直到使用时才开始初始化）静态变量的宏，允许我们在运行期初始化静态变量</span><br></pre></td></tr></table></figure>
<p>use lazy_static::lazy_static;<br>lazy_static! {<br>    static ref NAMES: Mutex<String> = Mutex::new(String::from(“Sunface, Jack, Allen”));<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;lazy_static&#96;宏，匹配的是&#96;static ref&#96;，所以定义的静态变量都是不可变引用</span><br><span class="line"></span><br><span class="line">**&#96;Box::leak&#96;**</span><br><span class="line"></span><br><span class="line">将一个变量从内存中漏出来，变为&#96;&#39;static&#39;&#96;生命周期</span><br></pre></td></tr></table></figure>
<p>#[derive(Debug)]<br>struct Config {<br>    a: String,<br>    b: String<br>}<br>static mut CONFIG: Option&lt;&amp;mut Config&gt; = None;</p>
<p>fn main() {<br>    let c = Box::new(Config {<br>        a: “A”.to_string(),<br>        b: “B”.to_string(),<br>    });</p>
<pre><code>unsafe {
    // 将`c`从内存中泄漏，变成`&apos;static`生命周期(正常情况下，一个局部变量不可赋给全局变量)
    CONFIG = Some(Box::leak(c));
    println!(&quot;{:?}&quot;, CONFIG);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 错误处理</span><br><span class="line"></span><br><span class="line">#### 组合器</span><br><span class="line"></span><br><span class="line">**&#96;or()&#96;和&#96;and()&#96;**</span><br><span class="line"></span><br><span class="line">对两个表达式做逻辑组合，最终返回 &#96;Option&#96; &#x2F; &#96;Result&#96;</span><br><span class="line"></span><br><span class="line">- &#96;or()&#96;，表达式按照顺序求值，若任何一个表达式的结果是 &#96;Some&#96; 或 &#96;Ok&#96;，则该值会立刻返回</span><br><span class="line">- &#96;and()&#96;，若两个表达式的结果都是 &#96;Some&#96; 或 &#96;Ok&#96;，则第二个表达式中的值被返回。若任何一个的结果是 &#96;None&#96; 或 &#96;Err&#96; ，则立刻返回。</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“some1”);<br>let s2 = Some(“some2”);<br>let n: Option&lt;&amp;str&gt; = None;<br>assert_eq!(s1.or(s2), s1);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注：&#96;or&#x2F;and()&#96;的两个表达式要是同一类型，不能一边是&#96;Option&#96;一边是&#96;Result&#96;</span><br><span class="line"></span><br><span class="line">**&#96;or_else()和and_then()&#96;**</span><br><span class="line"></span><br><span class="line">跟 &#96;or()&#96; 和 &#96;and()&#96; 类似，但第二个表达式是一个闭包</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“some1”);<br>let fn_some = || Some(“some2”);<br>let fn_none = || None;<br>assert_eq!(s1.or_else(fn_some), s1);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;fliter&#96;**</span><br><span class="line"></span><br><span class="line">用于对 &#96;Option&#96; 进行过滤</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(3);<br>let n = None;<br>let fn_is_even = |x: &amp;i8| x % 2 == 0;<br>assert_eq!(s1.filter(fn_is_even), n);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;map()&#96;和&#96;map_err()&#96;**</span><br><span class="line"></span><br><span class="line">&#96;map&#96; 可以将 &#96;Some&#96; 或 &#96;Ok&#96; 中的值映射为另一个（转化容器内的值）</span><br><span class="line"></span><br><span class="line"> 如果&#96;a&#96;的值是&#96;Some(n)&#96;，&#96;a.map(f)&#96;将&#96;a&#96;的值变为&#96;Some(f(n))&#96;</span><br><span class="line"></span><br><span class="line">用 &#96;map_err&#96;将 &#96;Err&#96; 中的值进行改变（效果同上）</span><br></pre></td></tr></table></figure>
<p>let s1 = Some(“abcde”);<br>let s2 = Some(5);<br>let fn_character_count = |s: &amp;str| s.chars().count();<br>assert_eq!(s1.map(fn_character_count), s2);</p>
<p>let e1: Result&lt;&amp;str, &amp;str&gt; = Err(“404”);<br>let e2: Result&lt;&amp;str, isize&gt; = Err(404);<br>let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() };<br>assert_eq!(e1.map_err(fn_character_count), e2);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**&#96;map_or()&#96;和&#96;map_or_else()&#96;**</span><br><span class="line"></span><br><span class="line">&#96;map_or&#96; 在 &#96;map&#96; 的基础上提供了一个默认值</span><br><span class="line"></span><br><span class="line">&#96;map_or_else&#96; 与 &#96;map_or&#96; 类似，但是它是通过一个闭包来提供默认值</span><br></pre></td></tr></table></figure>
<p>const V_DEFAULT: u32 = 1; // 默认值<br>let s: Result&lt;u32, ()&gt; = Ok(10);<br>let fn_closure = |v: u32| v + 2;<br>assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);</p>
<p>let s = Some(10);<br>let fn_closure = |v: i8| v + 2;<br>let fn_default = || 1; // 默认值<br>assert_eq!(s.map_or_else(fn_default, fn_closure), 12);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;ok_or()&#96;和&#96;ok_or_else&#96;**</span><br><span class="line"></span><br><span class="line">可以将 &#96;Option&#96; 类型转换为 &#96;Result&#96; 类型</span><br><span class="line"></span><br><span class="line">&#96;ok_or&#96; 接收一个默认的 &#96;Err&#96; 参数，&#96;ok_or_else&#96; 接收一个闭包作为 &#96;Err&#96; 参数</span><br></pre></td></tr></table></figure>
<p>const ERR_DEFAULT: &amp;str = “error message”;<br>// let fn_err_message = || “error message”;</p>
<p>assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)<br>assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 自定义错误类型</span><br></pre></td></tr></table></figure>
<p>use std::fmt::{Debug, Display};</p>
<p>pub trait Error: Debug + Display {<br>    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + ‘static)&gt; { … }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当自定义类型实现该特征后，该类型就可以作为 &#96;Err&#96; 来使用，同时可以归一化为&#96;Box&lt;dyn std::error:Error&gt;&#96;</span><br><span class="line"></span><br><span class="line">**将其他错误类型转化为自定义错误类型**</span><br><span class="line"></span><br><span class="line">只要实现&#96;From&#96;特征，即可使用&#96;?&#96;强制把返回的错误类型转换（同时返回）</span><br></pre></td></tr></table></figure>
<p>// std::convert::From特征<br>pub trait From<T>: Sized {<br>  fn from(_: T) -&gt; Self;<br>} // T为原本的错误类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**归一化不同错误类型**</span><br><span class="line"></span><br><span class="line">面临问题：要在一个函数中返回不同的错误</span><br><span class="line"></span><br><span class="line">解决方案：将不同的错误类型归一化为一种</span><br><span class="line"></span><br><span class="line">- 使用特征对象 &#96;Box&lt;dyn Error&gt;&#96;：需要实现&#96;Debug + Display&#96; 特征（存在问题：一个没有&#96;Error&#96;特征的类型同样可以用作&#96;Result&lt;T, E&gt;&#96;中的&#96;E&#96;）</span><br><span class="line">- 自定义错误类型：需要实现&#96;Error&#96;特征才能被转换出来</span><br><span class="line">- 使用 &#96;thiserror&#96;（一种三方库函数）</span><br><span class="line"></span><br><span class="line">### &#96;UnSafe&#96;</span><br><span class="line"></span><br><span class="line">面临问题：</span><br><span class="line"></span><br><span class="line">- 编译器过强且保守</span><br><span class="line">- 特定功能如底层硬件操作本就不安全</span><br><span class="line"></span><br><span class="line">&#96;unsafe&#96;功能</span><br><span class="line"></span><br><span class="line">- 解引用裸指针</span><br><span class="line">- 调用一个 &#96;unsafe&#96; 或外部的函数</span><br><span class="line">- 访问或修改一个可变的静态变量</span><br><span class="line">- 实现一个 &#96;unsafe&#96; 特征</span><br><span class="line">- 访问 &#96;union&#96; 中的字段</span><br><span class="line"></span><br><span class="line">#### 功能解析</span><br><span class="line"></span><br><span class="line">##### 解引用裸指针</span><br><span class="line"></span><br><span class="line">裸指针在功能上跟引用类似，同时它也需要显式地注明可变性。</span><br><span class="line"></span><br><span class="line">&#96;*const T&#96; 和 &#96;*mut T&#96;分别代表了不可变和可变（&#96;*&#96; 是类型名称的一部分而非解引用）</span><br><span class="line"></span><br><span class="line">裸指针的功能（类似于C的指针）：</span><br><span class="line"></span><br><span class="line">- 可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</span><br><span class="line">- 并不能保证指向合法的内存</span><br><span class="line">- 可以是 &#96;null&#96;</span><br><span class="line">- 没有实现任何自动的回收 (drop)</span><br></pre></td></tr></table></figure>
<p>// 基于引用创建裸指针<br>let mut num = 5;<br>let r1 = &amp;num as *const i32;<br>let r2 = &amp;mut num as *mut i32;</p>
<p>// 使用*解引用<br>unsafe {<br>    println!(“{}”, *r1);<br>}</p>
<p>// 基于智能指针创建裸指针<br>let a: Box<i32> = Box::new(10);<br>let b: <em>const i32 = &amp;</em>a; // 需要先解引用a<br>let c: *const i32 = Box::into_raw(a); // 使用 into_raw 来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注：</span><br><span class="line"></span><br><span class="line">- 创建裸指针是安全的行为，使用不是</span><br><span class="line">- 使用裸指针可以创建两个可变指针都指向同一个数据（需要自己处理数据竞争）</span><br><span class="line"></span><br><span class="line">##### 调用&#96;unsafe&#96;函数或方法</span><br></pre></td></tr></table></figure>
<p>// unsafe函数：外表唯一不同就是需要unsafe fn来定义，在调用时需要放在unsafe块<br>// 在unsafe函数中使用unsafe来注明块是多余的行为<br>unsafe fn dangerous() {}<br>fn main() {<br>    unsafe {<br>        dangerous();<br>    }<br>}</p>
<p>// 在函数中使用了unsafe声明块不代表函数要声明为unsafe fn:同样可以使用用安全的抽象包裹unsafr代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### &#96;FFI&#96;</span><br><span class="line"></span><br><span class="line">用来与其它语言进行交互</span><br><span class="line"></span><br><span class="line">面临问题：使用一个其他语言编写的库</span><br><span class="line"></span><br><span class="line">- 对该库进行重写或者移植</span><br><span class="line">- 使用 &#96;FFI&#96;</span><br></pre></td></tr></table></figure>
<p>// 调用C标准库中的abs函数<br>extern “C” { // C定义了外部函数所使用的应用二进制接口ABI<br>    fn abs(input: i32) -&gt; i32;<br>}<br>fn main() {<br>    unsafe { // 必须使用unsafe<br>        println!(“Absolute value of -3 according to C: {}”, abs(-3));<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 访问&#96;union&#96;中的字段</span><br><span class="line"></span><br><span class="line">&#96;union&#96;主要用于和&#96;C&#96;代码交互，访问其字段是不安全的</span><br></pre></td></tr></table></figure>
<p>#[repr(C)]<br>union MyUnion {<br>    f1: u32,<br>    f2: f32,<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &#96;Macro&#96;宏编程</span><br><span class="line"></span><br><span class="line">宏的参数可以使用 &#96;()&#96;、&#96;[]&#96; 以及 &#96;&#123;&#125;&#96;：虽然三种使用形式皆可，但是 Rust 内置的宏都有自己约定俗成的使用方式，例如 &#96;vec![...]&#96;、&#96;assert_eq!(...)&#96; 等</span><br><span class="line"></span><br><span class="line">宏分为两类：</span><br><span class="line"></span><br><span class="line">- 声明式宏</span><br><span class="line">- 三种过程宏</span><br><span class="line">  - &#96;#[derive]&#96;，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 &#96;Debug&#96; 特征</span><br><span class="line">  - 类属性宏(Attribute-like macro)，用于为目标添加自定义的属性</span><br><span class="line">  - 类函数宏(Function-like macro)，看上去就像是函数调用</span><br><span class="line"></span><br><span class="line">#### 宏与函数的区别</span><br><span class="line"></span><br><span class="line">元编程：通过一种代码来生成另一种代码，可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本</span><br><span class="line"></span><br><span class="line">可变参数：相比于&#96;Rust&#96;中函数参数个数的固定，宏的参数个数可变</span><br><span class="line"></span><br><span class="line">宏展开：宏展开过程是发生在编译器对代码进行解释之前，即编译期前；函数直到运行时才调用</span><br><span class="line"></span><br><span class="line">#### 声明式宏&#96;macro_rules&#96;</span><br><span class="line"></span><br><span class="line">声明式宏用来编写可以生成代码的代码，即可以编写自己的宏</span><br><span class="line"></span><br><span class="line">类似于&#96;match&#96;进行模式匹配，类似于函数可以传入参数</span><br></pre></td></tr></table></figure>
<p>// 基本形式<br>macro_rules! macro_name {<br>    (pattern) =&gt; { expansion };<br>    // 可以有多个匹配模式<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**模式匹配**的模式可以包括：字面量、元变量（以 &#96;$&#96; 开头的捕获，如 &#96;$x:expr&#96;）、重复（使用 &#96;$(...)*&#96; 或 &#96;$(...)+&#96; 等表示重复）</span><br><span class="line"></span><br><span class="line">**元变量类型**（类似于函数定义中形参的类型声明）</span><br><span class="line"></span><br><span class="line">- &#96;expr&#96;：表达式</span><br><span class="line">- &#96;ident&#96;：标识符（变量名、函数名等）</span><br><span class="line">- &#96;ty&#96;：类型</span><br><span class="line">- &#96;path&#96;：路径（如 &#96;std::collections::HashMap&#96;）</span><br><span class="line">- &#96;pat&#96;：模式</span><br><span class="line">- &#96;stmt&#96;：语句</span><br><span class="line">- &#96;block&#96;：代码块</span><br><span class="line">- &#96;item&#96;：项（函数、结构体、模块等）</span><br><span class="line">- &#96;meta&#96;：元项（&#96;#[...]&#96; 和 &#96;#![...]&#96; 属性内部的内容）</span><br><span class="line">- &#96;tt&#96;：标记树（单个标记或括号内的标记）</span><br><span class="line"></span><br><span class="line">**重复操作符**</span><br><span class="line"></span><br><span class="line">- &#96;*&#96;：0 次或多次</span><br><span class="line">- &#96;+&#96;：1 次或多次</span><br><span class="line">- &#96;?&#96;：0 次或 1 次</span><br></pre></td></tr></table></figure>
<p>#[macro_export] // 将宏进行了导出，其它的包就可以将该宏引入到当前作用域中<br>macro_rules! create_function { // 宏的名称是c_f，在调用时才需要加上！<br>    ($func_name:ident) =&gt; {<br>        fn $func_name() {<br>            println!(“You called {}”, stringify!($func_name));<br>        }<br>    };<br>}<br>// 使用<br>create_function!(foo); // 传入一个合法标识符，创建了一个函数<br>foo(); // 输出: You called foo</p>
<p>// 重复模式<br>#[macro_export]<br>macro_rules! vec {<br>    ( $( $x:expr ),* ) =&gt; {<br>        {<br>            let mut temp_vec = Vec::new();<br>            $(<br>                temp_vec.push($x);<br>            )* // 此处相当于一个循环<br>            temp_vec<br>        }<br>    };<br>}<br>// 使用<br>let v = vec!(“a”, “b”, “c”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 过程宏</span><br><span class="line"></span><br><span class="line">1. **派生宏（Derive Macros）** *&quot;自动为结构体&#x2F;枚举生成 trait 实现的代码扩展器。&quot;* → **用途**：如 &#96;#[derive(Serialize)]&#96; 为类型实现序列化逻辑。</span><br><span class="line">2. **属性宏（Attribute Macros）** *&quot;编译时代码加工器，能修改或增强被标记的项（如函数&#x2F;结构体）。&quot;* → **用途**：如 &#96;#[tokio::main]&#96; 将普通函数异步化。</span><br><span class="line">3. **函数式宏（Function-like Macros）** *&quot;将其他语法编译时转换为 Rust 代码的翻译器。&quot;* → **用途**：如 &#96;sql!(SELECT * FROM table)&#96; 生成类型安全的查询构建器。</span><br><span class="line"></span><br><span class="line">##### 自定义&#96;derive&#96;过程宏</span><br><span class="line"></span><br><span class="line">注：目前只能在单独的包中定义宏，包名以&#96;derive&#96;为后缀</span><br><span class="line"></span><br><span class="line">假设有一个特征 &#96;HelloMacro&#96;，现在有两种方式让用户使用它：</span><br><span class="line"></span><br><span class="line">- 为每个类型手动实现该特征，就像之前特征章节所做的</span><br><span class="line">- 使用过程宏来统一实现该特征，这样用户只需要对类型进行标记即可：&#96;#[derive(HelloMacro)]&#96;</span><br></pre></td></tr></table></figure>
<p>// hello_macro项目目录<br>hello_macro<br>├── Cargo.toml<br>├── src<br>│   ├── main.rs<br>│   └── lib.rs<br>└── hello_macro_derive // 此包中实现宏<br>    ├── Cargo.toml<br>    ├── src<br>        └── lib.rs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在项目的&#96;src&#x2F;main.rs&#96;中引用宏包中的内容：</span><br><span class="line"></span><br><span class="line">- 将 &#96;hello_macro_derive&#96; 发布到 &#96;crates.io&#96; 或 &#96;GitHub&#96; 中（类似于正常的依赖）</span><br><span class="line">- 使用相对路径引入的本地化方式</span><br></pre></td></tr></table></figure>
<p>// 修改 hello_macro/Cargo.toml 文件添加以下内容<br>[dependencies]<br>hello_macro_derive = { path = “../hello_macro/hello_macro_derive” }</p>
<h1 id="也可以使用下面的相对路径"><a href="#也可以使用下面的相对路径" class="headerlink" title="也可以使用下面的相对路径"></a>也可以使用下面的相对路径</h1><h1 id="hello-macro-derive-path-“-hello-macro-derive”"><a href="#hello-macro-derive-path-“-hello-macro-derive”" class="headerlink" title="hello_macro_derive = { path = “./hello_macro_derive” }"></a>hello_macro_derive = { path = “./hello_macro_derive” }</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">定义过程宏的过程</span><br></pre></td></tr></table></figure>
<p>// 1、在 hello_macro_derive/Cargo.toml 文件中添加<br>[lib]<br>proc-macro = true</p>
<p>[dependencies]<br>syn = “1.0”<br>quote = “1.0” // 这两个依赖包是定义中必须的</p>
<p>// 2、在 hello_macro_derive/src/lib.rs 中添加<br>extern crate proc_macro; // 过程宏核心库，提供 TokenStream 类型（表示宏的输入/输出）<br>use proc_macro::TokenStream;<br>use quote::quote;<br>use syn;<br>use syn::DeriveInput;</p>
<p>#[proc_macro_derive(HelloMacro)]<br>pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {<br>    // 基于 input 构建 AST 语法树<br>    let ast:DeriveInput = syn::parse(input).unwrap();</p>
<pre><code>// 构建特征实现代码
impl_hello_macro(&amp;ast)</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RCore学习记录</span><br><span class="line"></span><br><span class="line">顺序：&#96;bulid.rs&#96;文件会生成一个&#96;link_app.S&#96;（里面包含有各个程序标识起始地址的变量、名称和完整的ELF文件嵌入），这个文件由&#96;linker.S&#96;塞入内核镜像（编译链接后的程序文件），最后由&#96;load&#96;来执行</span><br><span class="line"></span><br><span class="line">任务切换的实质：切换任务上下文（即更改对应的寄存器为想执行的任务上下文中保存的数值）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 批处理系统</span><br><span class="line"></span><br><span class="line">**系统调用的基础函数：**</span><br><span class="line"></span><br><span class="line">&#96;syscall&#96; （用户文件中，标准库函数的基础） 和&#96;sbicall&#96; （系统文件中）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;rust</span><br><span class="line"> 3fn syscall(id: usize, args: [usize; 3]) -&gt; isize &#123;</span><br><span class="line"> 4   let mut ret: isize;</span><br><span class="line"> 5   unsafe &#123;</span><br><span class="line"> 6       core::arch::asm!(</span><br><span class="line"> 7           &quot;ecall&quot;,</span><br><span class="line"> 8           inlateout(&quot;x10&quot;) args[0] &#x3D;&gt; ret,</span><br><span class="line"> 9           in(&quot;x11&quot;) args[1],</span><br><span class="line">10           in(&quot;x12&quot;) args[2],</span><br><span class="line">11           in(&quot;x17&quot;) id</span><br><span class="line">12       );</span><br><span class="line">13   &#125;</span><br><span class="line">14   ret</span><br><span class="line">15&#125;</span><br></pre></td></tr></table></figure>



<p><strong>批处理系统的应用管理器：</strong></p>
<p>（从系统文件中一个记录了应用数量、各应用起始位置、最后一个应用结束位置的<code>link_app.S</code>中获取）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppManager</span></span> &#123;</span><br><span class="line">    num_app: <span class="built_in">usize</span>,</span><br><span class="line">    current_app: <span class="built_in">usize</span>,</span><br><span class="line">    app_start: [<span class="built_in">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法： <code>print_app_info/get_current_app/move_to_next_app</code> </p>
<p><code>load_app</code>将参数 <code>app_id</code> 对应的应用程序的二进制镜像加载到物理内存以 <code>0x80400000</code> 起始的位置</p>
<p><strong><code>batch</code>子模块暴露的接口</strong></p>
<ul>
<li><code>init</code> ：初始化 <code>APP_MANAGER</code> </li>
<li><code>run_next_app</code> ：加载并运行下一个应用程序</li>
</ul>
<p><strong>用户栈与内核栈</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">// os/src/batch.rs</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"> <span class="number">4</span><span class="keyword">struct</span> KernelStack &#123;</span><br><span class="line"> <span class="number">5</span>  data: [<span class="built_in">u8</span>; KERNEL_STACK_SIZE],</span><br><span class="line"> <span class="number">6</span>&#125;</span><br><span class="line"> <span class="number">7</span></span><br><span class="line"> <span class="number">8</span><span class="meta">#[repr(align(4096))]</span></span><br><span class="line"> <span class="number">9</span><span class="keyword">struct</span> UserStack &#123;</span><br><span class="line"><span class="number">10</span>  data: [<span class="built_in">u8</span>; USER_STACK_SIZE],</span><br><span class="line"><span class="number">11</span>&#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span><span class="keyword">static</span> KERNEL_STACK: KernelStack = KernelStack &#123;</span><br><span class="line"><span class="number">14</span>  data: [<span class="number">0</span>; KERNEL_STACK_SIZE],</span><br><span class="line"><span class="number">15</span>&#125;;</span><br><span class="line"><span class="number">16</span><span class="keyword">static</span> USER_STACK: UserStack = UserStack &#123;</span><br><span class="line"><span class="number">17</span>  data: [<span class="number">0</span>; USER_STACK_SIZE],</span><br><span class="line"><span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>实现了 <code>get_sp</code> 方法来获取栈顶地址</p>
<p><strong>特权级切换</strong></p>
<table>
<thead>
<tr>
<th>CSR 名</th>
<th>该 CSR 与 Trap 相关的功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>sstatus</code></td>
<td><code>SPP</code> 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息</td>
</tr>
<tr>
<td><code>sepc</code></td>
<td>当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址</td>
</tr>
<tr>
<td><code>scause</code></td>
<td>描述 Trap 的原因</td>
</tr>
<tr>
<td><code>stval</code></td>
<td>给出 Trap 附加信息</td>
</tr>
<tr>
<td><code>stvec</code></td>
<td>控制 Trap 处理代码的入口地址</td>
</tr>
</tbody></table>
<p>硬件自动完成：</p>
<ul>
<li><code>sstatus</code> 的 <code>SPP</code> 字段会被修改为 CPU 当前的特权级（U/S）。</li>
<li><code>sepc</code> 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。</li>
<li><code>scause/stval</code> 分别会被修改成这次 Trap 的原因以及相关的附加信息。</li>
<li>CPU 会跳转到 <code>stvec</code> 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。</li>
</ul>
<p>处理完成后通过S特权级<code>sret</code>指令：</p>
<ul>
<li>CPU 会将当前的特权级按照 <code>sstatus</code> 的 <code>SPP</code> 字段设置为 U 或者 S ；</li>
<li>CPU 会跳转到 <code>sepc</code> 寄存器指向的那条指令，然后继续执行。</li>
</ul>
<p><strong><code>Trap</code>上下文</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">// os/src/trap/context.rs</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="number">4</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line"><span class="number">6</span>    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line"><span class="number">7</span>    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line"><span class="number">8</span>&#125; <span class="comment">// 包含所有的通用寄存器 `x0~x31` ，还有 `sstatus` 和 `sepc`</span></span><br><span class="line"><span class="comment">// 从内存栈底分配34个空间保存</span></span><br></pre></td></tr></table></figure>

<p>实现 Trap 上下文保存和恢复的汇编代码<code>os/src/trap/trap.S</code>,用（汇编中的）外部符号 <code>__alltraps</code> 和 <code>__restore</code> 标记为函数</p>
<p>Trap 处理的总体流程如下：首先通过 <code>__alltraps</code> 将 Trap 上下文保存在内核栈上，然后跳转到使用 Rust 编写的 <code>trap_handler</code> 函数 完成 Trap 分发及处理。当 <code>trap_handler</code> 返回之后，使用 <code>__restore</code> 从保存在内核栈上的 Trap 上下文恢复寄存器。最后通过一条 <code>sret</code> 指令回到应用程序执行</p>
<p>使用<code>sp</code>表示当前的栈，<code>sscratch</code>代表另一个栈</p>
<p>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_sp</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="built_in">usize</span>) </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>(entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> </span><br><span class="line">    <span class="comment">// 修改其中的 sepc 寄存器为应用程序入口点 entry， sp 寄存器为我们设定的 一个栈指针，并将 sstatus 寄存器的 SPP 字段设置为 User</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="分时多任务"><a href="#分时多任务" class="headerlink" title="分时多任务"></a>分时多任务</h3><p><code>user/build.py</code>为每个应用定制各自的起始地址，.text 段的地址为 <code>0x80400000 + app_id * 0x20000</code></p>
<p><code>batch</code> 被拆分为 <code>loader</code> 和 <code>task</code> ， 前者负责启动时加载应用程序，后者负责切换和调度。</p>
<p><code>loader</code> 模块的 <code>load_apps</code> 函数负责将所有用户程序在内核初始化的时一并加载进内存</p>
<p><strong>任务切换</strong></p>
<p>当一个应用在内核态时，其 Trap 控制流可以调用一个特殊的 <code>__switch</code> 函数，函数调用时运行另一个任务，返回后运行原来的任务</p>
<p>在 <code>__switch</code> 中保存 CPU 的某些寄存器，它们就是任务上下文</p>
<p>函数拥有两个参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> __switch(</span><br><span class="line">    current_task_cx_ptr: *<span class="keyword">mut</span> TaskContext,</span><br><span class="line">    next_task_cx_ptr: *<span class="keyword">const</span> TaskContext</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>内核先把 <code>current_task_cx_ptr</code> 中包含的寄存器值逐个保存，再把 <code>next_task_cx_ptr</code> 中包含的寄存器值逐个恢复</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">// os/src/task/context.rs</span></span><br><span class="line"><span class="number">2</span><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="number">3</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span></span> &#123;</span><br><span class="line"><span class="number">4</span>    ra: <span class="built_in">usize</span>, <span class="comment">// 任务恢复后执行地址</span></span><br><span class="line"><span class="number">5</span>    sp: <span class="built_in">usize</span>, <span class="comment">// 该任务内核栈地址(当前是内核态)</span></span><br><span class="line"><span class="number">6</span>    s: [<span class="built_in">usize</span>; <span class="number">12</span>], <span class="comment">// 被调用者保存寄存器</span></span><br><span class="line"><span class="number">7</span>&#125; <span class="comment">// TaskContext 里包含的寄存器</span></span><br></pre></td></tr></table></figure>



<p><strong>管理多道程序</strong></p>
<ul>
<li>任务运行状态：未初始化、准备执行、正在执行、已退出</li>
<li>任务控制块：维护任务状态和任务上下文</li>
<li>任务相关系统调用：程序主动暂停 <code>sys_yield</code> 和主动退出 <code>sys_exit</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">TaskStatus</span></span> &#123; <span class="comment">// 任务状态</span></span><br><span class="line">    UnInit, <span class="comment">// 未初始化</span></span><br><span class="line">    Ready, <span class="comment">// 准备运行</span></span><br><span class="line">    Running, <span class="comment">// 正在运行</span></span><br><span class="line">    Exited, <span class="comment">// 已退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123; <span class="comment">// 任务控制块</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 任务状态</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 任务上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局的任务管理器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    num_app: <span class="built_in">usize</span>,</span><br><span class="line">    inner: UPSafeCell&lt;TaskManagerInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskManagerInner</span></span> &#123;</span><br><span class="line">    tasks: [TaskControlBlock; MAX_APP_NUM],</span><br><span class="line">    current_task: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TaskManager</code>方法：<code>mark_current_suspended</code>（暂停当前程序）/  <code>mark_current_exited</code> / <code>run_next_task</code> / <code>find_next_task</code>（找到下一个<code>Ready</code>状态的应用）</p>
<p><strong>时钟中断</strong></p>
<p>处理器维护时钟计数器 <code>mtime</code>，还有另外一个 CSR <code>mtimecmp</code> 。 一旦计数器 <code>mtime</code> 的值超过了 <code>mtimecmp</code>，就会触发一次时钟中断</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_time</span></span>() -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获得mtime值</span></span><br><span class="line">    time::read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_timer</span></span>(timer: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    sbi_call(SBI_SET_TIMER, timer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_next_trigger</span></span>() &#123; <span class="comment">// 设置时钟中断</span></span><br><span class="line">    set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>非叶节点（页目录表，非末级页表）的表项标志位含义和叶节点（页表，末级页表）相比有一些不同：</p>
<ul>
<li>当 <code>V</code> 为 0 的时候，代表当前指针是一个空指针，无法走向下一级节点，即该页表项对应的虚拟地址范围是无效的；</li>
<li>只有当 <code>V</code> 为1 且 <code>R/W/X</code> 均为 0 时，表示是一个合法的页目录表项，其包含的指针会指向下一级的页表；</li>
<li>注意: 当 <code>V</code> 为1 且 <code>R/W/X</code> 不全为 0 时，表示是一个合法的页表项，其包含了虚地址对应的物理页号。</li>
</ul>
<p><strong>物理地址与物理页号转换</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span><span class="keyword">impl</span> PhysAddr &#123;</span><br><span class="line"> <span class="number">4</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">page_offset</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="keyword">self</span>.<span class="number">0</span> &amp; (PAGE_SIZE - <span class="number">1</span>) &#125; <span class="comment">// 从自己的物理地址0x12345000得到偏移为0x000（末三位）</span></span><br><span class="line"> <span class="number">5</span>&#125;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span><span class="keyword">impl</span> <span class="built_in">From</span>&lt;PhysAddr&gt; <span class="keyword">for</span> PhysPageNum &#123;</span><br><span class="line"> <span class="number">8</span>    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(v: PhysAddr) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"> <span class="number">9</span>        <span class="built_in">assert_eq!</span>(v.page_offset(), <span class="number">0</span>);</span><br><span class="line"><span class="number">10</span>        v.floor()</span><br><span class="line"><span class="number">11</span>    &#125; <span class="comment">// 只有偏移为0（即对齐）才能从0x12345000得到物理页号0x12345</span></span><br><span class="line"><span class="number">12</span>&#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span><span class="keyword">impl</span> <span class="built_in">From</span>&lt;PhysPageNum&gt; <span class="keyword">for</span> PhysAddr &#123;</span><br><span class="line"><span class="number">15</span>    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(v: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123; <span class="keyword">Self</span>(v.<span class="number">0</span> &lt;&lt; PAGE_SIZE_BITS) &#125;</span><br><span class="line"><span class="number">16</span>&#125; <span class="comment">// 从物理页号0x12345还原回物理地址0x12345000</span></span><br></pre></td></tr></table></figure>

<p><strong>页表项的数据结构抽象与类型定义</strong></p>
<p>页表项共8个字节：</p>
<ul>
<li>V(0)    仅当 V(Valid) 位为 1 时，页表项才是合法的；</li>
<li>R(1)/W(2)/X(3)    R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；</li>
<li>U(4)    U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li>
<li>G(5)    G 我们不理会；</li>
<li>A(6)    A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li>
<li>D(7)    D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。</li>
<li>RSW(8-9)    </li>
<li>PPN[0] (10-18)    </li>
<li>PPN[1] (19-27)    </li>
<li>PPN[2] (28-53)    </li>
<li>Reserved(54-63)    </li>
</ul>
<p>前八位的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitflags!</span> &#123; <span class="comment">// 用来表示比特位的宏</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTEFlags</span></span>: <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> V = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> R = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> W = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> X = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> U = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">const</span> G = <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">const</span> A = <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">const</span> D = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的实现与方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"> <span class="number">4</span><span class="meta">#[repr(C)]</span></span><br><span class="line"> <span class="number">5</span><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTableEntry</span></span> &#123; <span class="comment">// 一个页表项</span></span><br><span class="line"> <span class="number">6</span>    <span class="keyword">pub</span> bits: <span class="built_in">usize</span>,</span><br><span class="line"> <span class="number">7</span>&#125;</span><br><span class="line"> <span class="number">8</span></span><br><span class="line"> <span class="number">9</span><span class="keyword">impl</span> PageTableEntry &#123;</span><br><span class="line"><span class="number">10</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum, flags: PTEFlags) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="number">11</span>        PageTableEntry &#123;</span><br><span class="line"><span class="number">12</span>            bits: ppn.<span class="number">0</span> &lt;&lt; <span class="number">10</span> | flags.bits <span class="keyword">as</span> <span class="built_in">usize</span>,</span><br><span class="line"><span class="number">13</span>        &#125;</span><br><span class="line"><span class="number">14</span>    &#125;</span><br><span class="line"><span class="number">15</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">empty</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line"><span class="number">16</span>        PageTableEntry &#123;</span><br><span class="line"><span class="number">17</span>            bits: <span class="number">0</span>,</span><br><span class="line"><span class="number">18</span>        &#125;</span><br><span class="line"><span class="number">19</span>    &#125;</span><br><span class="line"><span class="number">20</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ppn</span></span>(&amp;<span class="keyword">self</span>) -&gt; PhysPageNum &#123;</span><br><span class="line"><span class="number">22</span>    &#125;</span><br><span class="line"><span class="number">23</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">flags</span></span>(&amp;<span class="keyword">self</span>) -&gt; PTEFlags &#123;</span><br><span class="line"><span class="number">25</span>    &#125;</span><br><span class="line">     <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">26</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>页帧管理器</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackFrameAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>,</span><br><span class="line">    end: <span class="built_in">usize</span>,</span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;PhysPageNum&gt; <span class="comment">// 分配物理页</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ppn: PhysPageNum) <span class="comment">// 回收物理页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用以调用的接口</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">frame_alloc</span></span>() -&gt; <span class="built_in">Option</span>&lt;FrameTracker&gt;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">frame_dealloc</span></span>(ppn: PhysPageNum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表一个物理页帧</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameTracker</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> ppn: PhysPageNum,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> FrameTracker &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(ppn: PhysPageNum) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">		<span class="comment">// 将这个物理页帧上的所有字节清零</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        frame_dealloc(<span class="keyword">self</span>.ppn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>多级页表</strong></p>
<p>正常情况可以依靠MMU直接翻译，手动翻译是由于操作系统是不能直接靠MMU来访问用户地址程序的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个应用所有的页表</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageTable</span></span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum, <span class="comment">// 某应用的根节点物理页号</span></span><br><span class="line">    frames: <span class="built_in">Vec</span>&lt;FrameTracker&gt;, <span class="comment">// 页表中所有节点（包括根）的物理页帧，不包括叶节点指向的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 新建时只需要分配一个根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表：维护虚拟物理地址的映射</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags);</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问特定物理页帧</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> PhysPageNum &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_pte_array</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [PageTableEntry] &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回的是一个页表项定长数组的可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_bytes_array</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &#125; <span class="comment">//  返回的是一个字节数组的可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取一个恰好放在一个物理页帧开头的类型为 T 的数据的可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立/拆除虚实地址映射</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> VirtPageNum &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">indexes</span></span>(&amp;<span class="keyword">self</span>) -&gt; [<span class="built_in">usize</span>; <span class="number">3</span>] &#123; <span class="comment">// 返回虚拟页号的三级索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fn</span> <span class="title">find_pte_create</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt;  <span class="comment">// 给定虚拟页号，找到/创建页表项及中间层页表</span></span><br><span class="line">&#125; <span class="comment">// 注意，这个只返回最后一级的页表项，所以还要通过map/unmap来判断或创建最后的物理地址</span></span><br></pre></td></tr></table></figure>

<p>只查询，不建立</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> PageTable &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_token</span></span>(satp: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 从satp寄存器中读此时的根页表地址</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_pte</span></span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;&amp;PageTableEntry&gt; &#123;&#125; <span class="comment">// 查找对应的页表是否存在（没有也不新建）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translate</span></span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) -&gt; <span class="built_in">Option</span>&lt;PageTableEntry&gt; &#123;&#125; <span class="comment">// 如果存放就返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户虚拟地址 =&gt; 可写物理内存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_byte_buffer</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>地址空间抽象</strong></p>
<p>逻辑段：虚拟地址连续，虚拟地址映射到物理地址的方式相同（物理页帧具有的属性相同而非物理地址连续）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑段结构体</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapArea</span></span> &#123;</span><br><span class="line">    vpn_range: VPNRange, <span class="comment">// 一段虚拟页号的连续区间，是一个迭代器</span></span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;, <span class="comment">// 绑定生命周期，到期自动回收</span></span><br><span class="line">    map_type: MapType,</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">MapType</span></span> &#123; <span class="comment">// 逻辑段内虚拟页面映射的方式</span></span><br><span class="line">    Identical, <span class="comment">// 恒等映射</span></span><br><span class="line">    Framed, <span class="comment">// 分配物理页帧（随机）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitflags!</span> &#123; <span class="comment">// 该逻辑段的访问方式</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MapPermission</span></span>: <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> R = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> W = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> X = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">const</span> U = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> MapArea &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>( start_va: VirtAddr, end_va: VirtAddr, map_type: MapType, map_perm: MapPermission ) -&gt; <span class="keyword">Self</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map_one</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;&#125;; <span class="comment">// 在确定了虚拟页号之后，先在逻辑的页表管理MapArea里面加入虚拟页号和StackFrameAllocator分配的物理页帧，然后在pagetable里完善各级页表里面的指向路径</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap_one</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;&#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;&#125; <span class="comment">// 把当前结构体中的所有虚拟地址挨个map_one物理地址</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unmap</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;<span class="keyword">mut</span> PageTable) &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">copy_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, page_table: &amp;PageTable, data: &amp;[<span class="built_in">u8</span>]) &#123;&#125; <span class="comment">// 复制data到逻辑段开头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地址空间：一个进程能够访问的所有内存地址的集合，通常被组织为多个逻辑段</p>
<p><code>pagetable</code>    实际上查找虚拟/物理地址映射的方法（存储各级节点，可以手动搜索），供CPU/MMU使用</p>
<p><code>areas</code>    逻辑上管理的方法（管理虚拟内存、映射数组来直接寻找）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个地址空间的结构体</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemorySet</span></span> &#123; <span class="comment">// PageTable 下挂着所有多级页表的节点所在的物理页帧，而每个 MapArea 下则挂着对应逻辑段中的数据所在的物理页帧，这两部分合在一起构成了一个地址空间所需的所有物理页帧（绑定，自动回收）</span></span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: <span class="built_in">Vec</span>&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_bare</span></span>() -&gt; <span class="keyword">Self</span> </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> map_area: MapArea, data: <span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;) <span class="comment">// 插入新的逻辑段，还可以在物理页帧上写入data</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">insert_framed_area</span></span>( &amp;<span class="keyword">mut</span> <span class="keyword">self</span>, start_va: VirtAddr, end_va: VirtAddr, permission: MapPermission )  <span class="comment">// 新建并插入一段Framed方式映射的逻辑段</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_kernel</span></span>() -&gt; <span class="keyword">Self</span>; <span class="comment">// 生成内核的地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_elf</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; (<span class="keyword">Self</span>, <span class="built_in">usize</span>, <span class="built_in">usize</span>); <span class="comment">// 分析应用的ELF文件(并且根据这个文件建立新的地址空间，返回栈顶和执行入口)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">activate</span></span>(&amp;<span class="keyword">self</span>) &#123;&#125; <span class="comment">// 第一次使用会开启分页，并且进入当前地址空间的页表</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map_trampoline</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;&#125; <span class="comment">// 直接插入一个空间地址中最高位置到跳板的键值对（注：所有地址空间中的跳板都是指向trap.S文件）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内核的地址空间排布</strong>    </p>
<p>跳板、各应用的内核栈（栈间有空洞区域防溢出）</p>
<p>四个逻辑段<code>.text/.rodata/.data/.bss</code>（恒等映射）、恒等映射（除之前内核已使用）所有物理页帧的页表 （即是内核页表）（注：后面两项都是恒等映射建立的三级页表<code>MapArea</code>）</p>
<p><strong>应用程序的地址空间排布</strong>    </p>
<p>跳板、<code>trap</code>上下文（用户不可访问）</p>
<p>用户栈、保护页<code>guard page</code>、各逻辑段</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批处理系统升级：加载应用进入内存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_num_app</span></span>() -&gt; <span class="built_in">usize</span> &#123;&#125; <span class="comment">// 获取程序数量</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_app_data</span></span>(app_id: <span class="built_in">usize</span>) -&gt; &amp;<span class="symbol">'static</span> [<span class="built_in">u8</span>] &#123;&#125; <span class="comment">// 获得某个应用的全部数据</span></span><br></pre></td></tr></table></figure>



<p><strong>基于空间地址的分时多任务</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; <span class="comment">// 内核地址全局实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrapContext</span></span> &#123; <span class="comment">// trap上下文</span></span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="built_in">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="comment">// 以下为新增字段，在初始化时写入，便于保存完成寄存器后切换</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="built_in">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="built_in">usize</span>, <span class="comment">// 本来sp指向用户栈，sscratch指向内核栈，交换后在内核栈中保存上下文；但现在由于要更新页表寄存器不够，sscratch指向用户空间中trap上下文处保存，然后根据保存的内存栈顶直接更改sp</span></span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="number">3</span><span class="keyword">impl</span> TrapContext &#123;</span><br><span class="line"> <span class="number">4</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_sp</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="built_in">usize</span>) &#123; &#125;</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">app_init_context</span></span>( entry: <span class="built_in">usize</span>, sp: <span class="built_in">usize</span>, kernel_satp: <span class="built_in">usize</span>, kernel_sp: <span class="built_in">usize</span>, trap_handler: <span class="built_in">usize</span> ) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 从任务上下文中初始化trap上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>跳板就是执行<code>trap</code>时保存上下文的汇编代码<code>_alltraps</code>和<code>_restore</code>，由于其在内核与应用地址空间的位置相同，所以无论哪种页表都可以在同一位置访问</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务上下文</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet, <span class="comment">// 应用地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用trap上下文的实际物理页帧</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>, <span class="comment">// 应用地址空间大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>], app_id: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_trap_cx</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> TrapContext &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局应用管理器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskManagerInner</span></span> &#123;</span><br><span class="line">    tasks: <span class="built_in">Vec</span>&lt;TaskControlBlock&gt;,</span><br><span class="line">    current_task: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: TaskManager = &#123;&#125;; <span class="comment">// 初始化时根据loader提供的app数量和ELF文件来初始化所有任务上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>新增系统调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 功能：当前进程 fork 出来一个子进程。</span></span><br><span class="line"><span class="comment">/// 返回值：对于子进程返回 0，对于当前进程则返回子进程的 PID 。</span></span><br><span class="line"><span class="comment">/// syscall ID：220</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：当前进程等待一个子进程变为僵尸进程，回收其全部资源并收集其返回值。</span></span><br><span class="line"><span class="comment">/// 参数：pid 表示要等待的子进程的进程 ID，如果为 -1 的话表示等待任意一个子进程；</span></span><br><span class="line"><span class="comment">/// exit_code 表示保存子进程返回值的地址，如果这个地址为 0 的话表示不必保存。</span></span><br><span class="line"><span class="comment">/// 返回值：如果要等待的子进程不存在则返回 -1；否则如果要等待的子进程均未结束则返回 -2；</span></span><br><span class="line"><span class="comment">/// 否则返回结束的子进程的进程 ID。</span></span><br><span class="line"><span class="comment">/// syscall ID：260</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waitpid</span></span>(pid: <span class="built_in">isize</span>, exit_code: *<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：将当前进程的地址空间清空并加载一个特定的可执行文件，返回用户态后开始它的执行。</span></span><br><span class="line"><span class="comment">/// 参数：path 给出了要加载的可执行文件的名字；</span></span><br><span class="line"><span class="comment">/// 返回值：如果出错的话（如找不到名字相符的可执行文件）则返回 -1，否则不应该返回。</span></span><br><span class="line"><span class="comment">/// syscall ID：221</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：从文件中读取一段内容到缓冲区。</span></span><br><span class="line"><span class="comment">/// 参数：fd 是待读取文件的文件描述符，切片 buffer 则给出缓冲区。</span></span><br><span class="line"><span class="comment">/// 返回值：如果出现了错误则返回 -1，否则返回实际读到的字节数。</span></span><br><span class="line"><span class="comment">/// syscall ID：63</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buffer: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; <span class="built_in">isize</span>;</span><br></pre></td></tr></table></figure>

<p>在用户级中，在最最开始（即在<code>main</code>函数中）会初始化一个<code>initproc</code>用户初始进程，</p>
<p>其只会初始化一个<code>shell</code>进程，之后就持续循环+时间片轮转来回收进程（注：所有父进程被回收的进程都会变成其子进程）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于应用名的应用加载器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ref</span> APP_NAMES: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_app_data_by_name</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="symbol">'static</span> [<span class="built_in">u8</span>]&gt; <span class="comment">// 根据名字查找ELF数据</span></span><br></pre></td></tr></table></figure>



<p>进程标识符</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程标识符PID</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PidHandle</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> PidHandle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; <span class="comment">// 自动回收</span></span><br><span class="line">        PID_ALLOCATOR.exclusive_access().dealloc(<span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程分配器，类似于FrameAllocator</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PidAllocator</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">usize</span>, <span class="comment">// 当前已分配到多少</span></span><br><span class="line">    recycled: <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PidAllocator &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// current为0，数组为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; PidHandle &#123; <span class="comment">// 分配一个新的PIDHandle(其他啥也没有)，优先从回收中选取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, pid: <span class="built_in">usize</span>) &#123; <span class="comment">// 在PID已分配、未回收的情况下丢进回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ref</span> PID_ALLOCATOR : UPSafeCell&lt;PidAllocator&gt; <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure>



<p>内核栈</p>
<p>原本每个程序一个，固定大小按程序顺序排列，中间穿插守护页防止溢出</p>
<p>现在将应用编号替换为进程标识符<code>PTD</code>，在内核栈中保存</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">KernelStack</span></span> &#123;</span><br><span class="line">    pid: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> KernelStack &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(pid_handle: &amp;PidHandle) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 为一个已分配的进程标识符生成内核栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_on_top</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, value: T) -&gt; *<span class="keyword">mut</span> T <span class="keyword">where</span></span><br><span class="line">        T: <span class="built_in">Sized</span>, &#123; <span class="comment">// 将一个类型为 T 的变量压入内核栈顶并返回其裸指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_top</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获取当前内核栈顶在内核地址空间中的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> KernelStack &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_stack_position</span></span>(app_id: <span class="built_in">usize</span>) -&gt; (<span class="built_in">usize</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line"> <span class="comment">// 得到pid进程内核栈的起始/终止虚拟地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>进程控制块</strong></p>
<p>之前的<code>TaskControlBlock</code>分离为</p>
<p><code>Processor</code>处理器管理结构：管理CPU正在运行的任务</p>
<p><code>TaskManager</code>任务管理器：管理未在运行的所有任务</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123; <span class="comment">// 不可变</span></span><br><span class="line">    <span class="comment">// 不可变</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    <span class="keyword">pub</span> kernel_stack: KernelStack,</span><br><span class="line">    <span class="comment">// 可变</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">inner_exclusive_access</span></span>(&amp;<span class="keyword">self</span>) -&gt; RefMut&lt;<span class="symbol">'_</span>, TaskControlBlockInner&gt; &#123; <span class="comment">// 内层 TaskControlBlockInner 的可变引用</span></span><br><span class="line">        <span class="keyword">self</span>.inner.exclusive_access() </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">getpid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pid.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;...&#125; <span class="comment">// 仅用于内核中手动创建唯一一个初始进程 initproc</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;...&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;TaskControlBlock&gt;) -&gt; Arc&lt;TaskControlBlock&gt; &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用地址空间中的 Trap 上下文被放在的物理页帧的物理页号</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="built_in">usize</span>, <span class="comment">// 应用数据仅有可能出现在应用地址空间低于 base_size 字节的区域中</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 暂停的任务的任务上下文</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 当前进程的执行状态</span></span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet, <span class="comment">// 应用地址空间</span></span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="built_in">Option</span>&lt;Weak&lt;TaskControlBlock&gt;&gt;, <span class="comment">// Arc的非拥有引用，可访问但不拥有</span></span><br><span class="line">    <span class="keyword">pub</span> children: <span class="built_in">Vec</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 多个Arc拥有一个不可变值，计数为0时才释放</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlockInner &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_trap_cx</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">        <span class="keyword">self</span>.trap_cx_ppn.get_mut()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_user_token</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.memory_set.token()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_status</span></span>(&amp;<span class="keyword">self</span>) -&gt; TaskStatus &#123;</span><br><span class="line">        <span class="keyword">self</span>.task_status</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_zombie</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.get_status() == TaskStatus::Zombie</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务管理器与处理器管理器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务管理器</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskManager</span></span> &#123;</span><br><span class="line">    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 双端队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 新建一个空任务表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;) &#123; <span class="comment">// 在末尾新增一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123; <span class="comment">// 从开头拿取一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器管理结构</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Processor</span></span> &#123;</span><br><span class="line">    current: <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line">    idle_task_cx: TaskContext, <span class="comment">// 当前处理器上的 idle 控制流的任务上下文（调度器上下文）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Processor &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 初始化为None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_current</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 取出当前正在执行的任务</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">current</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回当前执行的任务的一份拷贝，可以用于获得token/trap_cx等等</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_idle_task_cx_ptr</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; *<span class="keyword">mut</span> TaskContext &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取当前处理器上的 idle 控制流的任务上下文指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> PROCESSOR: UPSafeCell&lt;Processor&gt; <span class="comment">// 单核只创建一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程转换</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run_tasks</span></span>() &#123; <span class="comment">// 负责在taskManager中获取要执行的任务并执行</span></span><br><span class="line">&#125; <span class="comment">// 持续循环，只要进程让出CPU回到调度器中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">schedule</span></span>(switched_task_cx_ptr: *<span class="keyword">mut</span> TaskContext) &#123;</span><br><span class="line">&#125; <span class="comment">// 在进程交出控制权后，用于回到run_tasks()执行循环中的函数</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>将<code>Processer</code>的任务上下文分离并且单独存储，是为了把调度和存储分离开，并无其他意义</li>
<li><code>Processer</code>由内核中的结构体和上下文组成，相当于一个没有进程控制块的进程来用于调度</li>
</ul>
<p><strong>进程机制实现</strong></p>
<ul>
<li>创建初始进程：创建第一个用户态进程 <code>initproc</code>；</li>
<li>进程调度机制：当进程主动调用 <code>sys_yield</code> 交出 CPU 使用权或者内核把本轮分配的时间片用尽的进程换出且换入下一个进程；</li>
<li>进程生成机制：进程相关的两个重要系统调用 <code>sys_fork/sys_exec</code> 的实现；</li>
<li>进程资源回收机制：当进程调用 <code>sys_exit</code> 正常退出或者出错被内核终止之后如何保存其退出码，其父进程通过 <code>sys_waitpid</code> 系统调用收集该进程的信息并回收其资源。</li>
<li>字符输入机制：为了支持shell程序-user_shell获得字符输入，介绍 <code>sys_read</code> 系统调用的实现；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建初始进程</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> INITPROC: Arc&lt;TaskControlBlock&gt; <span class="comment">// 懒加载全局的initproc进程控制块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_initproc</span></span>() &#123; <span class="comment">// 在taskManager中加入initproc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程调度机制</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">suspend_current_and_run_next</span></span>() &#123;</span><br><span class="line">&#125; <span class="comment">// Process::取出当前执行的任务，修改状态为Ready后放入taskmanager末尾；然后schedule触发调度并切换任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程生成机制</span></span><br><span class="line"><span class="keyword">impl</span> MapArea &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_another</span></span>(another: &amp;MapArea) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 创建一模一样的结构体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> MemorySet &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_existed_user</span></span>(user_space: &amp;MemorySet) -&gt; MemorySet &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建一模一样的结构体，并且物理地址按页复制数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(<span class="keyword">self</span>: &amp;Arc&lt;TaskControlBlock&gt;) -&gt; Arc&lt;TaskControlBlock&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 与new类似，不过不是从ELF中获取信息而是从memory_set复制后获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_fork</span></span>() -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 完全复制任务控制块，但是物理页帧不能直接复制，而且新的线程trap_cx中的a[0]（返回值寄存器）要改成0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>]) &#123;</span><br><span class="line">    &#125; <span class="comment">// 从一个ELF文件中获得Memory全部当前memory_set，然后更改控制块中信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_str</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 传递给调用的只有要执行的应用的名称字符串的起始地址，要以此在内存中查询得到整个字符串</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程退出机制</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exit</span></span>(exit_code: <span class="built_in">i32</span>) -&gt; ! &#123;</span><br><span class="line">&#125; <span class="comment">// 调用exit_current_and_run_next()</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exit_current_and_run_next</span></span>(exit_code: <span class="built_in">i32</span>) &#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waitpid</span></span>(pid: <span class="built_in">isize</span>, exit_code_ptr: *<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 等待某个子进程退出，返回它的 pid，并把它的退出码写到指定地址</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(exit_code: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 调用sys_waitpid，成功则返回退出码；失败（返回-2）则yield继续等待</span></span><br></pre></td></tr></table></figure>

<p>在执行<code>exit_current_and_run_next(exit_code: i32)</code>时</p>
<ul>
<li>修改当前进程控制块的状态为<code>TaskStatus::Zombie</code> 即僵尸进程</li>
<li>将退出码传入控制块等待父进程收集</li>
<li>将所有子进程挂载在<code>initproc</code>下面</li>
<li>对当前进程早期回收（回收<code>Memory_set</code>中的<code>areas</code>即数据页，不回收<code>pagetable</code>即页表页）</li>
</ul>
<p><strong>user_shell读入机制</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 仅支持从标准输入 FD_STDIN 即文件描述符 0 读入，且单次读入的长度限制为 1</span></span><br></pre></td></tr></table></figure>







<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><strong>文件与文件描述符</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件接口：只要实现了这个接口，就是文件</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">File</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户缓冲区：用户进程在系统调用的时候传给内核的地址空间（以内核为中转，用户缓冲区 &lt;=&gt; 文件）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">translated_byte_buffer</span></span>(token: <span class="built_in">usize</span>, ptr: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">UserBuffer</span></span> &#123; <span class="comment">// 将t_b_b中的切片进一步包装，即几页数据的数组</span></span><br><span class="line">    <span class="keyword">pub</span> buffers: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> UserBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(buffers: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">'static</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>]&gt;) -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 传入数据来新建缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">len</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// 获得总字节数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准输入/输出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stdin</span></span>;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Stdin &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区只能为一个字节大小，循环读取标准输入中的char，读取到则跳出循环写入缓冲区，未读取到则挂起继续循环，返回1 </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, _user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123; </span><br><span class="line">    &#125; <span class="comment">// 直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stdout</span></span>;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Stdout &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, _user_buf: UserBuffer) -&gt; <span class="built_in">usize</span>&#123;</span><br><span class="line">    &#125; <span class="comment">// 直接panic</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, user_buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区无大小限制，读出数据并print!,返回缓冲区字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件描述符：（文件描述符首先是一个非负整数）对于某一个进程，代表了其打开的一个文件对象，在要对文件进行操作时传入该整数即可（由内核来分配和记录，因为所有文件都在内核中）</p>
<p>文件描述符表：每个进程都有，记录所有其打开且可读写的文件集合（可以以表的下标作为描述符）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">	……</span><br><span class="line">    <span class="keyword">pub</span> fd_table: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> File + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(elf_data: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 建立新的TCB时要创建三个fd_table: </span></span><br><span class="line">    <span class="comment">// vec！[Some(Arc::new(Stdin)),Some(Arc::new(Stdout)),Some(Arc::new(Stdout))] 0，1，2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的数据结构：</p>
<ul>
<li><p><code>Vec</code> 无需设置一个固定的文件描述符数量上限；</p>
</li>
<li><p><code>Option</code> 区分一个文件描述符当前是否空闲：当它是 <code>None</code> 的时候是空闲的，而 <code>Some</code> 则代表它已被占用；</p>
</li>
<li><p><code>Arc</code> 提供了共享引用能力：可能会有多个进程共享同一个文件对它进行读写；</p>
<pre><code>被它包裹的内容会被放到内核堆而不是栈上，不需要在编译期有确定的大小</code></pre></li>
<li><p><code>dyn</code> 关键字表明 <code>Arc</code> 里面的类型实现了 <code>File/Send/Sync</code> 三个 Trait ，</p>
<pre><code>编译期无法知道它具体是哪个类型需要等到运行时才能知道它的具体类型。</code></pre></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_write</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_read</span></span>(fd: <span class="built_in">usize</span>, buf: *<span class="keyword">const</span> <span class="built_in">u8</span>, len: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁使用write/read访问当前进程符表中标识符（下标）为fd的文件，返回值为w/r的返回值</span></span><br></pre></td></tr></table></figure>



<p><strong>文件系统接口</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开/读写的系统调用</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sys_openat</span></span>(dirfd: <span class="built_in">usize</span>, path: &amp;<span class="built_in">str</span>, flags: <span class="built_in">u32</span>, mode: <span class="built_in">u32</span>) -&gt; <span class="built_in">isize</span> </span><br><span class="line"><span class="comment">// 打开文件并返回描述符，否则返回-1；dirfd/mode无视；path为文件名；flags描述打开文件的标志</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpenFlags</span></span>: <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> RDONLY = <span class="number">0</span>; <span class="comment">// 只读</span></span><br><span class="line">        <span class="keyword">const</span> WRONLY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 只写</span></span><br><span class="line">        <span class="keyword">const</span> RDWR = <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// 可读写</span></span><br><span class="line">        <span class="keyword">const</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>; <span class="comment">// 在找不到时允许创建</span></span><br><span class="line">        <span class="keyword">const</span> TRUNC = <span class="number">1</span> &lt;&lt; <span class="number">10</span>; <span class="comment">// 打开时清空文件并将大小归零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>简易文件系统</strong></p>
<ul>
<li><code>easy-fs</code> 是简易文件系统的本体</li>
<li><code>easy-fs-fuse</code> 是能在开发环境（如 Ubuntu）中运行的应用程序，用于将应用打包为 easy-fs 格式的文件系统镜像，也可以用来对 <code>easy-fs</code> 进行测试</li>
</ul>
<p>文件系统层次化（共分为五层，上层可以调用下层的接口）：</p>
<p>1、磁盘块设备接口层：以块为单位对磁盘块设备进行读写的 trait 接口</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">BlockDevice</span></span> : <span class="built_in">Send</span> + <span class="built_in">Sync</span> + Any &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]); <span class="comment">// 将编号为 block_id 的块从磁盘读入内存中的缓冲区 buf</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_block</span></span>(&amp;<span class="keyword">self</span>, block_id: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]); <span class="comment">// 将内存中的缓冲区 buf 中的数据写入磁盘编号为 block_id 的块</span></span><br><span class="line">&#125; <span class="comment">// 以实现了该特征的结构体为磁盘外设的模拟，在实现该特征时写入真正对硬件的操作</span></span><br></pre></td></tr></table></figure>

<p>2、块缓存层：在内存中缓存磁盘块的数据，避免频繁读写磁盘</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块缓存</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> BLOCK_SZ: <span class="built_in">usize</span> = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCache</span></span> &#123;</span><br><span class="line">    cache: [<span class="built_in">u8</span>; BLOCK_SZ], <span class="comment">// 512字节数组，内存中的缓冲区</span></span><br><span class="line">    block_id: <span class="built_in">usize</span>, <span class="comment">// 这个块的编号</span></span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;, <span class="comment">// 块所属的底层设备</span></span><br><span class="line">    modified: <span class="built_in">bool</span>, <span class="comment">// 从磁盘进入内存后是否被修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(block_id: <span class="built_in">usize</span>, block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 新建时从某个磁盘中读入一个块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCache &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">addr_of_offset</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获得cache中偏移量offset的地址</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_ref</span></span>&lt;T&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; &amp;T <span class="keyword">where</span> T: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取缓冲区中偏移量为offset的一个T类型值的不可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut</span></span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset: <span class="built_in">usize</span>) -&gt; &amp;<span class="keyword">mut</span> T <span class="keyword">where</span> T: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取可变引用</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>&lt;T, V&gt;(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;T) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125; <span class="comment">// 把闭包函数传入这个函数，在这个函数里面调用闭包直接返回其返回值，unsafe的T指针就不会给出去</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">modify</span></span>&lt;T, V&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, offset:<span class="built_in">usize</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> T) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 缓冲区被回收，由modified决定是否写回磁盘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块缓存全局管理器：一个磁盘拥有一个</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockCacheManager</span></span> &#123;</span><br><span class="line">    queue: VecDeque&lt;(<span class="built_in">usize</span>, Arc&lt;Mutex&lt;BlockCache&gt;&gt;)&gt;, <span class="comment">// 共享引用&amp;互斥访问 磁盘块编号&amp;块缓存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> BlockCacheManager &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_cache</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,block_id: <span class="built_in">usize</span>,block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,) -&gt; Arc&lt;Mutex&lt;BlockCache&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果这里存储了block_id的块则返回其副本，没找到且队列未满则新建并插入返回，已满则丢出去未被使用（引用计数为1）的第一个块然后插入返回，否则panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、磁盘数据结构层：磁盘上的超级块、位图、索引节点、数据块、目录项等核心数据结构和相关处理</p>
<p>easy-fs 磁盘按照块编号从小到大顺序分成 5 个连续区域：</p>
<ul>
<li>第一个区域只包括一个块，它是超级块，用于定位其他连续区域的位置，检查文件系统合法性</li>
<li>第二个区域是一个索引节点位图，长度为若干个块：记录索引节点区域中有哪些索引节点已经被分配出去使用了(每个<code>bit</code>表示一个节点)</li>
<li>第三个区域是索引节点区域，长度为若干个块，其中的每个块都存储了若干个索引节点（每个节点描述一个“文件”/“目录”）</li>
<li>第四个区域是一个数据块位图，长度为若干个块：记录后面的数据块区域中有哪些已经被分配出去使用</li>
<li>最后的区域则是数据块区域：每个被分配出去的块保存了文件或目录的具体内容</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个区域：超级块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span></span> &#123;</span><br><span class="line">    magic: <span class="built_in">u32</span>, <span class="comment">// 魔数：验证有效性</span></span><br><span class="line">    <span class="keyword">pub</span> total_blocks: <span class="built_in">u32</span>, <span class="comment">// 文件系统总块数</span></span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap_blocks: <span class="built_in">u32</span>, <span class="comment">// 索引节点位图块数</span></span><br><span class="line">    <span class="keyword">pub</span> inode_area_blocks: <span class="built_in">u32</span>, <span class="comment">// 索引节点区域块数</span></span><br><span class="line">    <span class="keyword">pub</span> data_bitmap_blocks: <span class="built_in">u32</span>, <span class="comment">// 数据块位图区域块数</span></span><br><span class="line">    <span class="keyword">pub</span> data_area_blocks: <span class="built_in">u32</span>, <span class="comment">// 数据库区域块数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> SuperBlock &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">initialize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, total_blocks: <span class="built_in">u32</span>, inode_bitmap_blocks: <span class="built_in">u32</span>, inode_area_blocks: <span class="built_in">u32</span>, data_bitmap_blocks: <span class="built_in">u32</span>, data_area_blocks: <span class="built_in">u32</span> ); <span class="comment">// 更上层初始化</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_valid</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="comment">// 根据魔数判断合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二/四个区域：位图-索引节点 / 位图-数据块</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bitmap</span></span> &#123; <span class="comment">// 位图区域管理器：区域起始编号+块数</span></span><br><span class="line">    start_block_id: <span class="built_in">usize</span>,</span><br><span class="line">    blocks: <span class="built_in">usize</span>,</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BitmapBlock</span></span> = [<span class="built_in">u64</span>; <span class="number">64</span>]; <span class="comment">// 一个块数据（划分方便操作）</span></span><br><span class="line"><span class="keyword">const</span> BLOCK_BITS: <span class="built_in">usize</span> = BLOCK_SZ * <span class="number">8</span>; <span class="comment">// 一个块中有多少个bit</span></span><br><span class="line"><span class="keyword">impl</span> Bitmap &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 遍历Bitmap中每个块，再遍历这个块中的每一个[u64]找到第一个为 0 的位置，该位置置1，返回该位的位置（在位图中的第n个比特位），以此作为分配的索引节点/数据块的编号；否则返回None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个区域：索引节点（包含文件/目录的元数据，以下仅写“文件”）</span></span><br><span class="line"><span class="keyword">const</span> INODE_DIRECT_COUNT: <span class="built_in">usize</span> = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DiskInode</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="built_in">u32</span>, <span class="comment">// 文件内容的字节数</span></span><br><span class="line">    <span class="keyword">pub</span> direct: [<span class="built_in">u32</span>; INODE_DIRECT_COUNT], <span class="comment">// 直接索引，数据块里是文件数据</span></span><br><span class="line">    <span class="keyword">pub</span> indirect1: <span class="built_in">u32</span>, <span class="comment">// 一级间接索引，该块上每一个u32指向一个文件数据块</span></span><br><span class="line">    <span class="keyword">pub</span> indirect2: <span class="built_in">u32</span>, <span class="comment">// 二级间接索引，该块上每一个指向一个一级间接索引</span></span><br><span class="line">    type_: DiskInodeType, <span class="comment">// 索引节点类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DiskInodeType</span></span> &#123;</span><br><span class="line">    File,</span><br><span class="line">    Directory,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> DiskInode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">initialize</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, type_: DiskInodeType) &#123;</span><br><span class="line">    &#125; <span class="comment">// 一 / 二级索引全部置为0</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_dir</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_file</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="comment">// 确定文件类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_block_id</span></span>(&amp;<span class="keyword">self</span>, inner_id: <span class="built_in">u32</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 获得索引中的第inner_id数据块的block_id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">data_blocks</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 返回文件内容字节数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">_data_blocks</span></span>(size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 容纳size个字节需要多少数据块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">total_blocks</span></span>(size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; <span class="comment">// 返回文件块+索引块数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">blocks_num_needed</span></span>(&amp;<span class="keyword">self</span>, new_size: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 扩容到new_size个字节需要新增多少数据块</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">increase_size</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_size: <span class="built_in">u32</span>, new_blocks: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;);</span><br><span class="line">    <span class="comment">// 扩容函数，size为扩容后大小，blocks为扩容所需块编号（由上层分配）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clear_size</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;; <span class="comment">//清空文件并且回收数据块</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>], block_device: &amp;Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="built_in">usize</span> &#123; </span><br><span class="line">    &#125; <span class="comment">// 将文件内容从 offset 字节开始的部分读到内存中的缓冲区 buf 中，返回读到字节数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_at</span></span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目录项结构（文件项无结构）</span></span><br><span class="line"><span class="keyword">const</span> NAME_LENGTH_LIMIT: <span class="built_in">usize</span> = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DirEntry</span></span> &#123; <span class="comment">// 该结构保存在数据块中</span></span><br><span class="line">    name: [<span class="built_in">u8</span>; NAME_LENGTH_LIMIT + <span class="number">1</span>], <span class="comment">// 这一级目录/这个文件的名字</span></span><br><span class="line">    inode_number: <span class="built_in">u32</span>, <span class="comment">// 这一级目录/这个文件的索引序号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> DIRENT_SZ: <span class="built_in">usize</span> = <span class="number">32</span>; <span class="comment">// 每个数据块可以存储16个</span></span><br><span class="line"><span class="keyword">impl</span> DirEntry &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">empty</span></span>() -&gt; <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="built_in">str</span>, inode_number: <span class="built_in">u32</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">name</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">inode_number</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_bytes</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;[<span class="built_in">u8</span>] &#123; <span class="comment">// 为了符合read/write_at接口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_bytes_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>] &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、磁盘块管理器层：合并了上述核心数据结构和磁盘布局所形成的磁盘文件系统数据结构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个文件系统对应一个磁盘（分区）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EasyFileSystem</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">    <span class="keyword">pub</span> inode_bitmap: Bitmap, <span class="comment">// 索引节点位图</span></span><br><span class="line">    <span class="keyword">pub</span> data_bitmap: Bitmap, <span class="comment">// 数据块位图</span></span><br><span class="line">    inode_area_start_block: <span class="built_in">u32</span>, <span class="comment">// 索引区域起始块编号</span></span><br><span class="line">    data_area_start_block: <span class="built_in">u32</span>, <span class="comment">// 数据块区域起始块编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;, total_blocks: <span class="built_in">u32</span>, inode_bitmap_blocks: <span class="built_in">u32</span>,) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 传入 总共的块数量/索引位图的块数量 规划好整个磁盘，创建新文件系统并清理内存</span></span><br><span class="line">      <span class="comment">// 同时初始化内存中的超级块、创建根目录</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open</span></span>(block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 从一个写入了easy-fs镜像（即按照该格式排布的数据块集合）的块设备block_device上打开文件系统</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_disk_inode_pos</span></span>(&amp;<span class="keyword">self</span>, inode_id: <span class="built_in">u32</span>) -&gt; (<span class="built_in">u32</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 根据索引的编号，返回它所在磁盘块编号block_id和块内偏移</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_data_block_id</span></span>(&amp;<span class="keyword">self</span>, data_block_id: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 得到某数据块的磁盘块编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_inode</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 分配一个索引返回其编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 分配一个数据块返回其磁盘块编号</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dealloc_data</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, block_id: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：只要知道了数据所在的具体磁盘块号和块内偏移，可以以任意结构体方式操作这一段数据<code>get_block_cache(block_id, device).lock().modify(offset, |变量名: &amp;mut 结构体| {})</code></p>
<p>5、索引节点层：管理索引节点，实现了文件创建/文件打开/文件读写等成员函数</p>
<p>便于直接看到目录树结构中逻辑上的文件和目录</p>
<ul>
<li><code>DiskInode</code> 放在磁盘块中比较固定的位置</li>
<li><code>Inode</code> 是放在内存中的记录文件索引节点信息的数据结构</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    block_id: <span class="built_in">usize</span>,</span><br><span class="line">    block_offset: <span class="built_in">usize</span>, <span class="comment">// 前两个用于记录具体位置</span></span><br><span class="line">    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;, <span class="comment">// 便于操作传参</span></span><br><span class="line">    block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化 get_block_cache.lock.read/modify 流程</span></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;DiskInode) -&gt; V) -&gt; V &#123;</span><br><span class="line">    &#125; <span class="comment">// 读取数据并且用闭包f处理</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">modify_disk_inode</span></span>&lt;V&gt;(&amp;<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> DiskInode) -&gt; V) -&gt; V &#123; <span class="comment">// 读取可修改数据并且用闭包f处理（都是更改索引节点 DiskInode 的值）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EasyFileSystem &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">root_inode</span></span>(efs: &amp;Arc&lt;Mutex&lt;<span class="keyword">Self</span>&gt;&gt;) -&gt; Inode &#123;</span><br><span class="line">    &#125; <span class="comment">// 获取根目录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Inode &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(block_id: <span class="built_in">u32</span>, block_offset: <span class="built_in">usize</span>, fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;, block_device: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt;) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建</span></span><br><span class="line">    <span class="comment">// 文件索引（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">find</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回本索引指向的目录下名称为name的文件的索引的新建Inode</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find_inode_id</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>, disk_inode: &amp;DiskInode) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; &#123; <span class="comment">// 找到传入的索引节点指向的目录下名称为name的文件的索引序号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件列举（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ls</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回该目录下所有文件的文件名的数组</span></span><br><span class="line">    <span class="comment">// 文件创建（仅根目录调用）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create</span></span>(&amp;<span class="keyword">self</span>, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;Inode&gt;&gt; &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建新的文件并返回其Inode，若存在则返回None</span></span><br><span class="line">    <span class="comment">// 文件清空</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clear</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 以某些方式打开时需要先传入文件Inode清空</span></span><br><span class="line">    <span class="comment">// 文件读写</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 从offset偏移处开始读</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_at</span></span>(&amp;<span class="keyword">self</span>, offset: <span class="built_in">usize</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 注意：在写之前需要先扩容为offset+buf.len()容量</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">increase_size</span></span>(&amp;<span class="keyword">self</span>, new_size: <span class="built_in">u32</span>, disk_inode: &amp;<span class="keyword">mut</span> DiskInode, fs: &amp;<span class="keyword">mut</span> MutexGuard&lt;EasyFileSystem&gt;) &#123;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内核中的easy-fs</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内核块设备实例</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">BlockDeviceImpl</span></span> = virtio_blk::VirtIOBlock; <span class="comment">// 一个实现了BlockDevice类特征的结构体</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> BLOCK_DEVICE: Arc&lt;<span class="keyword">dyn</span> BlockDevice&gt; = Arc::new(BlockDeviceImpl::new());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核索引节点层</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInode</span></span> &#123; <span class="comment">// 表示进程中一个被打开的常规文件或目录</span></span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    inner: UPSafeCell&lt;OSInodeInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OSInodeInner</span></span> &#123;</span><br><span class="line">    offset: <span class="built_in">usize</span>, <span class="comment">// 读写过程中的偏移量</span></span><br><span class="line">    inode: Arc&lt;Inode&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> OSInode &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="keyword">self</span>.readable &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">writable</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123; <span class="keyword">self</span>.writable &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 直接使用inode的read/write_at</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核文件系统实现</span></span><br><span class="line"><span class="comment">// 文件系统初始化</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> ROOT_INODE: Arc&lt;Inode&gt; = &#123;</span><br><span class="line">    &#125;; <span class="comment">// 打开efs并且获取根目录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpenFlags</span></span>: <span class="built_in">u32</span> &#123; <span class="comment">// 打开文件的方式</span></span><br><span class="line">        <span class="keyword">const</span> RDONLY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> WRONLY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> RDWR = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> CREATE = <span class="number">1</span> &lt;&lt; <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">const</span> TRUNC = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> OpenFlags &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_write</span></span>(&amp;<span class="keyword">self</span>) -&gt; (<span class="built_in">bool</span>, <span class="built_in">bool</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 返回（可读，可写）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open_file</span></span>(name: &amp;<span class="built_in">str</span>, flags: OpenFlags) -&gt; <span class="built_in">Option</span>&lt;Arc&lt;OSInode&gt;&gt; &#123;</span><br><span class="line">&#125; <span class="comment">// 根据flags的要求打开文件并且返回inode</span></span><br></pre></td></tr></table></figure>



<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><strong>管道</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用：为当前进程打开一个管道（包含一个只读、一个只写文件）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_pipe</span></span>(pipe: *<span class="keyword">mut</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>;<span class="comment">// pipe:应用地址空间中一个长度为2的usize数组的起始地址，内核负责讲管道读端、写端的文件描述符写入</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_close</span></span>(fd: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>; <span class="comment">// 关闭一个文件</span></span><br></pre></td></tr></table></figure>

<p>基于文件的管道</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道的一端（读/写）：会实现File特征，作为文件访问</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span></span> &#123;</span><br><span class="line">    readable: <span class="built_in">bool</span>,</span><br><span class="line">    writable: <span class="built_in">bool</span>,</span><br><span class="line">    buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Pipe &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_end_with_buffer</span></span>(buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;) -&gt; <span class="keyword">Self</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_end_with_buffer</span></span>(buffer: Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;) -&gt; <span class="keyword">Self</span> &#123;&#125; <span class="comment">// 根据一个已有的管道创建其读端和写端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> File <span class="keyword">for</span> Pipe &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">self</span>, buf: UserBuffer) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 从文件中最多读取应用缓冲区大小那么多字符：如果文件中没有字符且没有写端则返回，否则任务挂起</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RingBufferStatus</span></span> &#123; FULL, EMPTY, NORMAL &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">PipeRingBuffer</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">u8</span>; RING_BUFFER_SIZE],</span><br><span class="line">    head: <span class="built_in">usize</span>,</span><br><span class="line">    tail: <span class="built_in">usize</span>, <span class="comment">// 维护循环队列</span></span><br><span class="line">    status: RingBufferStatus, <span class="comment">// 缓冲区状态</span></span><br><span class="line">    write_end: <span class="built_in">Option</span>&lt;Weak&lt;Pipe&gt;&gt;, <span class="comment">// 写端的弱引用计数，来确认是否还有写端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> PipeRingBuffer &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123; <span class="comment">// 全部置为0，写端置为None</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_write_end</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, write_end: &amp;Arc&lt;Pipe&gt;) &#123; </span><br><span class="line">    &#125; <span class="comment">// 保留其写端的弱引用计数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_byte</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 读取管道中的一个字节，并且更新队头（如果与队尾重合则改为empty）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">available_read</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 计算管道中还有多少个字节可以读取</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">all_write_ends_closed</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 判断管道的所有写端是不是都被关闭了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">make_pipe</span></span>() -&gt; (Arc&lt;Pipe&gt;, Arc&lt;Pipe&gt;) &#123; <span class="comment">// 创建一个管道并返回其读写端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlockInner &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alloc_fd</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 在进程控制块中分配一个最小的空闲文件描述符来访问新打开的文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>命令行参数与标准I/O重定向</strong></p>
<p>命令行参数</p>
<p>在user_shell中读取一行后，根据空格分隔成<code>Vec&lt;String&gt;</code>，然后手动在每个字符串后面加上<code>\0</code>，在最后加上<code>0 as *const u8</code>，将字符串数组的起始地址传入<code>sys_exec()</code>内核调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用更新</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_exec</span></span>(path: *<span class="keyword">const</span> <span class="built_in">u8</span>, <span class="keyword">mut</span> args: *<span class="keyword">const</span> <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 依次转换地址并取出参数，在调用TCB::exec时传入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> TaskControlBlock &#123;</span><br><span class="line">     <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="built_in">u8</span>], args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) &#123;</span><br><span class="line">    &#125; <span class="comment">// 在从ELF文件创建进程后把参数压入用户栈（此时用户栈为空）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据TCB创建时从ELF中读出来的内容，所有进程第一次进入用户态都是从<code>_start</code>进入：这个函数会依次取出命令行参数并且放入一个数组中</p>
<p>标准输入输出重定向</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用：将进程中一个已经打开的文件复制一份并分配到一个新的文件描述符中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_dup</span></span>(fd: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span>; <span class="comment">//（在符表中分配一个新的描述符指向一个复制）</span></span><br></pre></td></tr></table></figure>

<p>在用户态的<code>user_shell</code>程序中，要检查是否存在通过<code>&lt;</code>/<code>&gt;</code>进行输入输出重定向：</p>
<p>存在则移除，并记录输入/输出的文件名并打开；</p>
<p>这时候关掉<code>0/1</code>的文件描述符，给打开的文件<code>dup</code>一个新的，由于<code>alloc_fd()</code>一定会分配最小的可用文件描述符（先扫描符表中有无可用的，再push一个），所以这个文件就可以顶替掉<code>0/1</code></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li>存在线程前：进程是程序的基本执行实体，是程序关于某数据集合上的一次运行活动，是            系统进行资源（处理器、 地址空间和文件等）分配和调度的基本单位。</li>
<li>存在线程后：进程是线程的资源容器， 线程成为了程序的基本执行实体。</li>
</ul>
<p><strong>并发相关术语</strong></p>
<ul>
<li>共享资源（shared resource）：不同的线程/进程都能访问的变量或数据结构。</li>
<li>临界区（critical section）：访问共享资源的一段代码。</li>
<li>竞态条件（race condition）：多个线程/进程都进入临界区时，都试图更新共享的数据结构，导致产生了不期望的结果。</li>
<li>不确定性（indeterminate）： 多个线程/进程在执行过程中出现了竞态条件，导致执行结果取决于哪些线程在何时运行， 即执行结果不确定，而开发者期望得到的是确定的结果。</li>
<li>互斥（mutual exclusion）：一种操作原语，能保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的执行结果。</li>
<li>原子性（atomic）：一系列操作要么全部完成，要么一个都没执行，不会看到中间状态。在数据库领域， 具有原子性的一系列操作称为事务（transaction）。</li>
<li>同步（synchronization）：多个并发执行的进程/线程在一些关键点上需要互相等待，这种相互制约的等待称为进程/线程同步。</li>
<li>死锁（dead lock）：一个线程/进程集合里面的每个线程/进程都在等待只能由这个集合中的其他一个线程/进程 （包括他自身）才能引发的事件，这种情况就是死锁。</li>
<li>饥饿（hungry）：指一个可运行的线程/进程尽管能继续执行，但由于操作系统的调度而被无限期地忽视，导致不能执行的情况。</li>
</ul>
<p><strong>线程</strong>（一个进程在一个时刻有多个执行点）</p>
<ul>
<li>程序计数器寄存器来记录当前的执行位置</li>
<li>一组通用寄存器记录当前的指令的操作数据</li>
<li>一个栈来保存线程执行过程的函数调用栈和局部变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_thread_create</span></span>(entry: <span class="built_in">usize</span>, arg: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> </span><br><span class="line"><span class="comment">// 创建新的线程（entry:入口函数地址， arg:参数）</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_waittid</span></span>(tid: <span class="built_in">usize</span>) -&gt; <span class="built_in">i32</span></span><br><span class="line"><span class="comment">// 等待线程结束：进程/主线程回收资源（tid:线程id，由主线程调用）</span></span><br></pre></td></tr></table></figure>

<p>线程管理由进程而来</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,</span><br><span class="line">    <span class="keyword">pub</span> kernel_stack: KernelStack,</span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;, <span class="comment">// 可变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlockInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum, <span class="comment">// 应用地址空间中线程的 Trap 上下文被放在的物理页帧的物理页号</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext, <span class="comment">// 暂停线程的线程上下文，用于线程切换</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus, <span class="comment">// 当前线程的执行状态</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;, <span class="comment">// 线程退出码</span></span><br><span class="line">    <span class="keyword">pub</span> res: <span class="built_in">Option</span>&lt;TaskUserRes&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskUserRes</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> tid: <span class="built_in">usize</span>, <span class="comment">// 线程标识符</span></span><br><span class="line">    <span class="keyword">pub</span> ustack_base: <span class="built_in">usize</span>, <span class="comment">// 线程栈顶</span></span><br><span class="line">    <span class="keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;, <span class="comment">// 所属进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>进程控制块</code></pre><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> tasks: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> task_res_allocator: RecycleAllocator,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>锁</strong></p>
<p>相关数据结构：使用锁来包裹共享资源</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> mutex_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;<span class="keyword">dyn</span> Mutex&gt;&gt;&gt;, <span class="comment">// 进程可能存在多个互斥资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Mutex</span></span>: <span class="built_in">Sync</span> + <span class="built_in">Send</span> &#123; <span class="comment">// 互斥锁特征</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MutexBlocking</span></span> &#123; <span class="comment">// 实现互斥锁特征的结构</span></span><br><span class="line">    inner: UPSafeCell&lt;MutexBlockingInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MutexBlockingInner</span></span> &#123;</span><br><span class="line">    locked: <span class="built_in">bool</span>, <span class="comment">// 是否上锁</span></span><br><span class="line">    wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 上锁的等待队列 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关系统调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_create</span></span>(blocking: <span class="built_in">bool</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 创建一个新的锁：当前mutex_list是否有空位/锁的类型来创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_lock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125; <span class="comment">// 只负责调用当前线程的第id个锁的lock()方法</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果已经上锁则加入等待队列，否则上锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sys_mutex_unlock</span></span>(mutex_id: <span class="built_in">usize</span>) -&gt; <span class="built_in">isize</span> &#123;</span><br><span class="line">&#125;<span class="comment">// 只负责调用当前线程的第id个锁的unlock()方法</span></span><br><span class="line"><span class="keyword">impl</span> Mutex <span class="keyword">for</span> MutexBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 如果有等待的线程则唤醒，否则释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>信号量</strong>：适用于一个共享资源可以被有限个线程同时访问的情况（互斥锁即为N=1）</p>
<p>P操作：尝试进入，失败则阻塞</p>
<p>V操作：信号量的值+1，如果有线程等待则唤醒</p>
<p>（注意，以上两个操作都应该有原子性）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> semaphore_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Semaphore&gt;&gt;&gt;, <span class="comment">// 进程可能有多个信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Semaphore</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;SemaphoreInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SemaphoreInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> count: <span class="built_in">isize</span>, <span class="comment">// 信号量值（count &lt;= 0时代表有线程在等待）</span></span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 等待序列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Semaphore &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(res_count: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建新的信号量，置放初始信号值</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">up</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// V操作：count++, count &lt;= 0时从等待队列中取队头唤醒</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">down</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// P操作：count--, count &lt; 0时进入等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>条件变量</strong></p>
<p>线程在检查满足某一条件后才会执行（条件变量时一个线程等待队列）</p>
<p><code>wait</code>操作：释放锁 =&gt; 挂起自己 =&gt; 被唤醒后获取锁</p>
<p><code>signal</code>操作：找到挂在条件变量上面的线程并唤醒</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line">    inner: UPSafeCell&lt;ProcessControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcessControlBlockInner</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pub</span> condvar_list: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;Arc&lt;Condvar&gt;&gt;&gt;, <span class="comment">// 进程中的条件变量列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Condvar</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: UPSafeCell&lt;CondvarInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CondvarInner</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;, <span class="comment">// 条件变量：等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Condvar &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">    &#125; <span class="comment">// 创建空的等待队列</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">signal</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    &#125; <span class="comment">// 唤醒条件变量的等待队列的队头</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">wait</span></span>(&amp;<span class="keyword">self</span>, mutex:Arc&lt;<span class="keyword">dyn</span> Mutex&gt;) &#123;</span><br><span class="line">    &#125; <span class="comment">// 释放互斥锁（线程在进入前获取），挂起当前进程，恢复后获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="ArceOS学习记录"><a href="#ArceOS学习记录" class="headerlink" title="ArceOS学习记录"></a>ArceOS学习记录</h1><p>第三阶段时间比较紧张，就只能写写测试写不了挑战题了</p>
<p><strong>第一部分<code>UniKernel</code></strong></p>
<p><code>print_with_color</code></p>
<p>在输出println宏的实现处加上标识颜色的<code>ASCⅡ</code>码即可，需要注意（本人踩过坑）的是如果不想引入<code>format!</code>来直接把颜色字符拼接进入要打印字符中而是分别打印，需要注意字符打印导致的换行问题，这个会导致后边测试脚本在读取数据时检测不通过的问题</p>
<p><code>support_hashmap</code></p>
<p>这个去网上查了一下资料，还以为有什么高级实现的方法</p>
<p>结果最后还是使用了最朴实无华的取模插入</p>
<p>果然所有的数据结构都很难想</p>
<p><code>alt_alloc</code></p>
<p>在怎么实现上还是纠结了挺久的，是存储字符数转化成页还是存储页转化成字符、如果有新加入的内存怎么在其中表示……后面不得不去找了一下，发现原来可以不支持新加入内存（）</p>
<p>其实还是学到了很多的，在上操作系统理论课的时候根本没有想过这些内存是由一个统一初始化的内存管理器来进行管理，就只是单纯的知道了一下页表是什么</p>
<p><strong>第二部分宏内核</strong></p>
<p><code>sys_mmap</code></p>
<p>难度还可以，好像在这里没有花很久时间</p>
<p><code>ramfs_rename</code></p>
<p>因为没有什么大项目的经验导致对依赖很不敏感，在实现了之后一直进入不了我想用的DirNode的trait里面</p>
<p>后面不断调试才终于在偶然中发现如果不在根目录的<code>cargo.toml</code>中使用patch的话需要改两个cargo.toml</p>
<p><strong>第三部分<code>Hypervisor</code></strong></p>
<p><code>simple_hv</code></p>
<p>这个其实挺简单的，但是卡了我很久很久。遇到的问题是我在一开始就触发不了<code>panic</code>程序会直接卡死，然后依然是不断通过打印去定位错误，竟然发现卡死在了<code>_run_guest</code>的汇编代码里面，就硬着头皮去看汇编。还是一直发现不了卡死的原因……</p>
<p>总之就是试了很久，分析<code>qemu</code>的日志才发现是<code>store_page_fault</code>和时钟错误交替出现，拷打了一下AI之后才发现是没有</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/author-Keranthos/" rel="tag"># author:Keranthos</a>
              <a href="/blog/tags/repo-https-github-com-LearningOS-2025s-rcore-Keranthos/" rel="tag"># repo:https://github.com/LearningOS/2025s-rcore-Keranthos</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2025/05/29/Lfan-ke%EF%BC%9AArceOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="穿越操作系统的迷雾">
      <i class="fa fa-chevron-left"></i> 穿越操作系统的迷雾
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2025/06/03/2025%E6%98%A5%E5%A4%8F%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B8%89%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A-vipectuSSS/" rel="next" title="2025春夏开源操作系统训练营三阶段总结报告--vipectuSSS">
      2025春夏开源操作系统训练营三阶段总结报告--vipectuSSS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
