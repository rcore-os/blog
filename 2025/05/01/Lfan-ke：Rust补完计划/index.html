<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rcore-os.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="Rust补完计划src：rust官网，rust官文，rust官仓，crates.io，rust-wiki，卡狗圣经 ​    Rust可看作一个在语法层面（编译时）具有严格检查和限制的C语言上位。且扩展了面向对象的便捷方法绑定。编译和运行方式类似于C&#x2F;C++，可以rustc xxx.rs编译，.&#x2F;xxx运行。有约定的项目目录格式，可使用Cargo配置toml进行包管理、编译、运行、测试等等。包资源">
<meta property="og:type" content="article">
<meta property="og:title" content="&lt;Rust补完计划&gt;">
<meta property="og:url" content="http://rcore-os.github.io/blog/2025/05/01/Lfan-ke%EF%BC%9ARust%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/index.html">
<meta property="og:site_name" content="rcore-os Blog">
<meta property="og:description" content="Rust补完计划src：rust官网，rust官文，rust官仓，crates.io，rust-wiki，卡狗圣经 ​    Rust可看作一个在语法层面（编译时）具有严格检查和限制的C语言上位。且扩展了面向对象的便捷方法绑定。编译和运行方式类似于C&#x2F;C++，可以rustc xxx.rs编译，.&#x2F;xxx运行。有约定的项目目录格式，可使用Cargo配置toml进行包管理、编译、运行、测试等等。包资源">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-01T12:00:28.000Z">
<meta property="article:modified_time" content="2025-05-27T03:36:30.981Z">
<meta property="article:author" content="rcore-os Group">
<meta property="article:tag" content="author:Lfan-ke">
<meta property="article:tag" content="author-alias:禾可&#x2F;禾可1228&#x2F;&quot;Leo Cheng&quot;">
<meta property="article:tag" content="repo:https:&#x2F;&#x2F;github.com&#x2F;LearningOS&#x2F;2025s-rustling-Lfan-ke">
<meta property="article:tag" content="description:初次学习Rust整理后的笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rcore-os.github.io/blog/2025/05/01/Lfan-ke%EF%BC%9ARust%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title><Rust补完计划> | rcore-os Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">rcore-os Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Rust补完计划"><span class="nav-number">1.</span> <span class="nav-text">Rust补完计划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#快速开始"><span class="nav-number">1.1.</span> <span class="nav-text">快速开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初次接触"><span class="nav-number">1.2.</span> <span class="nav-text">初次接触</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊部分"><span class="nav-number">1.3.</span> <span class="nav-text">特殊部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#所有权机制"><span class="nav-number">1.3.1.</span> <span class="nav-text">所有权机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用与借用"><span class="nav-number">1.3.2.</span> <span class="nav-text">引用与借用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期"><span class="nav-number">1.3.3.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量与容器"><span class="nav-number">1.3.4.</span> <span class="nav-text">变量与容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体相关"><span class="nav-number">1.3.5.</span> <span class="nav-text">结构体相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举相关"><span class="nav-number">1.3.6.</span> <span class="nav-text">枚举相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定方法"><span class="nav-number">1.3.7.</span> <span class="nav-text">绑定方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式匹配"><span class="nav-number">1.3.8.</span> <span class="nav-text">模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态详解"><span class="nav-number">1.3.9.</span> <span class="nav-text">多态详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能指针"><span class="nav-number">1.3.10.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包管理相关"><span class="nav-number">1.3.11.</span> <span class="nav-text">包管理相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步相关"><span class="nav-number">1.3.12.</span> <span class="nav-text">异步相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏编程"><span class="nav-number">1.3.13.</span> <span class="nav-text">宏编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络编程"><span class="nav-number">1.3.14.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-UDP"><span class="nav-number">1.3.14.1.</span> <span class="nav-text">TCP&#x2F;UDP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Http"><span class="nav-number">1.3.14.2.</span> <span class="nav-text">Http</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web"><span class="nav-number">1.3.14.3.</span> <span class="nav-text">Web</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统编程"><span class="nav-number">1.3.15.</span> <span class="nav-text">系统编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用"><span class="nav-number">1.3.15.1.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内核编程"><span class="nav-number">1.3.15.2.</span> <span class="nav-text">内核编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#杂七杂八"><span class="nav-number">1.3.15.3.</span> <span class="nav-text">杂七杂八</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#与C交互"><span class="nav-number">1.3.15.3.1.</span> <span class="nav-text">与C交互</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#嵌入汇编"><span class="nav-number">1.3.15.3.2.</span> <span class="nav-text">嵌入汇编</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rcore-os Group</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">710</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">622</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://rcore-os.github.io/blog/2025/05/01/Lfan-ke%EF%BC%9ARust%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="rcore-os Group">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rcore-os Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          <Rust补完计划>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-01 12:00:28" itemprop="dateCreated datePublished" datetime="2025-05-01T12:00:28+00:00">2025-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-27 03:36:30" itemprop="dateModified" datetime="2025-05-27T03:36:30+00:00">2025-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">补完计划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Rust补完计划"><a href="#Rust补完计划" class="headerlink" title="Rust补完计划"></a>Rust补完计划</h1><p>src：<a href="https://www.rust-lang.org/" target="_blank" rel="noopener">rust官网</a>，<a href="https://doc.rust-lang.org/std/index.html" target="_blank" rel="noopener">rust官文</a>，<a href="https://github.com/rust-lang/" target="_blank" rel="noopener">rust官仓</a>，<a href="crates.io">crates.io</a>，<a href="https://rustwiki.org/zh-CN/reference/items/associated-items.html" target="_blank" rel="noopener">rust-wiki</a>，<a href="https://course.rs/about-book.html" target="_blank" rel="noopener">卡狗圣经</a></p>
<p>​    Rust可看作一个在语法层面（编译时）具有严格检查和限制的C语言上位。且扩展了面向对象的便捷方法绑定。编译和运行方式类似于C/C++，可以<code>rustc xxx.rs</code>编译，<code>./xxx</code>运行。有约定的项目目录格式，可使用<code>Cargo</code>配置<code>toml</code>进行包管理、编译、运行、测试等等。包资源网站为<code>CratesIO</code>，见<code>src↑</code>。不支持运算符重载，支持多态。其中语句为：<code>表达式+;</code>，语句的值是<code>()</code>。</p>
<p>​    为了安全，几乎所有的方法/变量/属性都是私有的，除非使用<code>pub</code>进行显式公用声明。</p>
<p>​    说到底，编程语言就是人类用来快速生成机器码以便于执行的模板引擎，有的语法层面(编译时/解释时)有强约束，有的仅仅是把特定字符串替换成另外的字符串或二进制，属于弱约束或者无约束。所有你在编程语言所看到的抽象，在机器码的层面本来就是一场幻月楼阁。比如你在编程语言层面，继承多态面向对象权限生命周期搞的花里胡哨的，但是在机器码看来，就仅仅是把PC变一下，或者某数据/指针变一下而已，你所关心的语法层面，语义特性，都是高层编译时/解释时的语法约束。这些约束让你写正确的高级语法的同时，最重要的是保证执行的结果符合预期。所以学底层的，一定要层层解耦，梳理层层抽象！</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>

<p>推荐开发环境：</p>
<blockquote>
<p>VSCode + <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer" target="_blank" rel="noopener">rust-analyzer</a>，VIM，<a href="https://www.jetbrains.com/rust/" target="_blank" rel="noopener">RustRover</a></p>
</blockquote>
<p>见面礼：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; <span class="built_in">println!</span>(<span class="string">"hello world!"</span>) &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs -o main &amp;&amp; ./main</span><br></pre></td></tr></table></figure>

<p>使用包管理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo new my_project_name	# 生成项目目录结构，包括&#96;toml&#96;、&#96;lock&#96;、&#96;src&#96;、&#96;test&#96;等等</span><br><span class="line">cargo build					# 编译后生成文件在&#96;target&#x2F;debug&#x2F;项目名&#96;下生成可执行文件，可选--release生成优化版本</span><br><span class="line">cargo run					# 仅run也会build</span><br><span class="line">cargo clean					# 清除target下编译后的文件</span><br><span class="line">cargo check					# 仅检查语法是否出错</span><br><span class="line"># 安装新的包，在Cargo.toml的依赖下配置：&#96;包名&#x3D;版本&#96;即可</span><br></pre></td></tr></table></figure>

<p>包管理器代理：<code>vim ~/.cargo/config.toml</code></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[source.crates-io]</span></span><br><span class="line"><span class="attr">replace-with</span> = <span class="string">'ustc'</span></span><br><span class="line"></span><br><span class="line"><span class="section">[source.ustc]</span></span><br><span class="line"><span class="attr">registry</span> = <span class="string">"sparse+https://mirrors.ustc.edu.cn/crates.io-index/"</span></span><br></pre></td></tr></table></figure>



<h2 id="初次接触"><a href="#初次接触" class="headerlink" title="初次接触"></a>初次接触</h2><p>语法语义一览表：</p>
<blockquote>
<p>标识符：<code>^[a-Z0-9_][a-Z0-9_$]*</code> 其中，命名习惯为：<code>CONST_VAL</code>，<code>StructName</code>，<code>ImplName</code>，<code>method_name</code>，<code>val_name</code></p>
<p>注释符：<code>// 单行注释</code>，<code>/* 多行注释 */</code>，<code>/// 文档注释，支持MD语法以及文档测试以及自动生成文档</code></p>
<p>运算符：<code>+ - * / % += -= *= /= %= ! ~|&amp; ^ [] ; , &gt;&gt; &lt;&lt; == != &lt; &lt;= &gt; &gt;= &amp;&amp; ||</code></p>
<p>变量声明：<code>const CONST_VAL: i32 = 123;</code> <code>static STATIC_VAL: u32 = 321;</code> <code>let emm = 233;</code> <code>let mut var = 0;</code></p>
<p>类型别名：<code>type word = u64</code></p>
<p>类型转换：<code>var as type_name</code> <code>type_name::from(var)</code></p>
<p>分支：<code>if 条件必须是布尔值 { ... } else { ... }</code> <code>match obj { case xx =&gt; { ... }, _ =&gt; { ... } }</code></p>
<p>循环：<code>loop { ... }</code> <code>for i in 0..10</code> <code>while n &lt; 233</code>，<code>break</code> <code>continue</code></p>
<p>支持循环标签来跳出指定的循环：<code>tag1: loop { tag2: while true { break: tag1 } }</code></p>
<p>函数格式：<code>fn add(a: i32, b: i32) -&gt; i32 { a + b }</code> 默认返回值是最后一条表达式的值，等同于：<code>return a+b;</code></p>
<p>匿名函数：<code>|a: i32, b: i32| -&gt; i32 { a + b }</code> 如果只有一条执行语句，可以省略大括号</p>
<p>类和对象：采用结构体<code>struct</code>(存数据)和特质<code>trait</code>(类似于抽象<code>interface</code>存方法)抽象，数据方法分离的思想</p>
<p>方法多态：方法和数据的关系是多对多，支持采用数据/特质签名来访问匿去的数据/方法：<code>TraitA::fun1(&amp;obj)</code></p>
<p>基本类型：i8 u8 i16 u16 … 有无符号+位数，str，bool，f64 … 同整型</p>
<p>类型变体：<code>&amp;i32</code> - 不可变引用，<code>&amp;mut</code> - 可变引用，<code>*const</code> - 不可变裸指针，<code>*mut</code> - 可变裸指针</p>
<p>容器类型：<code>[1, 2, 3]</code> - <code>Array</code> - 定长同类型，<code>(1, &quot;heke&quot;, 1228)</code> - <code>Tuple</code> - 定长不可变</p>
<p>数据容器：<code>struct Person { age: u8; name: &amp;str; }</code> <code>struct Bag (i32, i32, u8)</code></p>
<p>枚举类型：<code>enum State { StateA, StateB, State233=233, ,PA(ch) ... }</code> 详见特殊部分与模式匹配 <code>↓</code></p>
<p>其他容器：<code>Vec</code>，<code>Deque</code>，<code>Queue</code>，<code>BTreeSet</code>，<code>BTreeMap</code> …</p>
<p>导入管理：<code>mod package_emm;</code> <code>mod mode_name { fn emm() { ... } }</code> <code>use mode_name::emm;</code></p>
<p>异步支持：<code>async</code>，<code>await</code>，<code>std::thread</code>，以及异步的通道和异步智能指针</p>
</blockquote>
<p>快速迁移（将采用Py作为对比语言）：</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emm</span><span class="params">(a: int, b: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">return</span> float(a) + b</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">emm</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">    <span class="comment">// 运算块的值是最后一句表达式的值，所以不显示写return也可以，语句的值是()表示空！</span></span><br><span class="line">    a <span class="keyword">as</span> <span class="built_in">f64</span> + b    <span class="comment">// 或写为：`return a as f64 + b` 或 `return f64::from(a) + b;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emm</span><span class="params">(op)</span> -&gt; (int, str, int):</span></span><br><span class="line">    op</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="string">"heke"</span>, <span class="number">1228</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">emm</span></span>(op) -&gt; (<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>, <span class="built_in">i32</span>) &#123;  <span class="comment">// op会在编译时自动根据所调用时的类型生成对应类型标签的多态方法</span></span><br><span class="line">    op;</span><br><span class="line">    <span class="number">1</span>, <span class="string">"heke"</span>.as_str(), <span class="number">1228</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a: int, b: int, c: int)</span>:</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">        self.c = c</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method233</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a += self.b</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	obj = A(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    obj.method233()</span><br><span class="line">    print(<span class="string">f"a: <span class="subst">&#123;obj.a&#125;</span>, b: <span class="subst">&#123;obj.b&#125;</span>"</span>)</span><br><span class="line">    print(<span class="string">"c: "</span>, obj.c)</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> a: <span class="built_in">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> b: <span class="built_in">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> c: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> A &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">method233</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.a += <span class="keyword">self</span>.b;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> obj = A &#123;a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>&#125;;</span><br><span class="line">    obj.method233();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">format!</span>(<span class="string">"a: &#123;&#125;, b: &#123;&#125;"</span>, obj.a, obj.b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c: &#123;&#125;"</span>, obj.c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> method <span class="keyword">import</span> *		<span class="comment"># '0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> method <span class="keyword">import</span> func		<span class="comment"># 语法多余，但是为了对比语法'1</span></span><br><span class="line"><span class="keyword">from</span> .method <span class="keyword">import</span> func	<span class="comment"># 语法多余，但是为了对比语法'2</span></span><br><span class="line">__all__ = [<span class="string">'func'</span>]			<span class="comment"># 'export</span></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">method.func()</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>() &#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.rs / mod.rs</span></span><br><span class="line"><span class="keyword">mod</span> method;						<span class="comment">// '0</span></span><br><span class="line"><span class="keyword">use</span> method::*;					<span class="comment">// '0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> method::func;			<span class="comment">// pub use使得导入此包的也可以被别的包从此包导入'1 'export</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::method::func;	<span class="comment">// crate表示从包的根目录进行相对路径索引'2 'export</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有main，则在main内：</span></span><br><span class="line">func();</span><br><span class="line">method::func();</span><br><span class="line">crate::method::func();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="特殊部分"><a href="#特殊部分" class="headerlink" title="特殊部分"></a>特殊部分</h2><h3 id="所有权机制"><a href="#所有权机制" class="headerlink" title="所有权机制"></a>所有权机制</h3><p>​    在其他语言中，变量的赋值一向秉持：<code>常用量固定地址，简单变量直接复制，复杂变量或引用复制指针不复制本体</code>的弯弯绕绕，导致很多编程语言新手写出一堆堆耐人寻味的bug。Rust引入的所有权机制将这种不同语言独具特性的弯弯绕绕统一划分为了两类：实现了<code>Copy Trait</code>的类型和未实现<code>CT</code>$$^{笔记中出现过一次的全名在下次出现若无歧义将直接采用首字母缩写}$$的类型。前者赋值操作会执行<code>.clone()</code>，后者则是所有权的移交，这样子保证了数据的访问安全。</p>
<p>​    如何理解所有权呢？对于未实现<code>CT</code>的类型：</p>
<ul>
<li>你有50块钱：<code>let 你的50块钱 = 微信余额;</code></li>
<li><code>let 小明 = 你的50块钱;</code>你把 50 v 给了小明</li>
<li>你现在不能使用 v 过去的 50 块钱，使用会报错</li>
<li>小明现在是这 50 块钱的所有者</li>
</ul>
<p>​    对于实现了CT的类型，就是你一个我一个，反正是复制过去的，大家都有份，此时在内存中已经是两个位置截然不同的家伙了。</p>
<p>这就是所有权的移交：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RMB</span></span> (<span class="keyword">pub</span> <span class="built_in">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">pay50from</span></span>(rmb: RMB) -&gt; RMB &#123;	<span class="comment">// 使用RMB调用函数时，RMB所有权已经不是你的了，是函数的第一个参数的</span></span><br><span class="line">    <span class="keyword">return</span> RMB;					<span class="comment">// 现在return出去的时候，RMB的所有权将会从函数移交给返回值的接收者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> RMB &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">show_rmb</span></span>(&amp;<span class="keyword">self</span>) &#123; <span class="built_in">println!</span>(<span class="string">"我还有：&#123;&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> your = RMB(<span class="number">50</span>);   <span class="comment">// 你有50</span></span><br><span class="line">    <span class="keyword">let</span> xiao_ming = pay50from(your);</span><br><span class="line">    <span class="comment">// your.show_rmb() -&gt; Panic! 因为你的50已经v给小明了</span></span><br><span class="line">    xiao_ming.show_rmb()  <span class="comment">// 将会输出：`我还有：50`，因为50现在是小明的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    而对于常用的基本类型：<code>bool</code>，<code>str</code>，<code>u32</code>等等都是内置实现CT的，所以<code>let a = 233; let mut b = a;</code>的时候，发生的是复制而非转移所有权！此时即使<code>b += 1</code>，<code>a</code>也可以照常使用，且<code>a</code>与<code>b</code>无关系，<code>b</code>变化不会影响到<code>a</code>！</p>
<h3 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h3><p>​    如何通俗理解引用与借用呢？引用：<code>我有个朋友他有 - 自己不能修改</code>，借用：<code>我朋友借我玩玩的，他说随便玩 - 自己可以修改</code>。引用可以同时存在多个：<code>A是BCDEF的朋友，则==B C D E F==都可以说：我朋友A他有</code>，借用同时只能存在一个，且与引用互斥：<code>但是如果A借给了B，则CDEF就不能说：A他有，因为B还指不定把东西搞成什么样呢，CDEF带着其他人去了A那里，结果A说东西被B霍霍了...不就尴尬了</code>。所以借用和引用同时存在具有不安全，未定义，不确定的错误，会引发<code>Panic!</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Switch</span></span> &#123;</span><br><span class="line">    owner: <span class="built_in">String</span>,</span><br><span class="line">    game_total: <span class="built_in">u32</span>,  <span class="comment">// 假设这是你的游戏库存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Switch &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_game</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; <span class="keyword">self</span>.game_total += <span class="number">1</span>; &#125; </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">rmv_game</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; <span class="keyword">self</span>.game_total -= <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">show_game</span></span>(&amp;<span class="keyword">self</span>) &#123; <span class="built_in">println!</span>(<span class="string">"游戏机所有者：[&#123;&#125;]，有[&#123;&#125;]款游戏！"</span>, <span class="keyword">self</span>.owner, <span class="keyword">self</span>.game_total); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> A_switch = Switch &#123; owner: <span class="string">"A"</span>.to_string(), game_total: <span class="number">233</span> &#125;;</span><br><span class="line">    A_switch.show_game();		<span class="comment">// 游戏机所有者：[A]，有[233]款游戏！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A的朋友C引用(&amp;)了A的switch，C可以和其他人炫耀：我那哥们A，打游戏杠杠的，有233款游戏呢！</span></span><br><span class="line">    <span class="keyword">let</span> C = &amp;A_switch;</span><br><span class="line">    C.show_game();				<span class="comment">// 游戏机所有者：[A]，有[233]款游戏！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A把游戏机借用(&amp;mut - 别名: 可变引用)给了B</span></span><br><span class="line">    <span class="keyword">let</span> B = &amp;<span class="keyword">mut</span> A_switch;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123; B.add_game() &#125;	<span class="comment">// B污染了库存，增加了[0, 100)这100个辣鸡游戏</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">10</span> &#123; B.rmv_game() &#125;	<span class="comment">// B把游戏又卸了[0, 10]这11个游戏</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// C.show_game() -&gt; Panic! 此时C已经不能炫耀A有233个游戏了，不然会被别人说：你说谎！</span></span><br><span class="line">    B.show_game();						<span class="comment">// 游戏机所有者：[A]，有[322]款游戏！</span></span><br><span class="line">    <span class="comment">// A：好好好，你这样玩是吧，FK，B，(此处省略n条花言巧语，F是friendly，K是kindly)！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- 彩蛋：heke1228 -->

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>​    上面的例子粗略的让大家理解了一下引用与借用的区别，那么问题来了，不是说：<code>==引用与借用不可共存==</code>？，看似C$$^{存在引用}$$还在的情况下，为什么还能让B$$^{存在借用}$$胡作非为？</p>
<p>​    那么就不得不提生命周期这个概念了：人有生老病死，变量/引用也一样。在B胡作非为的时候，由于下文没有C出场的机会，所以C先行告退了。所以B在借到A游戏机的时候，C已经不在了，所以<code>==B和C并没有同框出现过==</code>，就像奥特曼和他的人间体。</p>
<p>​    那么使用死神之眼，使用生命周期标识<code>&#39;life_tag</code>，以生命周期的角度观察一下上面示例的<code>main</code>函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> A_switch = Switch &#123; owner: <span class="string">"A"</span>.to_string(), game_total: <span class="number">233</span> &#125;;  <span class="comment">// 'a_alive A入场 aa</span></span><br><span class="line">    A_switch.show_game();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> C = &amp;A_switch;														<span class="comment">// 'c_alive C入场 cc</span></span><br><span class="line">    C.show_game();</span><br><span class="line">    																		<span class="comment">// 此时以下无C，C退场领盒饭去了 cc</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> B = &amp;<span class="keyword">mut</span> A_switch;													<span class="comment">// 'b_alive B入场 bb</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123; B.add_game() &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">10</span> &#123; B.rmv_game() &#125;</span><br><span class="line">    </span><br><span class="line">    B.show_game();</span><br><span class="line">&#125;																			<span class="comment">// main函数结束，B和A相继退场 aa bb</span></span><br></pre></td></tr></table></figure>

<p>同时，生命周期可以在引用声明的时候使用<code>生命周期描述符</code>$$^{[a-Z0-9_]+}$$来显示告诉编译器某引用的生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &amp;'<span class="number">1</span> emm;				<span class="comment">// &amp;+' 后面的`1`			就是生命周期描述符</span></span><br><span class="line"><span class="keyword">let</span> b = &amp;<span class="symbol">'b_life_tag</span> emm;		<span class="comment">// &amp;+' 后面的`b_life_tag`	就是生命周期描述符</span></span><br></pre></td></tr></table></figure>

<p>如果想指定一个程序运行时一直存在的引用，或者借此来绕过编译器的生命周期检查，可以使用<code>static</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &amp;<span class="symbol">'static</span> emm;</span><br><span class="line"><span class="comment">// 或者创建一个具有'static生命周期的变量</span></span><br><span class="line"><span class="keyword">static</span>	EMM = <span class="number">233</span>;</span><br><span class="line"><span class="comment">// 与const的区别就是，const不可变，且在编译时确定，static可变(前加mut)，可在运行时确定或修改：</span></span><br><span class="line"><span class="keyword">const</span>	EMM = <span class="number">233</span>;</span><br></pre></td></tr></table></figure>

<p>额外需要注意的一点就是：<code>本体退场之后，所有的引用和借用将会不可用！</code>，如果需要额外指定生命周期，请在函数或结构体指明生命周期</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">temp</span></span>(&amp;<span class="symbol">'a</span> var1, &amp;<span class="symbol">'b</span> var2) -&gt; &amp;<span class="symbol">'a</span> res &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Temp</span></span>&lt;<span class="symbol">'a</span>, T&gt; &#123;</span><br><span class="line">    param1: &amp;'a type,</span><br><span class="line">    param2: &amp;'static type,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="变量与容器"><a href="#变量与容器" class="headerlink" title="变量与容器"></a>变量与容器</h3><p>​    前面絮絮叨叨那么多，算是走马观花了，毕竟你还不知道，你可以在Rust使用什么类型的变量！所以，平心而论，你现在甚至都不会赋值特定的类型给某变量名！</p>
<p>​    其他语言想要精细操作变量，需要包或别名的辅助：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UInt a &#x3D; 233; -&gt; UInt32 a &#x3D; 233;</span><br><span class="line">unsigned int a &#x3D; 233; -&gt; uint32_t a &#x3D; 233;</span><br><span class="line">a &#x3D; 233; -&gt; a &#x3D; ctype_uint32(233);</span><br><span class="line"># 等等等，可以看到，语言默认支持的int等等类型会随着ARCH变化而变化，比如：</span><br><span class="line"># 	&#96;match&#x3D;ilp32&#96;的&#96;long&#96;和&#96;match&#x3D;lp64&#96;的&#96;long&#96;位长就不一致</span><br><span class="line">#	如果是在资源充足的机子上，32位和64位也没什么区别，但是在资源有限的板子上，那就有大问题了！</span><br></pre></td></tr></table></figure>

<p>​    所以，Rust的变量类型默认是：<code>[符号类型][位长]</code>，比如：<code>u32</code>，<code>i64</code>，<code>f128</code>等等</p>
<p>​    特殊的内置类型：<code>str - &quot;你写的字符串常量&quot;</code>，以及<code>ARCH</code>决定位长的：<code>isize/usize</code>，以及熟悉的<code>bool</code></p>
<p>​    至于String，那是核心库自带且自动导入的特殊容器，用来进行快捷的字符序列操作！</p>
<p>​    容器是什么？能吃吗？容器可以看作一个包，里面装着基本变量或嵌套的容器。内置的容器有两种：<code>Array/Tuple</code>，如果你是混沌中立玩家，那么<code>struct/enum</code>也是容器，但是<code>s/e</code>将会在之后说明，非内置的常用容器会在最后举例说明一下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置容器的赋值会尝试逐一复制成员变量，复制未实现CT的不成功会转移所有权！此时剩余的变量可继续使用。</span></span><br><span class="line"><span class="comment">// Tuple：可以存不同类型，不可变，定长</span></span><br><span class="line"><span class="keyword">let</span> a = (<span class="string">"heke"</span>, <span class="number">1228</span>, <span class="number">2003</span>)</span><br><span class="line"></span><br><span class="line">a.<span class="number">0</span> == <span class="string">"heke"</span></span><br><span class="line">a.<span class="number">1</span> ==  <span class="number">1228</span></span><br><span class="line"></span><br><span class="line">类型标签：a: (<span class="built_in">str</span>, <span class="built_in">u32</span>, <span class="built_in">u32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array：所有元素单一类型，不可变，等长</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">b[<span class="number">1</span>] == <span class="number">1</span></span><br><span class="line">b[<span class="number">2</span>] == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">类型标签：b: [<span class="built_in">u32</span>; <span class="number">3</span>]  <span class="comment">// 长度为3的数组，类型都是u32</span></span><br><span class="line">同值初始化的数组：[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] == [<span class="number">0</span>; <span class="number">3</span>] <span class="comment">// 初始化3个0</span></span><br></pre></td></tr></table></figure>



<p>常用非内置容器：</p>
<p>​    利用结构体/枚举/基本变量/内置容器实现的种种数据结构与算法中的老朋友：<code>Vec-向量/变长数组</code>，<code>Deque-双端队列</code>，<code>Stack-栈</code>，<code>List-链表</code>，<code>HashMap-字典/键值对映射</code>，<code>BTreeMap-字典另外一种实现</code>，<code>BTreeSet-集合</code>，<code>HashSet-集合</code>，<code>String-变长字符串</code>等等</p>
<p>​    数量依据标准库/第三方库/版本而变化，详见<code>src</code>的官方文档。但是也简单介绍一下<code>Vec</code>，毕竟，常见的数据结构和算法无非就<code>增删改查</code>四种操作，有人习惯<code>push/pop</code>，有人习惯<code>append/remove</code>，有的还是<code>add/del</code>，所以，更多的使用方式，直接看官文！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// 使用宏，初始化一个Vec&lt;i32&gt;的容器</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="built_in">Vec</span>::new();</span><br><span class="line">b.push(<span class="number">1</span>); b.push(<span class="number">2</span>); b.push(<span class="number">3</span>);  <span class="comment">// b现在和a一致了！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);		 <span class="comment">// 绝大多数容器都是Iter，看具体的实现，Iter见下面：迭代器相关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体相关"><a href="#结构体相关" class="headerlink" title="结构体相关"></a>结构体相关</h3><p>前面已经初步介绍过结构体了，这里更像是一个结构体相关的合集。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EMM</span></span> &#123;</span><br><span class="line">    pub public_attr: type,		// 由于Rust整体是一个保守的语言，公共字段需要手动+pub前缀</span><br><span class="line">    privite_attr: type,			// 默认的字段是私有的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> EMM &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">show_self</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 自己的方法，自己的属性，私有公有皆可访问！</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"public_attr: [&#123;&#125;], privite_attr: [&#123;&#125;]"</span>, <span class="keyword">self</span>.public_attr, <span class="keyword">self</span>.privite_attr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">show</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.show_self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">show_emm</span></span>(emm: EMM) &#123;</span><br><span class="line">    emm.show_self();		<span class="comment">// 报错！Panic！因为show_self是私有方法！！！</span></span><br><span class="line">    emm.show();				<span class="comment">// 这个就ok了！因为show是pub方法！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据结构体与生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面已经介绍过了，生命周期的写法，这里赘述一下，顺便加上泛型：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span></span>&lt;T, <span class="symbol">'emm</span>&gt; &#123;</span><br><span class="line">    attr1: &amp;<span class="symbol">'emm</span> T,</span><br><span class="line">    attr2: &amp;<span class="symbol">'static</span> T,</span><br><span class="line">    attr3: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> TraitName&gt;,		<span class="comment">// dyn是动态分配，这里露个面，详见下面的“杂七杂八”</span></span><br><span class="line">    attr4: EMM,						<span class="comment">// 上面的结构体，定大小的非递归结构体，不定大小的字段需要用指针包裹！</span></span><br><span class="line">    attr5: EnumTmp,					<span class="comment">// 枚举</span></span><br><span class="line">    attr6: <span class="built_in">Vec</span>&lt;T&gt;,</span><br><span class="line">    attr7: BTreeMap&lt;<span class="built_in">u8</span>, T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元组结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">emm</span></span> (<span class="built_in">u8</span>, <span class="keyword">pub</span> <span class="built_in">u32</span>, <span class="built_in">f64</span>);</span><br><span class="line"><span class="comment">// 为什么emm，233？因为大部分文档太过正式，很多入门者搞不清后面的东西是关键字还是用户自定义的标签</span></span><br><span class="line"><span class="comment">// 比如一个struct StructName，你会错把StructName当关键字，但是Emm就不会，国外的相比于emm好像更喜欢foo</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 我们把元组结构体展开：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">emm</span></span> (</span><br><span class="line">    <span class="built_in">u8</span>,			<span class="comment">// 使用方式和元组一致：obj.0 obj.1</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="built_in">u32</span>,	<span class="comment">// 只有emm.1这个字段是pub，其余的.0 .2都是私有的</span></span><br><span class="line">    <span class="built_in">f64</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> emm &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">show_emm</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Emm: [&#123;&#125;] [&#123;&#125;] [&#123;&#125;]"</span>, <span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>, <span class="keyword">self</span>.<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="枚举相关"><a href="#枚举相关" class="headerlink" title="枚举相关"></a>枚举相关</h3><p>​    在底层玩家的眼中，枚举可以说是最有用最常用的语法，因为很多人都是基于状态机来写板子的，标识这些状态最好的方法就是使用枚举。比如常见的电风扇：开机，1档，2档，3档，关机；空调：开窗，半开窗，全开窗，摆动开窗等等。当你使用常量作为这些状态标识的时候，你会发现你想加一个1/4开窗，你得STFSC，看看前几个状态都是几，然后match…case：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;some32.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> STAGE_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> STAGE_B = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> STAGE_C = <span class="number">233</span>;	<span class="comment">// 很多人不想看源码了，写中间加状态的时候就慢慢写飘了</span></span><br><span class="line"><span class="keyword">int</span> STAGE_D = <span class="number">666</span>;	<span class="comment">// 然后，简单的小板子还可以，状态多了迟早会出错</span></span><br><span class="line"><span class="keyword">int</span> STAGE_I_DONT_KNOW_WHAT_IS_THIS_STAGE = <span class="number">3</span>;	<span class="comment">// 甚至半路，状态名称也变的奇奇怪怪</span></span><br><span class="line"><span class="keyword">int</span> I_WILL_BE_FOGET = <span class="number">5</span>;						<span class="comment">// 还有定义了状态半路忘记处理的，导致状态悬空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> curr_stage &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">233</span>:</span><br><span class="line">        	xxxx;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STAGE_C:</span><br><span class="line">            xxx;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优良的代码习惯，让短短百行代码变的难以维护...</span></span><br></pre></td></tr></table></figure>

<p>Rust的强制Match的枚举就来了！他规定必须处理枚举的所有可能，在模式匹配的强大配合下，变的更加强大！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumTmp</span></span> &#123;</span><br><span class="line">    a, b, c, d = <span class="number">233</span>,</span><br><span class="line">    e, StructEMM&lt;T&gt;, <span class="built_in">Option</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">random_choose_a_state</span></span>() -&gt; EnumTmp;</span><br><span class="line"><span class="comment">// 因为枚举一用全用，所以当enum前声明权限pub的时候，所有的字段都是pub，这不同于struct</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> state = random_choose_a_state();</span><br><span class="line">    <span class="keyword">match</span> state &#123;</span><br><span class="line">        a =&gt; <span class="built_in">println!</span>(<span class="string">"匹配到a，每个语句使用逗号分割！"</span>),</span><br><span class="line">        <span class="number">233</span> =&gt; <span class="built_in">println!</span>(<span class="string">"匹配到233，实际上是d"</span>),</span><br><span class="line">        StructEMM &#123;attr1: x, attr2&#125; =&gt; &#123;	<span class="comment">// attr2: attr2缩写为：attr2，attr1别名为x</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"匹配到结构体，其中struct.attr1是&#123;&#125;，attr2是&#123;&#125;"</span>, x, attr2);</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"下划线匹配剩余的情况！"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="绑定方法"><a href="#绑定方法" class="headerlink" title="绑定方法"></a>绑定方法</h3><p>懂得了结构体、枚举的声明，现在要给他们附加方法，不然他们只是数据，实际操作起来多多少少不方便！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Copy</span> <span class="keyword">for</span> StructEmm &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span> ...;			//	为结构体<span class="title">StructEmm</span>实现<span class="title">Copy</span> <span class="title">Trait</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">trait</span> <span class="title">SomeFunc</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">fn</span> <span class="title">emm</span></span>() &#123; ... &#125;		<span class="comment">// 有函数体的特质方法即：方法的默认实现，给结构体实现/绑定的时候不要求必须实现</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">emm233</span></span>() &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">qwq</span></span>();				<span class="comment">//	此方法没有默认实现，所以实现的时候必须实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> SomeFunc <span class="keyword">for</span> StructEmm &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AnyFunc</span></span>: SomeFunc + <span class="built_in">Copy</span> &#123;	<span class="comment">// AnyFunc特质要求实现的结构体必须先实现SomeFunc和Copy特质</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">emm</span></span>() &#123; ... &#125;		<span class="comment">//	出现同名方法！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> StructEmm &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">emm</span></span>() &#123; ... &#125;		<span class="comment">//	出现同名方法！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名方法使用会首先查找默认实现，即`impl 结构体名字`下的方法，其次会寻找唯一实现</span></span><br><span class="line"><span class="comment">// 找不到就得使用特质签名手动调用了：</span></span><br><span class="line">AnyFunc::emm(obj);			<span class="comment">// obj的AnyFunc下的emm调用，若为唯一，则为：obj.emm()</span></span><br></pre></td></tr></table></figure>



<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>Rust等等高级语言最令人讨喜的高级语法！首先将介绍基本的模式匹配用法，后将介绍可用在哪。</p>
<p>基本用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> (a, b) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="literal">Some</span>(a) = <span class="literal">Some</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">let</span> StructEmm &#123;attr1: x, attr2&#125; = StructEmm &#123;attr1: <span class="number">123</span>, attr2: <span class="number">233</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>条件守卫：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要用在match：</span></span><br><span class="line"><span class="keyword">let</span> tmp = <span class="number">233</span>;</span><br><span class="line"><span class="keyword">match</span> obj &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"匹配到了1或2或3"</span>),</span><br><span class="line">    <span class="number">4</span> | <span class="number">6</span> <span class="keyword">if</span> tmp == <span class="number">233</span> =&gt;  <span class="built_in">println!</span>(<span class="string">"在tmp是233的时候匹配4或者5"</span>),</span><br><span class="line">    <span class="number">7</span>..<span class="number">9</span> =&gt; <span class="built_in">println!</span>(<span class="string">"匹配到了range(7, 9) -&gt; [7, 9)的数字之一"</span>),</span><br><span class="line">    <span class="string">'a'</span>..=<span class="string">'f'</span> =&gt; <span class="built_in">println!</span>(<span class="string">"匹配到了['a', 'f']的字母之一，范围匹配只允许数字字母"</span>),</span><br><span class="line">    <span class="literal">Some</span>(x) @ <span class="number">233</span> =&gt; <span class="built_in">println!</span>(<span class="string">"匹配到了Some(233)，此时x是233"</span>),</span><br><span class="line">    <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"Some(x)，因为x是233的情况在前面，所以这里的x不可能是233"</span>),</span><br><span class="line">    _	=&gt; <span class="built_in">println!</span>(<span class="string">"匹配任意变量，_不会绑定值，_开头的变量允许逃过必须使用的检查，如果是x=&gt;...则任意其余的值会绑定x"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可用在哪：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Mode(a) = mode;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> Mode(a) = mode &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"匹配的时候执行这里"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"其余情况到这里，else可选"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> Mode(a) = queue.pop() &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> Mode(a) <span class="keyword">in</span> IterMode &#123; ... &#125;</span><br><span class="line"><span class="keyword">match</span> ... case ... =&gt; ...</span><br></pre></td></tr></table></figure>



<h3 id="多态详解"><a href="#多态详解" class="headerlink" title="多态详解"></a>多态详解</h3><p>Rust的多态是基于泛型的，编译时多态为了节省运行时时间，会根据方法的使用情况生成对应的衍生体，运行时多态是在编译时多态不能确定的时候，留到运行时动态分发的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span></span>&lt;T,Y&gt; &#123;</span><br><span class="line">    a: T,</span><br><span class="line">    b: Y,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当你有：</span></span><br><span class="line">tmp &#123;a: <span class="number">1u32</span>, b:<span class="number">1u32</span>&#125;</span><br><span class="line">tmp &#123;a: <span class="number">1i32</span>, b:<span class="number">1f64</span>&#125;</span><br><span class="line"><span class="comment">// 的时候，编译时静态分发会生成struct tmpu32u32 &#123; u32, u32 &#125;和struct tmpi32f64 &#123; i32, f64 &#125;</span></span><br><span class="line"><span class="comment">// trait的多态方法也是，会自动在编译时生成对应版本，运行时就会节省判断类型再分发的消耗</span></span><br><span class="line"><span class="comment">// 如果你不确定有哪些方法会被使用，你需要提前给类型一点约束：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span></span>&lt;T: <span class="built_in">Copy</span>+Tmp,Y&gt; &#123;	<span class="comment">// T必须是实现了Copy和Tmp特质的类型</span></span><br><span class="line">    a: T,</span><br><span class="line">    b: Y,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; tmp&lt;T&gt; &#123;	<span class="comment">// 前一个T标识后面的T是类型名称</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>&lt;T&gt;() -&gt; <span class="keyword">impl</span> <span class="built_in">Copy</span> + Tmp &#123;		<span class="comment">// impl标识返回的是实现了Copy + Tmp的一个type的工厂函数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果就是不确定，非等得到运行时才能确定结构体的类型怎么办？运行时动态分发：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span></span>&lt;Y&gt; &#123;</span><br><span class="line">    a: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Copy</span>+Tmp&gt;,		<span class="comment">// dyn标识此字段将会是一个实现了Copy+Tmp特质的类型</span></span><br><span class="line">    b: Y,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态分发不会自动生成多个适应不同类型的结构体衍生，也就是说编译时优化不了，在运行的时候，会浪费一点资源判断类型后分发。</p>
<p>上面发现写类型前面有点冗长，有点乱了，所以可以使用<code>type</code>来定义类型，<code>where</code>定义约束：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 类似于C语言的typedef</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">emm</span></span> = <span class="built_in">u32</span>;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">qwq</span></span> = crate::collections::HashMap;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">asd</span></span> = <span class="keyword">ref</span> <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">zxc</span></span>&lt;T&gt; = tmp&lt;T,T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型约束：</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; xxx&lt;T: crate::collections::HashMap, F: [<span class="built_in">u32</span>; <span class="number">64</span>]&gt; &#123; ... &#125;</span><br><span class="line"><span class="comment">// 可写为：</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T,F&gt; xxx&lt;T,F&gt; </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">	T: crate::collections::HashMap,</span><br><span class="line">	F: [<span class="built_in">u32</span>; <span class="number">64</span>]</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，如果impl/mod里面书写类型过于麻烦，也可以内部定义类型，类似于临时起个别名：</span></span><br><span class="line"><span class="keyword">impl</span> Tmp &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">type_a</span></span> = [<span class="built_in">u8</span>; <span class="number">64</span>];</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">emm</span></span>(var1: type_a, var2: type_a) -&gt; type_a &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针是一个个可以解引用对象的封装，他们的功能块可以像乐高积木一样堆叠拼装</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">smart_pointers</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Box - 堆分配，单一所有者</span></span><br><span class="line">    <span class="keyword">let</span> boxed = <span class="built_in">Box</span>::new(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Box: &#123;&#125;"</span>, *boxed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rc - 引用计数，多所有者</span></span><br><span class="line">    <span class="keyword">let</span> rc1 = Rc::new(<span class="string">"shared"</span>.to_string());</span><br><span class="line">    <span class="keyword">let</span> rc2 = rc1.clone();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Rc count: &#123;&#125;"</span>, Rc::strong_count(&amp;rc1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RefCell - 内部可变性</span></span><br><span class="line">    <span class="keyword">let</span> refcell = RefCell::new(<span class="number">42</span>);</span><br><span class="line">    *refcell.borrow_mut() += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"RefCell: &#123;&#125;"</span>, refcell.borrow());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arc + Mutex - 线程安全的共享状态</span></span><br><span class="line">    <span class="keyword">let</span> arc_mutex = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> clone = arc_mutex.clone();</span><br><span class="line">    *clone.lock().unwrap() = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Arc+Mutex: &#123;&#125;"</span>, *arc_mutex.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="包管理相关"><a href="#包管理相关" class="headerlink" title="包管理相关"></a>包管理相关</h3><p>合理分割代码，合理安排代码位置，是熟悉设计模式的码农必需品。写完不仅仅心旷神怡，<code>debug</code>的时候也可以更快的定位<code>bug</code>！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo new 包名 --bin / --lib</span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中，默认为 --bin ，创建二进制程序，二进制程序就是含有程序入口 main 的程序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --lib 为创建一个包，类似于Py的 __init__.py</span></span><br></pre></td></tr></table></figure>


<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设的包结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">my_crate/</span></span><br><span class="line"><span class="comment">├── Cargo.toml</span></span><br><span class="line"><span class="comment">├── src/</span></span><br><span class="line"><span class="comment">│   ├── lib.rs        // 主要库文件</span></span><br><span class="line"><span class="comment">│   ├── utils.rs      // 工具模块</span></span><br><span class="line"><span class="comment">│   └── network/      // 子模块</span></span><br><span class="line"><span class="comment">│       ├── mod.rs</span></span><br><span class="line"><span class="comment">│       └── tcp.rs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/lib.rs 示例</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> network;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用pub use重导出，将 TcpConnection 导出至当前主命名空间</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> network::tcp::TcpConnection;		<span class="comment">// 类似于：from network.tcp import TcpConnection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cargo.toml 依赖示例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[dependencies]</span></span><br><span class="line"><span class="comment">serde = &#123; version = "1.0", features = ["derive"] &#125;</span></span><br><span class="line"><span class="comment">tokio = &#123; version = "1.0", features = ["full"] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>包的发布：</p>
<p>在<a href="crates.io">crates.io</a>创建用户，生成API Token，使用命令行登录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo login &lt;API_TOKEN&gt;</span><br></pre></td></tr></table></figure>

<p>在自己想要发布的包中，确认包含入以下字段：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"your-package"</span>  <span class="comment"># 必须唯一，全小写+连字符</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span>      <span class="comment"># 遵循语义化版本 (SemVer)</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">"随意简要描述即可"</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">"MIT/Apache-2.0"</span>  <span class="comment"># 必须使用 SPDX 标识符</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"XXX@example.com"</span>, <span class="string">"可以有多个作者，逗号隔开"</span>]</span><br><span class="line"><span class="attr">repository</span> = <span class="string">"https://github.com/your/repo"</span>  <span class="comment"># 可选但推荐</span></span><br></pre></td></tr></table></figure>

<p>打包和<a href="https://doc.rust-lang.org/cargo/" target="_blank" rel="noopener">发布</a>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo package  # 本地生成 .crate 文件（位于 target/package/）</span><br><span class="line"></span><br><span class="line">cargo publish --dry-run  # 模拟发布，检查潜在问题</span><br><span class="line">cargo publish  # 上传到 crates.io</span><br></pre></td></tr></table></figure>

<hr>
<p>如果想在本地引入本地/Git途径的包：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">your_lib</span> = &#123; git = <span class="string">"https://github.com/user/repo"</span>, branch = <span class="string">"main"</span> &#125;   <span class="comment"># Git</span></span><br><span class="line"><span class="attr">your_lib</span> = &#123; path = <span class="string">"../local-path"</span> &#125;                                  <span class="comment"># 本地</span></span><br></pre></td></tr></table></figure>



<h3 id="异步相关"><a href="#异步相关" class="headerlink" title="异步相关"></a>异步相关</h3><p>Rust的异步传输数据，一种是靠原子性的Arc/Mutex等等智能指针来查改值，一种是靠通信管道来传输值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Arc&lt;Mutex&gt; 共享状态</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">shared_state_example</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        handles.push(tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().<span class="keyword">await</span>;</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="keyword">await</span>.unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().<span class="keyword">await</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用通道通信</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">channel_example</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 其中管道常见的操作是使用Arc共享，之后使用move闭包传入</span></span><br><span class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = mpsc::channel(<span class="number">32</span>);</span><br><span class="line">    </span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tx.send(<span class="string">"Hello from task"</span>).<span class="keyword">await</span>.unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Received: &#123;:?&#125;"</span>, rx.recv().<span class="keyword">await</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    shared_state_example().<span class="keyword">await</span>;</span><br><span class="line">    channel_example().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多进程示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::process::Command;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process_example</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 启动子进程</span></span><br><span class="line">    <span class="keyword">let</span> child = Command::new(<span class="string">"ls"</span>)</span><br><span class="line">        .arg(<span class="string">"-l"</span>)</span><br><span class="line">        .spawn()</span><br><span class="line">        .expect(<span class="string">"Failed to start process"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Parent waiting..."</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待子进程结束</span></span><br><span class="line">    <span class="keyword">let</span> output = child.wait_with_output().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Process exited with: &#123;:?&#125;"</span>, output.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多线程示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">thread_example</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 创建线程间通道</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成线程</span></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.send(<span class="string">"Message from thread"</span>).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程接收消息</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, rx.recv().unwrap());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程池示例</span></span><br><span class="line">    <span class="keyword">let</span> pool = rayon::ThreadPoolBuilder::new()</span><br><span class="line">        .num_threads(<span class="number">4</span>)</span><br><span class="line">        .build()</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    pool.spawn(|| <span class="built_in">println!</span>(<span class="string">"Running in thread pool"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>协程示例（使用<a href="https://tokio-zh.github.io/" target="_blank" rel="noopener">Tokio</a>）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::task;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">coroutine_example</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 生成异步任务（协程）</span></span><br><span class="line">    <span class="keyword">let</span> handle = task::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        tokio::time::sleep(Duration::from_secs(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="string">"Task completed"</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务完成</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, handle.<span class="keyword">await</span>.unwrap());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并行执行多个协程</span></span><br><span class="line">    <span class="keyword">let</span> futures = <span class="built_in">vec!</span>[</span><br><span class="line">        task::spawn(<span class="keyword">async</span> &#123; <span class="number">1</span> &#125;),</span><br><span class="line">        task::spawn(<span class="keyword">async</span> &#123; <span class="number">2</span> &#125;),</span><br><span class="line">        task::spawn(<span class="keyword">async</span> &#123; <span class="number">3</span> &#125;),</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> results = futures::future::join_all(futures).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Results: &#123;:?&#125;"</span>, results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    coroutine_example().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="宏编程"><a href="#宏编程" class="headerlink" title="宏编程"></a>宏编程</h3><p>rust的宏编程包括简单的声明宏和高级的过程宏，声明宏使用<code>macro_rules!</code>声明；过程宏则是基于语法树进行操作。</p>
<p>声明宏示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span>   <span class="comment">// 默认宏只能在定义的命名空间使用，除非定义宏可导出！</span></span><br><span class="line"><span class="built_in">macro_rules!</span> outputlns &#123;</span><br><span class="line">    ($($val:expr),+) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 由于使用*匹配多个val，则需要在需要重复生成的语句后加 + 来重复生成</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, val);+</span><br><span class="line">        &#125;  <span class="comment">// 更常见的是整个语句块后重复生成多个语句，匹配参数数量的除了 + 还有 * ?</span></span><br><span class="line">    &#125;;  <span class="comment">// 每个匹配规则后记得加封号！</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"这是没有参数的空语句！"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用宏：</span></span><br><span class="line">outputlns!();   <span class="comment">// 同样可以使用 outputlns![];  outputlns!&#123;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>过程宏示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过程宏的导出需要专门的crate导出：</span></span><br><span class="line"><span class="comment">/// Cargo.toml：</span></span><br><span class="line"><span class="comment">/// [dependencies]</span></span><br><span class="line"><span class="comment">/// proc-macro2 = "1.0"</span></span><br><span class="line"><span class="comment">/// [lib]</span></span><br><span class="line"><span class="comment">/// proc-macro = true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(MyDerive)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">my_derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> input = syn::parse_macro_input!(input <span class="keyword">as</span> syn::DeriveInput);</span><br><span class="line">    <span class="keyword">let</span> name = input.ident;</span><br><span class="line">    </span><br><span class="line">    quote::quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> #name &#123;</span><br><span class="line">            <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">generated_fn</span></span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Generated for &#123;&#125;!"</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看宏展开：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo expand --test your_lib</span><br></pre></td></tr></table></figure>



<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h4><p>TCP示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">handle_client</span></span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line">    stream.read(&amp;<span class="keyword">mut</span> buffer).unwrap();</span><br><span class="line">    stream.write(<span class="string">b"HTTP/1.1 200 OK\r\n\r\nHello from TCP!"</span>).unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind(<span class="string">"127.0.0.1:8080"</span>).unwrap();</span><br><span class="line">    <span class="keyword">for</span> stream <span class="keyword">in</span> listener.incoming() &#123;</span><br><span class="line">        handle_client(stream.unwrap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UDP示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::UdpSocket;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> socket = UdpSocket::bind(<span class="string">"127.0.0.1:8080"</span>).unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">let</span> (amt, src) = socket.recv_from(&amp;<span class="keyword">mut</span> buf).unwrap();</span><br><span class="line">    socket.send_to(&amp;buf[..amt], src).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h4><p>网络请求示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> reqwest::blocking; <span class="comment">// 非异步注意使用 blocking 模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), reqwest::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> client = blocking::Client::new();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> response = client.get(<span class="string">"https://httpbin.org/get"</span>).send()?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Status: &#123;&#125;"</span>, response.status());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Body: &#123;&#125;"</span>, response.text()?);</span><br><span class="line">    </span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- 异步方案 ---</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> reqwest;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), reqwest::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> response = reqwest::get(<span class="string">"https://httpbin.org/get"</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Status: &#123;&#125;"</span>, response.status());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Body: &#123;&#125;"</span>, response.text().<span class="keyword">await</span>?);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><p>常见的Web空间目前[2024.09]有：<a href="https://rocket.rs/" target="_blank" rel="noopener">Rocket</a>，<a href="https://actix.rs/" target="_blank" rel="noopener">Actix</a>，<a href="https://github.com/tokio-rs/axum" target="_blank" rel="noopener">Axum</a>，<a href="https://github.com/poem-web/poem" target="_blank" rel="noopener">Poem</a>，<a href="https://salvo.rs/" target="_blank" rel="noopener">Salvo</a>等等；可以先入为主尝试<code>Rocket</code>和<code>Poem</code>！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span> <span class="keyword">extern</span> <span class="keyword">crate</span> rocket;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() -&gt; &amp;<span class="symbol">'static</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="string">"Hello, Rocket!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/hello/&lt;name&gt;?&lt;age&gt;"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: <span class="built_in">String</span>, age: <span class="built_in">Option</span>&lt;<span class="built_in">u8</span>&gt;) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Hello, &#123;&#125;! Age: &#123;:?&#125;"</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[launch]</span>      <span class="comment">// 旧版使用main函数中：rocket::ignite().mount("/hello", routes![hello]).launch();...</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">rocket</span></span>() -&gt; _ &#123;</span><br><span class="line">    rocket::build().mount(<span class="string">"/"</span>, routes![index, hello])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- Json序列化对象 ---</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> rocket::serde::&#123;json::Json, Deserialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[post(<span class="meta-string">"/user"</span>, data = <span class="meta-string">"&lt;user&gt;"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">create_user</span></span>(user: Json&lt;User&gt;) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">"Created user: &#123;&#125; (age &#123;&#125;)"</span>, user.name, user.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- WebSocket ---</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> rocket::tokio::net::TcpStream;</span><br><span class="line"><span class="keyword">use</span> rocket::response::stream::TextStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">"/ws"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ws</span></span>() -&gt; TextStream![] &#123;</span><br><span class="line">    TextStream! &#123; <span class="keyword">yield</span> <span class="string">"Connected to WebSocket!"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="系统编程"><a href="#系统编程" class="headerlink" title="系统编程"></a>系统编程</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>使用<a href="https://docs.rs/libc/latest/libc/" target="_blank" rel="noopener"><code>libc</code></a>库来直接使用系统调用函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> libc::&#123;c_int, open, O_RDONLY&#125;;</span><br><span class="line"><span class="keyword">let</span> fd = <span class="keyword">unsafe</span> &#123; open(<span class="string">"file.txt\0"</span>.as_ptr() <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i8</span>, O_RDONLY) &#125;;</span><br></pre></td></tr></table></figure>

<p>在linux平台可以使用<code>nix</code>封装，在win系统可以使用<code>winapi</code>封装。</p>
<p>不同平台可以使用<code>#[cfg(target_os = &quot;linux&quot;)]</code>类似的条件编译来编写跨平台代码……</p>
<h4 id="内核编程"><a href="#内核编程" class="headerlink" title="内核编程"></a>内核编程</h4><p>可参考：<a href="https://github.com/rust-osdev" target="_blank" rel="noopener">Rust OSDev</a></p>
<h4 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h4><h5 id="与C交互"><a href="#与C交互" class="headerlink" title="与C交互"></a>与C交互</h5><p>Rust端声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span>   <span class="comment">// 使得结构体满足C样式，不会自动优化结构体字段顺序</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Counter &#123;</span><br><span class="line">    <span class="meta">#[no_mangle]</span>  <span class="comment">// 禁止名称修饰</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; *<span class="keyword">mut</span> Counter &#123;</span><br><span class="line">        <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(Counter &#123; value: <span class="number">0</span> &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 也可以自己设置导出名：</span></span><br><span class="line">    <span class="comment">/// #[export_name = "custom_name"]</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[no_mangle]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">increment</span></span>(counter: *<span class="keyword">mut</span> Counter) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *counter &#125;.value += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[no_mangle]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_value</span></span>(counter: *<span class="keyword">const</span> Counter) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*counter &#125;.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[no_mangle]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">destroy</span></span>(counter: *<span class="keyword">mut</span> Counter) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="built_in">Box</span>::from_raw(counter) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C端调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Counter</span> <span class="title">Counter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Counter* <span class="title">counter_new</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter_increment</span><span class="params">(Counter*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">counter_get_value</span><span class="params">(<span class="keyword">const</span> Counter*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter_destroy</span><span class="params">(Counter*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Counter* c = counter_new();</span><br><span class="line">    counter_increment(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Value: %d\n"</span>, counter_get_value(c));</span><br><span class="line">    counter_destroy(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>C端声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">c_create_point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c_print_point</span><span class="params">(<span class="keyword">const</span> Point* p)</span></span>;</span><br></pre></td></tr></table></figure>



<p>Rust端调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.rs 确保链接C库</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"cargo:rustc-link-lib=dylib=example"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="meta">#[repr(C)]</span> <span class="comment">// 保证内存布局与C兼容</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">// 声明外部C函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">c_create_point</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) -&gt; Point;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">c_print_point</span></span>(p: *<span class="keyword">const</span> Point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">unsafe</span> &#123; c_create_point(<span class="number">10</span>, <span class="number">20</span>) &#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; c_print_point(&amp;p <span class="keyword">as</span> *<span class="keyword">const</span> Point) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>需要注意：C的字符串以<code>\0</code>结尾，Rust则没有，所以互相传递的时候可以使用<code>std::ffi::CString</code></p>
<p>自动绑定工具：<code>Rust -&gt; C: cbindgen</code>，<code>C -&gt; Rust: bindgen</code></p>
<h5 id="嵌入汇编"><a href="#嵌入汇编" class="headerlink" title="嵌入汇编"></a>嵌入汇编</h5><p>假设有一个<code>add_sub.S</code>的汇编文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.section .text.entry</span><br><span class="line">.globl _add_and_subtract</span><br><span class="line">.type _add_and_subtract, %function</span><br><span class="line"></span><br><span class="line">_add_and_subtract:</span><br><span class="line">    # 获取参数</span><br><span class="line">    addi    sp, sp, -16       # 为局部变量分配栈空间</span><br><span class="line">    sd      a0, 0(sp)         # 保存第一个参数到栈</span><br><span class="line">    sd      a1, 8(sp)         # 保存第二个参数到栈</span><br><span class="line"></span><br><span class="line">    # 读取参数</span><br><span class="line">    ld      t0, 0(sp)         # 加载第一个参数</span><br><span class="line">    ld      t1, 8(sp)         # 加载第二个参数</span><br><span class="line"></span><br><span class="line">    # 执行加法</span><br><span class="line">    addi    t2, t0, t1        # t2 &#x3D; t0 + t1</span><br><span class="line"></span><br><span class="line">    # 执行减法</span><br><span class="line">    subi    t3, t0, t1        # t3 &#x3D; t0 - t1</span><br><span class="line"></span><br><span class="line">    # 返回值</span><br><span class="line">    sd      t2, 16(sp)        # 保存加法结果到栈上的返回位置</span><br><span class="line">    sd      t3, 24(sp)        # 保存减法结果到栈上的返回位置</span><br><span class="line"></span><br><span class="line">    # 加载返回值地址</span><br><span class="line">    la      a0, 16(sp)        # 第一个返回值地址</span><br><span class="line">    la      a1, 24(sp)        # 第二个返回值地址</span><br><span class="line"></span><br><span class="line">    # 恢复栈指针</span><br><span class="line">    addi    sp, sp, 16        # 恢复栈指针</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>使用Rust编写/操作/调用汇编的简易示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(abi_riscv_call)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"riscv-call"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_and_subtract</span></span>(a: <span class="built_in">i64</span>, b: <span class="built_in">i64</span>) -&gt; (<span class="built_in">i64</span>, <span class="built_in">i64</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;  <span class="comment">// 裸机环境，直接定义入口函数 _start</span></span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i64</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> b: <span class="built_in">i64</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (sum, diff) = add_and_subtract(a, b);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Sum: &#123;&#125;, Difference: &#123;&#125;"</span>, sum, diff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意：裸机环境只有核心库<code>core</code>，<code>#![no_main]</code>且<code>#![no_std]</code>，所以常用的<code>println!</code>需要根据设备特性(uart/lcd/Serial.write)自己封装！</p>
<p>使用<code>asm!</code>宏嵌入汇编：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::arch::asm;   <span class="comment">// 也可以：#![feature(asm)]</span></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义RISC-V系统调用号</span></span><br><span class="line"><span class="keyword">const</span> SYS_WRITE: <span class="built_in">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> SYS_EXIT: <span class="built_in">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用包装函数</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">syscall</span></span>(syscall_num: <span class="built_in">usize</span>, arg0: <span class="built_in">usize</span>, arg1: <span class="built_in">usize</span>, arg2: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ret: <span class="built_in">usize</span>;</span><br><span class="line">    asm!(</span><br><span class="line">        <span class="string">"ecall"</span>,</span><br><span class="line">        <span class="keyword">in</span>(<span class="string">"a7"</span>) syscall_num,</span><br><span class="line">        inlateout(<span class="string">"a0"</span>) arg0 =&gt; ret,</span><br><span class="line">        <span class="keyword">in</span>(<span class="string">"a1"</span>) arg1,</span><br><span class="line">        <span class="keyword">in</span>(<span class="string">"a2"</span>) arg2,</span><br><span class="line">        options(nostack)</span><br><span class="line">    );</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印字符串到标准输出</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_str</span></span>(s: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        syscall(SYS_WRITE, <span class="number">1</span>, s.as_ptr() <span class="keyword">as</span> <span class="built_in">usize</span>, s.len());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出程序</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">exit</span></span>(code: <span class="built_in">usize</span>) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        syscall(SYS_EXIT, code, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算阶乘的汇编实现</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">factorial</span></span>(n: <span class="built_in">usize</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> result: <span class="built_in">usize</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i: <span class="built_in">usize</span> = n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">"1:"</span>,                    <span class="comment">// 标签1</span></span><br><span class="line">            <span class="string">"beqz &#123;i&#125;, 2f"</span>,          <span class="comment">// 如果i==0，跳转到标签2</span></span><br><span class="line">            <span class="string">"mul &#123;result&#125;, &#123;result&#125;, &#123;i&#125;"</span>,</span><br><span class="line">            <span class="string">"addi &#123;i&#125;, &#123;i&#125;, -1"</span>,      <span class="comment">// i--</span></span><br><span class="line">            <span class="string">"j 1b"</span>,                   <span class="comment">// 跳回标签1</span></span><br><span class="line">            <span class="string">"2:"</span>,                     <span class="comment">// 标签2</span></span><br><span class="line">            i = inout(reg) i,</span><br><span class="line">            result = inout(reg) result,</span><br><span class="line">            options(nostack)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存操作示例</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">memory_operations</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> array: [<span class="built_in">u32</span>; <span class="number">4</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sum: <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="comment">// 加载array[0]到t0</span></span><br><span class="line">            <span class="string">"lw t0, 0(&#123;ptr&#125;)"</span>,</span><br><span class="line">            <span class="comment">// 加载array[1]到t1</span></span><br><span class="line">            <span class="string">"lw t1, 4(&#123;ptr&#125;)"</span>,</span><br><span class="line">            <span class="comment">// 相加</span></span><br><span class="line">            <span class="string">"add t0, t0, t1"</span>,</span><br><span class="line">            <span class="comment">// 加载array[2]到t1</span></span><br><span class="line">            <span class="string">"lw t1, 8(&#123;ptr&#125;)"</span>,</span><br><span class="line">            <span class="comment">// 相加</span></span><br><span class="line">            <span class="string">"add t0, t0, t1"</span>,</span><br><span class="line">            <span class="comment">// 加载array[3]到t1</span></span><br><span class="line">            <span class="string">"lw t1, 12(&#123;ptr&#125;)"</span>,</span><br><span class="line">            <span class="comment">// 相加</span></span><br><span class="line">            <span class="string">"add &#123;sum&#125;, t0, t1"</span>,</span><br><span class="line">            ptr = <span class="keyword">in</span>(reg) array.as_ptr(),</span><br><span class="line">            sum = out(reg) sum,</span><br><span class="line">            options(nostack)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    print_str(<span class="string">"Array sum: "</span>);</span><br><span class="line">    print_uint(sum <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">    print_str(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_uint</span></span>(<span class="keyword">mut</span> num: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = [<span class="number">0u8</span>; <span class="number">20</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">        buffer[i] = <span class="string">b'0'</span>;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">            buffer[i] = (num % <span class="number">10</span>) <span class="keyword">as</span> <span class="built_in">u8</span> + <span class="string">b'0'</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[..i].reverse();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    print_str(<span class="keyword">unsafe</span> &#123; core::<span class="built_in">str</span>::from_utf8_unchecked(&amp;buffer[..i]) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    print_str(<span class="string">"RISC-V Assembly in Rust\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器操作示例</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c: <span class="built_in">usize</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">"add &#123;0&#125;, &#123;1&#125;, &#123;2&#125;"</span>,</span><br><span class="line">            out(reg) c,</span><br><span class="line">            <span class="keyword">in</span>(reg) a,</span><br><span class="line">            <span class="keyword">in</span>(reg) b,</span><br><span class="line">            options(nostack)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    print_str(<span class="string">"5 + 7 = "</span>);</span><br><span class="line">    print_uint(c);</span><br><span class="line">    print_str(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阶乘示例</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> fact = factorial(n);</span><br><span class="line">    print_str(<span class="string">"5! = "</span>);</span><br><span class="line">    print_uint(fact);</span><br><span class="line">    print_str(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存操作示例</span></span><br><span class="line">    memory_operations();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出程序</span></span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恐慌处理</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    print_str(<span class="string">"Panic occurred!\n"</span>);</span><br><span class="line">    exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/author-Lfan-ke/" rel="tag"># author:Lfan-ke</a>
              <a href="/blog/tags/author-alias-%E7%A6%BE%E5%8F%AF-%E7%A6%BE%E5%8F%AF1228-Leo-Cheng/" rel="tag"># author-alias:禾可/禾可1228/"Leo Cheng"</a>
              <a href="/blog/tags/repo-https-github-com-LearningOS-2025s-rustling-Lfan-ke/" rel="tag"># repo:https://github.com/LearningOS/2025s-rustling-Lfan-ke</a>
              <a href="/blog/tags/description-%E5%88%9D%E6%AC%A1%E5%AD%A6%E4%B9%A0Rust%E6%95%B4%E7%90%86%E5%90%8E%E7%9A%84%E7%AC%94%E8%AE%B0/" rel="tag"># description:初次学习Rust整理后的笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2025/04/30/rcore-camp-2025S-stage1&2-%E9%A2%9C%E7%86%99%E7%82%86/" rel="prev" title="rcore-camp-2025S-stage1&2-颜熙炆.md">
      <i class="fa fa-chevron-left"></i> rcore-camp-2025S-stage1&2-颜熙炆.md
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2025/05/01/2025%E6%98%A5%E5%A4%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93-heirish/" rel="next" title="2025春夏操作系统训练营第二阶段总结-heirish">
      2025春夏操作系统训练营第二阶段总结-heirish <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rcore-os Group</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
