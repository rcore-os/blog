---
title: stage one
date: 2022-08-01 00:48:52
categories:
	- report
tags:
	- author:jackyliu16
	- summerofcode2022
	- rcore-lab
	
---


# 总结报告

> 本文为刘逸珑在2022年开源操作系统训练营中的第一阶段总结报告

<!-- more -->

### 第一阶段：rust学习部分

达成的效果：

- 通过对于`rust 圣经`的进一步学习，粗浅的理解了`rust`开发中存在的一些概念

- 能够使用`rust`语言完成一些简单的程序设计，从某种程度上理解了`rust`语言中相对重要的`borrow and move`关系

- 简单的学习了`rust`相关的`cargo`管理工具包和构建工具

- 理解了`rust`语言的几种特性

存在的问题：

- 在对于`rust 圣经`进行阅读的时候，很多时候会感到前后章节的割裂感，但是在本夏令营的前期部分，由于我时间安排上所存在的问题，前期学习`rust`的时候，相对较赶，很多地方也没有去查阅英文原文，就比如说那几本著名的书籍，在配套完成`Rust By Practice`的时候同样存在类似的问题，很多时候，我的求知欲被我想要快速完成任务的欲望压迫了，包括很多在我完成（rust by practice）的时候所发现的，其所提及的，没有被`rust cource`所涵盖的内容，我也没有查阅相关的书籍给予了解，而是简单的，仅仅记住了相关结论（在看答案的时候）

### 第一阶段：rCorelab 部分

#### ch1 多道程序与分时多任务

###### 实验一让我更加理解了操作系统的启动过程，以及工作机制

- 基于对于文档的学习，对于系统的运行机制以及加电流程有了一个简单的了解，同时，对于操作系统与`rustsbi`之间的服务与被服务关系有了一个简单的了解

- 在完成`lab1`的过程中，通过实现`sys_task_info`的系统调用，我更深入的理解了应用与操作系统之间的`syscall`调用关系。

- 同时也对于在多道程序被统一装入计算机内存之后，我们通过`TASK_MANAGER`对于所有的`task`进行统一管理，实现一定的调用功能，以及在变换过程中所碰到的切换`trap`上下文的操作，使进程能切换上下文到操作系统的上下文的思路，都有了更加深入的理解

###### 面对的问题：

- 相对来说还是没有建立起对于整个章节的逻辑链路，没有办法通过程序流图或者说是类似的伪图描述整个系统的运作过程。

#### lab2 地址空间

###### 通过对于实验的研究与学习，了解了特权级以及用户态与内核态之间的分离

-  了解了程序在内核态（S）与应用态（U）之间的区别，以及该区别所带给我们的安全效果。

- 了解了`__trap`所实现的进行模式状态切换的效果以及方式。

- 了解了处理器通过模式状态变更所实现的指令保护（防止用户态程序直接对于操作系统进行操作，来避免可能出现的由用户态影响操作系统的情况的发生。

- 了解了动态加载技术

- 了解了通过`trap_handler`实现的`trap`类型检查技术

#### lab3 进程及进程管理

- 简单的通过`sys_spawn`的实现，学习了操作系统中有关于进程的创建与将其添加到等待队列中的必要知识，但是在实现的 过程中存在相对较多的问题，就比如说一开始如果没有成功实现这个内容可能没有那么方便进行调试 *(可能需要在前面简单介绍下几种类似的调试技术?)*

- 在实现了`sys_spawn`之后的的实现`stride`调度算法的时候也就没有什么相对较大的问题了，基本上就是一个根据题目要求在操作系统中具体实现的模拟 *(具体算法也在帮助中给出了相关的内容)*

- 本章节通过实现了多道程序在内存中的（同一加载在内存中，并通过`task`上下文的方式进行进程间切换

**存在的问题：**

- 在本章节的学习过程中我发现了对于`rust`语言的借用关系理解不足，部分的借用关系并没有理解透彻。*（包括`UPSafeCell`的实现相关内容）*

- 在重新复现前面的样例的过程中充分的反馈了我对于当前实验框架的理解不足

- 感觉可以在`mmap`和`unmap`的实现过程中提供更多样例来方便`debug`

#### lab4 文件系统操作

- 本章节仅需要简单的完成一个文件系统

- 可能存在的问题在于我们对于`OSInode`,`Inode`,`DiskInode`三者之间的关系的理解程度，我们到底是如何理解整体的思路，还有我们是理解文件系统的`debug`操作（*至少当时对于我这个傻白甜，没有了println我就不知道除了什么问题了*）

- 还有一系列的锁的控制，很多在具体操作中存在了的`let mut fs = self.fs.lock()`的调用，同样会影响外部的`lock`的调用，这也是一个相对来说较难关注到的点（*至少当时我是这样想的*）

- 其他的部分逻辑上也是非常简单的，大体上也就是内容以一定间隔存储在相关设备上，我们需要理解示例代码中的一系列操作，并且将这些操作放到我们的代码中来*虽然可能很多部分都有类似的功能，但是我还是更加倾向于我自己再写一遍*

- 我的整个实现操作可能更加接近于这样：
  
  - 想到一个问题，我们所需要实现的`info`方法其实对应的作用对象是`OSInode`但是，如果我们只对于`OSInode`实现对应的方法，则没有办法从外部对u有这个方法进行调用，经过检查怀疑是因为没有办法从外部检查出这个方法
  
  - 于是类似于类变量的实现一样，尝试通过添加一个元素到`trait`中来实现了相关操作

- 在需要进行调试，但是由于在当前情况下不太方便（或者说难度较大）通过gdb进行调试，可以参考[LearningOS/rust-based-os-comp2022#92](https://github.com/LearningOS/rust-based-os-comp2022/pull/92) 进行可视化调试 或者通过在toml中添加log = "0.4" 的方式实现`debug!(sth)`宏调试，都可以从很大程度上辅助我们对于结果进行测试。从而分析问题所在

#### lab5 并发部分

- 本章节代码主要是基于许善朴的框架开发完成，简单的理解了相关的内容【实际上是我怕我调代码的时间太长，赶不上时间，因此直接使用了他的框架】，我自己的框架还在进行调试，不知道什么时候调的完。

- 我初步的设想是创建一个新的结构体，由这个结构体单独负责所有与银行家算法 相关的内容*偷懒想直接拿之前写的c语言作业顶上*,但是后来发现这样操作可能还是相对麻烦，耦合性不好，还在考量应该如何进行相关操作，才能在低耦合高内聚的情况上完成相关操作 *因为我感觉，应该尽可能的避免由于银行家算法（未开启）影响程序的执行效率 *












