---
title: rCore_Blog_epoche
date: 2023-11-03 11:04:22
tags:
---

## rCore 二阶段总结
第一次看到训练营的通知是在 Rust 中文社区，本着尽可能的抓住所有学习的机会就随手报了训练营，
结果被 Rust 的语法的优雅，还有操作系统的复杂性，功能性深深吸引，奈何我只有一些通识导论课的基础，没有关于 Risc-v 或计算机体系结构等的课程基础，所以
学期二阶段的课程非常的慢，不过还好，赶上了截止日期。

第一第二章是教学演示用的，但是为了能跑起来我还是花了很长时间，在 mac 下配置 docker，在 docker 里配置实验环境也是踩了不少的坑。
rCore 以一种计算机操作系统历史的教学方法，从简单到困难，从底层的基础到高深的抽象，使得我虽然没有什么计算机基础（只有简单的编程基础）也能学的津津有味。

ch1 讲的是一个最小用户态的执行环境操作系统，使得可以在裸机上，不调用任何标准库，通过编写的 kernel 以及实现的 `sys_write` 系统调用接口，来打印属于 rCore 的 `hello world!`。
这一章给我带来的极大的兴趣，让我对操作系统的认知从之前的一个深不可测的黑盒到现在的“最基本的是一个执行环境”。

ch2 则针对操作系统的任务执行过程来讲，实现了从第一章的只能运行一个应用程序的最小用户态执行环境到可以一次性将多个任务加载到内存，并分别处理多个任务的批处理操作系统，提高了运行效率。

ch3 则更进一步，引入了程序自动放弃cpu的控制权 `yeild` 和系统在时间片下主动暂停程序执行的时钟中断，更进一步的提高了运行效率。

ch4 引入了内存空间这一概念，个人觉得这一章是我看到现在为止最复杂的一章，多级页表的设计，任务管理器与页表的连接，以及跳板的作用，如何处理陷入，非常复杂，第一次看完还是很蒙，但是头铁直接去做 lab2，边做边看源码，也慢慢的理解了其设计逻辑。

ch5 引入了进程的概念，更加细化了应用执行过程，代码逻辑中将 TaskManager 二分为处理 保存系统中存在的进程的容器 和 cpu 正在执行的进程。在从 ch4 迁移到 ch5 中，对我来说还是有一点难度。

rCore 的文档对于像我这样的新手来说非常好，实验难度也适中，给我的感觉是实验本身要实现的逻辑不是很难，但是实验的要求应该也不是仅仅通过测试用例，还要了解阅读 rCore 的核心代码和逻辑。
才能得到更好的收获。
