---
title: chibinz's Summer of Code Briefing
date: 2020-07-26 21:41:00
categories:
    - report
tags:
    - author:chibinz
    - summerofcode2020
---

# OS Summer of Code 第一阶段总结报告
首先自报家门，我是在来自上海科技大学信息学院的张18级本科生张驰斌。了解到这一次实习机会是通过大群里面一位同学发的消息。原本自己也对“用Rust在RISC-V机器上面写一个OS”这样新技术的梦幻联动也有过畅想过，加上对计算机底层知识比较感兴趣，没有多想就报名了。
<!-- more -->
## Summary
简单总结一下这三个周来取得的成果。Step 0部分完成了所有的rustlings和15道小练习题。Step 1部分从头到尾认真阅读了RISC-V Privileged ISA Specification。Technical manuals are fun！之前计算机体系结构课程学的就是RISC-V，Project包括了一个RV32I的解释器，还有用Logisim搭出来的CPU（麻雀虽小五脏俱全，Datapath里面的ALU，Regfile等应有尽有）。Step 2部分一步一步跟着教程实现了rCore，实验题因为时间原因只完成了部分，pr和issues倒是有积极的提交和回复。具体每一部分的情况留一个链接，就不机械性的在总结报告里面重复了。看到仓库的名字是blog博客，也没有具体规定写些啥，后面就写的freestyle一点，谈谈自己的感悟和随想。

## Peers
记得老师们在第一次交流会上说，这一次Summer of Code对于每一个同学最重要的是把握好自己的节奏。的确，第一阶段的学习的内容容量还是蛮大的，有Rust，RISC-V，以及OS三个方面的知识需要了解，综合性的运用，只有把握好自己的节奏才能有效率的在三周的时间里完成这一部分内容。但是在参加完交流会和阅览过部分同学的每日记录之后，我还是不可避免的感受到了peer pressure😅。有的同学在7.2活动正式开始之前就已经完成了rCore-Tutorial所有内容，在Rust社区里面积极做出贡献。而我只能望其项背概叹一句：I'm so vegetable…… 有的同学之前对于Rust，RISC-V和OS都不能说是特别熟悉，但是20多天顽强的坚持了下来，每日记录详细记录了自己的问题，可以看的出其认真。还有的同学在做rCore-Tutorial的时候大刀阔斧的进行了改动，而且给出了改动的理由，改完能够正常运行，想必对于OS有非常深厚的理解。自己在第一遍跟着教程做的时候就保守的多，生怕修改了之后和后面的lab不兼容，花费大量的时间进行debug。本来自己在学校水平也就一般般，走出校园认识到更多优秀的同学发现更是如此。Peer pressure也有好处，见贤思齐，勉励自己更加努力的学习。

## Rust
一开始学习Rust的时候感觉Rust和C这样的命令式语言并没有太大的区别，只不过是关键词变了变，类型标注放在了后面。但是随着写的Rust行数越来越多，和对编程语言的学习深入之后发现自己之前对于Rust理解是多么的浅薄，仅仅停留在了语法层面。

习惯了Rust了之后重新回到C最不适应的就是频频出现的Segmentation Fault。内存错误是C语言非常常见的错误，通常的形式表现为程序运行崩溃操作系统在命令行输出Segmentation Fault（core dumped）。至于是哪里出了问题则需要靠程序员的智慧和经验，debug的过程通常十分痛苦，在茫茫代码中寻找一个野指针或者数组越界问题。而Rust则杜绝这些问题，类型系统保证了一个没有初始化的引用在编译时就会被拒绝并给出清晰的报错信息，而运行时则会对数组的访问进行检查，如果有越界访问会panic并给出明确的原因。这一切都和Rust的语言设计密切相关。虽然C的编译检查，sanitizers也做的越来好了，但是因为指针可以做加减法，可以被转置成void*而不包含任何类型信息，编译器对这些也无能为力。C的是一个weakly typed语言，而Rust是一个strongly typed语言，类型系统的soundness保证了程序运行时不会出现代码逻辑之外的undefined behavior。Strong type for weak minds，和Rust的type checker做斗争的时候感觉很痛苦，写出来的程序太restrictive了。但是离开了Rust回到C之后却发现有一个全面、强大的类型系统对程序的正确性做出保证省去debug之苦是一件多么香的事情。

## RISC-V
体系结构是一种工程产物，纯粹是实用的东西为什么会有优雅和丑陋之分。我也不太清楚，但是这是我接触x86和RISC-V两个ISA之后实实在在的感觉。最初认为RISC-V的优雅之处在于指令的编码。x86的指令有几千条，绝大多数的mnemonic很奇怪，不make sense（尤其是后面的SIMD扩展，汇编已经没有太大意义只能看intrinics）。而RISC-V的基础指令集只有寥寥几十条，扩展指令集功能明确且正交。的x86的指令是不定长的，对于立即数和寄存器操作的指令编码十分不同。而RISC-V（不包括C扩展）指令是定长的，且所有指令都是5种编码格式之一。在实践完rCore-Tutorial之后发现RISC-V的优越之处并不局限于指令本身。RISC-V SBI规范的的提出也是一个非常大的该进。之前写OS（Pintos）需要写很多与硬件相关的汇编，包括时钟的访问，以及命令行的输出，不同机器有不同的接口。而在RISC-V里面，这些Supervisor必须要访问的硬件被统一在SBI下面，让操作系统可以专注于自身的功能。如果说syscall是Supervisor Level给User Level提供的接口，那么SBI就是Machine Level提供给Supervisor Level的接口，每个层专注于自己的职能，很好的实现了软工里面学到的Separation of Concerns的理念。

## rCore Tutorial
纸上得来终觉浅，绝知此事要躬行。作为一门实践性很强的课程，OS的学习不能止步于在概念上浅尝辄止，必须动手敲一敲代码才能深刻理解许多设计理念背后的缘由。进程和线程是OS种频繁提到的两个名词，但实际上硬件上并没有进程或者线程，他们都是OS抽象出来方便我们理解的概念。进程的抽象是为了资源/内存的管理/隔离，将其具体化的核心数据结构是页表，一个根页表对应了一个地址空间，不同的进程有各自的页表，运行在不同的地址空间里面。线程的抽象是为了方便cpu时间的multiplexing，描述的是程序运行状态，具体的来说就是寄存器的值和线程的栈。作业和考试中可能会给出一个页表考你虚拟地址到物理地址的翻译，这实际上这是由硬件完成的。OS更重要的工作是维护页表。实现上的细节也有微妙之处，为了中断能够正常进行，中断部分的代码也要映射到用户程序的地址空间里面。如果不用代码实现一下可能会孤立的看待这些不同的概念，不知道实践中他们如何有机地组合在一起。

## Acknowledgement
从这次活动的名字OS Summer of Code，就能知道是参考的Google Summer of Code。确实，中国在于开源社区方面还有待提高。OS Summer of Code迈出了第一步，给参加第二阶段的同学提供实习机会和一定的报酬，开一个很好的头。不过是第一次办，又在疫情期间，组织起来实属不易。想必陈渝老师和其他负责的老师在此次活动的规划和协调中费了不少功夫。鹏城实验室的李睿老师每次交流会和私聊都很nice。同学们都想去实习，但是鹏城实验室要求开复课证明，好多同学都开不出来。双方都不容易，在这疫情期间是无可奈何地事情。这个时候就要考验学校的行政水平了，希望自己的学校不要设卡。总之感谢支持此次活动老师、助教还有鹏城实验室，提供这样一个实习的机会。

> Written with [StackEdit](https://stackedit.io/).
