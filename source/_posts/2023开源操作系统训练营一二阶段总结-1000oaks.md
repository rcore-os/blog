---
title: 1000oaks的rCore前二阶段小结
date: 2023-11-04 16:08:16
tags:
  - author:1000oaks
  - repo:https://github.com/LearningOS/2023a-rcore-1000oaks
---

# 1000oaks的rCore前二阶段小结

> 写小结一刻, 却不知写些什么.

- 这已经是我第二次报名了rCore训练营了. 第一次报名于2022年夏季, 然而那个暑假我去研究托福的备考了, 所以第一次报名之后什么也没有做(虽然托福倒是速成成功, 但是这导致我下学期没有修读校内开设的操作系统研讨课). 要不是D同学督促我, 怕不是第二次报名也只停留于一阶段了.

- 过分杞人忧天, 不如在rCore上静心研究.

<!--more-->

## 一阶段 & Rust

- 一阶段主要是Rust语言的学习. 实话实说, 我仍认为自己属于"Rust初(中)级水平", 离"Rustaceans"相距甚远. 之前我足足花了一学期线下体验DeNero的CS61A, 才真正入门并理解Python基础. 这件事情在二阶段, 主要是在`use crate::...`上我花了些时间研究.

- Rustlings很丰富, 但是阅读死灵书后, 我仍然对自己的Rust水平感到黯然失色.

- 我曾经感到恐惧的所有权转移这件事情, 事实上在二阶段并没有真正影响个人的开发. 

- VSCode的`rust-analyzer`插件可以智能的分析依赖关系和语法错误(顺道提句, 我在Rustlings快做完之后才意识到Rustlings可以一键为`rust-analyzer`生成文件用以分析), 其中的一些提示可以触发解答练习的思考.

> `rust-analyzer`实在太有用了, 比如自动标注变量类型. 没有它, 我很难顺利完成前三个实验.

- 真正让我感到妙哉的是rCore中定义的`UPSafeCell`数据结构, 起被后续的`...Inner`反复使用.

## 二阶段 & rCore

- 受到本科三年的学校校内课程的影响, RISC-V汇编倒是不那么困难, 虽然我应该承认RISC-V的特权态机制没有做到100%理解和记忆. 在读The RISC-V Reader中文版第10章的时候, 我发现了一翻译错误, 然而中文译者暂没有回复我的GitHub Issues(后来我就去读英文原版了). 此外, 我发现了Rust by Example(英文原版)的一处撰稿错误, 然而Rust官方也没有回复我. 不过, 倒是有好心人跟进了我的GitHub Issues甚至提交了Pull Request: https://github.com/rust-lang/rust-by-example/issues/1755

> 虽然我觉得这是Rust by Example的错误, 但不排除我**自身**理解错误的可能. 如果是这样, 敬请批评指正!

- 顺便说句, RISC-V的GitHub仓库的官方ISA手册(新版), 相比于正式发行的旧版ISA手册, 删除了不少有价值好理解的内容. 我不知道他们为什么这么做.

- 阅读第一章时, 对于"为什么进入`rust_main`之前要设置`sp`指针一事, 我感到难以理解. 后来用GDB进行了步步跟踪, 才弄明白问题的原因: Rust编译器编译出的函数代码均带有`sp`指针的加减和对应内存区域的访问, 如果不设置`sp`, 那么`$sp=0`, 实际运行就会访问不允许被访问的区域(`0x0`)而被杀死, 然后QEMU进入死循环. 研究此事之时, 顺便研究了`wfi`指令, 其可以让陷入死循环的QEMU以低功耗模式"沉睡"; 体现在x86虚拟机中是CPU占用的大幅减少.

- 做Lab 1的时候, 我正处于感冒难受的一个周末. 虽然第三章的文档我阅读了很久, 但是Lab 1要求实现的内容不难.

> Lab 1的背后是`UPSafeCell<T>`(及其高层封装)的支撑, 这大幅简化了完成rCore练习的难度和时间.

- 做Lab 2的时候, 我发现`munmap`的实现总是无法通过测试. 然后分析发现, 通过`PageTable::from_token()`函数创建的页表对于内存空间管理没有实际控制权. 这一点已经很清楚的写在了讲义中, 这是读讲义不细致造成的. 最好认真阅读文档找到了问题所在.

> 实现内存映射和取消映射没有涉及到页表的过多细节. rCore的练习之后, 还需要阅读既有框架的源码, 才能更好理解rCore, 而非局限于练习. rCore Tutorial Book评论区的很多讨论我仍没有完全弄通, 需要逐个消化.

- 做Lab 3的时候, 我发现`spawn`的实现总是不正确. 然后分析发现, 我对`fork`函数如何区分父子进程的理解是完全不对的. 正确的分析了`fork`的工作原理之后, `spawn`就能得以实现了. 至于对于前两章代码框架的调整试配, 到并不那么苦难, 参考`get_user_token`函数的实现就可知一二.

> 我曾经试图通过直接调用`fork`和`exec`函数, 通过几行实现. 但后来发现, 这样似乎行不通. 实现`spawn`需要直接修改`new_task`的内部. 也许有更简洁优雅的实现, 仍待之后进一步探索.

- 不得不指出的是, 尽管完成了Lab 1 - Lab 3, 但是部分实现可能不是很好, 而且`ci-user`的测试也不涵盖所有情况(也就是说, 我自己的实现还有很多不"完备"的地方). 由于做实验的时间仓促, 部分边界情况没有考虑(比如`TimeVal`横跨两页), 而且还把某些不应该暴露的函数接口给设置成`pub`类型了. 这些事情仍有待完善.

> 虽然rCore本身不对练习的实现加以硬性限制, 但是是否让新实现的接口`pub`出来, 则关乎操作系统的设计理念.

- 听说Lab 5较麻烦, 显然这周周末之前我无法完成了.

> 最近确实有些懒惰了, 尤其是感冒结束和推免烦事突然**淡化**之后. 心态可能是能否顺利完成rCore三阶段的关键.

## 致谢

- 在广受赞誉的rCore Tutorial Book v3之前, 是rCore Tutorial Book v2和久负盛名的uCore Tutorial 2015/2020. 在此对rCore Tutorial v2/v3以及uCore Tutorial 2015/2020的所有作者的辛勤付出表示深深的感谢(以及督促我认真工作的D同学), 是你们让我在操作系统上真正"开窍", 虽然我离"精通"还差得很远.
