---
title: 第四阶段总结-邵卓炜
date: 2025-06-30 23:23:12
tags:
---
由于自己3月份开始接触rust异步机制，并且对异步运行时到底在处理什么很感兴趣，所以选择异步os的方向。
我首先选择完成的任务是基于iouring的用户态异步运行时，链接在https://github.com/Shao-ZW/kunio，支持常见的文件和网络（Tcp）io。在我的实践经历来看，用户态异步运行时的构建像写一个 任务调度器 + 操作系统IO接口的异步封装。
为了进一步优化运行时的任务队列（以及优化我们比赛的OS内核），我选择参考BBQ paper实现的无锁ringbuffer，链接在https://github.com/Shao-ZW/bbring，虽然最终性能并不理想，但实现该结构是一个很有趣的历程。无锁的设计总是“危险”而精妙的，哪怕论文给出算法伪代码，实现的过程依然是相当曲折的，内存序的问题，aba问题，以及如何调整测试复现特定的bug，这个过程只有踩过坑才能知道痛。
关于我们的比赛内核，链接在https://github.com/greatbridf/osdev，我和我的队友在原先宏内核的基础上做了大量的改动，内容聚焦在组件化拆分以及异步化改造，前者主要集中在工作量上的庞大，如果确定好组件的依赖，如何设计出合适接口，这都需要仔细考量；异步化的改造客观来说工作量也很大，这是async传染性带来的必然，（如果重头构建一个异步内核可能相对好点），所以说目前我们为了必然大范围的传染性，会使用block_on语义的函数做一个暂时解决方案。异步os一个大的优势是不需要对每个task分配内核栈，这确实会节约相当大的内存开销，但任务异步化引入的问题之一就是内核抢占，上届哈工大的os给出的解决方案是通过设置抢占标志允许至多一次的内核抢占，这是一个不错的方案，但通用性能否做的更好一点呢？或许早先组会上听到有无栈的结合是最佳的解决方案，但由于内核比赛测试临近，最近的工作在不停的修syscall，暂时没时间研究，希望能在决赛时拿出我们认为优秀的解决方案。