---

title: 调度与死锁
date: 2024-11-11
categories:
    - os
tags:
    - author:ekkure
    - repo:https://github.com/ekkure/blog

---
##  调度

#### **三级调度：**

作业调度、高级调度(频次最低)：主要解决：接纳多少个任务+接纳那哪些任务这两个工作

进程调度、低级调度(频次最高): 必须有、**核心**，**确定哪个进程可以占有CPU并执行**

中级调度：将那些暂时不能运行的进程从内存挂起到外存，(阻塞状态下进程实体(程序 + 数据 + PCB)还在内存中，而挂起状态会把进程实体挂到外存，但是PCB会存在系统内核空间中，会记录进程在外存的状态以及位置)，一般在**内存紧张**时使用



高级调度，用于批处理系统中，将任务从外存调度到内存中去。(在分时/实时系统中，任务是直接在内存，因此没有高级调度)

分时系统：**只有进程调度**

批处理系统：**进程调度 +  作业调度**



#### 调度算法相关

准则：周转时间(常用于**批处理系统**)、平均周转时间、带权周转时间

响应时间(交互性作业、分时系统)、截止时间的保证(实时系统)、优先权准则

周转时间 = 完成时间 - 到达时间

带权周转时间 = 周转时间 / 服务时间


**调度算法**

- FCFS(first come first serve), SJ(P)F等等
对于抢占式调度，注意**服务时间的更新，然后再比较，看谁抢**

- 高优先权 优先调度算法

   静态优先权：简单，但存在饥饿现象

   动态优先权：eg Rp = （等待时间 + 服务时间）/ 服务时间  作为优先权 1 + tw / ts;

- 时间片轮转 ......?

   多级反馈队列 S1 < S2 < S3 优先权 S1 > S2 > S3

   

- 实时调度

   非抢占：轮转 || 优先权

   抢占：基于中断时钟，好处是减少了上下文保存切换的次数

   ​      立即抢占

   实时调度算法：EDF、LLF，还有例题

- 其他一些？？

   MPS：CPU共享内存，  共享缓存(单个儿独立的，容易出现绑定，忙闲不均)

   SMP中进程分配方式：静态分配和动态分配

   ​               调度方式： 自调度和成组调度(两种方式就对应了用户级线程和系统级线程)，                       专用处理机分配？


## 死锁

**一些定义**：

- 可剥夺资源：如主存，CPU，可以在使用时被强占的资源
- 不可剥夺资源：不可被打断抢占的资源，如驱动器，打印机
- 永久资源(外存)，临时资源(进程运行过程中临时产生的数据资源等等)

**竞争非剥夺资源，或者竞争临时资源可导致死锁**

### 死锁的必要条件

- 互斥条件：进程互斥的使用临界资源
- 不剥夺条件(不可抢占)
- 请求-保持条件：进程在申请新的资源的同时，保持对某些资源的占有
- 环路等待：循环等待链





### 解决死锁的方法

从严格依次降低，为

预防 -> 避免 -> 检测与解除

#### 预防

上面4个条件是死锁的必要条件  ， Deadlock -> 4  其逆否命题为  !4 -> !Deadlock,所以我们从4个条件入手

1. 互斥，并没有好的办法
2. 不抢占：不抢占变成"抢占"，如果进程申请不到全部资源时，主动释放
3. 请求保持条件：使用AND机制，但是有点浪费资源
4. 环路等待：破除环路，资源排序，参考哲学家进餐

#### 避免死锁

**这是比较中庸的做法，既不损耗很多的效率，也比较的严格**

##### 银行家算法

一种是，资源分配表，为

| Process | Allocation | Need | Available |
| ------- | ---------- | ---- | --------- |
|         |            |      |           |

另一种是，计算表

| Work | Need | Allocation | work + Allocation | Finish |
| ---- | ---- | ---------- | ----------------- | ------ |
|      |      |            |                   |        |

**对资源进行分配时，分成两步**

1. 判断分配请求 R是否满足  R < Available && R < Need
2. 如果满足1，使用表1表示分配后的资源表T1，再次计算是否存在安全序列，如果不安全，退回至T0，否则保存T1，下次分配将从T1开始。

#### 检测和解除

使用方法：**资源分配图**

**几个结论**

- 不可完全简化 => 存在死锁
- 分配图中无环 => 不会存在死锁
- 分配图中有环 => 不一定死锁 

简化方法，对一个资源分配图，首先考虑持有边，如果持有者线程能够完成(获得所有需要的资源)，将持有边消去后，将资源返回，如果不能完成，边消去后，仍保持资源占有，直到完成。

然后考虑请求边，如果请求的资源有空闲的，可以把边消去，若请求线程能够完成，则可将该资源返回，否则保持占有

重复上述过程，直至卡住，或者全部成孤立。

**解除**

通过撤销进程或者挂起进程来释放一些资源，进而推动僵持状态。

而具体的对哪些进程，以什么样的顺序进行操作，可以参考`Dijkstra`之类的算法，找到一种损耗最小、利益最大的方法。
