---
title: 2023开源操作系统训练营第二阶段总结报告-FuuuOverclocking
date: 2023-11-17 16:23:21
tags:
    - author: FuuuOverclocking
    - repo: https://github.com/LearningOS/2023a-rcore-FuuuOverclocking
---

# 2023 rCore 二阶段总结

非常感谢清华大学开放的 rCore 课程，一番体验下来后，我对 RISC-V 上的 OS 开发有了比较清楚的认知。
课程为了一步步引导学生理解 OS 的结构和功能，费了很大的功夫在 OS 从简单到复杂的渐进式的构建，以及
各种周边设施的建设上，再次表达对课程精心准备和无私开放的感谢！

用 Rust 写 OS 是一件非常有趣的事情，传统上基建通常使用 C 语言，虽然它非常容易与汇编相对照，抽象
能力和整洁程度却不大理想。作为一门比 C 年轻了 30 多岁的语言，Rust 融入了许许多多现代的理论和特性，
在我看来，对于写 OS 来说比较突出的一点是，它的类型系统带来了更强的表达能力，而同时 RAII 思想的贯彻
有时也带来了一些挑战。

## Chapter 2

这一章介绍了经典的批处理系统。该系统区分特权级，但没有地址空间的保护，一个任务容易把其他任务的数据
写坏。

## Chapter 3

这一章介绍了分时多任务系统，任务通过定时器触发的中断来切换。

## Chapter 4

这一章增加了分页保护，内容一下子长了很多。

不知为何，rCore 提供的 `os::timer::get_time_us` 在这一章的实现有问题，而上一章却没有。整数
乘除的顺序有误使得误差较大。

在这一章额外做了一下 timer 设施的封装，模仿了 Rust 标准库的 `Instant` 和 `Duration`。

rCore 的地址空间管理，以及相应的 syscall 设计的比较简单，我觉得这里使用区间树，不用 RAII 风格，
这样可能 API 和实现会更方便合理。

## Chapter 5

这一章围绕进程管理以及呈现给用户态的接口。

按实验的要求，在进程被调度时为它的 stride 增加一个 pass，可能更合理的选择是在进程被切出时增加？
因为进程可能主动 yield，没有跑完一个时间片。CFS 调度器的设计看上去和这一算法的原理相似。

实验中使用了 Rust 标准库中的二叉堆来管理就绪队列，开始思考 CFS 选择红黑树而不是二叉堆的原因。
