---
title: 2023年秋冬季开源操作系统训练营一二阶段blog-aqpower
date: 2023-11-05 14:55:27
categories:
    - report
tags:
    - author:aqpower

---



## 背景

我是一名计算机专业的学生，现在进入大三上学期，学校已经安排了操作系统课程，但老师教授的偏理论性缺少实践的过程。我本来已经在学习MIT 6.S081操作系统课程，朋友推荐了rCore，采用Rust语言编写的操作系统课程，觉得非常棒交流环境很好而且是国产然后配套资源也很全，就报名学习了。一起学rCore吧！

我也认为在本科阶段，就需要认真学习理解计算机核心课程包括操作系统，应该学习计算机底层知识去了解探索计算机科学领域的魅力和故事，打下扎实基础，毕竟是计算机专业的本科生，大学毕业后可能没有足够的时间与精力去做这些事情。

<!--more-->

## 收获

我觉得rCore tutorial最赞的方面就是每一章都实现了一个操作系统，并且按照操作系统的发展历史由简单到负责，非常符合认知水平，一章章地看下去让我对于操作系统的发展和实现过程有了很深刻的印象。我大概陈述一下我对每个操作系统的认识吧：

从把操作系统放在qemu上运行开始，并提供一些printf和shutdown的函数调用，这时候的操作系统以函数库的形式存在。这里关键实现是需要支持函数调用操作，需要维护函数调用上下文。

这样好麻烦，每次都要输入一整个程序到计算机然后运行，再计算机等待输入程序再运行。批处理系统出来了，可以一次性将多个程序打包到一起输入计算机。而当一个程序运行结束后，计算机会自动加载下一个程序到内存并开始执行。这里开始有了操作系统的概念。这里关键是AppManager的实现，管理所有的应用程序。

但这么多应用一起执行，我们不希望相互影响，更不能影响内核代码，也不希望一个应用崩溃了就整个系统崩溃了，就引入了特权级机制，给os和应用程序不同的特权级，这里需要硬件软件一起实现，硬件控制User特权级下不能执行内核的代码，软件调整特权级需要通过`_alltrap`保存trapContext，同时找到内核态的`traphandle`的入口点，开始执行内核态的代码，之后再通过`_restore`恢复trapContext。

但是这些应用是逐个执行的，还是独占了计算机资源，它们在进行IO操作的时候CPU是空闲的，就引入了多道批处理系统，一次性把多个应用程序加载进入内存，在计算机中以task的形式存在，这里关键是`TaskManager`的实现管理所有的task，同时为每一个task实现一个TaskControlBlock，存储控制信息。这里也需要顺便实现调度算法调度各个task。

这个时候task一旦被调度开始执行，os只能等待操作系统主动放弃cpu，但是有些应用不自觉会长时间占着，也对我们的task不公平，这时候需要计算机来来控制，分时系统的概念形成了。这里的实现关键是定时发送时间中断使用户程序陷入trap交出CPU。

最后为了进一步提升操作系统的隔离性和防御性引入了地址空间和进程的抽象。

## 实验总结

### lab1

- sys_taskinfo
  - 目标是查找每个task的各个系统调用的次数和距离task第一次被调用的时间差。
    - 这个很好实现，第一眼就应该想到显然需要把这两个值放到task对应的TCB里。
    - task第一次被调度的时候记录时间并保存下来。
    - task每次进入trap_handle的时候更新syscall次数。
    - 写值的时候直接在unsafe块内向指针指向的地方写就行。

### lab2

- 兼容sys_taskinfo 和 sys_time
  - 因为引入了地址空间，我们在内核态看到的用户程序传来的虚拟地址在内核的地址空间中没有被映射，所以我们需要去通过当前task的地址空间的memory set去获取到就具体的物理地址再写入。
- sys_mmap
  - 需要页面对齐！！！指len长度应当修改为4096的整数倍。
  - 可以直接调用insert_framed_area建立映射，这里也会一起申请好pagetable。
  - 判断地址有没有被建立映射，可以去遍历当前地址空间的VPNRange
- sys_munmap
  - 这里要len正确才行！我们不对齐len，len错误的话直接返回错误。
  - 物理方面需要去移除输入的页面的areas。软件方面需要取消建立的映射。

### lab3

- 兼容之前的代码
  - 之前task的功能被拆分到了task和process，稍微改动即可。
- syscall spawn
  - 参考fork和exec，很容易实现，关键是要创建新的进程并加入调度。
- stride调度算法
  - 一种优先级调度算法，维护一个优先级和步长就行。
  - 每次调度的时候不再从task队首选择，而是选择当前步长最小的进行调度，并更新步幅。

## 总结与展望

前前后后花了几个礼拜的时间从学习rust开始，到配置qemu和docker环境，开始看rcore文档，开始写lab，痛苦debug，对所有权冲突焦虑不解，对概念理解不透彻。但还是一步一步实现了从0到1，最重要最后看到自己的代码成功跑起来实现了功能，作为操作系统的一部分的那一刻真的很兴奋。我已经被操作系统的魅力折服了！^_^

而且这次训练营有时间要求，有压力，我看rcore的速度加快了很多，如果没有训练营这样的大环境和时间要求在的话我是不能够以这样的速度完成的。

我目前只完成了ch5，但是剩下的部分也会稳扎稳打完成的，希望三阶段对操作系统能有一个更全面的理解和认识，自己能够顺利完成三阶段。

最后感谢一起组队的同学，感谢组织者和助教还有讲师，讲得很合理清晰有趣，感谢社区环境和提供的全面资源，感谢操作系统训练营这个大平台。
