---
title: Zxx开源操作系统第二阶段总结
date: 2024-11-10 18:18:58
tags:
    - author:Zia6
    - repo:rust-rustlings-2024-autumn-Zia6
---
### lab1总结
实验一相对简单。由于尚未实现页表，内核地址空间可以直接访问用户态地址空间，因此系统调用的实现只需直接返回用户态地址即可。此外，为了确保后续实验中的测试通过，建议使用高精度的 get_time_us 获取时间，避免因时间精度不足导致错误。至于统计系统调用次数，可以在 syscall 函数执行时进行更新。若需获取系统第一次调用的时间，则需修改 run_first_task 和 run_next_task。

### lab2总结
与实验一不同的是，实验二中需要实现页表。因此，之前的系统调用逻辑需要重构。内核必须找到传递参数的实际物理地址，并在该地址进行读写操作。

此外，实验要求实现两个新的系统调用：mmap 和 munmap。这两个调用涉及一段连续地址，因此需要检查该地址范围是否完全未映射或已映射。mmap 负责插入页面，而 munmap 则用于删除页面。

### lab3总结
在实验三中，首先需要将之前实验的代码引入本次实验。如果之前的代码有问题，本次实验的测试通常也无法通过。

本次实验的核心是实现 spawn 和 stride 调度算法。spawn 并非简单的 fork + exec，因此在实现前需充分理解其语义。可以借助 fork + exec 的部分代码来调整 TCB 数据结构至目标状态。

stride 是一种进程调度算法，由于本次实验示例较简单，按照教程步骤实现即可完成。

### lab4总结
相比之前的实验，实验四的难度有所增加。首先，需要确保兼容之前的代码。一开始 spawn 的兼容性问题导致多次报错，最终通过重新实现 spawn 才解决。

此外，还需注意可能出现的死锁问题。由于某些函数（如 find 和 create）对文件系统加锁，不能直接调用它们，而是需要将其实现逻辑拷贝并进行调整。

最后是 unlink 的目录项删除操作。在找到目标目录项后，需要更新内容。采用了群里分享的方法：删除原目录项后，将内容重新拷贝过去。

### lab5总结
实验五的任务是实现一个死锁检测算法，类似于银行家算法。但教程中的描述较为模糊，许多细节未明确说明。因此，需要仔细分析各个细节。sem 和 mutex 的实现思路基本相同。另外，sys_get_time 的实现必不可少，否则某些测试实例会出现死锁。

总结
总体来说，这些实验内容并不复杂，涉及的概念较为基础。但由于是第一次接触 Rust 并使用它编写操作系统，对我而言是一次新奇的体验。实验的主要难点在于 Rust 的使用上。此外，教程的部分内容并不完善，例如死锁检测算法的部分解释得较为模糊。若不是群里有人提到类似银行家算法，我很可能难以理解。因此，希望教程能进一步完善文档内容，帮助更多初学者。
