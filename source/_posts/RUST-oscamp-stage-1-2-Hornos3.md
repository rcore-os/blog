---
title: RUST-oscamp stage 1-2 - Hornos3
date: 2024-11-08 10:28:28
categories:
  - report
tags:
  - author:Hornos3
---

有关于Rust基础，是笔者在做毕设时因需要而学的，故而阶段一没有花费什么精力。但是对于阶段二，情况则截然不同。笔者没有听从项目文档的建议，选择了单枪匹马完成所有5个任务，期间也出现了许多迷之错误...

对于Rust这门编程语言来说，笔者个人认为，虽然它可以被用来编写底层的代码，包括bootloader、UEFI、OS内核等等，但是它的编译器已经决定了Rust的上限。笔者不才，曾经研究过一部分Rust的反编译分析，发现Rust对于栈内存的使用似乎非常奢侈。与C语言不同，Rust对于Shadowing的处理不是复用原来的栈内存空间，而是直接使用新的空间。另外Rust的结构也相比C臃肿很多，这就导致Rust作为底层架构的开发语言时，使用的内存空间要远多于C语言，粗略估计，实现同一种功能的情况下，Rust平均需要比C至少多1倍的栈内存空间。在时间效率上，Rust要实现与C语言相同的时间效率，编写的unsafe代码定然不少，对于开发人员的要求也必然不低，在这一点上，Rust相较于C可能并没有提升太多的编程效率。因此，使用Rust与C编写底层代码各有千秋，Rust定然无法取代C，而C也必然要接受Rust的发展。当前，Rust底层生态严重不足，导致上层建筑难以跟进，一旦Rust适配了足够多的ISA与外设，将大大方便底层中较高级别的编程开发，但对于MCU等内存需求、效率需求高的场景，C依然是不可替代的选择。

在此附上笔者的blog网址，其中有之前编写的9篇Rust逆向分析blog：[网址](hornos3.github.io)（~~界面丑了点，不要在意~~）

根据笔者对于Rust反编译的研究理解发现，Rust的各类结构具有一定的特征，在进行调试时，如果能够识别出此类特征，就能将汇编代码与源代码相对应，从而大致恢复源代码的执行逻辑，甚至直接逆向还原出源代码。正是因为笔者对Rust汇编的理解，在本次实验阶段二中的调试才能更快地找到问题所在。