---
title: 2023秋-训练营阶段总结-OneMore14
date: 2023-10-31 19:49:55
tags:
    - author:<OneMore14>
---



## 阶段一 rustlings

因为之前有一点 Rust 基础，直接做 Rustlings 没有太大问题，加上当时比较忙着工作和找租房的事，所以阶段一比较潦草，把题目做完就没有再花时间深究其中一些不熟悉的部分。总的来说，Rustings 确实是非常好的入门学习资料，重做一遍也相当于复习了。



## 阶段二 rCore

阶段二最开始看2023A的文档，但是感觉讲得有点模糊，后来读到详细的V3文档感觉一下子通顺了很多。虽然要读的内容多一点，但实际可能因为理解更清晰而做的更快一些。

前三章主要讲操作系统内核是如何启动的，以及启动后如何运行用户程序的。其实一切都没有魔法，无非是如何合理运用硬件规则而已。一般来说是硬件决定了第一条指令的起始位置，硬件决定如何输入输出，硬件也提供了分等级的环境让我们可以隔离用户态和内核态...总之，程序的运行最终都是落实在硬件之上的，因此操作系统需要根据硬件功能做出相应的适配。而为了简化这种适配的复杂度，又引出了位于硬件和内核之间的一层抽象，称为SBI。我们可以把SBI简单想象成"内核的操作系统"，通过SBI简化后的接口可以调用硬件某些复杂的功能，比如输入输出。在了解了裸机的基本运行环境后，再看内核其实和我们日常编写的应用软件是非常类似的，只是在某些时候，往往需要使用汇编语言来构造一些更底层的上下文或完成指令跳转。在熟悉这些技巧后，前三章内核的执行过程就比较好懂了。

第四章引入了地址空间的概念，这里再次体现硬件对内核的支持，硬件可以通过设置来开启MMU功能，直接实现了地址转换功能，甚至还提供 TLB 用作缓存。因此内核只需要考虑对内存的管理功能，而不需要在用户程序运行中转换每一个虚拟地址。在rCore的学习中，比较容易迷糊的是到底哪些空间包含了哪些部分，可以通过打印日志的访问查看堆栈的起止位置，感受程序的内存布局。

第五章引入进程的概念，其实更像是第三章的加强版。理解程序执行需要准备哪些上下文，申请哪些资源，程序进入/退出内核需要如何保存/恢复上下文，之后再做实验就不会迷茫。有点被卡住的是一开始不太理解 idle_task_cx 的作用，仔细阅读 __switch 函数才发现 idle_task_cx 保存了run_tasks() 里循环的上下文。阅读汇编代码实际含义确实不如普通代码好懂，这可能也是操作系统的难点之一吧。

第六章引入文件的实现，由于不需要关注硬件细节，最底层只需要调用实现了 BlockDevice trait的块设备结构体即可，总体比较好懂。且rCore是运行在单核处理器上，不需要考虑文件的共享问题，整体难度不大。

第七章进程间通信也主要是在目前内核至少实现一些方便的功能，并没有新硬件的引入。

第八章线程的引入更加细化了之前对进程的管理，而一些并发原语则是利用了硬件的原子指令的功能，才让一些共享变量能被安全访问。但是rCore没有引入多核，因此也比较好懂。

总体来说，通过这次rCore的学习，对操作系统内核的基本原理有了更直观的感受，一切都是硬件的支持和指令的跳转，同时也体会到Rust是如何应用在系统软件领域的，唯一稍有遗憾的是rCore没有引入多核，毕竟日常生活工作都是使用多核CPU。但瑕不掩瑜，rCore仍是非常好的操作系统入门资料，V3文档也非常详实，在此衷心感谢各位老师和同学的付出。

目前虽然完成了规定的几个实验，但深知在框架内添加代码和自己独立实现一个迷你操作系统仍有不小的差距，还需要多多学习。
