
# 阶段一-Rustlings

这个阶段主要是需要进行rust相关的学习.

其实早就有接触过rust,但是语法,尤其是所有权和生命周期这块,一直还比较生疏.

有关于所有权相关的内容主要是看了这个视频:[如何一步一步推导出Rust所有权、借用规则、引用类型以及秒懂生命周期标注_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hjh1emEAY/?spm_id_from=333.337.search-card.all.click)

其中关于rust作为无gc语言,大部分内存都是保存在栈上的,只有少部分是保存在栈里边.

**'a指出返回的引用与输入参数x、y之间有关联**.

这个非常非常重要.

# 阶段二-OS内核实验

## ch0-2

可以参见我之前复现[rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档](https://rcore-os.cn/rCore-Tutorial-Book-v3/)的笔记,被公开在博客园上.

[[winddevil的笔记 - 博客园](https://www.cnblogs.com/chenhan-winddevil/p/18292624)

这次学习主要是从`ch3~ch8`的学习,重点换做了解决通过测例,和一些自己的问题.

## ch3

主要是讲的一个任务切换的流程,有了任务切换之后又通过定时器中断实现了抢占式调度.

![替代文本|800](https://img2024.cnblogs.com/blog/3071041/202409/3071041-20240914172749474-2031592744.png "可选标题")

## ch4

这一章主要解决的是一个虚拟地址转换为物理地址的过程,说是虚拟地址,我原来以为真的改变了地址,实际上每一次调用资源都还是使用了物理地址的,利用地址空间对所有的需要访问具体物理地址的对象进行操作.

![替代文本|800](https://img2024.cnblogs.com/blog/3071041/202410/3071041-20241027024955160-396645957.png "可选标题")

## ch5

这一章同样是承接了上一章的知识,讲的主要是一个进程的概念,加入了很多新的结构体,后边我应该会有时间的时候更新一下图片.

进程中最巧妙的就是使用了`fork`这个复制一个任务的操作,有了进程,那么就可以实现编程的简洁性,倭只需要编写一个小任务,然后再进行组合,而不是调用`fn`,然后自己设计各种分支结构.

有了进程,相当于把调度的工作委托给了`os`.

## ch6

在上一章的基础上,引入了块和文件系统.

这一部分的知识学的非常的不牢靠.

但是让我印象深刻的地方是,这一章基本实现了我对之前学习的时候发现windows是可以直接"点开"应用这个操作的好奇.

那么应用保存在哪里,为什么我用U盘拷贝了还是可以继续运行.

之前学习单片机的时候很少想到我可以通过什么东西对"可执行"的东西进行操作.

通过二进制文件进行加载然后运行的操作属实惊艳到了我.

## ch7

这个和`ch4`更加相关.之前运行`rtos`的时候总是想着,那么这个变量可以直接以全局变量的方式进行传输为什么我要使用各种比如信号量比如邮箱的方式,现在就一目了然了.

因为地址空间的不同所以进程之间的通信需要通过管道,也就是需要经由操作系统这一层.

## ch8

这一部分让我想起了之前进行单片机编程的时候的`临界段保护`操作,那时候是通过非常暴力的方法关掉了所有的中断以保证这次读取不会出现问题.

或者使用原子操作保证中断无法打断单一时钟下的操作.

这里并没有和硬件和中断打交道,而是选用了三种方式,加锁\条件变量\信号量的方式.

使用银行家算法进行了调度,算法不难,但是调用本身很麻烦,需要在每一次加锁的时候对题中的变量进行操作.并且每一次上锁的时候都需要`detect`,那么对上锁的程序也必须进行改造.

## 本次体验

越到后边越忙,如果有幸进入下一个阶段一定不能好高骛远多线程操作,一定要留足时间给自己.
