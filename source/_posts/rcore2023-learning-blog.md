---
title: rcore2023_learning_blog
date: 2023-11-06 21:18:28
tags:
---
# 2023rcore第二阶段学习总结和个人与计算机系统的漫游
## 初识
与 [rcore开源操作系统训练营](https://github.com/LearningOS) 的相识，算是一个很偶然的机会吧。我与计算机结识很晚，在我上大学后，才从一个对计算机连打字都不会的人到慢慢熟练使用以及熟悉各种技术的人。与操作系统(Linux)结识，是大一下学期的 计算机系统基础课(教程是那本鼎鼎大名的 **深入了解计算机系统**)，那节课开启了我Linux的漫游旅途。
## 兴趣
在我刚接触计算机的时候，一直认为开发出一个web网站或者APP，就是一件特别特别酷的事情。在整个刚接触计算机的事情，写出一个web网页或者APP便是我一直想要做的事。但后来，大一结束的暑假，学习了一些这方面的技术，扒开了web的真实面目，便慢慢失去了很多兴趣，曾经很酷的事情，突然感觉很无味了。所幸的是，在这个时候，学校的 **OS** 课开了，杨老师是一名非常知识渊博、热爱体系结构的老师，他 **OS** 第一门课留给我们的作业便是
> 下载linux内核源码，并往内核中添加自定义系统调用
>
这算是我开启了我正式与操作系统内核接触的旅途。永远无法忘却第一次下载linux内核源码，然后编译的时候，满屏报错的电脑界面，特别是每次编译的时候，都会让我等待很久，几乎每次都是编译了三十多分钟，然后给我报错，如此循环往复……最后终于把代码编译完成。第一次进入**kernel** 目录下，进入代码里面，映入眼帘的是 **Linus Torvalds** 的大名，那是我第二次那么激动(第一次激动的时候是第一次敲出 “Hello, World”)。最后在各种操作之下，各种文件之间来回修改的条件下，我终于让自己自定义的一个系统调用成功运行了起来，那一瞬间，像是打开了潘多拉的魔盒，从此我开始对体系结构、操作系统方向的东西产生了很大兴趣，便也萌生了写一个OS的想法，从此整个想法，便一直根深蒂固着。
## 遇见rcore
诚恳的说，我是因为心中那个根深蒂固的想法才会有机会遇见rcore，刚开始的时候，我其实知道的是 **ucore**, 后来因为个人非常喜欢c++，而某段的时间里，网上的各样信息都在告诉我 **Rust** 是c++的强大竞争者，**Rust** 是如何的安全，如何的高效。便萌发了我对这一门新型语言的兴趣。
### Rust:
第一次用Rust的时候，它的cargo便惊艳了我很久，用c++的时候，每次安装第三方包，亦或是换个平台，编译东西，都会让我折磨很久，总是在各种编译器之间的实现困惑，msvc有的特性，在gcc有时候却无法运行，有时候在gcc能够运行的东西，在clang也无法运行。同样让人痛苦的时候，c++20/c++23都出了很久了，但是不同编译器的支持却是层出不穷……。换到Rust，突然很多东西便让人清爽了许多。也便逐渐开始了学习Rust的旅途。
### risc-v:
对于risc-v的了解，在开始rcore之前，我也只知道它是开源的，文档内容少(远没有X86和Arm那样内容复杂和繁冗)。后来了解了一下龙芯，[一生一芯](https://oscpu.github.io/ysyx/)等，便也对risc-v有了极大兴趣，恰逢此时，rcore便出现在了我面前。
### rcore:
[rcore Book](https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html) 的娓娓道来，特别是以各种史前生物 来描述，增加了一番故事书的趣味。而[Guide](http://learningos.cn/rCore-Tutorial-Guide-2023A/)则能够快速地让我明白了代码地框架，每个文件，每个模块是什么样的功能。但无奈个人基础不好，所以大部分时间还是在看 Book。本次实验让我们实现操作系统核心的几个重要功能：
1. 多到程序与分时多道任务
* Lab1 需要完善系统调用。对于 sys_task_info 系统调用，我们在 TCP 添加相应字段处理即
```Rust
pub fn sys_task_info(ti: *mut TaskInfo) -> isize {
        unsafe{
        *ti = TaskInfo{
            status:get_current_status(),
            syscall_times:get_syscall_times(),
            time : (get_time_us() - get_current_start_time()) / 1000

        };
    }
    0
}
```
2. 虚拟内存管理  

    这部分的内容中，为 Rcore 引入了虚拟内存，为地址空间加上了一层抽象，# 地址空间
    刚学计算机的时候，个人非常总喜欢将所有代码放在一个文件里，觉得分开各种代码很是麻烦。后来因为学习深入，开始对分离代码，抽象多了很多体会。特别是在学计算机网络的TCP/IP模型和操作系统的时候，对**抽象，加层**的思想确实是不断体会，不断明白了那句话“在计算机中，没有什么是不能加一层解决不了的”。现在来好好感受在ch4中的抽象加一层。
    1. 为什么要添加一层抽象层：
        * 从应用开发的角度看，需要应用程序决定自己会被加载到哪个物理地址运行，需要直接访问真实的物理内存。这就要求应用开发者对于硬件的特性和使用方法有更多了解，产生额外的学习成本，也会为应用的开发和调试带来不便
        * 从内核的角度来看，将直接访问物理内存的权力下放到应用会使得它难以对应用程序的访存行为进行有效管理，已有的特权级机制亦无法阻止很多来自应用程序的恶意行为。
    2. 该抽象层要完成的目标：
    
        * 透明 ：应用开发者可以不必了解底层真实物理内存的硬件细节，且在非必要时也不必关心内核的实现策略， 最小化他们的心智负担；

        * 高效 ：这层抽象至少在大多数情况下不应带来过大的额外开销；

        * 安全 ：这层抽象应该有效检测并阻止应用读写其他应用或内核的代码、数据等一系列恶意行为。
3. 进程管理
    * 对于进程、程序、可执行文件等的了解更加深入了
        1.  进程是在操作系统管理下的程序的一次执行过程，程序是一个静态的概念。
        2. 可执行文件是一张“蓝图”：一张编译器解析源代码之后总结出的一张记载如何利用各种硬件资源进行一轮生产流程的 **蓝图**
        3. 加载同一个可执行文件的两个进程也是不同的：它们的启动时间、占据的硬件资源、输入数据均有可能是不同的，这些条件均会导致它们是不一样的执行过程。
        4. 对于创建进程需要fork()和exec()两个系统调用而不只是一个系统调用。两个组合更加灵活，fork是为了 exec 一个新应用提供空间，然后exec可以读取不同的elf文件，执行不同的操作。

4. 文件系统(未完待续)
5. 并发(未完待续)

但很可惜，因为个人基础和时间还有其他各种各样的原因，个人并没有完成五个实验，前面三个实验也只是勉强完成（虽然运行过了，但还是有很多东西之间还不明白）。接下来的时间，我将好好把先前没有弄明白的知识点再好好梳理一遍。并将继续做完还没有先前没有做完的工作。向训练营各位优秀的同学学习，以后要多写博客，多写博客(这次学到的一个优秀习惯)，及时梳理知识。纸上得来终觉浅，绝知此事要躬行！！！。
